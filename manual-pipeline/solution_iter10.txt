 % ./bb
 % Args:
DEBUG P1READ: Terminal 0 battery=100.00
DEBUG P1READ: Terminal 1 battery=90.00
DEBUG P1READ: Terminal 2 battery=98.00
DEBUG P1READ: Terminal 3 battery=100.00
DEBUG P1READ: Terminal 4 battery=98.00
DEBUG P1READ: Terminal 5 battery=85.50
DEBUG P1READ: Terminal 6 battery=100.00
DEBUG P1READ: Terminal 7 battery=100.00
DEBUG P1READ: Terminal 8 battery=100.00
DEBUG P1READ: Terminal 9 battery=100.00
DEBUG P1READ: Terminal 10 battery=88.20
DEBUG P1READ: Terminal 11 battery=44.70
DEBUG P1READ: Terminal 12 battery=100.00
DEBUG P1READ: Terminal 13 battery=77.90
DEBUG P1READ: Terminal 14 battery=58.30
DEBUG P1READ: Terminal 15 battery=100.00
DEBUG P1READ: Terminal 16 battery=76.00
DEBUG P1READ: Terminal 17 battery=100.00
DEBUG P1READ: Terminal 18 battery=89.20
DEBUG P1READ: Terminal 19 battery=100.00
DEBUG HG: num_verts=20, num_edges=40
 % Phase 1: 0.00 seconds

%%BeginSetup

0 1 0 1 SetAxes

20 DefineTerminals
	.4588350000000000	.2373240000000000	DT
	.1270640000000000	.3509960000000000	DT
	.1544540000000000	.4808220000000000	DT
	.9474030000000000	.1441120000000000	DT
	.2867390000000000	.0565890000000000	DT
	.1326890000000000	.1166050000000000	DT
	.6273950000000000	.2122140000000000	DT
	.0794880000000000	.7970990000000000	DT
	.0327480000000000	.8803250000000000	DT
	.3110550000000000	.8689670000000000	DT
	.0916180000000000	.0221720000000000	DT
	.3600710000000000	.6382240000000000	DT
	.7197120000000000	.7181670000000000	DT
	.4424420000000000	.1450340000000000	DT
	.9983770000000000	.5729870000000000	DT
	.9654920000000000	.1935700000000000	DT
	.1600100000000000	.4187950000000000	DT
	.2909450000000000	.9620800000000000	DT
	.3330000000000000	.9414120000000000	DT
	.9512590000000000	.5074670000000000	DT

%%EndSetup

DEBUG ALGO: num_verts=20 <= 8? NO, num_edges=40 <= 12? NO
DEBUG ALGO: Forcing BRANCH-AND-CUT for multi-objective optimization (vertices=20 > 1)
DEBUG SPANNING: Adding modified spanning constraint for budget mode
DEBUG SPANNING: Added modified spanning constraint: Σ(|FST|-1)*x + Σnot_covered = 19
DEBUG CONSTRAINT: Adding soft cutset constraints with not_covered variables
DEBUG CONSTRAINT: Added constraint x[2] + not_covered[0] ≤ 1 for terminal 0
DEBUG CONSTRAINT: Added constraint x[27] + not_covered[0] ≤ 1 for terminal 0
DEBUG CONSTRAINT: Added constraint x[31] + not_covered[0] ≤ 1 for terminal 0
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 3·not_covered[0] ≤ 3 for terminal 0
DEBUG CONSTRAINT: Added constraint x[0] + not_covered[1] ≤ 1 for terminal 1
DEBUG CONSTRAINT: Added constraint x[24] + not_covered[1] ≤ 1 for terminal 1
DEBUG CONSTRAINT: Added constraint x[33] + not_covered[1] ≤ 1 for terminal 1
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 3·not_covered[1] ≤ 3 for terminal 1
DEBUG CONSTRAINT: Added constraint x[5] + not_covered[2] ≤ 1 for terminal 2
DEBUG CONSTRAINT: Added constraint x[7] + not_covered[2] ≤ 1 for terminal 2
DEBUG CONSTRAINT: Added constraint x[16] + not_covered[2] ≤ 1 for terminal 2
DEBUG CONSTRAINT: Added constraint x[23] + not_covered[2] ≤ 1 for terminal 2
DEBUG CONSTRAINT: Added constraint x[36] + not_covered[2] ≤ 1 for terminal 2
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 5·not_covered[2] ≤ 5 for terminal 2
DEBUG CONSTRAINT: Added constraint x[3] + not_covered[3] ≤ 1 for terminal 3
DEBUG CONSTRAINT: Added constraint x[4] + not_covered[3] ≤ 1 for terminal 3
DEBUG CONSTRAINT: Added constraint x[17] + not_covered[3] ≤ 1 for terminal 3
DEBUG CONSTRAINT: Added constraint x[20] + not_covered[3] ≤ 1 for terminal 3
DEBUG CONSTRAINT: Added constraint x[22] + not_covered[3] ≤ 1 for terminal 3
DEBUG CONSTRAINT: Added constraint x[39] + not_covered[3] ≤ 1 for terminal 3
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 6·not_covered[3] ≤ 6 for terminal 3
DEBUG CONSTRAINT: Added constraint x[0] + not_covered[4] ≤ 1 for terminal 4
DEBUG CONSTRAINT: Added constraint x[1] + not_covered[4] ≤ 1 for terminal 4
DEBUG CONSTRAINT: Added constraint x[30] + not_covered[4] ≤ 1 for terminal 4
DEBUG CONSTRAINT: Added constraint x[32] + not_covered[4] ≤ 1 for terminal 4
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 4·not_covered[4] ≤ 4 for terminal 4
DEBUG CONSTRAINT: Added constraint x[0] + not_covered[5] ≤ 1 for terminal 5
DEBUG CONSTRAINT: Added constraint x[1] + not_covered[5] ≤ 1 for terminal 5
DEBUG CONSTRAINT: Added constraint x[29] + not_covered[5] ≤ 1 for terminal 5
DEBUG CONSTRAINT: Added constraint x[30] + not_covered[5] ≤ 1 for terminal 5
DEBUG CONSTRAINT: Added constraint x[33] + not_covered[5] ≤ 1 for terminal 5
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 5·not_covered[5] ≤ 5 for terminal 5
DEBUG CONSTRAINT: Added constraint x[2] + not_covered[6] ≤ 1 for terminal 6
DEBUG CONSTRAINT: Added constraint x[3] + not_covered[6] ≤ 1 for terminal 6
DEBUG CONSTRAINT: Added constraint x[4] + not_covered[6] ≤ 1 for terminal 6
DEBUG CONSTRAINT: Added constraint x[11] + not_covered[6] ≤ 1 for terminal 6
DEBUG CONSTRAINT: Added constraint x[17] + not_covered[6] ≤ 1 for terminal 6
DEBUG CONSTRAINT: Added constraint x[18] + not_covered[6] ≤ 1 for terminal 6
DEBUG CONSTRAINT: Added constraint x[20] + not_covered[6] ≤ 1 for terminal 6
DEBUG CONSTRAINT: Added constraint x[31] + not_covered[6] ≤ 1 for terminal 6
DEBUG CONSTRAINT: Added constraint x[39] + not_covered[6] ≤ 1 for terminal 6
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 9·not_covered[6] ≤ 9 for terminal 6
DEBUG CONSTRAINT: Added constraint x[5] + not_covered[7] ≤ 1 for terminal 7
DEBUG CONSTRAINT: Added constraint x[6] + not_covered[7] ≤ 1 for terminal 7
DEBUG CONSTRAINT: Added constraint x[8] + not_covered[7] ≤ 1 for terminal 7
DEBUG CONSTRAINT: Added constraint x[13] + not_covered[7] ≤ 1 for terminal 7
DEBUG CONSTRAINT: Added constraint x[14] + not_covered[7] ≤ 1 for terminal 7
DEBUG CONSTRAINT: Added constraint x[15] + not_covered[7] ≤ 1 for terminal 7
DEBUG CONSTRAINT: Added constraint x[16] + not_covered[7] ≤ 1 for terminal 7
DEBUG CONSTRAINT: Added constraint x[19] + not_covered[7] ≤ 1 for terminal 7
DEBUG CONSTRAINT: Added constraint x[28] + not_covered[7] ≤ 1 for terminal 7
DEBUG CONSTRAINT: Added constraint x[35] + not_covered[7] ≤ 1 for terminal 7
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 10·not_covered[7] ≤ 10 for terminal 7
DEBUG CONSTRAINT: Added constraint x[6] + not_covered[8] ≤ 1 for terminal 8
DEBUG CONSTRAINT: Added constraint x[13] + not_covered[8] ≤ 1 for terminal 8
DEBUG CONSTRAINT: Added constraint x[14] + not_covered[8] ≤ 1 for terminal 8
DEBUG CONSTRAINT: Added constraint x[19] + not_covered[8] ≤ 1 for terminal 8
DEBUG CONSTRAINT: Added constraint x[28] + not_covered[8] ≤ 1 for terminal 8
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 5·not_covered[8] ≤ 5 for terminal 8
DEBUG CONSTRAINT: Added constraint x[6] + not_covered[9] ≤ 1 for terminal 9
DEBUG CONSTRAINT: Added constraint x[7] + not_covered[9] ≤ 1 for terminal 9
DEBUG CONSTRAINT: Added constraint x[8] + not_covered[9] ≤ 1 for terminal 9
DEBUG CONSTRAINT: Added constraint x[9] + not_covered[9] ≤ 1 for terminal 9
DEBUG CONSTRAINT: Added constraint x[12] + not_covered[9] ≤ 1 for terminal 9
DEBUG CONSTRAINT: Added constraint x[13] + not_covered[9] ≤ 1 for terminal 9
DEBUG CONSTRAINT: Added constraint x[14] + not_covered[9] ≤ 1 for terminal 9
DEBUG CONSTRAINT: Added constraint x[15] + not_covered[9] ≤ 1 for terminal 9
DEBUG CONSTRAINT: Added constraint x[16] + not_covered[9] ≤ 1 for terminal 9
DEBUG CONSTRAINT: Added constraint x[19] + not_covered[9] ≤ 1 for terminal 9
DEBUG CONSTRAINT: Added constraint x[25] + not_covered[9] ≤ 1 for terminal 9
DEBUG CONSTRAINT: Added constraint x[34] + not_covered[9] ≤ 1 for terminal 9
DEBUG CONSTRAINT: Added constraint x[35] + not_covered[9] ≤ 1 for terminal 9
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 13·not_covered[9] ≤ 13 for terminal 9
DEBUG CONSTRAINT: Added constraint x[1] + not_covered[10] ≤ 1 for terminal 10
DEBUG CONSTRAINT: Added constraint x[29] + not_covered[10] ≤ 1 for terminal 10
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 2·not_covered[10] ≤ 2 for terminal 10
DEBUG CONSTRAINT: Added constraint x[5] + not_covered[11] ≤ 1 for terminal 11
DEBUG CONSTRAINT: Added constraint x[7] + not_covered[11] ≤ 1 for terminal 11
DEBUG CONSTRAINT: Added constraint x[8] + not_covered[11] ≤ 1 for terminal 11
DEBUG CONSTRAINT: Added constraint x[9] + not_covered[11] ≤ 1 for terminal 11
DEBUG CONSTRAINT: Added constraint x[13] + not_covered[11] ≤ 1 for terminal 11
DEBUG CONSTRAINT: Added constraint x[16] + not_covered[11] ≤ 1 for terminal 11
DEBUG CONSTRAINT: Added constraint x[34] + not_covered[11] ≤ 1 for terminal 11
DEBUG CONSTRAINT: Added constraint x[36] + not_covered[11] ≤ 1 for terminal 11
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 8·not_covered[11] ≤ 8 for terminal 11
DEBUG CONSTRAINT: Added constraint x[9] + not_covered[12] ≤ 1 for terminal 12
DEBUG CONSTRAINT: Added constraint x[10] + not_covered[12] ≤ 1 for terminal 12
DEBUG CONSTRAINT: Added constraint x[18] + not_covered[12] ≤ 1 for terminal 12
DEBUG CONSTRAINT: Added constraint x[20] + not_covered[12] ≤ 1 for terminal 12
DEBUG CONSTRAINT: Added constraint x[37] + not_covered[12] ≤ 1 for terminal 12
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 5·not_covered[12] ≤ 5 for terminal 12
DEBUG CONSTRAINT: Added constraint x[2] + not_covered[13] ≤ 1 for terminal 13
DEBUG CONSTRAINT: Added constraint x[27] + not_covered[13] ≤ 1 for terminal 13
DEBUG CONSTRAINT: Added constraint x[32] + not_covered[13] ≤ 1 for terminal 13
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 3·not_covered[13] ≤ 3 for terminal 13
DEBUG CONSTRAINT: Added constraint x[10] + not_covered[14] ≤ 1 for terminal 14
DEBUG CONSTRAINT: Added constraint x[26] + not_covered[14] ≤ 1 for terminal 14
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 2·not_covered[14] ≤ 2 for terminal 14
DEBUG CONSTRAINT: Added constraint x[3] + not_covered[15] ≤ 1 for terminal 15
DEBUG CONSTRAINT: Added constraint x[11] + not_covered[15] ≤ 1 for terminal 15
DEBUG CONSTRAINT: Added constraint x[17] + not_covered[15] ≤ 1 for terminal 15
DEBUG CONSTRAINT: Added constraint x[18] + not_covered[15] ≤ 1 for terminal 15
DEBUG CONSTRAINT: Added constraint x[20] + not_covered[15] ≤ 1 for terminal 15
DEBUG CONSTRAINT: Added constraint x[22] + not_covered[15] ≤ 1 for terminal 15
DEBUG CONSTRAINT: Added constraint x[38] + not_covered[15] ≤ 1 for terminal 15
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 7·not_covered[15] ≤ 7 for terminal 15
DEBUG CONSTRAINT: Added constraint x[23] + not_covered[16] ≤ 1 for terminal 16
DEBUG CONSTRAINT: Added constraint x[24] + not_covered[16] ≤ 1 for terminal 16
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 2·not_covered[16] ≤ 2 for terminal 16
DEBUG CONSTRAINT: Added constraint x[12] + not_covered[17] ≤ 1 for terminal 17
DEBUG CONSTRAINT: Added constraint x[15] + not_covered[17] ≤ 1 for terminal 17
DEBUG CONSTRAINT: Added constraint x[19] + not_covered[17] ≤ 1 for terminal 17
DEBUG CONSTRAINT: Added constraint x[21] + not_covered[17] ≤ 1 for terminal 17
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 4·not_covered[17] ≤ 4 for terminal 17
DEBUG CONSTRAINT: Added constraint x[12] + not_covered[18] ≤ 1 for terminal 18
DEBUG CONSTRAINT: Added constraint x[14] + not_covered[18] ≤ 1 for terminal 18
DEBUG CONSTRAINT: Added constraint x[15] + not_covered[18] ≤ 1 for terminal 18
DEBUG CONSTRAINT: Added constraint x[19] + not_covered[18] ≤ 1 for terminal 18
DEBUG CONSTRAINT: Added constraint x[21] + not_covered[18] ≤ 1 for terminal 18
DEBUG CONSTRAINT: Added constraint x[25] + not_covered[18] ≤ 1 for terminal 18
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 6·not_covered[18] ≤ 6 for terminal 18
DEBUG CONSTRAINT: Added constraint x[4] + not_covered[19] ≤ 1 for terminal 19
DEBUG CONSTRAINT: Added constraint x[10] + not_covered[19] ≤ 1 for terminal 19
DEBUG CONSTRAINT: Added constraint x[11] + not_covered[19] ≤ 1 for terminal 19
DEBUG CONSTRAINT: Added constraint x[17] + not_covered[19] ≤ 1 for terminal 19
DEBUG CONSTRAINT: Added constraint x[18] + not_covered[19] ≤ 1 for terminal 19
DEBUG CONSTRAINT: Added constraint x[20] + not_covered[19] ≤ 1 for terminal 19
DEBUG CONSTRAINT: Added constraint x[26] + not_covered[19] ≤ 1 for terminal 19
DEBUG CONSTRAINT: Added constraint x[37] + not_covered[19] ≤ 1 for terminal 19
DEBUG CONSTRAINT: Added constraint x[38] + not_covered[19] ≤ 1 for terminal 19
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 9·not_covered[19] ≤ 9 for terminal 19
DEBUG CONSTRAINT: Added source terminal constraint: not_covered[0] = 0
DEBUG BUDGET: Adding budget constraint ≤ 1800000.000 to constraint pool
DEBUG BUDGET: Using raw tree costs directly
DEBUG BUDGET: Budget limit: 1800000.000
DEBUG BUDGET: Building raw cost constraint coefficients:
DEBUG BUDGET:   x[0] coefficient = 398991 (raw=398991.100)
DEBUG BUDGET:   x[1] coefficient = 260889 (raw=260889.712)
DEBUG BUDGET:   x[2] coefficient = 256773 (raw=256773.057)
DEBUG BUDGET:   x[3] coefficient = 376541 (raw=376541.557)
DEBUG BUDGET:   x[4] coefficient = 646084 (raw=646084.462)
DEBUG BUDGET:   x[5] coefficient = 520973 (raw=520973.020)
DEBUG BUDGET:   x[6] coefficient = 334575 (raw=334575.182)
DEBUG BUDGET:   x[7] coefficient = 494448 (raw=494448.457)
DEBUG BUDGET:   x[8] coefficient = 455905 (raw=455905.519)
DEBUG BUDGET:   x[9] coefficient = 584020 (raw=584020.499)
DEBUG BUDGET:   x[10] coefficient = 380918 (raw=380918.244)
DEBUG BUDGET:   x[11] coefficient = 621357 (raw=621357.781)
DEBUG BUDGET:   x[12] coefficient = 120675 (raw=120675.719)
DEBUG BUDGET:   x[13] coefficient = 551354 (raw=551354.477)
DEBUG BUDGET:   x[14] coefficient = 410262 (raw=410262.679)
DEBUG BUDGET:   x[15] coefficient = 362962 (raw=362962.653)
DEBUG BUDGET:   x[16] coefficient = 702244 (raw=702244.403)
DEBUG BUDGET:   x[17] coefficient = 673894 (raw=673894.542)
DEBUG BUDGET:   x[18] coefficient = 933994 (raw=933994.022)
DEBUG BUDGET:   x[19] coefficient = 454199 (raw=454199.906)
DEBUG BUDGET:   x[20] coefficient = 986439 (raw=986439.144)
DEBUG BUDGET:   x[21] coefficient = 46859 (raw=46859.249)
DEBUG BUDGET:   x[22] coefficient = 52662 (raw=52662.185)
DEBUG BUDGET:   x[23] coefficient = 62275 (raw=62275.339)
DEBUG BUDGET:   x[24] coefficient = 75379 (raw=75379.993)
DEBUG BUDGET:   x[25] coefficient = 75695 (raw=75695.846)
DEBUG BUDGET:   x[26] coefficient = 80703 (raw=80703.013)
DEBUG BUDGET:   x[27] coefficient = 93734 (raw=93734.596)
DEBUG BUDGET:   x[28] coefficient = 95452 (raw=95452.578)
DEBUG BUDGET:   x[29] coefficient = 102977 (raw=102977.757)
DEBUG BUDGET:   x[30] coefficient = 165327 (raw=165327.925)
DEBUG BUDGET:   x[31] coefficient = 170420 (raw=170420.027)
DEBUG BUDGET:   x[32] coefficient = 179069 (raw=179069.657)
DEBUG BUDGET:   x[33] coefficient = 234458 (raw=234458.486)
DEBUG BUDGET:   x[34] coefficient = 235891 (raw=235891.713)
DEBUG BUDGET:   x[35] coefficient = 242462 (raw=242462.956)
DEBUG BUDGET:   x[36] coefficient = 258947 (raw=258947.370)
DEBUG BUDGET:   x[37] coefficient = 313063 (raw=313063.098)
DEBUG BUDGET:   x[38] coefficient = 314219 (raw=314219.517)
DEBUG BUDGET:   x[39] coefficient = 327174 (raw=327174.269)
DEBUG BUDGET: Constraint: Σ tree_cost[i] * x[i] ≤ 1800000
DEBUG BUDGET: Budget constraint added to pool with 40 FSTs
DEBUG CONSTRAINT: Adding 'at least one FST' constraint: Σ x[i] ≥ 1
DEBUG CONSTRAINT: Added 'at least one FST' constraint: Σ x[i] ≥ 1
 % _gst_initialize_constraint_pool: 0.00 seconds.
 % Constraint pool initialized with:
 % 	1	Total degree rows	40	coeffs.
 % 	20	Cutset rows		111	coeffs.
 % 	0	Incompatibility rows	0	coeffs.
 % 	29	2-terminal SEC rows	102	coeffs.
 % 	1	At least one FST rows	40	coeffs.
 % 	163	Total rows in pool	135	in LP
 % @PMEM 163 rows, 1 blocks, 415 nzfree, 0 nzwasted, 1172 nztotal
DEBUG SOFT: Found 20 terminals, 40 FSTs
DEBUG SOFT: Adding space for 20 not_covered variables in soft constraints, total ncoeff=514
DEBUG LP_SETUP: Created LP with 0 rows, 60 columns (nedges=40 + nterms=20)
DEBUG SOFT: Set bounds for 40 FST vars [1-40] and 20 coverage vars [41-60]
DEBUG OBJ: Using raw costs - alpha=10000.0 (battery weight), beta=1500000 (coverage penalty)
DEBUG OBJ: Allocated rowvec[0-60] for ncols=60 LP variables
DEBUG OBJ: Full_trees battery_score=0.000 for FST 0
DEBUG OBJ: Recalculating for FST 0 with 3 terminals
DEBUG OBJ: Terminal 0 (idx 5): battery=85.50, running_total=85.50
DEBUG OBJ: Terminal 1 (idx 1): battery=90.00, running_total=175.50
DEBUG OBJ: Terminal 2 (idx 4): battery=98.00, running_total=273.50
DEBUG OBJ: Recalculated battery_score=273.500 for FST 0
DEBUG OBJ: FST 0: tree_cost=398991.100, battery_cost=273.500 (weighted=2735000.0), combined=3133991.1
DEBUG OBJ: Full_trees battery_score=0.000 for FST 1
DEBUG OBJ: Recalculating for FST 1 with 3 terminals
DEBUG OBJ: Terminal 0 (idx 10): battery=88.20, running_total=88.20
DEBUG OBJ: Terminal 1 (idx 5): battery=85.50, running_total=173.70
DEBUG OBJ: Terminal 2 (idx 4): battery=98.00, running_total=271.70
DEBUG OBJ: Recalculated battery_score=271.700 for FST 1
DEBUG OBJ: FST 1: tree_cost=260889.712, battery_cost=271.700 (weighted=2717000.0), combined=2977889.7
DEBUG OBJ: Full_trees battery_score=0.000 for FST 2
DEBUG OBJ: Recalculating for FST 2 with 3 terminals
DEBUG OBJ: Terminal 0 (idx 13): battery=77.90, running_total=77.90
DEBUG OBJ: Terminal 1 (idx 0): battery=100.00, running_total=177.90
DEBUG OBJ: Terminal 2 (idx 6): battery=100.00, running_total=277.90
DEBUG OBJ: Recalculated battery_score=277.900 for FST 2
DEBUG OBJ: FST 2: tree_cost=256773.057, battery_cost=277.900 (weighted=2779000.0), combined=3035773.1
DEBUG OBJ: Full_trees battery_score=0.000 for FST 3
DEBUG OBJ: Recalculating for FST 3 with 3 terminals
DEBUG OBJ: Terminal 0 (idx 15): battery=100.00, running_total=100.00
DEBUG OBJ: Terminal 1 (idx 3): battery=100.00, running_total=200.00
DEBUG OBJ: Terminal 2 (idx 6): battery=100.00, running_total=300.00
DEBUG OBJ: Recalculated battery_score=300.000 for FST 3
DEBUG OBJ: FST 3: tree_cost=376541.557, battery_cost=300.000 (weighted=3000000.0), combined=3376541.6
DEBUG OBJ: Full_trees battery_score=0.000 for FST 4
DEBUG OBJ: Recalculating for FST 4 with 3 terminals
DEBUG OBJ: Terminal 0 (idx 19): battery=100.00, running_total=100.00
DEBUG OBJ: Terminal 1 (idx 3): battery=100.00, running_total=200.00
DEBUG OBJ: Terminal 2 (idx 6): battery=100.00, running_total=300.00
DEBUG OBJ: Recalculated battery_score=300.000 for FST 4
DEBUG OBJ: FST 4: tree_cost=646084.462, battery_cost=300.000 (weighted=3000000.0), combined=3646084.5
DEBUG OBJ: Full_trees battery_score=0.000 for FST 5
DEBUG OBJ: Recalculating for FST 5 with 3 terminals
DEBUG OBJ: Terminal 0 (idx 11): battery=44.70, running_total=44.70
DEBUG OBJ: Terminal 1 (idx 2): battery=98.00, running_total=142.70
DEBUG OBJ: Terminal 2 (idx 7): battery=100.00, running_total=242.70
DEBUG OBJ: Recalculated battery_score=242.700 for FST 5
DEBUG OBJ: FST 5: tree_cost=520973.020, battery_cost=242.700 (weighted=2427000.0), combined=2947973.0
DEBUG OBJ: Full_trees battery_score=0.000 for FST 6
DEBUG OBJ: Recalculating for FST 6 with 3 terminals
DEBUG OBJ: Terminal 0 (idx 9): battery=100.00, running_total=100.00
DEBUG OBJ: Terminal 1 (idx 7): battery=100.00, running_total=200.00
DEBUG OBJ: Terminal 2 (idx 8): battery=100.00, running_total=300.00
DEBUG OBJ: Recalculated battery_score=300.000 for FST 6
DEBUG OBJ: FST 6: tree_cost=334575.182, battery_cost=300.000 (weighted=3000000.0), combined=3334575.2
DEBUG OBJ: Full_trees battery_score=0.000 for FST 7
DEBUG OBJ: Recalculating for FST 7 with 3 terminals
DEBUG OBJ: Terminal 0 (idx 11): battery=44.70, running_total=44.70
DEBUG OBJ: Terminal 1 (idx 2): battery=98.00, running_total=142.70
DEBUG OBJ: Terminal 2 (idx 9): battery=100.00, running_total=242.70
DEBUG OBJ: Recalculated battery_score=242.700 for FST 7
DEBUG OBJ: FST 7: tree_cost=494448.457, battery_cost=242.700 (weighted=2427000.0), combined=2921448.5
DEBUG OBJ: Full_trees battery_score=0.000 for FST 8
DEBUG OBJ: Recalculating for FST 8 with 3 terminals
DEBUG OBJ: Terminal 0 (idx 11): battery=44.70, running_total=44.70
DEBUG OBJ: Terminal 1 (idx 7): battery=100.00, running_total=144.70
DEBUG OBJ: Terminal 2 (idx 9): battery=100.00, running_total=244.70
DEBUG OBJ: Recalculated battery_score=244.700 for FST 8
DEBUG OBJ: FST 8: tree_cost=455905.519, battery_cost=244.700 (weighted=2447000.0), combined=2902905.5
DEBUG OBJ: Full_trees battery_score=0.000 for FST 9
DEBUG OBJ: Recalculating for FST 9 with 3 terminals
DEBUG OBJ: Terminal 0 (idx 12): battery=100.00, running_total=100.00
DEBUG OBJ: Terminal 1 (idx 11): battery=44.70, running_total=144.70
DEBUG OBJ: Terminal 2 (idx 9): battery=100.00, running_total=244.70
DEBUG OBJ: Recalculated battery_score=244.700 for FST 9
DEBUG OBJ: FST 9: tree_cost=584020.499, battery_cost=244.700 (weighted=2447000.0), combined=3031020.5
DEBUG OBJ: Full_trees battery_score=0.000 for FST 10
DEBUG OBJ: Recalculating for FST 10 with 3 terminals
DEBUG OBJ: Terminal 0 (idx 19): battery=100.00, running_total=100.00
DEBUG OBJ: Terminal 1 (idx 12): battery=100.00, running_total=200.00
DEBUG OBJ: Terminal 2 (idx 14): battery=58.30, running_total=258.30
DEBUG OBJ: Recalculated battery_score=258.300 for FST 10
DEBUG OBJ: FST 10: tree_cost=380918.244, battery_cost=258.300 (weighted=2583000.0), combined=2963918.2
DEBUG OBJ: Full_trees battery_score=0.000 for FST 11
DEBUG OBJ: Recalculating for FST 11 with 3 terminals
DEBUG OBJ: Terminal 0 (idx 19): battery=100.00, running_total=100.00
DEBUG OBJ: Terminal 1 (idx 15): battery=100.00, running_total=200.00
DEBUG OBJ: Terminal 2 (idx 6): battery=100.00, running_total=300.00
DEBUG OBJ: Recalculated battery_score=300.000 for FST 11
DEBUG OBJ: FST 11: tree_cost=621357.781, battery_cost=300.000 (weighted=3000000.0), combined=3621357.8
DEBUG OBJ: Full_trees battery_score=0.000 for FST 12
DEBUG OBJ: Recalculating for FST 12 with 3 terminals
DEBUG OBJ: Terminal 0 (idx 18): battery=89.20, running_total=89.20
DEBUG OBJ: Terminal 1 (idx 9): battery=100.00, running_total=189.20
DEBUG OBJ: Terminal 2 (idx 17): battery=100.00, running_total=289.20
DEBUG OBJ: Recalculated battery_score=289.200 for FST 12
DEBUG OBJ: FST 12: tree_cost=120675.719, battery_cost=289.200 (weighted=2892000.0), combined=3012675.7
DEBUG OBJ: Full_trees battery_score=0.000 for FST 13
DEBUG OBJ: Recalculating for FST 13 with 4 terminals
DEBUG OBJ: Terminal 0 (idx 11): battery=44.70, running_total=44.70
DEBUG OBJ: Terminal 1 (idx 7): battery=100.00, running_total=144.70
DEBUG OBJ: Terminal 2 (idx 8): battery=100.00, running_total=244.70
DEBUG OBJ: Terminal 3 (idx 9): battery=100.00, running_total=344.70
DEBUG OBJ: Recalculated battery_score=344.700 for FST 13
DEBUG OBJ: FST 13: tree_cost=551354.477, battery_cost=344.700 (weighted=3447000.0), combined=3998354.5
DEBUG OBJ: Full_trees battery_score=0.000 for FST 14
DEBUG OBJ: Recalculating for FST 14 with 4 terminals
DEBUG OBJ: Terminal 0 (idx 18): battery=89.20, running_total=89.20
DEBUG OBJ: Terminal 1 (idx 9): battery=100.00, running_total=189.20
DEBUG OBJ: Terminal 2 (idx 7): battery=100.00, running_total=289.20
DEBUG OBJ: Terminal 3 (idx 8): battery=100.00, running_total=389.20
DEBUG OBJ: Recalculated battery_score=389.200 for FST 14
DEBUG OBJ: FST 14: tree_cost=410262.679, battery_cost=389.200 (weighted=3892000.0), combined=4302262.7
DEBUG OBJ: Full_trees battery_score=0.000 for FST 15
DEBUG OBJ: Recalculating for FST 15 with 4 terminals
DEBUG OBJ: Terminal 0 (idx 18): battery=89.20, running_total=89.20
DEBUG OBJ: Terminal 1 (idx 9): battery=100.00, running_total=189.20
DEBUG OBJ: Terminal 2 (idx 7): battery=100.00, running_total=289.20
DEBUG OBJ: Terminal 3 (idx 17): battery=100.00, running_total=389.20
DEBUG OBJ: Recalculated battery_score=389.200 for FST 15
DEBUG OBJ: FST 15: tree_cost=362962.653, battery_cost=389.200 (weighted=3892000.0), combined=4254962.7
DEBUG OBJ: Full_trees battery_score=0.000 for FST 16
DEBUG OBJ: Recalculating for FST 16 with 4 terminals
DEBUG OBJ: Terminal 0 (idx 11): battery=44.70, running_total=44.70
DEBUG OBJ: Terminal 1 (idx 2): battery=98.00, running_total=142.70
DEBUG OBJ: Terminal 2 (idx 7): battery=100.00, running_total=242.70
DEBUG OBJ: Terminal 3 (idx 9): battery=100.00, running_total=342.70
DEBUG OBJ: Recalculated battery_score=342.700 for FST 16
DEBUG OBJ: FST 16: tree_cost=702244.403, battery_cost=342.700 (weighted=3427000.0), combined=4129244.4
DEBUG OBJ: Full_trees battery_score=0.000 for FST 17
DEBUG OBJ: Recalculating for FST 17 with 4 terminals
DEBUG OBJ: Terminal 0 (idx 19): battery=100.00, running_total=100.00
DEBUG OBJ: Terminal 1 (idx 15): battery=100.00, running_total=200.00
DEBUG OBJ: Terminal 2 (idx 3): battery=100.00, running_total=300.00
DEBUG OBJ: Terminal 3 (idx 6): battery=100.00, running_total=400.00
DEBUG OBJ: Recalculated battery_score=400.000 for FST 17
DEBUG OBJ: FST 17: tree_cost=673894.542, battery_cost=400.000 (weighted=4000000.0), combined=4673894.5
DEBUG OBJ: Full_trees battery_score=0.000 for FST 18
DEBUG OBJ: Recalculating for FST 18 with 4 terminals
DEBUG OBJ: Terminal 0 (idx 19): battery=100.00, running_total=100.00
DEBUG OBJ: Terminal 1 (idx 15): battery=100.00, running_total=200.00
DEBUG OBJ: Terminal 2 (idx 6): battery=100.00, running_total=300.00
DEBUG OBJ: Terminal 3 (idx 12): battery=100.00, running_total=400.00
DEBUG OBJ: Recalculated battery_score=400.000 for FST 18
DEBUG OBJ: FST 18: tree_cost=933994.022, battery_cost=400.000 (weighted=4000000.0), combined=4933994.0
DEBUG OBJ: Full_trees battery_score=0.000 for FST 19
DEBUG OBJ: Recalculating for FST 19 with 5 terminals
DEBUG OBJ: Terminal 0 (idx 18): battery=89.20, running_total=89.20
DEBUG OBJ: Terminal 1 (idx 9): battery=100.00, running_total=189.20
DEBUG OBJ: Terminal 2 (idx 7): battery=100.00, running_total=289.20
DEBUG OBJ: Terminal 3 (idx 8): battery=100.00, running_total=389.20
DEBUG OBJ: Terminal 4 (idx 17): battery=100.00, running_total=489.20
DEBUG OBJ: Recalculated battery_score=489.200 for FST 19
DEBUG OBJ: FST 19: tree_cost=454199.906, battery_cost=489.200 (weighted=4892000.0), combined=5346199.9
DEBUG OBJ: Full_trees battery_score=0.000 for FST 20
DEBUG OBJ: Recalculating for FST 20 with 5 terminals
DEBUG OBJ: Terminal 0 (idx 19): battery=100.00, running_total=100.00
DEBUG OBJ: Terminal 1 (idx 15): battery=100.00, running_total=200.00
DEBUG OBJ: Terminal 2 (idx 3): battery=100.00, running_total=300.00
DEBUG OBJ: Terminal 3 (idx 6): battery=100.00, running_total=400.00
DEBUG OBJ: Terminal 4 (idx 12): battery=100.00, running_total=500.00
DEBUG OBJ: Recalculated battery_score=500.000 for FST 20
DEBUG OBJ: FST 20: tree_cost=986439.144, battery_cost=500.000 (weighted=5000000.0), combined=5986439.1
DEBUG OBJ: Full_trees battery_score=0.000 for FST 21
DEBUG OBJ: Recalculating for FST 21 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 18): battery=89.20, running_total=89.20
DEBUG OBJ: Terminal 1 (idx 17): battery=100.00, running_total=189.20
DEBUG OBJ: Recalculated battery_score=189.200 for FST 21
DEBUG OBJ: FST 21: tree_cost=46859.249, battery_cost=189.200 (weighted=1892000.0), combined=1938859.2
DEBUG OBJ: Full_trees battery_score=0.000 for FST 22
DEBUG OBJ: Recalculating for FST 22 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 15): battery=100.00, running_total=100.00
DEBUG OBJ: Terminal 1 (idx 3): battery=100.00, running_total=200.00
DEBUG OBJ: Recalculated battery_score=200.000 for FST 22
DEBUG OBJ: FST 22: tree_cost=52662.185, battery_cost=200.000 (weighted=2000000.0), combined=2052662.2
DEBUG OBJ: Full_trees battery_score=0.000 for FST 23
DEBUG OBJ: Recalculating for FST 23 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 16): battery=76.00, running_total=76.00
DEBUG OBJ: Terminal 1 (idx 2): battery=98.00, running_total=174.00
DEBUG OBJ: Recalculated battery_score=174.000 for FST 23
DEBUG OBJ: FST 23: tree_cost=62275.339, battery_cost=174.000 (weighted=1740000.0), combined=1802275.3
DEBUG OBJ: Full_trees battery_score=0.000 for FST 24
DEBUG OBJ: Recalculating for FST 24 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 16): battery=76.00, running_total=76.00
DEBUG OBJ: Terminal 1 (idx 1): battery=90.00, running_total=166.00
DEBUG OBJ: Recalculated battery_score=166.000 for FST 24
DEBUG OBJ: FST 24: tree_cost=75379.993, battery_cost=166.000 (weighted=1660000.0), combined=1735380.0
DEBUG OBJ: Full_trees battery_score=0.000 for FST 25
DEBUG OBJ: Recalculating for FST 25 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 18): battery=89.20, running_total=89.20
DEBUG OBJ: Terminal 1 (idx 9): battery=100.00, running_total=189.20
DEBUG OBJ: Recalculated battery_score=189.200 for FST 25
DEBUG OBJ: FST 25: tree_cost=75695.846, battery_cost=189.200 (weighted=1892000.0), combined=1967695.8
DEBUG OBJ: Full_trees battery_score=0.000 for FST 26
DEBUG OBJ: Recalculating for FST 26 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 14): battery=58.30, running_total=58.30
DEBUG OBJ: Terminal 1 (idx 19): battery=100.00, running_total=158.30
DEBUG OBJ: Recalculated battery_score=158.300 for FST 26
DEBUG OBJ: FST 26: tree_cost=80703.013, battery_cost=158.300 (weighted=1583000.0), combined=1663703.0
DEBUG OBJ: Full_trees battery_score=0.000 for FST 27
DEBUG OBJ: Recalculating for FST 27 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 0): battery=100.00, running_total=100.00
DEBUG OBJ: Terminal 1 (idx 13): battery=77.90, running_total=177.90
DEBUG OBJ: Recalculated battery_score=177.900 for FST 27
DEBUG OBJ: FST 27: tree_cost=93734.596, battery_cost=177.900 (weighted=1779000.0), combined=1872734.6
DEBUG OBJ: Full_trees battery_score=0.000 for FST 28
DEBUG OBJ: Recalculating for FST 28 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 8): battery=100.00, running_total=100.00
DEBUG OBJ: Terminal 1 (idx 7): battery=100.00, running_total=200.00
DEBUG OBJ: Recalculated battery_score=200.000 for FST 28
DEBUG OBJ: FST 28: tree_cost=95452.578, battery_cost=200.000 (weighted=2000000.0), combined=2095452.6
DEBUG OBJ: Full_trees battery_score=0.000 for FST 29
DEBUG OBJ: Recalculating for FST 29 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 5): battery=85.50, running_total=85.50
DEBUG OBJ: Terminal 1 (idx 10): battery=88.20, running_total=173.70
DEBUG OBJ: Recalculated battery_score=173.700 for FST 29
DEBUG OBJ: FST 29: tree_cost=102977.757, battery_cost=173.700 (weighted=1737000.0), combined=1839977.8
DEBUG OBJ: Full_trees battery_score=0.000 for FST 30
DEBUG OBJ: Recalculating for FST 30 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 4): battery=98.00, running_total=98.00
DEBUG OBJ: Terminal 1 (idx 5): battery=85.50, running_total=183.50
DEBUG OBJ: Recalculated battery_score=183.500 for FST 30
DEBUG OBJ: FST 30: tree_cost=165327.925, battery_cost=183.500 (weighted=1835000.0), combined=2000327.9
DEBUG OBJ: Full_trees battery_score=0.000 for FST 31
DEBUG OBJ: Recalculating for FST 31 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 6): battery=100.00, running_total=100.00
DEBUG OBJ: Terminal 1 (idx 0): battery=100.00, running_total=200.00
DEBUG OBJ: Recalculated battery_score=200.000 for FST 31
DEBUG OBJ: FST 31: tree_cost=170420.027, battery_cost=200.000 (weighted=2000000.0), combined=2170420.0
DEBUG OBJ: Full_trees battery_score=0.000 for FST 32
DEBUG OBJ: Recalculating for FST 32 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 13): battery=77.90, running_total=77.90
DEBUG OBJ: Terminal 1 (idx 4): battery=98.00, running_total=175.90
DEBUG OBJ: Recalculated battery_score=175.900 for FST 32
DEBUG OBJ: FST 32: tree_cost=179069.657, battery_cost=175.900 (weighted=1759000.0), combined=1938069.7
DEBUG OBJ: Full_trees battery_score=0.000 for FST 33
DEBUG OBJ: Recalculating for FST 33 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 5): battery=85.50, running_total=85.50
DEBUG OBJ: Terminal 1 (idx 1): battery=90.00, running_total=175.50
DEBUG OBJ: Recalculated battery_score=175.500 for FST 33
DEBUG OBJ: FST 33: tree_cost=234458.486, battery_cost=175.500 (weighted=1755000.0), combined=1989458.5
DEBUG OBJ: Full_trees battery_score=0.000 for FST 34
DEBUG OBJ: Recalculating for FST 34 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 11): battery=44.70, running_total=44.70
DEBUG OBJ: Terminal 1 (idx 9): battery=100.00, running_total=144.70
DEBUG OBJ: Recalculated battery_score=144.700 for FST 34
DEBUG OBJ: FST 34: tree_cost=235891.713, battery_cost=144.700 (weighted=1447000.0), combined=1682891.7
DEBUG OBJ: Full_trees battery_score=0.000 for FST 35
DEBUG OBJ: Recalculating for FST 35 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 9): battery=100.00, running_total=100.00
DEBUG OBJ: Terminal 1 (idx 7): battery=100.00, running_total=200.00
DEBUG OBJ: Recalculated battery_score=200.000 for FST 35
DEBUG OBJ: FST 35: tree_cost=242462.956, battery_cost=200.000 (weighted=2000000.0), combined=2242463.0
DEBUG OBJ: Full_trees battery_score=0.000 for FST 36
DEBUG OBJ: Recalculating for FST 36 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 2): battery=98.00, running_total=98.00
DEBUG OBJ: Terminal 1 (idx 11): battery=44.70, running_total=142.70
DEBUG OBJ: Recalculated battery_score=142.700 for FST 36
DEBUG OBJ: FST 36: tree_cost=258947.370, battery_cost=142.700 (weighted=1427000.0), combined=1685947.4
DEBUG OBJ: Full_trees battery_score=0.000 for FST 37
DEBUG OBJ: Recalculating for FST 37 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 19): battery=100.00, running_total=100.00
DEBUG OBJ: Terminal 1 (idx 12): battery=100.00, running_total=200.00
DEBUG OBJ: Recalculated battery_score=200.000 for FST 37
DEBUG OBJ: FST 37: tree_cost=313063.098, battery_cost=200.000 (weighted=2000000.0), combined=2313063.1
DEBUG OBJ: Full_trees battery_score=0.000 for FST 38
DEBUG OBJ: Recalculating for FST 38 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 15): battery=100.00, running_total=100.00
DEBUG OBJ: Terminal 1 (idx 19): battery=100.00, running_total=200.00
DEBUG OBJ: Recalculated battery_score=200.000 for FST 38
DEBUG OBJ: FST 38: tree_cost=314219.517, battery_cost=200.000 (weighted=2000000.0), combined=2314219.5
DEBUG OBJ: Full_trees battery_score=0.000 for FST 39
DEBUG OBJ: Recalculating for FST 39 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 3): battery=100.00, running_total=100.00
DEBUG OBJ: Terminal 1 (idx 6): battery=100.00, running_total=200.00
DEBUG OBJ: Recalculated battery_score=200.000 for FST 39
DEBUG OBJ: FST 39: tree_cost=327174.269, battery_cost=200.000 (weighted=2000000.0), combined=2327174.3
DEBUG OBJ: Added penalty terms beta=1500000 for 20 not_covered variables [41-60]
DEBUG LP_MATRIX: LP has 0 rows, 60 columns after setup
DEBUG EXTRA_COEFF: Calculated extra_coeff=1 for 135 rows
DEBUG SOFT: Added not_covered_0 (RC_var 43 -> matrix_idx 40) to soft constraint 134
DEBUG MATRIX_CHECK: nzi=495, ncoeff=514, extra_coeff=1, expected=515
ERROR: Matrix coefficient count mismatch! nzi=495 != ncoeff=514 + extra_coeff=1
WARNING: Allowing discrepancy in budget mode (nzi=495 vs expected=515)
DEBUG MATRIX: Total matrix has 495 entries (nzi=495)
DEBUG MATRIX: matbeg[135] = 495 (should equal nzi)
DEBUG LP: Calling add_rows with 135 rows
DEBUG LP: Before add_rows: LP has 0 rows, 60 cols, 60 nonzeros
DEBUG LP: After add_rows: LP has 135 rows, 60 cols, 555 nonzeros
DEBUG NLPROWS: nrows=135, extra_rows=0, setting nlprows=135
 % _gst_build_initial_formulation: 0.00 seconds.
DEBUG BB: Expected nlprows=135, total rows=163
DEBUG BB: Row 0 (uid=0) has lprow=0 (included, j=0)
DEBUG BB: Row 1 (uid=1) has lprow=1 (included, j=1)
DEBUG BB: Row 2 (uid=2) has lprow=2 (included, j=2)
DEBUG BB: Row 3 (uid=3) has lprow=3 (included, j=3)
DEBUG BB: Row 4 (uid=4) has lprow=4 (included, j=4)
DEBUG BB: Row 5 (uid=5) has lprow=5 (included, j=5)
DEBUG BB: Row 6 (uid=6) has lprow=6 (included, j=6)
DEBUG BB: Row 7 (uid=7) has lprow=7 (included, j=7)
DEBUG BB: Row 8 (uid=8) has lprow=8 (included, j=8)
DEBUG BB: Row 9 (uid=9) has lprow=9 (included, j=9)
DEBUG BB: Row 10 (uid=10) has lprow=10 (included, j=10)
DEBUG BB: Row 11 (uid=11) has lprow=11 (included, j=11)
DEBUG BB: Row 12 (uid=12) has lprow=12 (included, j=12)
DEBUG BB: Row 13 (uid=13) has lprow=13 (included, j=13)
DEBUG BB: Row 14 (uid=14) has lprow=14 (included, j=14)
DEBUG BB: Row 15 (uid=15) has lprow=15 (included, j=15)
DEBUG BB: Row 16 (uid=16) has lprow=16 (included, j=16)
DEBUG BB: Row 17 (uid=17) has lprow=17 (included, j=17)
DEBUG BB: Row 18 (uid=18) has lprow=18 (included, j=18)
DEBUG BB: Row 19 (uid=19) has lprow=19 (included, j=19)
DEBUG BB: Row 20 (uid=20) has lprow=20 (included, j=20)
DEBUG BB: Row 21 (uid=21) has lprow=21 (included, j=21)
DEBUG BB: Row 22 (uid=22) has lprow=22 (included, j=22)
DEBUG BB: Row 23 (uid=23) has lprow=23 (included, j=23)
DEBUG BB: Row 24 (uid=24) has lprow=24 (included, j=24)
DEBUG BB: Row 25 (uid=25) has lprow=25 (included, j=25)
DEBUG BB: Row 26 (uid=26) has lprow=26 (included, j=26)
DEBUG BB: Row 27 (uid=27) has lprow=27 (included, j=27)
DEBUG BB: Row 28 (uid=28) has lprow=28 (included, j=28)
DEBUG BB: Row 29 (uid=29) has lprow=29 (included, j=29)
DEBUG BB: Row 30 (uid=30) has lprow=30 (included, j=30)
DEBUG BB: Row 31 (uid=31) has lprow=31 (included, j=31)
DEBUG BB: Row 32 (uid=32) has lprow=32 (included, j=32)
DEBUG BB: Row 33 (uid=33) has lprow=33 (included, j=33)
DEBUG BB: Row 34 (uid=34) has lprow=34 (included, j=34)
DEBUG BB: Row 35 (uid=35) has lprow=35 (included, j=35)
DEBUG BB: Row 36 (uid=36) has lprow=36 (included, j=36)
DEBUG BB: Row 37 (uid=37) has lprow=37 (included, j=37)
DEBUG BB: Row 38 (uid=38) has lprow=38 (included, j=38)
DEBUG BB: Row 39 (uid=39) has lprow=39 (included, j=39)
DEBUG BB: Row 40 (uid=40) has lprow=40 (included, j=40)
DEBUG BB: Row 41 (uid=41) has lprow=41 (included, j=41)
DEBUG BB: Row 42 (uid=42) has lprow=42 (included, j=42)
DEBUG BB: Row 43 (uid=43) has lprow=43 (included, j=43)
DEBUG BB: Row 44 (uid=44) has lprow=44 (included, j=44)
DEBUG BB: Row 45 (uid=45) has lprow=45 (included, j=45)
DEBUG BB: Row 46 (uid=46) has lprow=46 (included, j=46)
DEBUG BB: Row 47 (uid=47) has lprow=47 (included, j=47)
DEBUG BB: Row 48 (uid=48) has lprow=48 (included, j=48)
DEBUG BB: Row 49 (uid=49) has lprow=49 (included, j=49)
DEBUG BB: Row 50 (uid=50) has lprow=50 (included, j=50)
DEBUG BB: Row 51 (uid=51) has lprow=51 (included, j=51)
DEBUG BB: Row 52 (uid=52) has lprow=52 (included, j=52)
DEBUG BB: Row 53 (uid=53) has lprow=53 (included, j=53)
DEBUG BB: Row 54 (uid=54) has lprow=54 (included, j=54)
DEBUG BB: Row 55 (uid=55) has lprow=55 (included, j=55)
DEBUG BB: Row 56 (uid=56) has lprow=56 (included, j=56)
DEBUG BB: Row 57 (uid=57) has lprow=57 (included, j=57)
DEBUG BB: Row 58 (uid=58) has lprow=58 (included, j=58)
DEBUG BB: Row 59 (uid=59) has lprow=59 (included, j=59)
DEBUG BB: Row 60 (uid=60) has lprow=60 (included, j=60)
DEBUG BB: Row 61 (uid=61) has lprow=61 (included, j=61)
DEBUG BB: Row 62 (uid=62) has lprow=62 (included, j=62)
DEBUG BB: Row 63 (uid=63) has lprow=63 (included, j=63)
DEBUG BB: Row 64 (uid=64) has lprow=64 (included, j=64)
DEBUG BB: Row 65 (uid=65) has lprow=65 (included, j=65)
DEBUG BB: Row 66 (uid=66) has lprow=66 (included, j=66)
DEBUG BB: Row 67 (uid=67) has lprow=67 (included, j=67)
DEBUG BB: Row 68 (uid=68) has lprow=68 (included, j=68)
DEBUG BB: Row 69 (uid=69) has lprow=69 (included, j=69)
DEBUG BB: Row 70 (uid=70) has lprow=70 (included, j=70)
DEBUG BB: Row 71 (uid=71) has lprow=71 (included, j=71)
DEBUG BB: Row 72 (uid=72) has lprow=72 (included, j=72)
DEBUG BB: Row 73 (uid=73) has lprow=73 (included, j=73)
DEBUG BB: Row 74 (uid=74) has lprow=74 (included, j=74)
DEBUG BB: Row 75 (uid=75) has lprow=75 (included, j=75)
DEBUG BB: Row 76 (uid=76) has lprow=76 (included, j=76)
DEBUG BB: Row 77 (uid=77) has lprow=77 (included, j=77)
DEBUG BB: Row 78 (uid=78) has lprow=78 (included, j=78)
DEBUG BB: Row 79 (uid=79) has lprow=79 (included, j=79)
DEBUG BB: Row 80 (uid=80) has lprow=80 (included, j=80)
DEBUG BB: Row 81 (uid=81) has lprow=81 (included, j=81)
DEBUG BB: Row 82 (uid=82) has lprow=82 (included, j=82)
DEBUG BB: Row 83 (uid=83) has lprow=83 (included, j=83)
DEBUG BB: Row 84 (uid=84) has lprow=84 (included, j=84)
DEBUG BB: Row 85 (uid=85) has lprow=85 (included, j=85)
DEBUG BB: Row 86 (uid=86) has lprow=86 (included, j=86)
DEBUG BB: Row 87 (uid=87) has lprow=87 (included, j=87)
DEBUG BB: Row 88 (uid=88) has lprow=88 (included, j=88)
DEBUG BB: Row 89 (uid=89) has lprow=89 (included, j=89)
DEBUG BB: Row 90 (uid=90) has lprow=90 (included, j=90)
DEBUG BB: Row 91 (uid=91) has lprow=91 (included, j=91)
DEBUG BB: Row 92 (uid=92) has lprow=92 (included, j=92)
DEBUG BB: Row 93 (uid=93) has lprow=93 (included, j=93)
DEBUG BB: Row 94 (uid=94) has lprow=94 (included, j=94)
DEBUG BB: Row 95 (uid=95) has lprow=95 (included, j=95)
DEBUG BB: Row 96 (uid=96) has lprow=96 (included, j=96)
DEBUG BB: Row 97 (uid=97) has lprow=97 (included, j=97)
DEBUG BB: Row 98 (uid=98) has lprow=98 (included, j=98)
DEBUG BB: Row 99 (uid=99) has lprow=99 (included, j=99)
DEBUG BB: Row 100 (uid=100) has lprow=100 (included, j=100)
DEBUG BB: Row 101 (uid=101) has lprow=101 (included, j=101)
DEBUG BB: Row 102 (uid=102) has lprow=102 (included, j=102)
DEBUG BB: Row 103 (uid=103) has lprow=103 (included, j=103)
DEBUG BB: Row 104 (uid=104) has lprow=104 (included, j=104)
DEBUG BB: Row 105 (uid=105) has lprow=105 (included, j=105)
DEBUG BB: Row 106 (uid=106) has lprow=106 (included, j=106)
DEBUG BB: Row 107 (uid=107) has lprow=107 (included, j=107)
DEBUG BB: Row 108 (uid=108) has lprow=108 (included, j=108)
DEBUG BB: Row 109 (uid=109) has lprow=109 (included, j=109)
DEBUG BB: Row 110 (uid=110) has lprow=110 (included, j=110)
DEBUG BB: Row 111 (uid=111) has lprow=111 (included, j=111)
DEBUG BB: Row 112 (uid=112) has lprow=112 (included, j=112)
DEBUG BB: Row 113 (uid=113) has lprow=113 (included, j=113)
DEBUG BB: Row 114 (uid=114) has lprow=114 (included, j=114)
DEBUG BB: Row 115 (uid=115) has lprow=115 (included, j=115)
DEBUG BB: Row 116 (uid=116) has lprow=116 (included, j=116)
DEBUG BB: Row 117 (uid=117) has lprow=117 (included, j=117)
DEBUG BB: Row 118 (uid=118) has lprow=118 (included, j=118)
DEBUG BB: Row 119 (uid=119) has lprow=119 (included, j=119)
DEBUG BB: Row 120 (uid=120) has lprow=120 (included, j=120)
DEBUG BB: Row 121 (uid=121) has lprow=121 (included, j=121)
DEBUG BB: Row 122 (uid=122) has lprow=122 (included, j=122)
DEBUG BB: Row 123 (uid=123) has lprow=123 (included, j=123)
DEBUG BB: Row 124 (uid=124) has lprow=124 (included, j=124)
DEBUG BB: Row 125 (uid=125) has lprow=125 (included, j=125)
DEBUG BB: Row 126 (uid=126) has lprow=126 (included, j=126)
DEBUG BB: Row 127 (uid=127) has lprow=127 (included, j=127)
DEBUG BB: Row 128 (uid=128) has lprow=128 (included, j=128)
DEBUG BB: Row 129 (uid=129) has lprow=129 (included, j=129)
DEBUG BB: Row 130 (uid=130) has lprow=130 (included, j=130)
DEBUG BB: Row 131 (uid=131) has lprow=131 (included, j=131)
DEBUG BB: Row 132 (uid=132) has lprow=132 (included, j=132)
DEBUG BB: Row 133 (uid=133) has lprow=-1 (skipped)
DEBUG BB: Row 134 (uid=134) has lprow=-1 (skipped)
DEBUG BB: Row 135 (uid=135) has lprow=-1 (skipped)
DEBUG BB: Row 136 (uid=136) has lprow=-1 (skipped)
DEBUG BB: Row 137 (uid=137) has lprow=-1 (skipped)
DEBUG BB: Row 138 (uid=138) has lprow=-1 (skipped)
DEBUG BB: Row 139 (uid=139) has lprow=-1 (skipped)
DEBUG BB: Row 140 (uid=140) has lprow=-1 (skipped)
DEBUG BB: Row 141 (uid=141) has lprow=-1 (skipped)
DEBUG BB: Row 142 (uid=142) has lprow=-1 (skipped)
DEBUG BB: Row 143 (uid=143) has lprow=-1 (skipped)
DEBUG BB: Row 144 (uid=144) has lprow=-1 (skipped)
DEBUG BB: Row 145 (uid=145) has lprow=-1 (skipped)
DEBUG BB: Row 146 (uid=146) has lprow=-1 (skipped)
DEBUG BB: Row 147 (uid=147) has lprow=-1 (skipped)
DEBUG BB: Row 148 (uid=148) has lprow=-1 (skipped)
DEBUG BB: Row 149 (uid=149) has lprow=-1 (skipped)
DEBUG BB: Row 150 (uid=150) has lprow=-1 (skipped)
DEBUG BB: Row 151 (uid=151) has lprow=-1 (skipped)
DEBUG BB: Row 152 (uid=152) has lprow=-1 (skipped)
DEBUG BB: Row 153 (uid=153) has lprow=-1 (skipped)
DEBUG BB: Row 154 (uid=154) has lprow=-1 (skipped)
DEBUG BB: Row 155 (uid=155) has lprow=-1 (skipped)
DEBUG BB: Row 156 (uid=156) has lprow=-1 (skipped)
DEBUG BB: Row 157 (uid=157) has lprow=-1 (skipped)
DEBUG BB: Row 158 (uid=158) has lprow=-1 (skipped)
DEBUG BB: Row 159 (uid=159) has lprow=-1 (skipped)
DEBUG BB: Row 160 (uid=160) has lprow=-1 (skipped)
DEBUG BB: Row 161 (uid=161) has lprow=133 (included, j=133)
DEBUG BB: Row 162 (uid=162) has lprow=134 (included, j=134)
DEBUG BB: Found 135 actual LP rows, expected 135
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7ca0600
% Resuming node 0
DEBUG CONSTRNT: LP rows=135, pool->nlprows=135, pool->npend=0
DEBUG CONSTRNT: Checking 135 LP rows (pool tracks 135, total LP rows 135)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 1
DEBUG CONSTRNT: Pool row 1 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 2
DEBUG CONSTRNT: Pool row 2 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 3
DEBUG CONSTRNT: Pool row 3 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 4
DEBUG CONSTRNT: Pool row 4 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 20
DEBUG CONSTRNT: Pool row 20 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 41
DEBUG CONSTRNT: Pool row 41 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 45
DEBUG CONSTRNT: Pool row 45 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 49
DEBUG CONSTRNT: Pool row 49 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 51
DEBUG CONSTRNT: Pool row 51 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 52
DEBUG CONSTRNT: Pool row 52 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=54, expected 54
DEBUG CONSTRNT: Checking LP row 55 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=55, expected 55
DEBUG CONSTRNT: Checking LP row 56 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=56, expected 56
DEBUG CONSTRNT: Checking LP row 57 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=57, expected 57
DEBUG CONSTRNT: Checking LP row 58 -> pool row 58
DEBUG CONSTRNT: Pool row 58 has lprow=58, expected 58
DEBUG CONSTRNT: Checking LP row 59 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=59, expected 59
DEBUG CONSTRNT: Checking LP row 60 -> pool row 60
DEBUG CONSTRNT: Pool row 60 has lprow=60, expected 60
DEBUG CONSTRNT: Checking LP row 61 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=61, expected 61
DEBUG CONSTRNT: Checking LP row 62 -> pool row 62
DEBUG CONSTRNT: Pool row 62 has lprow=62, expected 62
DEBUG CONSTRNT: Checking LP row 63 -> pool row 63
DEBUG CONSTRNT: Pool row 63 has lprow=63, expected 63
DEBUG CONSTRNT: Checking LP row 64 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=64, expected 64
DEBUG CONSTRNT: Checking LP row 65 -> pool row 65
DEBUG CONSTRNT: Pool row 65 has lprow=65, expected 65
DEBUG CONSTRNT: Checking LP row 66 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=66, expected 66
DEBUG CONSTRNT: Checking LP row 67 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=67, expected 67
DEBUG CONSTRNT: Checking LP row 68 -> pool row 68
DEBUG CONSTRNT: Pool row 68 has lprow=68, expected 68
DEBUG CONSTRNT: Checking LP row 69 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=69, expected 69
DEBUG CONSTRNT: Checking LP row 70 -> pool row 70
DEBUG CONSTRNT: Pool row 70 has lprow=70, expected 70
DEBUG CONSTRNT: Checking LP row 71 -> pool row 71
DEBUG CONSTRNT: Pool row 71 has lprow=71, expected 71
DEBUG CONSTRNT: Checking LP row 72 -> pool row 72
DEBUG CONSTRNT: Pool row 72 has lprow=72, expected 72
DEBUG CONSTRNT: Checking LP row 73 -> pool row 73
DEBUG CONSTRNT: Pool row 73 has lprow=73, expected 73
DEBUG CONSTRNT: Checking LP row 74 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=74, expected 74
DEBUG CONSTRNT: Checking LP row 75 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=75, expected 75
DEBUG CONSTRNT: Checking LP row 76 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=76, expected 76
DEBUG CONSTRNT: Checking LP row 77 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=77, expected 77
DEBUG CONSTRNT: Checking LP row 78 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=78, expected 78
DEBUG CONSTRNT: Checking LP row 79 -> pool row 79
DEBUG CONSTRNT: Pool row 79 has lprow=79, expected 79
DEBUG CONSTRNT: Checking LP row 80 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=80, expected 80
DEBUG CONSTRNT: Checking LP row 81 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=81, expected 81
DEBUG CONSTRNT: Checking LP row 82 -> pool row 82
DEBUG CONSTRNT: Pool row 82 has lprow=82, expected 82
DEBUG CONSTRNT: Checking LP row 83 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=83, expected 83
DEBUG CONSTRNT: Checking LP row 84 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=84, expected 84
DEBUG CONSTRNT: Checking LP row 85 -> pool row 85
DEBUG CONSTRNT: Pool row 85 has lprow=85, expected 85
DEBUG CONSTRNT: Checking LP row 86 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=86, expected 86
DEBUG CONSTRNT: Checking LP row 87 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=87, expected 87
DEBUG CONSTRNT: Checking LP row 88 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=88, expected 88
DEBUG CONSTRNT: Checking LP row 89 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=89, expected 89
DEBUG CONSTRNT: Checking LP row 90 -> pool row 90
DEBUG CONSTRNT: Pool row 90 has lprow=90, expected 90
DEBUG CONSTRNT: Checking LP row 91 -> pool row 91
DEBUG CONSTRNT: Pool row 91 has lprow=91, expected 91
DEBUG CONSTRNT: Checking LP row 92 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=92, expected 92
DEBUG CONSTRNT: Checking LP row 93 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=93, expected 93
DEBUG CONSTRNT: Checking LP row 94 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=94, expected 94
DEBUG CONSTRNT: Checking LP row 95 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=95, expected 95
DEBUG CONSTRNT: Checking LP row 96 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=96, expected 96
DEBUG CONSTRNT: Checking LP row 97 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=97, expected 97
DEBUG CONSTRNT: Checking LP row 98 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=98, expected 98
DEBUG CONSTRNT: Checking LP row 99 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=99, expected 99
DEBUG CONSTRNT: Checking LP row 100 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=100, expected 100
DEBUG CONSTRNT: Checking LP row 101 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=101, expected 101
DEBUG CONSTRNT: Checking LP row 102 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=102, expected 102
DEBUG CONSTRNT: Checking LP row 103 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=103, expected 103
DEBUG CONSTRNT: Checking LP row 104 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=104, expected 104
DEBUG CONSTRNT: Checking LP row 105 -> pool row 105
DEBUG CONSTRNT: Pool row 105 has lprow=105, expected 105
DEBUG CONSTRNT: Checking LP row 106 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=106, expected 106
DEBUG CONSTRNT: Checking LP row 107 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=107, expected 107
DEBUG CONSTRNT: Checking LP row 108 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=108, expected 108
DEBUG CONSTRNT: Checking LP row 109 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=109, expected 109
DEBUG CONSTRNT: Checking LP row 110 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=110, expected 110
DEBUG CONSTRNT: Checking LP row 111 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=111, expected 111
DEBUG CONSTRNT: Checking LP row 112 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=112, expected 112
DEBUG CONSTRNT: Checking LP row 113 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=113, expected 113
DEBUG CONSTRNT: Checking LP row 114 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=114, expected 114
DEBUG CONSTRNT: Checking LP row 115 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=115, expected 115
DEBUG CONSTRNT: Checking LP row 116 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=116, expected 116
DEBUG CONSTRNT: Checking LP row 117 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=117, expected 117
DEBUG CONSTRNT: Checking LP row 118 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=118, expected 118
DEBUG CONSTRNT: Checking LP row 119 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=119, expected 119
DEBUG CONSTRNT: Checking LP row 120 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=120, expected 120
DEBUG CONSTRNT: Checking LP row 121 -> pool row 121
DEBUG CONSTRNT: Pool row 121 has lprow=121, expected 121
DEBUG CONSTRNT: Checking LP row 122 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=122, expected 122
DEBUG CONSTRNT: Checking LP row 123 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=123, expected 123
DEBUG CONSTRNT: Checking LP row 124 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=124, expected 124
DEBUG CONSTRNT: Checking LP row 125 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=125, expected 125
DEBUG CONSTRNT: Checking LP row 126 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=126, expected 126
DEBUG CONSTRNT: Checking LP row 127 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=127, expected 127
DEBUG CONSTRNT: Checking LP row 128 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=128, expected 128
DEBUG CONSTRNT: Checking LP row 129 -> pool row 129
DEBUG CONSTRNT: Pool row 129 has lprow=129, expected 129
DEBUG CONSTRNT: Checking LP row 130 -> pool row 130
DEBUG CONSTRNT: Pool row 130 has lprow=130, expected 130
DEBUG CONSTRNT: Checking LP row 131 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=131, expected 131
DEBUG CONSTRNT: Checking LP row 132 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=132, expected 132
DEBUG CONSTRNT: Checking LP row 133 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=133, expected 133
DEBUG CONSTRNT: Checking LP row 134 -> pool row 162
DEBUG CONSTRNT: Pool row 162 has lprow=134, expected 134
 % @PAP adding 135 rows, 494 nz to LP
DEBUG BB: Processing node 0, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=149, theta=6.333333, up=1.000000
ITER 2: row=1, varin=155, theta=4.000000, up=1.000000
ITER 3: row=1, varin=152, theta=4.000000, up=1.000000
ITER 4: row=1, varin=151, theta=3.000000, up=1.000000
ITER 5: row=1, varin=150, theta=2.000000, up=1.000000
ITER 6: row=1, varin=144, theta=1.500000, up=1.000000
ITER 7: row=1, varin=143, theta=0.500000, up=1.000000
ITER 8: row=134, varin=176, theta=5.598769, up=1.000000
ITER 9: row=134, varin=177, theta=4.598769, up=1.000000
ITER 10: row=134, varin=178, theta=3.598769, up=1.000000
LP PHASE: Switching to primal (iter=29)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=135)
DEBUG SOLUTION: LP solution array indices: FST[136-175], not_covered[176-195]
DEBUG SOLUTION: lp->best_solution[0] = 26871710.919246
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 0.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 0.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 3.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.385563
DEBUG SOLUTION: lp->best_solution[11] = 0.385563
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.385563
DEBUG SOLUTION: lp->best_solution[14] = 0.385563
  % @PL 135 rows, 60 cols, 554 nonzeros, 83 slack, 52 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 83 slack rows
  % @PAP adding 10 rows, 44 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=54, varin=78, theta=5.411348, up=1.000000
ITER 2: row=54, varin=70, theta=3.026994, up=1.000000
ITER 3: row=54, varin=68, theta=1.923791, up=1.000000
ITER 4: row=54, varin=73, theta=1.263448, up=1.000000
ITER 5: row=54, varin=64, theta=0.384654, up=1.000000
ITER 6: row=6, varin=6, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=52, varin=76, theta=1.000000, up=1.000000
ITER 8: row=1, varin=35, theta=1.748171, up=999999999999999983222784.000000
ITER 9: row=39, varin=38, theta=1.000000, up=999999999999999983222784.000000
ITER 10: row=42, varin=40, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=13)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=62)
DEBUG SOLUTION: LP solution array indices: FST[63-102], not_covered[103-122]
DEBUG SOLUTION: lp->best_solution[0] = 27684326.745664
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 6.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 62 rows, 60 cols, 326 nonzeros, 7 slack, 55 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 7 slack rows
  % @PAP adding 9 rows, 35 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=58, varin=107, theta=0.400000, up=1.000000
ITER 2: row=61, varin=41, theta=0.250000, up=999999999999999983222784.000000
ITER 3: row=64, varin=70, theta=1.000000, up=1.000000
ITER 4: row=62, varin=117, theta=2.235003, up=1.000000
ITER 5: row=62, varin=66, theta=1.803200, up=1.000000
ITER 6: row=62, varin=85, theta=0.212427, up=1.000000
ITER 7: row=15, varin=109, theta=1.000000, up=1.000000
ITER 8: row=1, varin=119, theta=1.198896, up=1.000000
ITER 9: row=1, varin=120, theta=0.198896, up=1.000000
ITER 10: row=60, varin=61, theta=7.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=21)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=64)
DEBUG SOLUTION: LP solution array indices: FST[65-104], not_covered[105-124]
DEBUG SOLUTION: lp->best_solution[0] = 27713543.731098
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 0.688085
DEBUG SOLUTION: lp->best_solution[8] = 0.688085
DEBUG SOLUTION: lp->best_solution[9] = 0.688085
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.688085
DEBUG SOLUTION: lp->best_solution[12] = 0.688085
DEBUG SOLUTION: lp->best_solution[13] = 4.440427
DEBUG SOLUTION: lp->best_solution[14] = 0.376171
  % @PL 64 rows, 60 cols, 347 nonzeros, 34 slack, 30 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 34 slack rows
  % @PAP adding 8 rows, 33 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=37, varin=98, theta=0.148625, up=1.000000
ITER 2: row=31, varin=93, theta=1.000000, up=1.000000
ITER 3: row=35, varin=37, theta=7.342128, up=999999999999999983222784.000000
ITER 4: row=8, varin=46, theta=0.537552, up=1.000000
ITER 5: row=33, varin=83, theta=1.619214, up=1.000000
ITER 6: row=33, varin=94, theta=0.174438, up=1.000000
ITER 7: row=8, varin=83, theta=0.644111, up=1.000000
ITER 8: row=38, varin=41, theta=0.570175, up=1.000000
ITER 9: row=1, varin=91, theta=0.156659, up=1.000000
LP PHASE: Switching to primal (iter=9)
ITER 10: row=1, varin=40, theta=0.212436, up=1.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=38)
DEBUG SOLUTION: LP solution array indices: FST[39-78], not_covered[79-98]
DEBUG SOLUTION: lp->best_solution[0] = 27749546.229125
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 38 rows, 60 cols, 274 nonzeros, 5 slack, 33 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % @PAP adding 4 rows, 19 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=34, varin=45, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=37)
DEBUG SOLUTION: LP solution array indices: FST[38-77], not_covered[78-97]
DEBUG SOLUTION: lp->best_solution[0] = 27753117.021048
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 37 rows, 60 cols, 264 nonzeros, 2 slack, 35 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 2 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=36, varin=47, theta=0.139639, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=37)
DEBUG SOLUTION: LP solution array indices: FST[38-77], not_covered[78-97]
DEBUG SOLUTION: lp->best_solution[0] = 27754246.099158
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 37 rows, 60 cols, 253 nonzeros, 0 slack, 37 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 0 LP 1 Solution, length = 27754246.099158, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.279277 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.500000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.500000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.139639 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.500000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.500000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.500000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.500000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.720723 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.720723 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.500000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.720723 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.500000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.500000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.500000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.500000 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=27754246.099158, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
 % @LO 0.00  27.75424609915779328162 99.9000000000
 % @LN 0.00  27.75424609915779328162 99.9000000000
DEBUG CG: Second cutoff check: z=27754246.099158, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 % initially 3 congested vertices:
 % _gst_find_congested_components found 1 components:
 % 	component 0:	3 verts,	4 edges
 % @PAP adding 1 rows, 12 nz to LP
 % @PMEM 164 rows, 1 blocks, 402 nzfree, 0 nzwasted, 1172 nztotal
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=38, varin=41, theta=0.198333, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=38)
DEBUG SOLUTION: LP solution array indices: FST[39-78], not_covered[79-98]
DEBUG SOLUTION: lp->best_solution[0] = 27754413.920471
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 38 rows, 60 cols, 265 nonzeros, 0 slack, 38 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=39, varin=17, theta=154412.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=40)
DEBUG SOLUTION: LP solution array indices: FST[41-80], not_covered[81-100]
DEBUG SOLUTION: lp->best_solution[0] = 27756089.338381
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 40 rows, 60 cols, 271 nonzeros, 1 slack, 39 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 0 LP 2 Solution, length = 27756089.338381, 0.00/0.00/0.00/0.00/0.00/0.00/0.00 1
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.500000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.500000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.500000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.500000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.500000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.500000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.500000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.500000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.500000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.500000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.500000 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=27756089.338381, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
 % @LO 0.00  27.75424609915779328162 99.9000000000
 % @LN 0.00  27.75608933838106651137 99.9000000000
DEBUG CG: Second cutoff check: z=27756089.338381, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 0 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 0
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.500000
DEBUG CAREFUL: Adding var 5 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.500000
DEBUG CAREFUL: Adding var 7 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.500000
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.500000
DEBUG CAREFUL: Adding var 20 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 4 fractional variables

  %  Carefully choosing branching variable, nfrac = 4
DEBUG CAREFUL: Testing fvar[0] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 10
DEBUG CAREFUL: New best var: 10
DEBUG CAREFUL: Testing fvar[1] = var 20
DEBUG CAREFUL: Calling compare_branch_vars for var 20
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 20
DEBUG CAREFUL: New best var: 20
DEBUG CAREFUL: Testing fvar[2] = var 5
DEBUG CAREFUL: Calling compare_branch_vars for var 5
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 5
DEBUG CAREFUL: Testing fvar[3] = var 7
DEBUG CAREFUL: Calling compare_branch_vars for var 7
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 7
  % Initial guess is x20, Z0 = 27756089.3383811        , Z1 = 27764204.5066157        

DEBUG EVAL: Testing var 10 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=27, varin=27, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=36, varin=32, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 0 gives z=27780910.644085
  % 	x10 = 0,	Z0 = 27780910.6440854        
DEBUG EVAL: First branch cutoff check: z=27780910.644085, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 1
ITER 1: row=27, varin=35, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=1, varin=59, theta=0.250000, up=1.000000
ITER 3: row=28, varin=93, theta=1.000000, up=1.000000
  % 	x10 = 1,	Z1 = 27780601.9453603        
DEBUG EVAL: Second branch cutoff check: z=27780601.945360, best_z=INF, threshold=INF
  %   New best:  x10, Z = 27780601.9453603        
DEBUG EVAL: Testing var 20 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=6, varin=27, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=36, varin=31, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=1, varin=59, theta=0.250000, up=1.000000
ITER 4: row=28, varin=93, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 20 = 1 gives z=27803122.845308
  % 	x20 = 1,	Z1 = 27803122.8453078        
DEBUG EVAL: First branch cutoff check: z=27803122.845308, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 20 = 0
ITER 1: row=6, varin=35, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=1, varin=59, theta=0.250000, up=1.000000
ITER 3: row=28, varin=93, theta=1.000000, up=1.000000
  % 	x20 = 0,	Z0 = 27780601.9453603        
DEBUG EVAL: Second branch cutoff check: z=27780601.945360, best_z=INF, threshold=INF
  %   New best:  x20, Z = 27780601.9453603        
DEBUG EVAL: Testing var 5 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=7, varin=33, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=1, varin=59, theta=0.250000, up=1.000000
ITER 3: row=28, varin=93, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 5 = 0 gives z=27778600.113891
  % 	x5 = 0,	Z0 = 27778600.1138909        
DEBUG EVAL: First branch cutoff check: z=27778600.113891, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 7 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=25, varin=33, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=1, varin=59, theta=0.250000, up=1.000000
ITER 3: row=28, varin=93, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 7 = 1 gives z=27778600.113891
  % 	x7 = 1,	Z1 = 27778600.1138909        
DEBUG EVAL: First branch cutoff check: z=27778600.113891, best_z=INF, threshold=INF
  % Best branch is x20, Z0 = 27780601.9453603        , Z1 = 27803122.8453078        

DEBUG CAREFUL: Final result - returning best.var = 20
DEBUG BB: Branching variable chosen: j=20
 % @NC    1    0	x20 = 0	27780601.945360
 % @NC    2    0	x20 = 1	27803122.845308
 %       0     2 27756089.3384               27780601.9454
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cae7d0
% @LO 0.00  27.75608933838106651137 99.9000000000
% @LN 0.00  27.78060194536031701773 99.9000000000
% Resuming node 1 at  27.78060194536031701773
DEBUG CONSTRNT: LP rows=39, pool->nlprows=39, pool->npend=0
DEBUG CONSTRNT: Checking 39 LP rows (pool tracks 39, total LP rows 39)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 150
DEBUG CONSTRNT: Pool row 150 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 151
DEBUG CONSTRNT: Pool row 151 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=38, expected 38
 % @PAP adding 39 rows, 171 nz to LP
DEBUG BB: Processing node 1, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=6, varin=35, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=1, varin=59, theta=0.250000, up=1.000000
ITER 3: row=28, varin=93, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=39)
DEBUG SOLUTION: LP solution array indices: FST[40-79], not_covered[80-99]
DEBUG SOLUTION: lp->best_solution[0] = 27780601.945360
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 39 rows, 60 cols, 231 nonzeros, 3 slack, 36 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 12 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=40, varin=32, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=41)
DEBUG SOLUTION: LP solution array indices: FST[42-81], not_covered[82-101]
DEBUG SOLUTION: lp->best_solution[0] = 27780910.644085
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 41 rows, 60 cols, 243 nonzeros, 1 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 1 LP 1 Solution, length = 27780910.644085, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.500000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.500000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.500000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 2 fractional variables
DEBUG CG: LP optimal, z=27780910.644085, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
 % @LO 0.00  27.78060194536031701773 99.9000000000
 % @LN 0.00  27.78091064408537746999 99.9000000000
DEBUG CG: Second cutoff check: z=27780910.644085, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 1 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 1
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.500000
DEBUG CAREFUL: Adding var 5 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.500000
DEBUG CAREFUL: Adding var 7 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 2 fractional variables

  %  Carefully choosing branching variable, nfrac = 2
DEBUG CAREFUL: Testing fvar[0] = var 5
DEBUG CAREFUL: Calling compare_branch_vars for var 5
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 5
DEBUG CAREFUL: New best var: 5
DEBUG CAREFUL: Testing fvar[1] = var 7
DEBUG CAREFUL: Calling compare_branch_vars for var 7
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 7
  % Initial guess is x5, Z0 = 27780910.6440854        , Z1 = 27780910.6440854        

DEBUG EVAL: Testing var 5 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=32, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=27, varin=28, theta=0.166667, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 5 = 0 gives z=27808212.001585
  % 	x5 = 0,	Z0 = 27808212.0015846        
DEBUG EVAL: First branch cutoff check: z=27808212.001585, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 5 = 1
ITER 1: row=1, varin=25, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=33, varin=26, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=27, varin=58, theta=0.333333, up=1.000000
ITER 4: row=40, varin=9, theta=0.041667, up=999999999999999983222784.000000
  % 	x5 = 1,	Z1 = 27853628.31674          
DEBUG EVAL: Second branch cutoff check: z=27853628.316740, best_z=INF, threshold=INF
  %   New best:  x5, Z = 27808212.0015846        
DEBUG EVAL: Testing var 7 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=25, varin=25, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=33, varin=26, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=27, varin=28, theta=0.166667, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 7 = 0 gives z=27830315.803990
  % 	x7 = 0,	Z0 = 27830315.8039897        
DEBUG EVAL: First branch cutoff check: z=27830315.803990, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 7 = 1
ITER 1: row=25, varin=32, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=27, varin=28, theta=0.250000, up=999999999999999983222784.000000
ITER 3: row=1, varin=58, theta=0.333333, up=1.000000
ITER 4: row=40, varin=9, theta=0.041667, up=999999999999999983222784.000000
  % 	x7 = 1,	Z1 = 27827103.7538538        
DEBUG EVAL: Second branch cutoff check: z=27827103.753854, best_z=INF, threshold=INF
  %   New best:  x7, Z = 27827103.7538538        
  % Best branch is x7, Z0 = 27830315.8039897        , Z1 = 27827103.7538538        

DEBUG CAREFUL: Final result - returning best.var = 7
DEBUG BB: Branching variable chosen: j=7
 % @NC    3    1	x7 = 1	27827103.753854
 % @NC    4    1	x7 = 0	27830315.803990
 %       1     3 27780910.6441               27803122.8453   x20 D     0     1
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7caffe0
% @LO 0.00  27.78091064408537746999 99.9000000000
% @LN 0.00  27.80312284530776167912 99.9000000000
% Resuming node 2 at  27.80312284530776167912
DEBUG CONSTRNT: LP rows=40, pool->nlprows=40, pool->npend=0
DEBUG CONSTRNT: Checking 40 LP rows (pool tracks 40, total LP rows 40)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 150
DEBUG CONSTRNT: Pool row 150 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 151
DEBUG CONSTRNT: Pool row 151 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=39, expected 39
 % @PAP adding 39 rows, 171 nz to LP
DEBUG BB: Processing node 2, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=6, varin=27, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=36, varin=31, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=1, varin=59, theta=0.250000, up=1.000000
ITER 4: row=28, varin=93, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=39)
DEBUG SOLUTION: LP solution array indices: FST[40-79], not_covered[80-99]
DEBUG SOLUTION: lp->best_solution[0] = 27803122.845308
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 39 rows, 60 cols, 231 nonzeros, 3 slack, 36 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 40 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=40, varin=28, theta=0.257425, up=999999999999999983222784.000000
ITER 2: row=39, varin=38, theta=0.170482, up=999999999999999983222784.000000
ITER 3: row=1, varin=32, theta=0.205909, up=999999999999999983222784.000000
ITER 4: row=32, varin=37, theta=0.159757, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=40)
DEBUG SOLUTION: LP solution array indices: FST[41-80], not_covered[81-100]
DEBUG SOLUTION: lp->best_solution[0] = 27831156.758384
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 40 rows, 60 cols, 271 nonzeros, 6 slack, 34 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 6 slack rows
  % Node 2 LP 1 Solution, length = 27831156.758384, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.304146 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.304146 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.231951 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.231951 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.768049 (FST 19)
  % DEBUG LP_VARS: x[20] = 1.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.695854 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.231951 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.231951 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.231951 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.695854 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.231951 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.231951 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=27831156.758384, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 2 at  27.83115675838436331446
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7ca0600
% @LO 0.00  27.80312284530776167912 99.9000000000
% @LN 0.00  27.82710375385379819591 99.9000000000
% Resuming node 3 at  27.82710375385379819591
DEBUG CONSTRNT: LP rows=34, pool->nlprows=34, pool->npend=0
DEBUG CONSTRNT: Checking 34 LP rows (pool tracks 34, total LP rows 34)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=33, expected 33
 % @PAP adding 40 rows, 179 nz to LP
DEBUG BB: Processing node 3, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=25, varin=32, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=27, varin=28, theta=0.250000, up=999999999999999983222784.000000
ITER 3: row=1, varin=58, theta=0.333333, up=1.000000
ITER 4: row=40, varin=9, theta=0.041667, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=40)
DEBUG SOLUTION: LP solution array indices: FST[41-80], not_covered[81-100]
DEBUG SOLUTION: lp->best_solution[0] = 27827103.753854
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.958333
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 40 rows, 60 cols, 239 nonzeros, 4 slack, 36 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 7 rows, 33 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=41, varin=48, theta=0.500000, up=1.000000
ITER 2: row=2, varin=6, theta=0.500000, up=999999999999999983222784.000000
ITER 3: row=44, varin=17, theta=0.111111, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 27860015.707551
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 47 rows, 60 cols, 272 nonzeros, 7 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 7 slack rows
  % @PAP adding 2 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=41, varin=12, theta=0.285714, up=999999999999999983222784.000000
ITER 2: row=42, varin=84, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 27901639.463045
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 42 rows, 60 cols, 254 nonzeros, 3 slack, 39 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 4 rows, 15 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=40, varin=59, theta=0.333333, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 27903902.611877
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.666667
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 43 rows, 60 cols, 261 nonzeros, 1 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 3 LP 1 Solution, length = 27903902.611877, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.333333 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.666667 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.333333 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.333333 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.333333 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.333333 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 2 fractional variables
DEBUG CG: LP optimal, z=27903902.611877, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 3 at  27.90390261187718223823
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cb30f0
% @LO 0.00  27.82710375385379819591 99.9000000000
% @LN 0.00  27.83031580398970916690 99.9000000000
% Resuming node 4 at  27.83031580398970916690
DEBUG CONSTRNT: LP rows=42, pool->nlprows=42, pool->npend=0
DEBUG CONSTRNT: Checking 42 LP rows (pool tracks 42, total LP rows 42)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=41, expected 41
 % @PAP adding 40 rows, 179 nz to LP
DEBUG BB: Processing node 4, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=25, varin=25, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=33, varin=26, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=27, varin=28, theta=0.166667, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=40)
DEBUG SOLUTION: LP solution array indices: FST[41-80], not_covered[81-100]
DEBUG SOLUTION: lp->best_solution[0] = 27830315.803990
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 40 rows, 60 cols, 239 nonzeros, 5 slack, 35 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 4 LP 1 Solution, length = 27830315.803990, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.833333 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.166667 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.166667 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.833333 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.166667 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.166667 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.166667 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.166667 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.166667 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.166667 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.166667 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=27830315.803990, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=27830315.803990, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 4 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 4
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.833333
DEBUG CAREFUL: Adding var 5 to fractional list (xi=0.833333)
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.166667
DEBUG CAREFUL: Adding var 12 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.166667
DEBUG CAREFUL: Adding var 13 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.833333
DEBUG CAREFUL: Adding var 19 to fractional list (xi=0.833333)
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 4 fractional variables

  %  Carefully choosing branching variable, nfrac = 4
DEBUG CAREFUL: Testing fvar[0] = var 13
DEBUG CAREFUL: Calling compare_branch_vars for var 13
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 13
DEBUG CAREFUL: New best var: 13
DEBUG CAREFUL: Testing fvar[1] = var 12
DEBUG CAREFUL: Calling compare_branch_vars for var 12
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 12
DEBUG CAREFUL: Testing fvar[2] = var 19
DEBUG CAREFUL: Calling compare_branch_vars for var 19
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 19
DEBUG CAREFUL: New best var: 19
DEBUG CAREFUL: Testing fvar[3] = var 5
DEBUG CAREFUL: Calling compare_branch_vars for var 5
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 5
DEBUG CAREFUL: New best var: 5
  % Initial guess is x5, Z0 = 27830315.8039897        , Z1 = 27853628.31674          

DEBUG EVAL: Testing var 13 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=17, varin=50, theta=0.500000, up=1.000000
DEBUG EVAL: Branch var 13 = 0 gives z=27835696.665213
  % 	x13 = 0,	Z0 = 27835696.6652128        
DEBUG EVAL: First branch cutoff check: z=27835696.665213, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 13 = 1
ITER 1: row=17, varin=51, theta=5.000000, up=1.000000
ITER 2: row=17, varin=39, theta=4.000000, up=999999999999999983222784.000000
ITER 3: row=38, varin=42, theta=4.000000, up=1.000000
ITER 4: row=38, varin=37, theta=1.200000, up=999999999999999983222784.000000
ITER 5: row=39, varin=22, theta=1.500000, up=999999999999999983222784.000000
ITER 6: row=22, varin=38, theta=3.000000, up=999999999999999983222784.000000
  % 	x13 = 1,	Z1 = 27940162.4332934        
DEBUG EVAL: Second branch cutoff check: z=27940162.433293, best_z=INF, threshold=INF
  %   New best:  x13, Z = 27835696.6652128        
DEBUG EVAL: Testing var 12 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=22, varin=50, theta=0.500000, up=1.000000
DEBUG EVAL: Branch var 12 = 0 gives z=27835696.665213
  % 	x12 = 0,	Z0 = 27835696.6652128        
DEBUG EVAL: First branch cutoff check: z=27835696.665213, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 12 = 1
ITER 1: row=22, varin=51, theta=5.000000, up=1.000000
ITER 2: row=22, varin=39, theta=4.000000, up=999999999999999983222784.000000
ITER 3: row=38, varin=42, theta=4.000000, up=1.000000
ITER 4: row=38, varin=37, theta=1.200000, up=999999999999999983222784.000000
ITER 5: row=39, varin=11, theta=3.000000, up=999999999999999983222784.000000
ITER 6: row=12, varin=15, theta=2.000000, up=999999999999999983222784.000000
ITER 7: row=33, varin=12, theta=1.000000, up=999999999999999983222784.000000
  % 	x12 = 1,	Z1 = 27952838.1526879        
DEBUG EVAL: Second branch cutoff check: z=27952838.152688, best_z=INF, threshold=INF
  %   New best:  x12, Z = 27835696.6652128        
DEBUG EVAL: Testing var 19 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=10, varin=50, theta=0.500000, up=1.000000
DEBUG EVAL: Branch var 19 = 1 gives z=27835696.665213
  % 	x19 = 1,	Z1 = 27835696.6652128        
DEBUG EVAL: First branch cutoff check: z=27835696.665213, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 19 = 0
ITER 1: row=10, varin=51, theta=5.000000, up=1.000000
ITER 2: row=10, varin=39, theta=4.000000, up=999999999999999983222784.000000
ITER 3: row=38, varin=42, theta=4.000000, up=1.000000
ITER 4: row=38, varin=37, theta=1.200000, up=999999999999999983222784.000000
ITER 5: row=39, varin=22, theta=1.500000, up=999999999999999983222784.000000
ITER 6: row=22, varin=38, theta=3.000000, up=999999999999999983222784.000000
  % 	x19 = 0,	Z0 = 27940162.4332934        
DEBUG EVAL: Second branch cutoff check: z=27940162.433293, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 5 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=58, theta=0.333333, up=1.000000
ITER 2: row=40, varin=9, theta=0.041667, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 5 = 1 gives z=27853628.316740
  % 	x5 = 1,	Z1 = 27853628.31674          
DEBUG EVAL: First branch cutoff check: z=27853628.316740, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 5 = 0
ITER 1: row=1, varin=51, theta=5.000000, up=1.000000
ITER 2: row=1, varin=39, theta=4.000000, up=999999999999999983222784.000000
ITER 3: row=38, varin=50, theta=1.000000, up=1.000000
  % 	x5 = 0,	Z0 = 27841138.6492192        
DEBUG EVAL: Second branch cutoff check: z=27841138.649219, best_z=INF, threshold=INF
  %   New best:  x5, Z = 27841138.6492192        
  % Best branch is x5, Z0 = 27841138.6492192        , Z1 = 27853628.31674          

DEBUG CAREFUL: Final result - returning best.var = 5
DEBUG BB: Branching variable chosen: j=5
 % @NC    5    4	x5 = 0	27841138.649219
 % @NC    6    4	x5 = 1	27853628.316740
 %       4     4 27830315.8040               27831156.7584    x7 D     1     2
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7caffe0
% @LO 0.00  27.83031580398970916690 99.9000000000
% @LN 0.00  27.83115675838436331446 99.9000000000
% Resuming node 2 at  27.83115675838436331446
DEBUG CONSTRNT: LP rows=40, pool->nlprows=40, pool->npend=0
DEBUG CONSTRNT: Checking 40 LP rows (pool tracks 40, total LP rows 40)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 150
DEBUG CONSTRNT: Pool row 150 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 151
DEBUG CONSTRNT: Pool row 151 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=39, expected 39
 % @PAP adding 34 rows, 186 nz to LP
DEBUG BB: Processing node 2, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 2 LP 2 Solution, length = 27831156.758384, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.304146 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.304146 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.231951 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.231951 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.768049 (FST 19)
  % DEBUG LP_VARS: x[20] = 1.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.695854 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.231951 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.231951 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.231951 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.695854 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.231951 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.231951 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=27831156.758384, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=27831156.758384, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 2 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 2
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.304146
DEBUG CAREFUL: Adding var 5 to fractional list (xi=0.304146)
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.304146
DEBUG CAREFUL: Adding var 7 to fractional list (xi=0.304146)
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.231951
DEBUG CAREFUL: Adding var 12 to fractional list (xi=0.231951)
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.231951
DEBUG CAREFUL: Adding var 13 to fractional list (xi=0.231951)
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.768049
DEBUG CAREFUL: Adding var 19 to fractional list (xi=0.768049)
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=1.000000
DEBUG CAREFUL: Skipping var 20: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 19
DEBUG CAREFUL: Calling compare_branch_vars for var 19
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 19
DEBUG CAREFUL: New best var: 19
DEBUG CAREFUL: Testing fvar[1] = var 12
DEBUG CAREFUL: Calling compare_branch_vars for var 12
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 12
DEBUG CAREFUL: Testing fvar[2] = var 13
DEBUG CAREFUL: Calling compare_branch_vars for var 13
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 13
DEBUG CAREFUL: Testing fvar[3] = var 5
DEBUG CAREFUL: Calling compare_branch_vars for var 5
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 5
DEBUG CAREFUL: Testing fvar[4] = var 7
DEBUG CAREFUL: Calling compare_branch_vars for var 7
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 7
  % Initial guess is x19, Z0 = 27845684.1451666        , Z1 = 27831156.7583844        

DEBUG EVAL: Testing var 19 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
DEBUG EVAL: Branch var 19 = 1 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x19 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=10, varin=15, theta=4.278765, up=999999999999999983222784.000000
ITER 2: row=34, varin=20, theta=1.860487, up=999999999999999983222784.000000
ITER 3: row=20, varin=28, theta=1.557125, up=999999999999999983222784.000000
ITER 4: row=1, varin=33, theta=3.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=34)
DEBUG SOLUTION: LP solution array indices: FST[35-74], not_covered[75-94]
DEBUG SOLUTION: lp->best_solution[0] = 27943137.543149
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 34 rows, 60 cols, 246 nonzeros, 8 slack, 26 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 8 slack rows
   % @PAP adding 10 rows, 59 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=33, varin=12, theta=0.117716, up=999999999999999983222784.000000
ITER 2: row=27, varin=10, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=29, varin=11, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=1, varin=95, theta=1.117716, up=1.000000
ITER 5: row=1, varin=42, theta=0.056565, up=1.000000
ITER 6: row=32, varin=33, theta=11.996520, up=999999999999999983222784.000000
ITER 7: row=34, varin=49, theta=1.230902, up=1.000000
ITER 8: row=34, varin=20, theta=0.395063, up=999999999999999983222784.000000
ITER 9: row=35, varin=49, theta=0.353567, up=1.000000
ITER 10: row=36, varin=47, theta=0.441487, up=1.000000
LP PHASE: Switching to primal (iter=12)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=36)
DEBUG SOLUTION: LP solution array indices: FST[37-76], not_covered[77-96]
DEBUG SOLUTION: lp->best_solution[0] = 27995933.674635
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 36 rows, 60 cols, 281 nonzeros, 8 slack, 28 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 8 slack rows
   % @PAP adding 6 rows, 22 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=31, varin=11, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=33, varin=47, theta=1.000000, up=1.000000
ITER 3: row=29, varin=22, theta=783985.000000, up=999999999999999983222784.000000
ITER 4: row=1, varin=27, theta=2.000000, up=999999999999999983222784.000000
ITER 5: row=16, varin=51, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=34)
DEBUG SOLUTION: LP solution array indices: FST[35-74], not_covered[75-94]
DEBUG SOLUTION: lp->best_solution[0] = 28050238.584257
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.500000
   % @PL 34 rows, 60 cols, 262 nonzeros, 3 slack, 31 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 3 slack rows
   % @PAP adding 2 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=32, varin=49, theta=0.333333, up=1.000000
ITER 2: row=33, varin=76, theta=0.074074, up=1.000000
ITER 3: row=29, varin=33, theta=2.666667, up=999999999999999983222784.000000
ITER 4: row=1, varin=92, theta=0.074074, up=1.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=33)
DEBUG SOLUTION: LP solution array indices: FST[34-73], not_covered[74-93]
DEBUG SOLUTION: lp->best_solution[0] = 28054387.354374
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.925926
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 33 rows, 60 cols, 221 nonzeros, 3 slack, 30 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 3 slack rows
   % @PAP adding 2 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=31, varin=28, theta=0.444444, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=32)
DEBUG SOLUTION: LP solution array indices: FST[33-72], not_covered[73-92]
DEBUG SOLUTION: lp->best_solution[0] = 28056265.238729
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 32 rows, 60 cols, 210 nonzeros, 1 slack, 31 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 2 at  28.05626523872902922108
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cae7d0
% @LO 0.00  27.83115675838436331446 99.9000000000
% @LN 0.00  27.84113864921917169681 99.9000000000
% Resuming node 5 at  27.84113864921917169681
DEBUG CONSTRNT: LP rows=31, pool->nlprows=31, pool->npend=0
DEBUG CONSTRNT: Checking 31 LP rows (pool tracks 31, total LP rows 31)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 65
DEBUG CONSTRNT: Pool row 65 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=30, expected 30
 % @PAP adding 40 rows, 179 nz to LP
DEBUG BB: Processing node 5, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=51, theta=5.000000, up=1.000000
ITER 2: row=1, varin=39, theta=4.000000, up=999999999999999983222784.000000
ITER 3: row=38, varin=50, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=40)
DEBUG SOLUTION: LP solution array indices: FST[41-80], not_covered[81-100]
DEBUG SOLUTION: lp->best_solution[0] = 27841138.649219
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 40 rows, 60 cols, 239 nonzeros, 3 slack, 37 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 11 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=41, varin=36, theta=0.666667, up=999999999999999983222784.000000
ITER 2: row=42, varin=33, theta=0.046512, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 27865226.639983
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 42 rows, 60 cols, 250 nonzeros, 8 slack, 34 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 8 slack rows
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=35, varin=34, theta=1.714286, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=35)
DEBUG SOLUTION: LP solution array indices: FST[36-75], not_covered[76-95]
DEBUG SOLUTION: lp->best_solution[0] = 27866075.518559
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 35 rows, 60 cols, 223 nonzeros, 1 slack, 34 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 5 LP 1 Solution, length = 27866075.518559, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.285714 (FST 9)
  % DEBUG LP_VARS: x[10] = 1.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.285714 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.285714 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.714286 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.285714 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.285714 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.285714 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.714286 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.285714 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.285714 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=27866075.518559, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 5 at  27.86607551855918885053
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cb66c0
% @LO 0.00  27.84113864921917169681 99.9000000000
% @LN 0.00  27.85362831673998229576 99.9000000000
% Resuming node 6 at  27.85362831673998229576
DEBUG CONSTRNT: LP rows=34, pool->nlprows=34, pool->npend=0
DEBUG CONSTRNT: Checking 34 LP rows (pool tracks 34, total LP rows 34)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=33, expected 33
 % @PAP adding 40 rows, 179 nz to LP
DEBUG BB: Processing node 6, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=58, theta=0.333333, up=1.000000
ITER 2: row=40, varin=9, theta=0.041667, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=40)
DEBUG SOLUTION: LP solution array indices: FST[41-80], not_covered[81-100]
DEBUG SOLUTION: lp->best_solution[0] = 27853628.316740
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.958333
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 40 rows, 60 cols, 239 nonzeros, 4 slack, 36 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 7 rows, 33 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=41, varin=48, theta=0.500000, up=1.000000
ITER 2: row=2, varin=6, theta=0.500000, up=999999999999999983222784.000000
ITER 3: row=44, varin=17, theta=0.111111, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 27886540.270437
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 47 rows, 60 cols, 272 nonzeros, 7 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 7 slack rows
  % @PAP adding 2 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=41, varin=10, theta=0.285714, up=999999999999999983222784.000000
ITER 2: row=42, varin=84, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 27928164.025931
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 42 rows, 60 cols, 252 nonzeros, 3 slack, 39 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 4 rows, 15 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=40, varin=59, theta=0.333333, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 27930427.174763
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 0.666667
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 43 rows, 60 cols, 259 nonzeros, 1 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 6 LP 1 Solution, length = 27930427.174763, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.333333 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.666667 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.333333 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.333333 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.333333 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.333333 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 2 fractional variables
DEBUG CG: LP optimal, z=27930427.174763, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 6 at  27.93042717476336633808
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cae7d0
% @LO 0.00  27.85362831673998229576 99.9000000000
% @LN 0.00  27.86607551855918885053 99.9000000000
% Resuming node 5 at  27.86607551855918885053
DEBUG CONSTRNT: LP rows=42, pool->nlprows=42, pool->npend=0
DEBUG CONSTRNT: Checking 42 LP rows (pool tracks 42, total LP rows 42)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=41, expected 41
 % @PAP adding 34 rows, 154 nz to LP
DEBUG BB: Processing node 5, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 5 LP 2 Solution, length = 27866075.518559, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.285714 (FST 9)
  % DEBUG LP_VARS: x[10] = 1.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.285714 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.285714 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.714286 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.285714 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.285714 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.285714 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.714286 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.285714 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.285714 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=27866075.518559, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=27866075.518559, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 5 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 5
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.285714
DEBUG CAREFUL: Adding var 9 to fractional list (xi=0.285714)
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=1.000000
DEBUG CAREFUL: Skipping var 10: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.285714
DEBUG CAREFUL: Adding var 12 to fractional list (xi=0.285714)
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.285714
DEBUG CAREFUL: Adding var 13 to fractional list (xi=0.285714)
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.714286
DEBUG CAREFUL: Adding var 19 to fractional list (xi=0.714286)
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 4 fractional variables

  %  Carefully choosing branching variable, nfrac = 4
DEBUG CAREFUL: Testing fvar[0] = var 13
DEBUG CAREFUL: Calling compare_branch_vars for var 13
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 13
DEBUG CAREFUL: New best var: 13
DEBUG CAREFUL: Testing fvar[1] = var 12
DEBUG CAREFUL: Calling compare_branch_vars for var 12
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 12
DEBUG CAREFUL: New best var: 12
DEBUG CAREFUL: Testing fvar[2] = var 19
DEBUG CAREFUL: Calling compare_branch_vars for var 19
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 19
DEBUG CAREFUL: Testing fvar[3] = var 9
DEBUG CAREFUL: Calling compare_branch_vars for var 9
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 9
  % Initial guess is x12, Z0 = 27866075.5185592        , Z1 = 27952838.1526879        

DEBUG EVAL: Testing var 13 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=17, varin=36, theta=5.000000, up=1.000000
ITER 2: row=17, varin=29, theta=1.600000, up=999999999999999983222784.000000
ITER 3: row=1, varin=33, theta=2.000000, up=999999999999999983222784.000000
ITER 4: row=29, varin=20, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 13 = 1 gives z=27940162.433293
  % 	x13 = 1,	Z1 = 27940162.4332934        
DEBUG EVAL: First branch cutoff check: z=27940162.433293, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 13 = 0
ITER 1: row=17, varin=34, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=29, varin=30, theta=2.000000, up=999999999999999983222784.000000
ITER 3: row=31, varin=45, theta=1.000000, up=1.000000
  % 	x13 = 0,	Z0 = 27877220.4048972        
DEBUG EVAL: Second branch cutoff check: z=27877220.404897, best_z=INF, threshold=INF
  %   New best:  x13, Z = 27877220.4048972        
DEBUG EVAL: Testing var 12 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=20, varin=36, theta=5.000000, up=1.000000
ITER 2: row=20, varin=29, theta=1.600000, up=999999999999999983222784.000000
ITER 3: row=1, varin=33, theta=2.000000, up=999999999999999983222784.000000
ITER 4: row=29, varin=14, theta=2.000000, up=999999999999999983222784.000000
ITER 5: row=15, varin=6, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 12 = 1 gives z=27952838.152688
  % 	x12 = 1,	Z1 = 27952838.1526879        
DEBUG EVAL: First branch cutoff check: z=27952838.152688, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 12 = 0
ITER 1: row=20, varin=34, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=29, varin=30, theta=2.000000, up=999999999999999983222784.000000
ITER 3: row=31, varin=45, theta=1.000000, up=1.000000
  % 	x12 = 0,	Z0 = 27877220.4048972        
DEBUG EVAL: Second branch cutoff check: z=27877220.404897, best_z=INF, threshold=INF
  %   New best:  x12, Z = 27877220.4048972        
DEBUG EVAL: Testing var 19 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=10, varin=34, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=29, varin=30, theta=2.000000, up=999999999999999983222784.000000
ITER 3: row=31, varin=45, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 19 = 1 gives z=27877220.404897
  % 	x19 = 1,	Z1 = 27877220.4048972        
DEBUG EVAL: First branch cutoff check: z=27877220.404897, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 19 = 0
ITER 1: row=10, varin=36, theta=5.000000, up=1.000000
ITER 2: row=10, varin=29, theta=1.600000, up=999999999999999983222784.000000
ITER 3: row=1, varin=33, theta=2.000000, up=999999999999999983222784.000000
ITER 4: row=29, varin=20, theta=1.000000, up=999999999999999983222784.000000
  % 	x19 = 0,	Z0 = 27940162.4332934        
DEBUG EVAL: Second branch cutoff check: z=27940162.433293, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 9 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=29, varin=33, theta=0.400000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 9 = 0 gives z=27876050.266295
  % 	x9 = 0,	Z0 = 27876050.2662952        
DEBUG EVAL: First branch cutoff check: z=27876050.266295, best_z=INF, threshold=INF
  % Best branch is x12, Z0 = 27877220.4048972        , Z1 = 27952838.1526879        

DEBUG CAREFUL: Final result - returning best.var = 12
DEBUG BB: Branching variable chosen: j=12
 % @NC    7    5	x12 = 0	27877220.404897
 % @NC    8    5	x12 = 1	27952838.152688
 %       5     5 27866075.5186               27877220.4049    x5 D     4     3
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cb30f0
% @LO 0.00  27.86607551855918885053 99.9000000000
% @LN 0.00  27.87722040489720498613 99.9000000000
% Resuming node 7 at  27.87722040489720498613
DEBUG CONSTRNT: LP rows=34, pool->nlprows=34, pool->npend=0
DEBUG CONSTRNT: Checking 34 LP rows (pool tracks 34, total LP rows 34)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=33, expected 33
 % @PAP adding 34 rows, 154 nz to LP
DEBUG BB: Processing node 7, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=20, varin=34, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=29, varin=30, theta=2.000000, up=999999999999999983222784.000000
ITER 3: row=31, varin=45, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=34)
DEBUG SOLUTION: LP solution array indices: FST[35-74], not_covered[75-94]
DEBUG SOLUTION: lp->best_solution[0] = 27877220.404897
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 34 rows, 60 cols, 214 nonzeros, 1 slack, 33 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=35, varin=20, theta=0.250000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=36)
DEBUG SOLUTION: LP solution array indices: FST[37-76], not_covered[77-96]
DEBUG SOLUTION: lp->best_solution[0] = 27879177.292005
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 36 rows, 60 cols, 222 nonzeros, 5 slack, 31 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % @PAP adding 3 rows, 20 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=34, varin=44, theta=0.250000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=34)
DEBUG SOLUTION: LP solution array indices: FST[35-74], not_covered[75-94]
DEBUG SOLUTION: lp->best_solution[0] = 27880442.606140
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 34 rows, 60 cols, 222 nonzeros, 0 slack, 34 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 7 LP 1 Solution, length = 27880442.606140, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.750000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.750000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.250000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.750000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.250000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.250000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.250000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.250000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.250000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.250000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.250000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.250000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.250000 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=27880442.606140, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
 % @LO 0.00  27.87722040489720498613 99.9000000000
 % @LN 0.00  27.88044260613972014085 99.9000000000
DEBUG CG: Second cutoff check: z=27880442.606140, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 7 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 7
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.750000
DEBUG CAREFUL: Adding var 9 to fractional list (xi=0.750000)
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.750000
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.750000)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.250000
DEBUG CAREFUL: Adding var 13 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.750000
DEBUG CAREFUL: Adding var 19 to fractional list (xi=0.750000)
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 4 fractional variables

  %  Carefully choosing branching variable, nfrac = 4
DEBUG CAREFUL: Testing fvar[0] = var 13
DEBUG CAREFUL: Calling compare_branch_vars for var 13
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 13
DEBUG CAREFUL: New best var: 13
DEBUG CAREFUL: Testing fvar[1] = var 19
DEBUG CAREFUL: Calling compare_branch_vars for var 19
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 19
DEBUG CAREFUL: Testing fvar[2] = var 9
DEBUG CAREFUL: Calling compare_branch_vars for var 9
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 9
DEBUG CAREFUL: Testing fvar[3] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
  % Initial guess is x13, Z0 = 27880442.6061397        , Z1 = 27940162.4332934        

DEBUG EVAL: Testing var 13 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=17, varin=31, theta=3.000000, up=999999999999999983222784.000000
ITER 2: row=21, varin=28, theta=2.000000, up=999999999999999983222784.000000
ITER 3: row=27, varin=34, theta=2.000000, up=999999999999999983222784.000000
ITER 4: row=1, varin=36, theta=2.000000, up=1.000000
ITER 5: row=1, varin=26, theta=0.400000, up=999999999999999983222784.000000
ITER 6: row=28, varin=11, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 13 = 1 gives z=27940162.433293
  % 	x13 = 1,	Z1 = 27940162.4332934        
DEBUG EVAL: First branch cutoff check: z=27940162.433293, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 13 = 0
ITER 1: row=17, varin=52, theta=0.333333, up=1.000000
ITER 2: row=29, varin=9, theta=0.041667, up=999999999999999983222784.000000
  % 	x13 = 0,	Z0 = 27900594.0404307        
DEBUG EVAL: Second branch cutoff check: z=27900594.040431, best_z=INF, threshold=INF
  %   New best:  x13, Z = 27900594.0404307        
DEBUG EVAL: Testing var 19 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=10, varin=52, theta=0.333333, up=1.000000
ITER 2: row=29, varin=9, theta=0.041667, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 19 = 1 gives z=27900594.040431
  % 	x19 = 1,	Z1 = 27900594.0404307        
DEBUG EVAL: First branch cutoff check: z=27900594.040431, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 19 = 0
ITER 1: row=10, varin=31, theta=3.000000, up=999999999999999983222784.000000
ITER 2: row=21, varin=28, theta=2.000000, up=999999999999999983222784.000000
ITER 3: row=27, varin=34, theta=2.000000, up=999999999999999983222784.000000
ITER 4: row=1, varin=36, theta=2.000000, up=1.000000
ITER 5: row=1, varin=26, theta=0.400000, up=999999999999999983222784.000000
ITER 6: row=28, varin=15, theta=1.000000, up=999999999999999983222784.000000
  % 	x19 = 0,	Z0 = 27940162.4332934        
DEBUG EVAL: Second branch cutoff check: z=27940162.433293, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 9 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=52, theta=0.333333, up=1.000000
ITER 2: row=29, varin=9, theta=0.041667, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 9 = 1 gives z=27900594.040431
  % 	x9 = 1,	Z1 = 27900594.0404307        
DEBUG EVAL: First branch cutoff check: z=27900594.040431, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 9 = 0
ITER 1: row=1, varin=34, theta=0.750000, up=999999999999999983222784.000000
  % 	x9 = 0,	Z0 = 27884238.5485439        
DEBUG EVAL: Second branch cutoff check: z=27884238.548544, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 10 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=21, varin=31, theta=0.333333, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 1 gives z=27881516.673221
  % 	x10 = 1,	Z1 = 27881516.6732206        
DEBUG EVAL: First branch cutoff check: z=27881516.673221, best_z=INF, threshold=INF
  % Best branch is x13, Z0 = 27900594.0404307        , Z1 = 27940162.4332934        

DEBUG CAREFUL: Final result - returning best.var = 13
DEBUG BB: Branching variable chosen: j=13
 % @NC    9    7	x13 = 0	27900594.040431
 % @NC   10    7	x13 = 1	27940162.433293
 %       7     6 27880442.6061               27900594.0404   x12 D     5     4
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cae7d0
% @LO 0.00  27.88044260613972014085 99.9000000000
% @LN 0.00  27.90059404043068269630 99.9000000000
% Resuming node 9 at  27.90059404043068269630
DEBUG CONSTRNT: LP rows=34, pool->nlprows=34, pool->npend=0
DEBUG CONSTRNT: Checking 34 LP rows (pool tracks 34, total LP rows 34)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 63
DEBUG CONSTRNT: Pool row 63 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=33, expected 33
 % @PAP adding 34 rows, 162 nz to LP
DEBUG BB: Processing node 9, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=17, varin=52, theta=0.333333, up=1.000000
ITER 2: row=29, varin=9, theta=0.041667, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=34)
DEBUG SOLUTION: LP solution array indices: FST[35-74], not_covered[75-94]
DEBUG SOLUTION: lp->best_solution[0] = 27900594.040431
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.958333
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 34 rows, 60 cols, 222 nonzeros, 2 slack, 32 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 5 rows, 21 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=35, varin=40, theta=0.500000, up=1.000000
ITER 2: row=2, varin=56, theta=0.250000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=39)
DEBUG SOLUTION: LP solution array indices: FST[40-79], not_covered[80-99]
DEBUG SOLUTION: lp->best_solution[0] = 27913165.087683
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 39 rows, 60 cols, 243 nonzeros, 2 slack, 37 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 2 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=38, varin=6, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=36, varin=23, theta=0.333333, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=39)
DEBUG SOLUTION: LP solution array indices: FST[40-79], not_covered[80-99]
DEBUG SOLUTION: lp->best_solution[0] = 27937173.900504
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 39 rows, 60 cols, 242 nonzeros, 3 slack, 36 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % Node 9 LP 1 Solution, length = 27937173.900504, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.666667 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.666667 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.333333 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.666667 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.666667 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.333333 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.333333 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.333333 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.333333 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.333333 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.333333 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.333333 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.333333 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.333333 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=27937173.900504, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 9 at  27.93717390050390037004
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7ca0600
% @LO 0.00  27.90059404043068269630 99.9000000000
% @LN 0.00  27.90390261187718223823 99.9000000000
% Resuming node 3 at  27.90390261187718223823
DEBUG CONSTRNT: LP rows=36, pool->nlprows=36, pool->npend=0
DEBUG CONSTRNT: Checking 36 LP rows (pool tracks 36, total LP rows 36)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 63
DEBUG CONSTRNT: Pool row 63 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=35, expected 35
 % @PAP adding 42 rows, 199 nz to LP
DEBUG BB: Processing node 3, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 3 LP 2 Solution, length = 27903902.611877, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.333333 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.666667 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.333333 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.333333 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.333333 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.333333 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 2 fractional variables
DEBUG CG: LP optimal, z=27903902.611877, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=27903902.611877, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 3 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 3
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=1.000000
DEBUG CAREFUL: Skipping var 7: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.333333
DEBUG CAREFUL: Adding var 15 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.666667
DEBUG CAREFUL: Adding var 19 to fractional list (xi=0.666667)
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 2 fractional variables

  %  Carefully choosing branching variable, nfrac = 2
DEBUG CAREFUL: Testing fvar[0] = var 15
DEBUG CAREFUL: Calling compare_branch_vars for var 15
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 15
DEBUG CAREFUL: New best var: 15
DEBUG CAREFUL: Testing fvar[1] = var 19
DEBUG CAREFUL: Calling compare_branch_vars for var 19
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 19
  % Initial guess is x15, Z0 = 27903902.6118772        , Z1 = 28046272.4652531        

DEBUG EVAL: Testing var 15 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=25, varin=39, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=2, varin=38, theta=0.285714, up=999999999999999983222784.000000
ITER 3: row=13, varin=33, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=31, varin=2, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=39, varin=30, theta=0.588235, up=999999999999999983222784.000000
ITER 6: row=33, varin=28, theta=2.000000, up=999999999999999983222784.000000
ITER 7: row=27, varin=53, theta=2.000000, up=1.000000
ITER 8: row=27, varin=26, theta=0.428571, up=999999999999999983222784.000000
ITER 9: row=1, varin=44, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 15 = 1 gives z=28118219.066739
  % 	x15 = 1,	Z1 = 28118219.066739         
DEBUG EVAL: First branch cutoff check: z=28118219.066739, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 15 = 0
ITER 1: row=25, varin=61, theta=0.333333, up=1.000000
ITER 2: row=34, varin=21, theta=0.052632, up=999999999999999983222784.000000
ITER 3: row=36, varin=57, theta=0.333333, up=1.000000
  % 	x15 = 0,	Z0 = 27919669.2869365        
DEBUG EVAL: Second branch cutoff check: z=27919669.286937, best_z=INF, threshold=INF
  %   New best:  x15, Z = 27919669.2869365        
DEBUG EVAL: Testing var 19 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=7, varin=61, theta=0.333333, up=1.000000
ITER 2: row=34, varin=21, theta=0.052632, up=999999999999999983222784.000000
ITER 3: row=36, varin=53, theta=0.048276, up=1.000000
ITER 4: row=35, varin=33, theta=0.006849, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 19 = 1 gives z=27921626.499398
  % 	x19 = 1,	Z1 = 27921626.499398         
DEBUG EVAL: First branch cutoff check: z=27921626.499398, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 19 = 0
ITER 1: row=7, varin=39, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=2, varin=33, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=31, varin=2, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=39, varin=30, theta=0.588235, up=999999999999999983222784.000000
ITER 5: row=33, varin=28, theta=2.000000, up=999999999999999983222784.000000
ITER 6: row=27, varin=53, theta=2.000000, up=1.000000
ITER 7: row=27, varin=26, theta=0.428571, up=999999999999999983222784.000000
ITER 8: row=1, varin=44, theta=1.000000, up=1.000000
  % 	x19 = 0,	Z0 = 28118219.066739         
DEBUG EVAL: Second branch cutoff check: z=28118219.066739, best_z=INF, threshold=INF
  %   New best:  x19, Z = 27921626.499398         
  % Best branch is x19, Z0 = 28118219.066739         , Z1 = 27921626.499398         

DEBUG CAREFUL: Final result - returning best.var = 19
DEBUG BB: Branching variable chosen: j=19
 % @NC   11    3	x19 = 1	27921626.499398
 % @NC   12    3	x19 = 0	28118219.066739
 %       3     7 27903902.6119               27921626.4994    x7 U     1     2
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cb30f0
% @LO 0.00  27.90390261187718223823 99.9000000000
% @LN 0.00  27.92162649939803742427 99.9000000000
% Resuming node 11 at  27.92162649939803742427
DEBUG CONSTRNT: LP rows=42, pool->nlprows=42, pool->npend=0
DEBUG CONSTRNT: Checking 42 LP rows (pool tracks 42, total LP rows 42)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=41, expected 41
 % @PAP adding 42 rows, 199 nz to LP
DEBUG BB: Processing node 11, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=7, varin=61, theta=0.333333, up=1.000000
ITER 2: row=34, varin=21, theta=0.052632, up=999999999999999983222784.000000
ITER 3: row=36, varin=53, theta=0.048276, up=1.000000
ITER 4: row=32, varin=29, theta=0.055172, up=999999999999999983222784.000000
ITER 5: row=35, varin=33, theta=0.006849, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 27921626.499398
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.952055
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.952055
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 42 rows, 60 cols, 259 nonzeros, 8 slack, 34 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 5 rows, 14 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=43, varin=36, theta=1.615385, up=999999999999999983222784.000000
ITER 2: row=33, varin=74, theta=1.000000, up=1.000000
ITER 3: row=43, varin=32, theta=0.263158, up=999999999999999983222784.000000
ITER 4: row=46, varin=34, theta=0.555556, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 27944292.578552
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.888889
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.888889
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 47 rows, 60 cols, 273 nonzeros, 10 slack, 37 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 10 slack rows
  % @PAP adding 3 rows, 7 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=38, varin=77, theta=1.000000, up=1.000000
ITER 2: row=17, varin=44, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=40)
DEBUG SOLUTION: LP solution array indices: FST[41-80], not_covered[81-100]
DEBUG SOLUTION: lp->best_solution[0] = 27955919.140923
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 40 rows, 60 cols, 235 nonzeros, 0 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 6 rows, 31 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=41, varin=27, theta=0.833333, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=46)
DEBUG SOLUTION: LP solution array indices: FST[47-86], not_covered[87-106]
DEBUG SOLUTION: lp->best_solution[0] = 27958952.435013
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 46 rows, 60 cols, 266 nonzeros, 4 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % Node 11 LP 1 Solution, length = 27958952.435013, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.166667 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.166667 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.166667 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.166667 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.166667 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.166667 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.833333 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.833333 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.833333 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.833333 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.833333 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.833333 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.833333 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=27958952.435013, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 11 at  27.95895243501328764069
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cb66c0
% @LO 0.00  27.92162649939803742427 99.9000000000
% @LN 0.00  27.93042717476336633808 99.9000000000
% Resuming node 6 at  27.93042717476336633808
DEBUG CONSTRNT: LP rows=42, pool->nlprows=42, pool->npend=0
DEBUG CONSTRNT: Checking 42 LP rows (pool tracks 42, total LP rows 42)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=41, expected 41
 % @PAP adding 42 rows, 197 nz to LP
DEBUG BB: Processing node 6, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 6 LP 2 Solution, length = 27930427.174763, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.333333 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.666667 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.333333 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.333333 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.333333 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.333333 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 2 fractional variables
DEBUG CG: LP optimal, z=27930427.174763, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=27930427.174763, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 6 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 6
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=1.000000
DEBUG CAREFUL: Skipping var 5: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.333333
DEBUG CAREFUL: Adding var 15 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.666667
DEBUG CAREFUL: Adding var 19 to fractional list (xi=0.666667)
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 2 fractional variables

  %  Carefully choosing branching variable, nfrac = 2
DEBUG CAREFUL: Testing fvar[0] = var 15
DEBUG CAREFUL: Calling compare_branch_vars for var 15
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 15
DEBUG CAREFUL: New best var: 15
DEBUG CAREFUL: Testing fvar[1] = var 19
DEBUG CAREFUL: Calling compare_branch_vars for var 19
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 19
  % Initial guess is x15, Z0 = 27930427.1747634        , Z1 = 28094507.0378495        

DEBUG EVAL: Testing var 15 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=25, varin=39, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=2, varin=38, theta=0.285714, up=999999999999999983222784.000000
ITER 3: row=13, varin=33, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=31, varin=2, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=39, varin=30, theta=0.588235, up=999999999999999983222784.000000
ITER 6: row=33, varin=28, theta=2.000000, up=999999999999999983222784.000000
ITER 7: row=27, varin=53, theta=2.000000, up=1.000000
ITER 8: row=27, varin=26, theta=0.428571, up=999999999999999983222784.000000
ITER 9: row=1, varin=44, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 15 = 1 gives z=28144743.629625
  % 	x15 = 1,	Z1 = 28144743.6296252        
DEBUG EVAL: First branch cutoff check: z=28144743.629625, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 15 = 0
ITER 1: row=25, varin=61, theta=0.333333, up=1.000000
ITER 2: row=34, varin=19, theta=0.052632, up=999999999999999983222784.000000
ITER 3: row=36, varin=57, theta=0.333333, up=1.000000
  % 	x15 = 0,	Z0 = 27946193.8498227        
DEBUG EVAL: Second branch cutoff check: z=27946193.849823, best_z=INF, threshold=INF
  %   New best:  x15, Z = 27946193.8498227        
DEBUG EVAL: Testing var 19 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=7, varin=61, theta=0.333333, up=1.000000
ITER 2: row=34, varin=19, theta=0.052632, up=999999999999999983222784.000000
ITER 3: row=36, varin=53, theta=0.048276, up=1.000000
ITER 4: row=35, varin=33, theta=0.006849, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 19 = 1 gives z=27948151.062284
  % 	x19 = 1,	Z1 = 27948151.0622842        
DEBUG EVAL: First branch cutoff check: z=27948151.062284, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 19 = 0
ITER 1: row=7, varin=39, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=2, varin=33, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=31, varin=2, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=39, varin=30, theta=0.588235, up=999999999999999983222784.000000
ITER 5: row=33, varin=28, theta=2.000000, up=999999999999999983222784.000000
ITER 6: row=27, varin=53, theta=2.000000, up=1.000000
ITER 7: row=27, varin=26, theta=0.428571, up=999999999999999983222784.000000
ITER 8: row=1, varin=44, theta=1.000000, up=1.000000
  % 	x19 = 0,	Z0 = 28144743.6296252        
DEBUG EVAL: Second branch cutoff check: z=28144743.629625, best_z=INF, threshold=INF
  %   New best:  x19, Z = 27948151.0622842        
  % Best branch is x19, Z0 = 28144743.6296252        , Z1 = 27948151.0622842        

DEBUG CAREFUL: Final result - returning best.var = 19
DEBUG BB: Branching variable chosen: j=19
 % @NC   13    6	x19 = 1	27948151.062284
 % @NC   14    6	x19 = 0	28144743.629625
 %       6     8 27930427.1748               27937173.9005    x5 U     4     3
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cae7d0
% @LO 0.00  27.93042717476336633808 99.9000000000
% @LN 0.00  27.93717390050390037004 99.9000000000
% Resuming node 9 at  27.93717390050390037004
DEBUG CONSTRNT: LP rows=42, pool->nlprows=42, pool->npend=0
DEBUG CONSTRNT: Checking 42 LP rows (pool tracks 42, total LP rows 42)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=41, expected 41
 % @PAP adding 36 rows, 172 nz to LP
DEBUG BB: Processing node 9, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 9 LP 2 Solution, length = 27937173.900504, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.666667 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.666667 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.333333 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.666667 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.666667 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.333333 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.333333 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.333333 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.333333 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.333333 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.333333 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.333333 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.333333 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.333333 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=27937173.900504, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=27937173.900504, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 9 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 9
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.666667
DEBUG CAREFUL: Adding var 9 to fractional list (xi=0.666667)
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.666667
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.666667)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.333333
DEBUG CAREFUL: Adding var 16 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.666667
DEBUG CAREFUL: Adding var 19 to fractional list (xi=0.666667)
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 4 fractional variables

  %  Carefully choosing branching variable, nfrac = 4
DEBUG CAREFUL: Testing fvar[0] = var 16
DEBUG CAREFUL: Calling compare_branch_vars for var 16
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 16
DEBUG CAREFUL: New best var: 16
DEBUG CAREFUL: Testing fvar[1] = var 19
DEBUG CAREFUL: Calling compare_branch_vars for var 19
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 19
DEBUG CAREFUL: Testing fvar[2] = var 9
DEBUG CAREFUL: Calling compare_branch_vars for var 9
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 9
DEBUG CAREFUL: Testing fvar[3] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
  % Initial guess is x16, Z0 = 27937173.9005039        , Z1 = 28011332.5323117        

DEBUG EVAL: Testing var 16 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=17, varin=34, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=32, varin=2, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=2, varin=31, theta=0.588235, up=999999999999999983222784.000000
ITER 4: row=34, varin=24, theta=2.000000, up=999999999999999983222784.000000
ITER 5: row=23, varin=27, theta=2.000000, up=999999999999999983222784.000000
ITER 6: row=18, varin=30, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=22, varin=22, theta=0.428571, up=999999999999999983222784.000000
ITER 8: row=1, varin=38, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 16 = 1 gives z=28071052.359465
  % 	x16 = 1,	Z1 = 28071052.3594654        
DEBUG EVAL: First branch cutoff check: z=28071052.359465, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 16 = 0
ITER 1: row=17, varin=52, theta=0.250000, up=1.000000
ITER 2: row=28, varin=30, theta=0.250000, up=999999999999999983222784.000000
  % 	x16 = 0,	Z0 = 27944594.6502801        
DEBUG EVAL: Second branch cutoff check: z=27944594.650280, best_z=INF, threshold=INF
  %   New best:  x16, Z = 27944594.6502801        
DEBUG EVAL: Testing var 19 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=10, varin=52, theta=1.000000, up=1.000000
ITER 2: row=17, varin=78, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 19 = 1 gives z=27975129.749622
  % 	x19 = 1,	Z1 = 27975129.7496222        
DEBUG EVAL: First branch cutoff check: z=27975129.749622, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 19 = 0
ITER 1: row=10, varin=34, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=32, varin=2, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=2, varin=31, theta=0.588235, up=999999999999999983222784.000000
ITER 4: row=34, varin=24, theta=2.000000, up=999999999999999983222784.000000
ITER 5: row=23, varin=27, theta=2.000000, up=999999999999999983222784.000000
ITER 6: row=18, varin=30, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=22, varin=22, theta=0.428571, up=999999999999999983222784.000000
ITER 8: row=1, varin=38, theta=1.000000, up=1.000000
  % 	x19 = 0,	Z0 = 28071052.3594654        
DEBUG EVAL: Second branch cutoff check: z=28071052.359465, best_z=INF, threshold=INF
  %   New best:  x19, Z = 27975129.7496222        
DEBUG EVAL: Testing var 9 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=22, varin=52, theta=0.250000, up=1.000000
ITER 2: row=28, varin=30, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=17, varin=78, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 9 = 1 gives z=27975129.749622
  % 	x9 = 1,	Z1 = 27975129.7496222        
DEBUG EVAL: First branch cutoff check: z=27975129.749622, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 9 = 0
ITER 1: row=22, varin=30, theta=0.666667, up=999999999999999983222784.000000
  % 	x9 = 0,	Z0 = 27940548.0715299        
DEBUG EVAL: Second branch cutoff check: z=27940548.071530, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 10 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=18, varin=52, theta=0.250000, up=1.000000
ITER 2: row=28, varin=30, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=17, varin=27, theta=0.333333, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 1 gives z=27967052.732074
  % 	x10 = 1,	Z1 = 27967052.7320744        
DEBUG EVAL: First branch cutoff check: z=27967052.732074, best_z=INF, threshold=INF
  % Best branch is x19, Z0 = 28071052.3594654        , Z1 = 27975129.7496222        

DEBUG CAREFUL: Final result - returning best.var = 19
DEBUG BB: Branching variable chosen: j=19
 % @NC   15    9	x19 = 1	27975129.749622
 % @NC   16    9	x19 = 0	28071052.359465
 %       9     9 27937173.9005               27940162.4333   x13 D     7     5
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cb6f50
% @LO 0.01  27.93717390050390037004 99.9000000000
% @LN 0.01  27.94016243329341619983 99.9000000000
% Resuming node 10 at  27.94016243329341619983
DEBUG CONSTRNT: LP rows=36, pool->nlprows=36, pool->npend=0
DEBUG CONSTRNT: Checking 36 LP rows (pool tracks 36, total LP rows 36)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 63
DEBUG CONSTRNT: Pool row 63 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=35, expected 35
 % @PAP adding 34 rows, 162 nz to LP
DEBUG BB: Processing node 10, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=17, varin=31, theta=3.000000, up=999999999999999983222784.000000
ITER 2: row=21, varin=28, theta=2.000000, up=999999999999999983222784.000000
ITER 3: row=27, varin=34, theta=2.000000, up=999999999999999983222784.000000
ITER 4: row=1, varin=36, theta=2.000000, up=1.000000
ITER 5: row=1, varin=26, theta=0.400000, up=999999999999999983222784.000000
ITER 6: row=28, varin=11, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=34)
DEBUG SOLUTION: LP solution array indices: FST[35-74], not_covered[75-94]
DEBUG SOLUTION: lp->best_solution[0] = 27940162.433293
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 34 rows, 60 cols, 222 nonzeros, 2 slack, 32 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 6 rows, 40 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=35, varin=10, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=37, varin=12, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=1, varin=43, theta=0.600000, up=1.000000
ITER 4: row=39, varin=50, theta=1.000000, up=1.000000
ITER 5: row=33, varin=30, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=28, varin=42, theta=2.000000, up=1.000000
ITER 7: row=28, varin=51, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=7)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=40)
DEBUG SOLUTION: LP solution array indices: FST[41-80], not_covered[81-100]
DEBUG SOLUTION: lp->best_solution[0] = 27998354.476901
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 40 rows, 60 cols, 262 nonzeros, 7 slack, 33 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 7 slack rows
  % @PAP adding 2 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=34, varin=84, theta=1.000000, up=1.000000
ITER 2: row=1, varin=9, theta=1.500000, up=999999999999999983222784.000000
ITER 3: row=24, varin=53, theta=0.333333, up=1.000000
ITER 4: row=27, varin=25, theta=0.083333, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=35)
DEBUG SOLUTION: LP solution array indices: FST[36-75], not_covered[76-95]
DEBUG SOLUTION: lp->best_solution[0] = 28057809.868113
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.958333
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 35 rows, 60 cols, 228 nonzeros, 4 slack, 31 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % @PAP adding 7 rows, 33 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=32, varin=39, theta=0.500000, up=1.000000
ITER 2: row=2, varin=6, theta=0.500000, up=999999999999999983222784.000000
ITER 3: row=35, varin=80, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=38)
DEBUG SOLUTION: LP solution array indices: FST[39-78], not_covered[79-98]
DEBUG SOLUTION: lp->best_solution[0] = 28132345.577304
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 38 rows, 60 cols, 247 nonzeros, 3 slack, 35 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 4 rows, 15 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=36, varin=58, theta=0.333333, up=1.000000
ITER 2: row=33, varin=16, theta=0.052632, up=999999999999999983222784.000000
ITER 3: row=35, varin=50, theta=0.048276, up=1.000000
ITER 4: row=31, varin=21, theta=0.055172, up=999999999999999983222784.000000
ITER 5: row=34, varin=32, theta=0.006849, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=39)
DEBUG SOLUTION: LP solution array indices: FST[40-79], not_covered[80-99]
DEBUG SOLUTION: lp->best_solution[0] = 28152332.613657
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.952055
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 39 rows, 60 cols, 254 nonzeros, 5 slack, 34 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % @PAP adding 5 rows, 14 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=35, varin=30, theta=1.615385, up=999999999999999983222784.000000
ITER 2: row=38, varin=66, theta=1.000000, up=1.000000
ITER 3: row=35, varin=35, theta=0.102041, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=39)
DEBUG SOLUTION: LP solution array indices: FST[40-79], not_covered[80-99]
DEBUG SOLUTION: lp->best_solution[0] = 28165442.897631
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 39 rows, 60 cols, 253 nonzeros, 5 slack, 34 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % @PAP adding 4 rows, 9 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=35, varin=29, theta=2.500000, up=999999999999999983222784.000000
ITER 2: row=37, varin=75, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=38)
DEBUG SOLUTION: LP solution array indices: FST[39-78], not_covered[79-98]
DEBUG SOLUTION: lp->best_solution[0] = 28184301.846637
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 38 rows, 60 cols, 240 nonzeros, 0 slack, 38 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=39, varin=44, theta=0.357143, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=40)
DEBUG SOLUTION: LP solution array indices: FST[41-80], not_covered[81-100]
DEBUG SOLUTION: lp->best_solution[0] = 28187925.238363
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 40 rows, 60 cols, 248 nonzeros, 1 slack, 39 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 3 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=40, varin=27, theta=0.666667, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 28189658.549272
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 42 rows, 60 cols, 244 nonzeros, 1 slack, 41 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 10 LP 1 Solution, length = 28189658.549272, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.166667 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.166667 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.166667 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 1.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.166667 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.166667 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.166667 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.833333 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.833333 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.833333 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.833333 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.833333 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.833333 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.833333 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28189658.549272, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 10 at  28.18965854927236591720
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7ca0600
% @LO 0.01  27.94016243329341619983 99.9000000000
% @LN 0.01  27.94815106228422507684 99.9000000000
% Resuming node 13 at  27.94815106228422507684
DEBUG CONSTRNT: LP rows=41, pool->nlprows=41, pool->npend=0
DEBUG CONSTRNT: Checking 41 LP rows (pool tracks 41, total LP rows 41)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 65
DEBUG CONSTRNT: Pool row 65 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=40, expected 40
 % @PAP adding 42 rows, 197 nz to LP
DEBUG BB: Processing node 13, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=7, varin=61, theta=0.333333, up=1.000000
ITER 2: row=34, varin=19, theta=0.052632, up=999999999999999983222784.000000
ITER 3: row=36, varin=53, theta=0.048276, up=1.000000
ITER 4: row=32, varin=29, theta=0.055172, up=999999999999999983222784.000000
ITER 5: row=35, varin=33, theta=0.006849, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 27948151.062284
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.952055
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.952055
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 42 rows, 60 cols, 257 nonzeros, 8 slack, 34 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 5 rows, 14 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=43, varin=36, theta=1.615385, up=999999999999999983222784.000000
ITER 2: row=33, varin=74, theta=1.000000, up=1.000000
ITER 3: row=43, varin=32, theta=0.263158, up=999999999999999983222784.000000
ITER 4: row=46, varin=34, theta=0.555556, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 27970817.141438
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.888889
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.888889
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 47 rows, 60 cols, 271 nonzeros, 10 slack, 37 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 10 slack rows
  % @PAP adding 3 rows, 7 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=38, varin=77, theta=1.000000, up=1.000000
ITER 2: row=15, varin=44, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=40)
DEBUG SOLUTION: LP solution array indices: FST[41-80], not_covered[81-100]
DEBUG SOLUTION: lp->best_solution[0] = 27982443.703809
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 40 rows, 60 cols, 233 nonzeros, 0 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 6 rows, 31 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=41, varin=27, theta=0.833333, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=46)
DEBUG SOLUTION: LP solution array indices: FST[47-86], not_covered[87-106]
DEBUG SOLUTION: lp->best_solution[0] = 27985476.997899
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 46 rows, 60 cols, 264 nonzeros, 4 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % Node 13 LP 1 Solution, length = 27985476.997899, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.166667 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.166667 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.166667 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.166667 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.166667 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.166667 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.833333 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.833333 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.833333 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.833333 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.833333 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.833333 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.833333 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=27985476.997899, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 13 at  27.98547699789947174054
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cb6780
% @LO 0.01  27.94815106228422507684 99.9000000000
% @LN 0.01  27.95283815268794569420 99.9000000000
% Resuming node 8 at  27.95283815268794569420
DEBUG CONSTRNT: LP rows=42, pool->nlprows=42, pool->npend=0
DEBUG CONSTRNT: Checking 42 LP rows (pool tracks 42, total LP rows 42)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=41, expected 41
 % @PAP adding 34 rows, 154 nz to LP
DEBUG BB: Processing node 8, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=20, varin=36, theta=5.000000, up=1.000000
ITER 2: row=20, varin=29, theta=1.600000, up=999999999999999983222784.000000
ITER 3: row=1, varin=33, theta=2.000000, up=999999999999999983222784.000000
ITER 4: row=29, varin=14, theta=2.000000, up=999999999999999983222784.000000
ITER 5: row=15, varin=6, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=34)
DEBUG SOLUTION: LP solution array indices: FST[35-74], not_covered[75-94]
DEBUG SOLUTION: lp->best_solution[0] = 27952838.152688
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 34 rows, 60 cols, 214 nonzeros, 3 slack, 31 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 9 rows, 48 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=41, varin=12, theta=0.153846, up=999999999999999983222784.000000
ITER 2: row=35, varin=10, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=37, varin=11, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=1, varin=101, theta=1.153846, up=1.000000
ITER 5: row=1, varin=53, theta=0.080000, up=1.000000
ITER 6: row=42, varin=15, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=39, varin=41, theta=10.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=7)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 27983858.651827
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 43 rows, 60 cols, 262 nonzeros, 8 slack, 35 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 8 slack rows
  % @PAP adding 5 rows, 65 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=39, varin=42, theta=0.176987, up=1.000000
ITER 2: row=36, varin=98, theta=1.000000, up=1.000000
ITER 3: row=38, varin=43, theta=1.834663, up=1.000000
ITER 4: row=38, varin=51, theta=-4.809196, up=1.000000
ITER 5: row=7, varin=39, theta=617252.666667, up=999999999999999983222784.000000
ITER 6: row=27, varin=43, theta=1.000000, up=1.000000
ITER 7: row=20, varin=57, theta=0.333333, up=1.000000
LP PHASE: Switching to primal (iter=7)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=40)
DEBUG SOLUTION: LP solution array indices: FST[41-80], not_covered[81-100]
DEBUG SOLUTION: lp->best_solution[0] = 28054660.171687
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.666667
  % @PL 40 rows, 60 cols, 281 nonzeros, 7 slack, 33 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 7 slack rows
  % @PAP adding 2 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=34, varin=9, theta=1.500000, up=999999999999999983222784.000000
ITER 2: row=22, varin=53, theta=0.333333, up=1.000000
ITER 3: row=25, varin=23, theta=0.083333, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=35)
DEBUG SOLUTION: LP solution array indices: FST[36-75], not_covered[76-95]
DEBUG SOLUTION: lp->best_solution[0] = 28070485.587507
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.958333
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 35 rows, 60 cols, 229 nonzeros, 2 slack, 33 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 7 rows, 33 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=34, varin=20, theta=0.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=40)
DEBUG SOLUTION: LP solution array indices: FST[41-80], not_covered[81-100]
DEBUG SOLUTION: lp->best_solution[0] = 28076475.159382
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 40 rows, 60 cols, 256 nonzeros, 3 slack, 37 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % Node 8 LP 1 Solution, length = 28076475.159382, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 1.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.500000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.500000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.500000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.500000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.500000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 2 fractional variables
DEBUG CG: LP optimal, z=28076475.159382, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 8 at  28.07647515938188931273
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cb30f0
% @LO 0.01  27.95283815268794569420 99.9000000000
% @LN 0.01  27.95895243501328764069 99.9000000000
% Resuming node 11 at  27.95895243501328764069
DEBUG CONSTRNT: LP rows=37, pool->nlprows=37, pool->npend=0
DEBUG CONSTRNT: Checking 37 LP rows (pool tracks 37, total LP rows 37)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=36, expected 36
 % @PAP adding 42 rows, 171 nz to LP
DEBUG BB: Processing node 11, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 11 LP 2 Solution, length = 27958952.435013, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.166667 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.166667 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.166667 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.166667 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.166667 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.166667 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.833333 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.833333 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.833333 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.833333 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.833333 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.833333 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.833333 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=27958952.435013, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=27958952.435013, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 11 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 11
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.166667
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.166667
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=1.000000
DEBUG CAREFUL: Skipping var 7: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.166667
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.166667
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.166667
DEBUG CAREFUL: Adding var 18 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.166667
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 6 fractional variables

  %  Carefully choosing branching variable, nfrac = 6
DEBUG CAREFUL: Testing fvar[0] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 17
DEBUG CAREFUL: New best var: 17
DEBUG CAREFUL: Testing fvar[1] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 10
DEBUG CAREFUL: New best var: 10
DEBUG CAREFUL: Testing fvar[2] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[3] = var 18
DEBUG CAREFUL: Calling compare_branch_vars for var 18
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 18
DEBUG CAREFUL: New best var: 18
DEBUG CAREFUL: Testing fvar[4] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 3
DEBUG CAREFUL: Testing fvar[5] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
  % Initial guess is x18, Z0 = 27958952.4350133        , Z1 = 28206791.628127         

DEBUG EVAL: Testing var 17 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=23, varin=25, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=34, varin=67, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 17 = 0 gives z=28003028.355459
  % 	x17 = 0,	Z0 = 28003028.3554587        
DEBUG EVAL: First branch cutoff check: z=28003028.355459, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 17 = 1
ITER 1: row=23, varin=40, theta=2.500000, up=999999999999999983222784.000000
ITER 2: row=21, varin=17, theta=3.000000, up=999999999999999983222784.000000
ITER 3: row=17, varin=37, theta=3.000000, up=999999999999999983222784.000000
ITER 4: row=37, varin=35, theta=0.666667, up=999999999999999983222784.000000
ITER 5: row=24, varin=33, theta=0.666667, up=999999999999999983222784.000000
  % 	x17 = 1,	Z1 = 28085898.8793565        
DEBUG EVAL: Second branch cutoff check: z=28085898.879357, best_z=INF, threshold=INF
  %   New best:  x17, Z = 28003028.3554587        
DEBUG EVAL: Testing var 10 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=16, varin=40, theta=2.500000, up=999999999999999983222784.000000
ITER 2: row=21, varin=17, theta=3.000000, up=999999999999999983222784.000000
ITER 3: row=17, varin=37, theta=3.000000, up=999999999999999983222784.000000
ITER 4: row=37, varin=26, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 1 gives z=28053397.417084
  % 	x10 = 1,	Z1 = 28053397.4170842        
DEBUG EVAL: First branch cutoff check: z=28053397.417084, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 0
ITER 1: row=16, varin=19, theta=0.200000, up=999999999999999983222784.000000
ITER 2: row=34, varin=67, theta=1.000000, up=1.000000
  % 	x10 = 0,	Z0 = 28003028.3554587        
DEBUG EVAL: Second branch cutoff check: z=28003028.355459, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 2 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=22, theta=0.200000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 0 gives z=27990058.638097
  % 	x2 = 0,	Z0 = 27990058.6380969        
DEBUG EVAL: First branch cutoff check: z=27990058.638097, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 18 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=33, varin=40, theta=2.500000, up=999999999999999983222784.000000
ITER 2: row=21, varin=17, theta=3.000000, up=999999999999999983222784.000000
ITER 3: row=17, varin=37, theta=3.000000, up=999999999999999983222784.000000
ITER 4: row=37, varin=25, theta=2.000000, up=999999999999999983222784.000000
ITER 5: row=34, varin=29, theta=2.000000, up=999999999999999983222784.000000
ITER 6: row=2, varin=26, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 18 = 1 gives z=28201333.685689
  % 	x18 = 1,	Z1 = 28206791.628127         
DEBUG EVAL: First branch cutoff check: z=28206791.628127, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 18 = 0
ITER 1: row=33, varin=35, theta=0.333333, up=999999999999999983222784.000000
ITER 2: row=24, varin=67, theta=1.000000, up=1.000000
  % 	x18 = 0,	Z0 = 28003028.3554587        
DEBUG EVAL: Second branch cutoff check: z=28003028.355459, best_z=INF, threshold=INF
  %   New best:  x18, Z = 28003028.3554587        
DEBUG EVAL: Testing var 3 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=21, varin=17, theta=5.000000, up=999999999999999983222784.000000
ITER 2: row=17, varin=37, theta=5.000000, up=999999999999999983222784.000000
ITER 3: row=37, varin=35, theta=1.333333, up=999999999999999983222784.000000
ITER 4: row=24, varin=23, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=41, varin=33, theta=1.333333, up=999999999999999983222784.000000
ITER 6: row=33, varin=24, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=42, varin=29, theta=1.000000, up=999999999999999983222784.000000
ITER 8: row=2, varin=25, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 3 = 1 gives z=28248869.369074
  % 	x3 = 1,	Z1 = 28248869.3690744        
DEBUG EVAL: First branch cutoff check: z=28248869.369074, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 3 = 0
ITER 1: row=21, varin=40, theta=0.250000, up=999999999999999983222784.000000
  % 	x3 = 0,	Z0 = 27960469.0820587        
DEBUG EVAL: Second branch cutoff check: z=27960469.082059, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 26 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=37, varin=37, theta=0.200000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 26 = 0 gives z=27964472.646867
  % 	x26 = 0,	Z0 = 27964472.6468668        
DEBUG EVAL: First branch cutoff check: z=27964472.646867, best_z=INF, threshold=INF
  % Best branch is x18, Z0 = 28003028.3554587        , Z1 = 28206791.628127         

DEBUG CAREFUL: Final result - returning best.var = 18
DEBUG BB: Branching variable chosen: j=18
 % @NC   17   11	x18 = 0	28003028.355459
 % @NC   18   11	x18 = 1	28206791.628127
 %      11    10 27958952.4350               27975129.7496   x19 U     3     3
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cb66c0
% @LO 0.01  27.95895243501328764069 99.9000000000
% @LN 0.01  27.97512974962216603103 99.9000000000
% Resuming node 15 at  27.97512974962216603103
DEBUG CONSTRNT: LP rows=42, pool->nlprows=42, pool->npend=0
DEBUG CONSTRNT: Checking 42 LP rows (pool tracks 42, total LP rows 42)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=41, expected 41
 % @PAP adding 36 rows, 172 nz to LP
DEBUG BB: Processing node 15, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=10, varin=52, theta=1.000000, up=1.000000
ITER 2: row=17, varin=78, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=36)
DEBUG SOLUTION: LP solution array indices: FST[37-76], not_covered[77-96]
DEBUG SOLUTION: lp->best_solution[0] = 27975129.749622
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 36 rows, 60 cols, 232 nonzeros, 3 slack, 33 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 5 rows, 55 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=41, varin=30, theta=0.018787, up=999999999999999983222784.000000
ITER 2: row=37, varin=60, theta=0.333333, up=1.000000
ITER 3: row=35, varin=20, theta=0.052632, up=999999999999999983222784.000000
ITER 4: row=18, varin=41, theta=38624.348684, up=999999999999999983222784.000000
ITER 5: row=33, varin=25, theta=0.052632, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=41)
DEBUG SOLUTION: LP solution array indices: FST[42-81], not_covered[82-101]
DEBUG SOLUTION: lp->best_solution[0] = 27989224.529698
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.947368
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.947368
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 41 rows, 60 cols, 287 nonzeros, 7 slack, 34 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 7 slack rows
  % @PAP adding 3 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=37, varin=48, theta=0.315789, up=1.000000
ITER 2: row=35, varin=27, theta=0.263158, up=999999999999999983222784.000000
ITER 3: row=36, varin=29, theta=1.250000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=37)
DEBUG SOLUTION: LP solution array indices: FST[38-77], not_covered[78-97]
DEBUG SOLUTION: lp->best_solution[0] = 28003319.368414
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 37 rows, 60 cols, 228 nonzeros, 4 slack, 33 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % Node 15 LP 1 Solution, length = 28003319.368414, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.250000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.750000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.750000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.250000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.250000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.750000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.750000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.250000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.250000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.750000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.250000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.750000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.250000 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28003319.368414, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 15 at  28.00331936841390501058
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7ca0600
% @LO 0.01  27.97512974962216603103 99.9000000000
% @LN 0.01  27.98547699789947174054 99.9000000000
% Resuming node 13 at  27.98547699789947174054
DEBUG CONSTRNT: LP rows=33, pool->nlprows=33, pool->npend=0
DEBUG CONSTRNT: Checking 33 LP rows (pool tracks 33, total LP rows 33)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=32, expected 32
 % @PAP adding 42 rows, 169 nz to LP
DEBUG BB: Processing node 13, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 13 LP 2 Solution, length = 27985476.997899, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.166667 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.166667 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.166667 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.166667 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.166667 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.166667 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.833333 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.833333 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.833333 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.833333 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.833333 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.833333 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.833333 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=27985476.997899, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=27985476.997899, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 13 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 13
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.166667
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.166667
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=1.000000
DEBUG CAREFUL: Skipping var 5: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.166667
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.166667
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.166667
DEBUG CAREFUL: Adding var 18 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.166667
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 6 fractional variables

  %  Carefully choosing branching variable, nfrac = 6
DEBUG CAREFUL: Testing fvar[0] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 10
DEBUG CAREFUL: New best var: 10
DEBUG CAREFUL: Testing fvar[1] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[2] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[3] = var 18
DEBUG CAREFUL: Calling compare_branch_vars for var 18
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 18
DEBUG CAREFUL: New best var: 18
DEBUG CAREFUL: Testing fvar[4] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 3
DEBUG CAREFUL: Testing fvar[5] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
  % Initial guess is x18, Z0 = 27985476.9978995        , Z1 = 28206791.628127         

DEBUG EVAL: Testing var 10 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=14, varin=40, theta=2.500000, up=999999999999999983222784.000000
ITER 2: row=21, varin=15, theta=3.000000, up=999999999999999983222784.000000
ITER 3: row=15, varin=37, theta=3.000000, up=999999999999999983222784.000000
ITER 4: row=37, varin=26, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 1 gives z=28079921.979970
  % 	x10 = 1,	Z1 = 28079921.9799704        
DEBUG EVAL: First branch cutoff check: z=28079921.979970, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 0
ITER 1: row=14, varin=17, theta=0.200000, up=999999999999999983222784.000000
ITER 2: row=34, varin=67, theta=1.000000, up=1.000000
  % 	x10 = 0,	Z0 = 28029552.9183449        
DEBUG EVAL: Second branch cutoff check: z=28029552.918345, best_z=INF, threshold=INF
  %   New best:  x10, Z = 28029552.9183449        
DEBUG EVAL: Testing var 17 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=23, varin=25, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=34, varin=67, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 17 = 0 gives z=28029552.918345
  % 	x17 = 0,	Z0 = 28029552.9183449        
DEBUG EVAL: First branch cutoff check: z=28029552.918345, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 17 = 1
ITER 1: row=23, varin=40, theta=2.500000, up=999999999999999983222784.000000
ITER 2: row=21, varin=15, theta=3.000000, up=999999999999999983222784.000000
ITER 3: row=15, varin=37, theta=3.000000, up=999999999999999983222784.000000
ITER 4: row=37, varin=35, theta=0.666667, up=999999999999999983222784.000000
ITER 5: row=24, varin=33, theta=0.666667, up=999999999999999983222784.000000
  % 	x17 = 1,	Z1 = 28112423.4422427        
DEBUG EVAL: Second branch cutoff check: z=28112423.442243, best_z=INF, threshold=INF
  %   New best:  x17, Z = 28029552.9183449        
DEBUG EVAL: Testing var 2 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=22, theta=0.200000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 0 gives z=28016583.200983
  % 	x2 = 0,	Z0 = 28016583.2009831        
DEBUG EVAL: First branch cutoff check: z=28016583.200983, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 18 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=33, varin=40, theta=2.500000, up=999999999999999983222784.000000
ITER 2: row=21, varin=15, theta=3.000000, up=999999999999999983222784.000000
ITER 3: row=15, varin=37, theta=3.000000, up=999999999999999983222784.000000
ITER 4: row=37, varin=25, theta=2.000000, up=999999999999999983222784.000000
ITER 5: row=34, varin=29, theta=2.000000, up=999999999999999983222784.000000
ITER 6: row=2, varin=26, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 18 = 1 gives z=28227858.248575
  % 	x18 = 1,	Z1 = 28227858.248575         
DEBUG EVAL: First branch cutoff check: z=28227858.248575, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 18 = 0
ITER 1: row=33, varin=35, theta=0.333333, up=999999999999999983222784.000000
ITER 2: row=24, varin=67, theta=1.000000, up=1.000000
  % 	x18 = 0,	Z0 = 28029552.9183449        
DEBUG EVAL: Second branch cutoff check: z=28029552.918345, best_z=INF, threshold=INF
  %   New best:  x18, Z = 28029552.9183449        
DEBUG EVAL: Testing var 3 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=21, varin=15, theta=5.000000, up=999999999999999983222784.000000
ITER 2: row=15, varin=37, theta=5.000000, up=999999999999999983222784.000000
ITER 3: row=37, varin=35, theta=1.333333, up=999999999999999983222784.000000
ITER 4: row=24, varin=23, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=41, varin=33, theta=1.333333, up=999999999999999983222784.000000
ITER 6: row=33, varin=24, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=42, varin=29, theta=1.000000, up=999999999999999983222784.000000
ITER 8: row=2, varin=25, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 3 = 1 gives z=28275393.931961
  % 	x3 = 1,	Z1 = 28275393.9319606        
DEBUG EVAL: First branch cutoff check: z=28275393.931961, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 3 = 0
ITER 1: row=21, varin=40, theta=0.250000, up=999999999999999983222784.000000
  % 	x3 = 0,	Z0 = 27986993.6449449        
DEBUG EVAL: Second branch cutoff check: z=27986993.644945, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 26 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=37, varin=37, theta=0.200000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 26 = 0 gives z=27990997.209753
  % 	x26 = 0,	Z0 = 27990997.209753         
DEBUG EVAL: First branch cutoff check: z=27990997.209753, best_z=INF, threshold=INF
  % Best branch is x18, Z0 = 28029552.9183449        , Z1 = 28227858.248575         

DEBUG CAREFUL: Final result - returning best.var = 18
DEBUG BB: Branching variable chosen: j=18
 % @NC   19   13	x18 = 0	28029552.918345
 % @NC   20   13	x18 = 1	28227858.248575
 %      13    11 27985476.9979               28003028.3555   x19 U     6     4
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cae7d0
% @LO 0.01  27.98547699789947174054 99.9000000000
% @LN 0.01  28.00302835545867807809 99.9000000000
% Resuming node 17 at  28.00302835545867807809
DEBUG CONSTRNT: LP rows=42, pool->nlprows=42, pool->npend=0
DEBUG CONSTRNT: Checking 42 LP rows (pool tracks 42, total LP rows 42)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=41, expected 41
 % @PAP adding 42 rows, 171 nz to LP
DEBUG BB: Processing node 17, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=33, varin=35, theta=0.333333, up=999999999999999983222784.000000
ITER 2: row=24, varin=67, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 28003028.355459
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 42 rows, 60 cols, 231 nonzeros, 0 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 11 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=43, varin=33, theta=0.333333, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=46)
DEBUG SOLUTION: LP solution array indices: FST[47-86], not_covered[87-106]
DEBUG SOLUTION: lp->best_solution[0] = 28005591.833460
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 46 rows, 60 cols, 242 nonzeros, 4 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % Node 17 LP 1 Solution, length = 28005591.833460, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.333333 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.333333 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.333333 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.333333 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.333333 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.666667 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.666667 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.666667 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.666667 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.666667 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.666667 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.666667 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28005591.833460, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 17 at  28.00559183346042857465
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cb66c0
% @LO 0.01  28.00302835545867807809 99.9000000000
% @LN 0.01  28.00331936841390501058 99.9000000000
% Resuming node 15 at  28.00331936841390501058
DEBUG CONSTRNT: LP rows=42, pool->nlprows=42, pool->npend=0
DEBUG CONSTRNT: Checking 42 LP rows (pool tracks 42, total LP rows 42)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=41, expected 41
 % @PAP adding 33 rows, 140 nz to LP
DEBUG BB: Processing node 15, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 15 LP 2 Solution, length = 28003319.368414, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.250000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.750000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.750000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.250000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.250000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.750000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.750000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.250000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.250000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.750000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.250000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.750000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.250000 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28003319.368414, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28003319.368414, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 15 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 15
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.250000
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.750000
DEBUG CAREFUL: Adding var 9 to fractional list (xi=0.750000)
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.750000
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.750000)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.250000
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.250000
DEBUG CAREFUL: Adding var 18 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 18
DEBUG CAREFUL: Calling compare_branch_vars for var 18
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 18
DEBUG CAREFUL: New best var: 18
DEBUG CAREFUL: Testing fvar[1] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[2] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[3] = var 9
DEBUG CAREFUL: Calling compare_branch_vars for var 9
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 9
DEBUG CAREFUL: Testing fvar[4] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
  % Initial guess is x18, Z0 = 28003319.3684139        , Z1 = 28216557.9269004        

DEBUG EVAL: Testing var 18 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=23, varin=27, theta=3.000000, up=999999999999999983222784.000000
ITER 2: row=5, varin=50, theta=3.000000, up=1.000000
ITER 3: row=5, varin=25, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=15, varin=50, theta=1.000000, up=1.000000
ITER 5: row=25, varin=2, theta=0.400000, up=999999999999999983222784.000000
ITER 6: row=27, varin=23, theta=0.333333, up=999999999999999983222784.000000
ITER 7: row=21, varin=20, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 18 = 1 gives z=28280193.927530
  % 	x18 = 1,	Z1 = 28280193.9275297        
DEBUG EVAL: First branch cutoff check: z=28280193.927530, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 18 = 0
ITER 1: row=23, varin=60, theta=1.000000, up=1.000000
  % 	x18 = 0,	Z0 = 28004841.6623228        
DEBUG EVAL: Second branch cutoff check: z=28004841.662323, best_z=INF, threshold=INF
  %   New best:  x18, Z = 28004841.6623228        
DEBUG EVAL: Testing var 2 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=60, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 2 = 0 gives z=28004841.662323
  % 	x2 = 0,	Z0 = 28004841.6623228        
DEBUG EVAL: First branch cutoff check: z=28004841.662323, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 1
ITER 1: row=1, varin=31, theta=0.750000, up=999999999999999983222784.000000
  % 	x2 = 1,	Z1 = 28030149.1611286        
DEBUG EVAL: Second branch cutoff check: z=28030149.161129, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 17 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=21, varin=60, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 17 = 0 gives z=28004841.662323
  % 	x17 = 0,	Z0 = 28004841.6623228        
DEBUG EVAL: First branch cutoff check: z=28004841.662323, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 17 = 1
ITER 1: row=21, varin=32, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=24, varin=31, theta=1.000000, up=999999999999999983222784.000000
  % 	x17 = 1,	Z1 = 28050806.2476876        
DEBUG EVAL: Second branch cutoff check: z=28050806.247688, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 9 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=19, varin=60, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 9 = 1 gives z=28004841.662323
  % 	x9 = 1,	Z1 = 28004841.6623228        
DEBUG EVAL: First branch cutoff check: z=28004841.662323, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 9 = 0
ITER 1: row=19, varin=33, theta=0.750000, up=999999999999999983222784.000000
  % 	x9 = 0,	Z0 = 28007115.3108181        
DEBUG EVAL: Second branch cutoff check: z=28007115.310818, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 10 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=16, varin=60, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 10 = 1 gives z=28004841.662323
  % 	x10 = 1,	Z1 = 28004841.6623228        
DEBUG EVAL: First branch cutoff check: z=28004841.662323, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 0
ITER 1: row=16, varin=33, theta=0.750000, up=999999999999999983222784.000000
  % 	x10 = 0,	Z0 = 28007115.3108181        
DEBUG EVAL: Second branch cutoff check: z=28007115.310818, best_z=INF, threshold=INF
  % Best branch is x18, Z0 = 28004841.6623228        , Z1 = 28280193.9275297        

DEBUG CAREFUL: Final result - returning best.var = 18
DEBUG BB: Branching variable chosen: j=18
 % @NC   21   15	x18 = 0	28004841.662323
 % @NC   22   15	x18 = 1	28280193.927530
 %      15    12 28003319.3684               28004841.6623   x19 U     9     6
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7ca0600
% @LO 0.01  28.00331936841390501058 99.9000000000
% @LN 0.01  28.00484166232277516428 99.9000000000
% Resuming node 21 at  28.00484166232277516428
DEBUG CONSTRNT: LP rows=33, pool->nlprows=33, pool->npend=0
DEBUG CONSTRNT: Checking 33 LP rows (pool tracks 33, total LP rows 33)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=32, expected 32
 % @PAP adding 33 rows, 140 nz to LP
DEBUG BB: Processing node 21, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=23, varin=60, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=33)
DEBUG SOLUTION: LP solution array indices: FST[34-73], not_covered[74-93]
DEBUG SOLUTION: lp->best_solution[0] = 28004841.662323
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 33 rows, 60 cols, 200 nonzeros, 0 slack, 33 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=34, varin=33, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=34)
DEBUG SOLUTION: LP solution array indices: FST[35-74], not_covered[75-94]
DEBUG SOLUTION: lp->best_solution[0] = 28009902.918862
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 34 rows, 60 cols, 202 nonzeros, 1 slack, 33 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 4 rows, 17 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=34, varin=32, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=24, varin=72, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=37)
DEBUG SOLUTION: LP solution array indices: FST[38-77], not_covered[78-97]
DEBUG SOLUTION: lp->best_solution[0] = 28016966.640586
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 37 rows, 60 cols, 215 nonzeros, 1 slack, 36 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 21 LP 1 Solution, length = 28016966.640586, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.500000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.500000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.500000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.500000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.500000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.500000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.500000 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=28016966.640586, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 21 at  28.01696664058593810864
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cae7d0
% @LO 0.01  28.00484166232277516428 99.9000000000
% @LN 0.01  28.00559183346042857465 99.9000000000
% Resuming node 17 at  28.00559183346042857465
DEBUG CONSTRNT: LP rows=36, pool->nlprows=36, pool->npend=0
DEBUG CONSTRNT: Checking 36 LP rows (pool tracks 36, total LP rows 36)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 158
DEBUG CONSTRNT: Pool row 158 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=35, expected 35
 % @PAP adding 42 rows, 174 nz to LP
DEBUG BB: Processing node 17, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 17 LP 2 Solution, length = 28005591.833460, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.333333 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.333333 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.333333 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.333333 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.333333 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.666667 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.666667 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.666667 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.666667 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.666667 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.666667 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.666667 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28005591.833460, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28005591.833460, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 17 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 17
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.333333
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.333333
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=1.000000
DEBUG CAREFUL: Skipping var 7: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.333333
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.333333
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.333333
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 17
DEBUG CAREFUL: New best var: 17
DEBUG CAREFUL: Testing fvar[1] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[2] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[3] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 3
DEBUG CAREFUL: New best var: 3
DEBUG CAREFUL: Testing fvar[4] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
  % Initial guess is x3, Z0 = 28005591.8334604        , Z1 = 28248869.3690744        

DEBUG EVAL: Testing var 17 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=23, varin=39, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=39, varin=36, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 17 = 1 gives z=28104937.218536
  % 	x17 = 1,	Z1 = 28104937.2185362        
DEBUG EVAL: First branch cutoff check: z=28104937.218536, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 17 = 0
ITER 1: row=23, varin=66, theta=1.000000, up=1.000000
ITER 2: row=42, varin=54, theta=0.500000, up=1.000000
  % 	x17 = 0,	Z0 = 28078327.2530872        
DEBUG EVAL: Second branch cutoff check: z=28078327.253087, best_z=INF, threshold=INF
  %   New best:  x17, Z = 28078327.2530872        
DEBUG EVAL: Testing var 10 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=16, varin=39, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=39, varin=26, theta=0.666667, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 1 gives z=28090672.671744
  % 	x10 = 1,	Z1 = 28090672.6717441        
DEBUG EVAL: First branch cutoff check: z=28090672.671744, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 0
ITER 1: row=16, varin=19, theta=0.500000, up=999999999999999983222784.000000
  % 	x10 = 0,	Z0 = 28060752.9401567        
DEBUG EVAL: Second branch cutoff check: z=28060752.940157, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 2 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=66, theta=1.000000, up=1.000000
ITER 2: row=42, varin=54, theta=0.500000, up=1.000000
DEBUG EVAL: Branch var 2 = 0 gives z=28078327.253087
  % 	x2 = 0,	Z0 = 28078327.2530872        
DEBUG EVAL: First branch cutoff check: z=28078327.253087, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 1
ITER 1: row=1, varin=39, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=39, varin=24, theta=0.666667, up=999999999999999983222784.000000
  % 	x2 = 1,	Z1 = 28029440.5380957        
DEBUG EVAL: Second branch cutoff check: z=28029440.538096, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 3 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=21, varin=39, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=39, varin=17, theta=2.000000, up=999999999999999983222784.000000
ITER 3: row=17, varin=23, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=37, varin=33, theta=2.000000, up=999999999999999983222784.000000
ITER 5: row=33, varin=24, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=38, varin=29, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=40, varin=2, theta=0.400000, up=999999999999999983222784.000000
ITER 8: row=29, varin=25, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 3 = 1 gives z=28248869.369074
  % 	x3 = 1,	Z1 = 28248869.3690744        
DEBUG EVAL: First branch cutoff check: z=28248869.369074, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 3 = 0
ITER 1: row=21, varin=66, theta=1.000000, up=1.000000
ITER 2: row=42, varin=54, theta=0.500000, up=1.000000
  % 	x3 = 0,	Z0 = 28078327.2530872        
DEBUG EVAL: Second branch cutoff check: z=28078327.253087, best_z=INF, threshold=INF
  %   New best:  x3, Z = 28078327.2530872        
DEBUG EVAL: Testing var 26 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=33, varin=33, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 26 = 0 gives z=28042712.062318
  % 	x26 = 0,	Z0 = 28042712.0623177        
DEBUG EVAL: First branch cutoff check: z=28042712.062318, best_z=INF, threshold=INF
  % Best branch is x3, Z0 = 28078327.2530872        , Z1 = 28248869.3690744        

DEBUG CAREFUL: Final result - returning best.var = 3
DEBUG BB: Branching variable chosen: j=3
 % @NC   23   17	x3 = 0	28078327.253087
 % @NC   24   17	x3 = 1	28248869.369074
 %      17    13 28005591.8335               28016966.6406   x18 D    11     4
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7ca0600
% @LO 0.01  28.00559183346042857465 99.9000000000
% @LN 0.01  28.01696664058593810864 99.9000000000
% Resuming node 21 at  28.01696664058593810864
DEBUG CONSTRNT: LP rows=42, pool->nlprows=42, pool->npend=0
DEBUG CONSTRNT: Checking 42 LP rows (pool tracks 42, total LP rows 42)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=41, expected 41
 % @PAP adding 36 rows, 145 nz to LP
DEBUG BB: Processing node 21, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 21 LP 2 Solution, length = 28016966.640586, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.500000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.500000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.500000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.500000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.500000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.500000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.500000 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=28016966.640586, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28016966.640586, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 21 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 21
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.500000
DEBUG CAREFUL: Adding var 9 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.500000
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.500000
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.500000
DEBUG CAREFUL: Adding var 34 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 4 fractional variables

  %  Carefully choosing branching variable, nfrac = 4
DEBUG CAREFUL: Testing fvar[0] = var 34
DEBUG CAREFUL: Calling compare_branch_vars for var 34
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 34
DEBUG CAREFUL: New best var: 34
DEBUG CAREFUL: Testing fvar[1] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
DEBUG CAREFUL: Testing fvar[2] = var 9
DEBUG CAREFUL: Calling compare_branch_vars for var 9
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 9
DEBUG CAREFUL: Testing fvar[3] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
  % Initial guess is x34, Z0 = 28016966.6405859        , Z1 = 28029091.6188491        

DEBUG EVAL: Testing var 34 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=24, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=23, varin=34, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 34 = 1 gives z=28024030.362310
  % 	x34 = 1,	Z1 = 28029091.6188491        
DEBUG EVAL: First branch cutoff check: z=28029091.618849, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 34 = 0
ITER 1: row=1, varin=73, theta=0.500000, up=1.000000
  % 	x34 = 0,	Z0 = 28018494.4689083        
DEBUG EVAL: Second branch cutoff check: z=28018494.468908, best_z=INF, threshold=INF
  %   New best:  x34, Z = 28018494.4689083        
DEBUG EVAL: Testing var 26 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=33, varin=34, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 26 = 0 gives z=28024030.362310
  % 	x26 = 0,	Z0 = 28024030.3623102        
DEBUG EVAL: First branch cutoff check: z=28024030.362310, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 26 = 1
ITER 1: row=33, varin=17, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=36, varin=18, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=1, varin=73, theta=1.000000, up=1.000000
  % 	x26 = 1,	Z1 = 28378742.0016883        
DEBUG EVAL: Second branch cutoff check: z=28378742.001688, best_z=INF, threshold=INF
  %   New best:  x26, Z = 28024030.3623102        
DEBUG EVAL: Testing var 9 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=22, varin=33, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 9 = 0 gives z=28029091.618849
  % 	x9 = 0,	Z0 = 28029091.6188491        
DEBUG EVAL: First branch cutoff check: z=28029091.618849, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 9 = 1
ITER 1: row=22, varin=34, theta=1.000000, up=999999999999999983222784.000000
  % 	x9 = 1,	Z1 = 28024030.3623102        
DEBUG EVAL: Second branch cutoff check: z=28024030.362310, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 10 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=17, varin=33, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 0 gives z=28029091.618849
  % 	x10 = 0,	Z0 = 28029091.6188491        
DEBUG EVAL: First branch cutoff check: z=28029091.618849, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 1
ITER 1: row=17, varin=34, theta=1.000000, up=999999999999999983222784.000000
  % 	x10 = 1,	Z1 = 28024030.3623102        
DEBUG EVAL: Second branch cutoff check: z=28024030.362310, best_z=INF, threshold=INF
  % Best branch is x26, Z0 = 28024030.3623102        , Z1 = 28378742.0016883        

DEBUG CAREFUL: Final result - returning best.var = 26
DEBUG BB: Branching variable chosen: j=26
 % @NC   25   21	x26 = 0	28024030.362310
 % @NC   26   21	x26 = 1	28378742.001688
 %      21    14 28016966.6406               28024030.3623   x18 D    15     7
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cae7d0
% @LO 0.01  28.01696664058593810864 99.9000000000
% @LN 0.01  28.02403036231015676094 99.9000000000
% Resuming node 25 at  28.02403036231015676094
DEBUG CONSTRNT: LP rows=36, pool->nlprows=36, pool->npend=0
DEBUG CONSTRNT: Checking 36 LP rows (pool tracks 36, total LP rows 36)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 158
DEBUG CONSTRNT: Pool row 158 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=35, expected 35
 % @PAP adding 36 rows, 145 nz to LP
DEBUG BB: Processing node 25, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=33, varin=34, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=36)
DEBUG SOLUTION: LP solution array indices: FST[37-76], not_covered[77-96]
DEBUG SOLUTION: lp->best_solution[0] = 28024030.362310
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 36 rows, 60 cols, 205 nonzeros, 3 slack, 33 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 18 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=37, varin=75, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=38)
DEBUG SOLUTION: LP solution array indices: FST[39-78], not_covered[79-98]
DEBUG SOLUTION: lp->best_solution[0] = 28027086.018955
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 38 rows, 60 cols, 223 nonzeros, 3 slack, 35 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 2 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=36, varin=33, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=37)
DEBUG SOLUTION: LP solution array indices: FST[38-77], not_covered[78-97]
DEBUG SOLUTION: lp->best_solution[0] = 28029091.618849
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 37 rows, 60 cols, 224 nonzeros, 1 slack, 36 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 2 rows, 11 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=37, varin=42, theta=0.250000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=38)
DEBUG SOLUTION: LP solution array indices: FST[39-78], not_covered[79-98]
DEBUG SOLUTION: lp->best_solution[0] = 28029250.523174
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 38 rows, 60 cols, 233 nonzeros, 1 slack, 37 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 6 rows, 31 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=38, varin=31, theta=0.166667, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 28032816.659872
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 43 rows, 60 cols, 255 nonzeros, 5 slack, 38 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % Node 25 LP 1 Solution, length = 28032816.659872, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.166667 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.166667 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.500000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.500000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.166667 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.500000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.833333 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.833333 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.500000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.833333 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.500000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.833333 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.500000 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28032816.659872, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 25 at  28.03281665987228166159
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cb30f0
% @LO 0.01  28.02403036231015676094 99.9000000000
% @LN 0.01  28.02955291834486573066 99.9000000000
% Resuming node 19 at  28.02955291834486573066
DEBUG CONSTRNT: LP rows=38, pool->nlprows=38, pool->npend=0
DEBUG CONSTRNT: Checking 38 LP rows (pool tracks 38, total LP rows 38)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=37, expected 37
 % @PAP adding 42 rows, 169 nz to LP
DEBUG BB: Processing node 19, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=33, varin=35, theta=0.333333, up=999999999999999983222784.000000
ITER 2: row=24, varin=67, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 28029552.918345
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 42 rows, 60 cols, 229 nonzeros, 0 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 11 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=43, varin=33, theta=0.333333, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=46)
DEBUG SOLUTION: LP solution array indices: FST[47-86], not_covered[87-106]
DEBUG SOLUTION: lp->best_solution[0] = 28032116.396347
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 46 rows, 60 cols, 240 nonzeros, 4 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % Node 19 LP 1 Solution, length = 28032116.396347, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.333333 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.333333 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.333333 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.333333 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.333333 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.666667 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.666667 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.666667 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.666667 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.666667 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.666667 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.666667 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28032116.396347, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
 % @LO 0.01  28.02955291834486573066 99.9000000000
 % @LN 0.01  28.03211639634661267451 99.9000000000
DEBUG CG: Second cutoff check: z=28032116.396347, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 19 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 19
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.333333
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.333333
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=1.000000
DEBUG CAREFUL: Skipping var 5: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.333333
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.333333
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.333333
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 10
DEBUG CAREFUL: New best var: 10
DEBUG CAREFUL: Testing fvar[1] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 17
DEBUG CAREFUL: New best var: 17
DEBUG CAREFUL: Testing fvar[2] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[3] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 3
DEBUG CAREFUL: New best var: 3
DEBUG CAREFUL: Testing fvar[4] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
  % Initial guess is x3, Z0 = 28032116.3963466        , Z1 = 28275393.9319606        

DEBUG EVAL: Testing var 10 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=14, varin=39, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=39, varin=26, theta=0.666667, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 1 gives z=28117197.234630
  % 	x10 = 1,	Z1 = 28117197.2346303        
DEBUG EVAL: First branch cutoff check: z=28117197.234630, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 0
ITER 1: row=14, varin=52, theta=1.000000, up=1.000000
ITER 2: row=20, varin=17, theta=0.500000, up=999999999999999983222784.000000
  % 	x10 = 0,	Z0 = 28087277.5030429        
DEBUG EVAL: Second branch cutoff check: z=28087277.503043, best_z=INF, threshold=INF
  %   New best:  x10, Z = 28087277.5030429        
DEBUG EVAL: Testing var 17 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=23, varin=39, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=39, varin=36, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 17 = 1 gives z=28131461.781422
  % 	x17 = 1,	Z1 = 28131461.7814224        
DEBUG EVAL: First branch cutoff check: z=28131461.781422, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 17 = 0
ITER 1: row=23, varin=52, theta=1.000000, up=1.000000
ITER 2: row=20, varin=66, theta=1.000000, up=1.000000
ITER 3: row=42, varin=54, theta=0.500000, up=1.000000
  % 	x17 = 0,	Z0 = 28104851.8159734        
DEBUG EVAL: Second branch cutoff check: z=28104851.815973, best_z=INF, threshold=INF
  %   New best:  x17, Z = 28104851.8159734        
DEBUG EVAL: Testing var 2 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=52, theta=1.000000, up=1.000000
ITER 2: row=20, varin=66, theta=1.000000, up=1.000000
ITER 3: row=42, varin=54, theta=0.500000, up=1.000000
DEBUG EVAL: Branch var 2 = 0 gives z=28104851.815973
  % 	x2 = 0,	Z0 = 28104851.8159734        
DEBUG EVAL: First branch cutoff check: z=28104851.815973, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 1
ITER 1: row=1, varin=39, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=39, varin=24, theta=0.666667, up=999999999999999983222784.000000
  % 	x2 = 1,	Z1 = 28055965.1009819        
DEBUG EVAL: Second branch cutoff check: z=28055965.100982, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 3 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=21, varin=39, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=39, varin=15, theta=2.000000, up=999999999999999983222784.000000
ITER 3: row=15, varin=23, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=37, varin=33, theta=2.000000, up=999999999999999983222784.000000
ITER 5: row=33, varin=24, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=38, varin=29, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=40, varin=2, theta=0.400000, up=999999999999999983222784.000000
ITER 8: row=29, varin=25, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 3 = 1 gives z=28275393.931961
  % 	x3 = 1,	Z1 = 28275393.9319606        
DEBUG EVAL: First branch cutoff check: z=28275393.931961, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 3 = 0
ITER 1: row=21, varin=52, theta=1.000000, up=1.000000
ITER 2: row=20, varin=66, theta=1.000000, up=1.000000
ITER 3: row=42, varin=54, theta=0.500000, up=1.000000
  % 	x3 = 0,	Z0 = 28104851.8159734        
DEBUG EVAL: Second branch cutoff check: z=28104851.815973, best_z=INF, threshold=INF
  %   New best:  x3, Z = 28104851.8159734        
DEBUG EVAL: Testing var 26 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=33, varin=33, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 26 = 0 gives z=28069236.625204
  % 	x26 = 0,	Z0 = 28069236.6252039        
DEBUG EVAL: First branch cutoff check: z=28069236.625204, best_z=INF, threshold=INF
  % Best branch is x3, Z0 = 28104851.8159734        , Z1 = 28275393.9319606        

DEBUG CAREFUL: Final result - returning best.var = 3
DEBUG BB: Branching variable chosen: j=3
 % @NC   27   19	x3 = 0	28104851.815973
 % @NC   28   19	x3 = 1	28275393.931961
 %      19    15 28032116.3963               28032816.6599   x18 D    13     5
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cae7d0
% @LO 0.01  28.03211639634661267451 99.9000000000
% @LN 0.01  28.03281665987228166159 99.9000000000
% Resuming node 25 at  28.03281665987228166159
DEBUG CONSTRNT: LP rows=42, pool->nlprows=42, pool->npend=0
DEBUG CONSTRNT: Checking 42 LP rows (pool tracks 42, total LP rows 42)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=41, expected 41
 % @PAP adding 38 rows, 166 nz to LP
DEBUG BB: Processing node 25, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 25 LP 2 Solution, length = 28032816.659872, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.166667 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.166667 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.500000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.500000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.166667 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.500000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.833333 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.833333 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.500000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.833333 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.500000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.833333 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.500000 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28032816.659872, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28032816.659872, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 25 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 25
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.166667
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.166667
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.500000
DEBUG CAREFUL: Adding var 9 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.500000
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.166667
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.500000
DEBUG CAREFUL: Adding var 34 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 6 fractional variables

  %  Carefully choosing branching variable, nfrac = 6
DEBUG CAREFUL: Testing fvar[0] = var 9
DEBUG CAREFUL: Calling compare_branch_vars for var 9
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 9
DEBUG CAREFUL: New best var: 9
DEBUG CAREFUL: Testing fvar[1] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[2] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[3] = var 34
DEBUG CAREFUL: Calling compare_branch_vars for var 34
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 34
DEBUG CAREFUL: Testing fvar[4] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 17
DEBUG CAREFUL: New best var: 17
DEBUG CAREFUL: Testing fvar[5] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 3
DEBUG CAREFUL: New best var: 3
  % Initial guess is x3, Z0 = 28032816.6598723        , Z1 = 28186659.7066406        

DEBUG EVAL: Testing var 9 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=21, varin=31, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 9 = 0 gives z=28041602.957434
  % 	x9 = 0,	Z0 = 28041602.9574344        
DEBUG EVAL: First branch cutoff check: z=28041602.957434, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 9 = 1
ITER 1: row=21, varin=35, theta=1.000000, up=999999999999999983222784.000000
  % 	x9 = 1,	Z1 = 28036541.7008955        
DEBUG EVAL: Second branch cutoff check: z=28036541.700895, best_z=INF, threshold=INF
  %   New best:  x9, Z = 28036541.7008955        
DEBUG EVAL: Testing var 10 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=16, varin=31, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 0 gives z=28041602.957434
  % 	x10 = 0,	Z0 = 28041602.9574344        
DEBUG EVAL: First branch cutoff check: z=28041602.957434, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 1
ITER 1: row=16, varin=35, theta=1.000000, up=999999999999999983222784.000000
  % 	x10 = 1,	Z1 = 28036541.7008955        
DEBUG EVAL: Second branch cutoff check: z=28036541.700895, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 2 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=63, theta=0.500000, up=1.000000
ITER 2: row=3, varin=20, theta=0.250000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 0 gives z=28072724.158553
  % 	x2 = 0,	Z0 = 28072724.1585531        
DEBUG EVAL: First branch cutoff check: z=28072724.158553, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 1
ITER 1: row=1, varin=36, theta=1.250000, up=999999999999999983222784.000000
ITER 2: row=19, varin=35, theta=1.000000, up=999999999999999983222784.000000
  % 	x2 = 1,	Z1 = 28050806.2476876        
DEBUG EVAL: Second branch cutoff check: z=28050806.247688, best_z=INF, threshold=INF
  %   New best:  x2, Z = 28050806.2476876        
DEBUG EVAL: Testing var 34 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=31, varin=35, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 34 = 0 gives z=28036541.700895
  % 	x34 = 0,	Z0 = 28036541.7008955        
DEBUG EVAL: First branch cutoff check: z=28036541.700895, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 17 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=23, varin=36, theta=1.250000, up=999999999999999983222784.000000
ITER 2: row=19, varin=35, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 17 = 1 gives z=28050806.247688
  % 	x17 = 1,	Z1 = 28050806.2476876        
DEBUG EVAL: First branch cutoff check: z=28050806.247688, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 17 = 0
ITER 1: row=23, varin=63, theta=0.500000, up=1.000000
ITER 2: row=3, varin=62, theta=0.500000, up=1.000000
ITER 3: row=34, varin=50, theta=0.250000, up=1.000000
  % 	x17 = 0,	Z0 = 28090454.5792566        
DEBUG EVAL: Second branch cutoff check: z=28090454.579257, best_z=INF, threshold=INF
  %   New best:  x17, Z = 28050806.2476876        
DEBUG EVAL: Testing var 3 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=19, varin=35, theta=5.000000, up=999999999999999983222784.000000
ITER 2: row=16, varin=33, theta=2.000000, up=999999999999999983222784.000000
ITER 3: row=33, varin=31, theta=2.000000, up=999999999999999983222784.000000
ITER 4: row=31, varin=27, theta=2.000000, up=999999999999999983222784.000000
ITER 5: row=5, varin=55, theta=2.000000, up=1.000000
ITER 6: row=5, varin=23, theta=0.500000, up=999999999999999983222784.000000
ITER 7: row=15, varin=55, theta=1.000000, up=1.000000
ITER 8: row=37, varin=24, theta=1.000000, up=999999999999999983222784.000000
ITER 9: row=38, varin=2, theta=0.800000, up=999999999999999983222784.000000
ITER 10: row=27, varin=25, theta=0.666667, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 3 = 1 gives z=28311418.109904
  % 	x3 = 1,	Z1 = 28311418.1099044        
DEBUG EVAL: First branch cutoff check: z=28311418.109904, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 3 = 0
ITER 1: row=19, varin=36, theta=0.500000, up=999999999999999983222784.000000
  % 	x3 = 0,	Z0 = 28039948.9332683        
DEBUG EVAL: Second branch cutoff check: z=28039948.933268, best_z=INF, threshold=INF
  % Best branch is x17, Z0 = 28090454.5792566        , Z1 = 28050806.2476876        

DEBUG CAREFUL: Final result - returning best.var = 17
DEBUG BB: Branching variable chosen: j=17
 % @NC   29   25	x17 = 1	28050806.247688
 % @NC   30   25	x17 = 0	28090454.579257
 %      25    16 28032816.6599               28050806.2477   x26 D    21     8
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cb30f0
% @LO 0.01  28.03281665987228166159 99.9000000000
% @LN 0.01  28.05080624768756436538 99.9000000000
% Resuming node 29 at  28.05080624768756436538
DEBUG CONSTRNT: LP rows=38, pool->nlprows=38, pool->npend=0
DEBUG CONSTRNT: Checking 38 LP rows (pool tracks 38, total LP rows 38)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=37, expected 37
 % @PAP adding 38 rows, 166 nz to LP
DEBUG BB: Processing node 29, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=23, varin=36, theta=1.250000, up=999999999999999983222784.000000
ITER 2: row=19, varin=35, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=38)
DEBUG SOLUTION: LP solution array indices: FST[39-78], not_covered[79-98]
DEBUG SOLUTION: lp->best_solution[0] = 28050806.247688
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 38 rows, 60 cols, 226 nonzeros, 4 slack, 34 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 40 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=39, varin=33, theta=0.556485, up=999999999999999983222784.000000
ITER 2: row=33, varin=31, theta=0.569782, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=39)
DEBUG SOLUTION: LP solution array indices: FST[40-79], not_covered[80-99]
DEBUG SOLUTION: lp->best_solution[0] = 28053690.058969
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 39 rows, 60 cols, 266 nonzeros, 6 slack, 33 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 6 slack rows
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=34, varin=38, theta=5.772766, up=1.000000
ITER 2: row=34, varin=18, theta=0.623503, up=999999999999999983222784.000000
ITER 3: row=21, varin=38, theta=0.646049, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=34)
DEBUG SOLUTION: LP solution array indices: FST[35-74], not_covered[75-94]
DEBUG SOLUTION: lp->best_solution[0] = 28187666.263166
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 34 rows, 60 cols, 242 nonzeros, 1 slack, 33 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 3 rows, 14 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=34, varin=71, theta=0.754141, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=36)
DEBUG SOLUTION: LP solution array indices: FST[37-76], not_covered[77-96]
DEBUG SOLUTION: lp->best_solution[0] = 28192549.227927
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 36 rows, 60 cols, 254 nonzeros, 0 slack, 36 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=37, varin=62, theta=0.352891, up=1.000000
ITER 2: row=3, varin=74, theta=0.542601, up=1.000000
ITER 3: row=30, varin=61, theta=0.344298, up=1.000000
ITER 4: row=31, varin=67, theta=0.372470, up=1.000000
ITER 5: row=29, varin=25, theta=0.097845, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=37)
DEBUG SOLUTION: LP solution array indices: FST[38-77], not_covered[78-97]
DEBUG SOLUTION: lp->best_solution[0] = 28246481.705376
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 37 rows, 60 cols, 256 nonzeros, 1 slack, 36 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 3 rows, 7 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=38, varin=67, theta=0.365675, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=39)
DEBUG SOLUTION: LP solution array indices: FST[40-79], not_covered[80-99]
DEBUG SOLUTION: lp->best_solution[0] = 28248568.440503
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 39 rows, 60 cols, 261 nonzeros, 0 slack, 39 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=40, varin=62, theta=0.334710, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=40)
DEBUG SOLUTION: LP solution array indices: FST[41-80], not_covered[81-100]
DEBUG SOLUTION: lp->best_solution[0] = 28261912.456975
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 40 rows, 60 cols, 263 nonzeros, 0 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=41, varin=7, theta=0.098200, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=41)
DEBUG SOLUTION: LP solution array indices: FST[42-81], not_covered[82-101]
DEBUG SOLUTION: lp->best_solution[0] = 28276785.476149
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 0.901800
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 41 rows, 60 cols, 267 nonzeros, 2 slack, 39 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 3 rows, 7 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=41, varin=68, theta=0.353104, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 28278531.644405
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 42 rows, 60 cols, 270 nonzeros, 0 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 5 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=43, varin=55, theta=0.319740, up=1.000000
ITER 2: row=33, varin=58, theta=0.365982, up=1.000000
ITER 3: row=14, varin=45, theta=0.307387, up=1.000000
ITER 4: row=37, varin=76, theta=0.439735, up=1.000000
ITER 5: row=25, varin=48, theta=0.333992, up=1.000000
ITER 6: row=32, varin=36, theta=0.190609, up=999999999999999983222784.000000
ITER 7: row=36, varin=72, theta=0.366919, up=1.000000
LP PHASE: Switching to primal (iter=7)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 28330641.075357
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 43 rows, 60 cols, 275 nonzeros, 0 slack, 43 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 5 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=44, varin=24, theta=0.146999, up=999999999999999983222784.000000
ITER 2: row=40, varin=101, theta=0.303775, up=1.000000
ITER 3: row=44, varin=61, theta=0.275320, up=1.000000
ITER 4: row=14, varin=41, theta=0.096847, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28354395.100916
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.806306
DEBUG SOLUTION: lp->best_solution[5] = 2.806306
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 44 rows, 60 cols, 280 nonzeros, 5 slack, 39 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % @PAP adding 4 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=40, varin=74, theta=0.196155, up=1.000000
ITER 2: row=43, varin=66, theta=0.216025, up=1.000000
ITER 3: row=29, varin=75, theta=0.430890, up=1.000000
LP PHASE: Switching to primal (iter=3)
ITER 4: row=29, varin=47, theta=0.000000, up=1.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 28395347.565106
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 43 rows, 60 cols, 275 nonzeros, 0 slack, 43 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=44, varin=67, theta=0.216025, up=1.000000
ITER 2: row=29, varin=68, theta=0.165761, up=1.000000
ITER 3: row=33, varin=78, theta=0.544603, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28409207.858950
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 44 rows, 60 cols, 277 nonzeros, 2 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 5 rows, 13 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=43, varin=3, theta=0.174802, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 28411189.860573
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.825198
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 47 rows, 60 cols, 286 nonzeros, 2 slack, 45 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % Node 29 LP 1 Solution, length = 28411189.860573, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.174802 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.174802 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.150397 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.150397 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 1.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.174802 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.174802 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.174802 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.174802 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.150397 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.825198 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.825198 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.825198 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.825198 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.849603 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.849603 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.849603 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 9 fractional variables
DEBUG CG: LP optimal, z=28411189.860573, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 29 at  28.41118986057296780245
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7caffe0
% @LO 0.01  28.05080624768756436538 99.9000000000
% @LN 0.01  28.05626523872902922108 99.9000000000
% Resuming node 2 at  28.05626523872902922108
DEBUG CONSTRNT: LP rows=45, pool->nlprows=45, pool->npend=0
DEBUG CONSTRNT: Checking 45 LP rows (pool tracks 45, total LP rows 45)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 133
DEBUG CONSTRNT: Pool row 133 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 134
DEBUG CONSTRNT: Pool row 134 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=44, expected 44
 % @PAP adding 31 rows, 145 nz to LP
DEBUG BB: Processing node 2, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 2 LP 3 Solution, length = 28056265.238729, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.222222 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.222222 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.555556 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.222222 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.222222 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 1.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.777778 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.444444 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.444444 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.444444 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.444444 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.777778 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.777778 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28056265.238729, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28056265.238729, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 2 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 2
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.222222
DEBUG CAREFUL: Adding var 7 to fractional list (xi=0.222222)
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.222222
DEBUG CAREFUL: Adding var 12 to fractional list (xi=0.222222)
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.555556
DEBUG CAREFUL: Adding var 13 to fractional list (xi=0.555556)
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.222222
DEBUG CAREFUL: Adding var 15 to fractional list (xi=0.222222)
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.222222
DEBUG CAREFUL: Adding var 16 to fractional list (xi=0.222222)
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=1.000000
DEBUG CAREFUL: Skipping var 20: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 15
DEBUG CAREFUL: Calling compare_branch_vars for var 15
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 15
DEBUG CAREFUL: New best var: 15
DEBUG CAREFUL: Testing fvar[1] = var 16
DEBUG CAREFUL: Calling compare_branch_vars for var 16
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 16
DEBUG CAREFUL: Testing fvar[2] = var 13
DEBUG CAREFUL: Calling compare_branch_vars for var 13
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 13
DEBUG CAREFUL: Testing fvar[3] = var 7
DEBUG CAREFUL: Calling compare_branch_vars for var 7
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 7
DEBUG CAREFUL: Testing fvar[4] = var 12
DEBUG CAREFUL: Calling compare_branch_vars for var 12
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 12
  % Initial guess is x15, Z0 = 28056265.238729         , Z1 = 28169816.4201466        

DEBUG EVAL: Testing var 15 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=19, varin=37, theta=2.333333, up=1.000000
ITER 2: row=19, varin=29, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=24, varin=37, theta=4.000000, up=1.000000
ITER 4: row=24, varin=33, theta=3.000000, up=1.000000
ITER 5: row=24, varin=25, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=25, varin=27, theta=2.000000, up=999999999999999983222784.000000
ITER 7: row=31, varin=28, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 15 = 1 gives z=28140739.966686
  % 	x15 = 1,	Z1 = 28169816.4201466        
DEBUG EVAL: First branch cutoff check: z=28169816.420147, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 15 = 0
ITER 1: row=19, varin=85, theta=2.000000, up=1.000000
ITER 2: row=19, varin=46, theta=0.111111, up=1.000000
  % 	x15 = 0,	Z0 = 28060149.6319899        
DEBUG EVAL: Second branch cutoff check: z=28060149.631990, best_z=INF, threshold=INF
  %   New best:  x15, Z = 28060149.6319899        
DEBUG EVAL: Testing var 16 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=24, varin=13, theta=1.166667, up=999999999999999983222784.000000
ITER 2: row=1, varin=33, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 16 = 1 gives z=28093573.259413
  % 	x16 = 1,	Z1 = 28097998.9331366        
DEBUG EVAL: First branch cutoff check: z=28097998.933137, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 16 = 0
ITER 1: row=24, varin=85, theta=2.000000, up=1.000000
ITER 2: row=24, varin=37, theta=0.166667, up=1.000000
  % 	x16 = 0,	Z0 = 28056776.1640781        
DEBUG EVAL: Second branch cutoff check: z=28056776.164078, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 13 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=12, varin=85, theta=2.000000, up=1.000000
ITER 2: row=12, varin=37, theta=0.666667, up=1.000000
ITER 3: row=1, varin=29, theta=0.500000, up=999999999999999983222784.000000
ITER 4: row=24, varin=49, theta=0.333333, up=1.000000
DEBUG EVAL: Branch var 13 = 1 gives z=28078531.525296
  % 	x13 = 1,	Z1 = 28078531.5252956        
DEBUG EVAL: First branch cutoff check: z=28078531.525296, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 13 = 0
ITER 1: row=12, varin=33, theta=2.500000, up=1.000000
ITER 2: row=12, varin=13, theta=1.000000, up=999999999999999983222784.000000
  % 	x13 = 0,	Z0 = 28093573.2594129        
DEBUG EVAL: Second branch cutoff check: z=28093573.259413, best_z=INF, threshold=INF
  %   New best:  x13, Z = 28078531.5252956        
DEBUG EVAL: Testing var 7 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=85, theta=2.000000, up=1.000000
ITER 2: row=1, varin=37, theta=0.166667, up=1.000000
DEBUG EVAL: Branch var 7 = 0 gives z=28056776.164078
  % 	x7 = 0,	Z0 = 28056776.1640781        
DEBUG EVAL: First branch cutoff check: z=28056776.164078, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 12 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=13, varin=85, theta=2.000000, up=1.000000
ITER 2: row=13, varin=27, theta=0.125000, up=999999999999999983222784.000000
ITER 3: row=31, varin=46, theta=0.111111, up=1.000000
DEBUG EVAL: Branch var 12 = 0 gives z=28060149.631990
  % 	x12 = 0,	Z0 = 28060149.6319899        
DEBUG EVAL: First branch cutoff check: z=28060149.631990, best_z=INF, threshold=INF
  % Best branch is x13, Z0 = 28093573.2594129        , Z1 = 28078531.5252956        

DEBUG CAREFUL: Final result - returning best.var = 13
DEBUG BB: Branching variable chosen: j=13
 % @NC   31    2	x13 = 1	28078531.525296
 % @NC   32    2	x13 = 0	28093573.259413
 %       2    17 28056265.2387               28071052.3595   x20 U     0     1
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cc2570
% @LO 0.01  28.05626523872902922108 99.9000000000
% @LN 0.01  28.07105235946540844338 99.9000000000
% Resuming node 16 at  28.07105235946540844338
DEBUG CONSTRNT: LP rows=31, pool->nlprows=31, pool->npend=0
DEBUG CONSTRNT: Checking 31 LP rows (pool tracks 31, total LP rows 31)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 65
DEBUG CONSTRNT: Pool row 65 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=30, expected 30
 % @PAP adding 36 rows, 172 nz to LP
DEBUG BB: Processing node 16, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=10, varin=34, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=32, varin=2, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=2, varin=31, theta=0.588235, up=999999999999999983222784.000000
ITER 4: row=34, varin=24, theta=2.000000, up=999999999999999983222784.000000
ITER 5: row=23, varin=27, theta=2.000000, up=999999999999999983222784.000000
ITER 6: row=18, varin=30, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=22, varin=22, theta=0.428571, up=999999999999999983222784.000000
ITER 8: row=1, varin=38, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=8)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=36)
DEBUG SOLUTION: LP solution array indices: FST[37-76], not_covered[77-96]
DEBUG SOLUTION: lp->best_solution[0] = 28071052.359465
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 36 rows, 60 cols, 232 nonzeros, 1 slack, 35 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 6 rows, 40 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=37, varin=10, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=39, varin=12, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=1, varin=45, theta=0.642857, up=1.000000
ITER 4: row=41, varin=52, theta=1.000000, up=1.000000
ITER 5: row=29, varin=26, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=24, varin=58, theta=0.333333, up=1.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 28145408.897238
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.333333
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.333333
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 42 rows, 60 cols, 272 nonzeros, 8 slack, 34 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 8 slack rows
  % @PAP adding 4 rows, 16 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=35, varin=12, theta=0.400000, up=999999999999999983222784.000000
ITER 2: row=37, varin=53, theta=0.333333, up=1.000000
ITER 3: row=38, varin=13, theta=0.058824, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=38)
DEBUG SOLUTION: LP solution array indices: FST[39-78], not_covered[79-98]
DEBUG SOLUTION: lp->best_solution[0] = 28162393.978164
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.941176
DEBUG SOLUTION: lp->best_solution[13] = 0.941176
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 38 rows, 60 cols, 244 nonzeros, 3 slack, 35 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 3 rows, 10 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=36, varin=49, theta=2.000000, up=1.000000
ITER 2: row=36, varin=35, theta=1.250000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=38)
DEBUG SOLUTION: LP solution array indices: FST[39-78], not_covered[79-98]
DEBUG SOLUTION: lp->best_solution[0] = 28168429.090455
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 38 rows, 60 cols, 245 nonzeros, 2 slack, 36 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 2 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=37, varin=49, theta=0.333333, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=38)
DEBUG SOLUTION: LP solution array indices: FST[39-78], not_covered[79-98]
DEBUG SOLUTION: lp->best_solution[0] = 28169463.401024
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 38 rows, 60 cols, 244 nonzeros, 1 slack, 37 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 16 LP 1 Solution, length = 28169463.401024, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.333333 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.333333 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.333333 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.666667 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.333333 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.333333 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.333333 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.333333 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.666667 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.666667 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.666667 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.666667 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.666667 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=28169463.401024, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 16 at  28.16946340102352053236
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cb6780
% @LO 0.01  28.07105235946540844338 99.9000000000
% @LN 0.01  28.07647515938188931273 99.9000000000
% Resuming node 8 at  28.07647515938188931273
DEBUG CONSTRNT: LP rows=37, pool->nlprows=37, pool->npend=0
DEBUG CONSTRNT: Checking 37 LP rows (pool tracks 37, total LP rows 37)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 49
DEBUG CONSTRNT: Pool row 49 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 68
DEBUG CONSTRNT: Pool row 68 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 82
DEBUG CONSTRNT: Pool row 82 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=36, expected 36
 % @PAP adding 37 rows, 186 nz to LP
DEBUG BB: Processing node 8, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 8 LP 2 Solution, length = 28076475.159382, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 1.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.500000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.500000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.500000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.500000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.500000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 2 fractional variables
DEBUG CG: LP optimal, z=28076475.159382, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28076475.159382, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 8 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 8
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=1.000000
DEBUG CAREFUL: Skipping var 12: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.500000
DEBUG CAREFUL: Adding var 13 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.500000
DEBUG CAREFUL: Adding var 16 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 2 fractional variables

  %  Carefully choosing branching variable, nfrac = 2
DEBUG CAREFUL: Testing fvar[0] = var 16
DEBUG CAREFUL: Calling compare_branch_vars for var 16
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 16
DEBUG CAREFUL: New best var: 16
DEBUG CAREFUL: Testing fvar[1] = var 13
DEBUG CAREFUL: Calling compare_branch_vars for var 13
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 13
  % Initial guess is x16, Z0 = 28076475.1593819        , Z1 = 28083728.0788599        

DEBUG EVAL: Testing var 16 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=22, varin=31, theta=0.333333, up=999999999999999983222784.000000
ITER 2: row=31, varin=20, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=1, varin=90, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 16 = 1 gives z=28105838.366790
  % 	x16 = 1,	Z1 = 28105838.3667898        
DEBUG EVAL: First branch cutoff check: z=28105838.366790, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 16 = 0
ITER 1: row=22, varin=38, theta=0.500000, up=1.000000
ITER 2: row=2, varin=81, theta=0.500000, up=1.000000
ITER 3: row=34, varin=79, theta=1.000000, up=1.000000
  % 	x16 = 0,	Z0 = 28145021.2966989        
DEBUG EVAL: Second branch cutoff check: z=28145021.296699, best_z=INF, threshold=INF
  %   New best:  x16, Z = 28105838.3667898        
DEBUG EVAL: Testing var 13 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=11, varin=31, theta=0.333333, up=999999999999999983222784.000000
ITER 2: row=31, varin=20, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=1, varin=90, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 13 = 0 gives z=28105838.366790
  % 	x13 = 0,	Z0 = 28105838.3667898        
DEBUG EVAL: First branch cutoff check: z=28105838.366790, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 13 = 1
ITER 1: row=11, varin=38, theta=0.500000, up=1.000000
ITER 2: row=2, varin=81, theta=0.500000, up=1.000000
ITER 3: row=34, varin=79, theta=1.000000, up=1.000000
  % 	x13 = 1,	Z1 = 28145021.2966989        
DEBUG EVAL: Second branch cutoff check: z=28145021.296699, best_z=INF, threshold=INF
  % Best branch is x16, Z0 = 28145021.2966989        , Z1 = 28105838.3667898        

DEBUG CAREFUL: Final result - returning best.var = 16
DEBUG BB: Branching variable chosen: j=16
 % @NC   33    8	x16 = 1	28105838.366790
 % @NC   34    8	x16 = 0	28145021.296699
 %       8    18 28076475.1594               28078327.2531   x12 U     5     4
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cb66c0
% @LO 0.01  28.07647515938188931273 99.9000000000
% @LN 0.01  28.07832725308718124779 99.9000000000
% Resuming node 23 at  28.07832725308718124779
DEBUG CONSTRNT: LP rows=37, pool->nlprows=37, pool->npend=0
DEBUG CONSTRNT: Checking 37 LP rows (pool tracks 37, total LP rows 37)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=36, expected 36
 % @PAP adding 42 rows, 174 nz to LP
DEBUG BB: Processing node 23, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=21, varin=66, theta=1.000000, up=1.000000
ITER 2: row=42, varin=54, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 28078327.253087
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 42 rows, 60 cols, 234 nonzeros, 0 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 6 rows, 34 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=43, varin=36, theta=0.333333, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 28087197.241570
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 48 rows, 60 cols, 268 nonzeros, 6 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 6 slack rows
  % Node 23 LP 1 Solution, length = 28087197.241570, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.333333 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.333333 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.333333 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.333333 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.333333 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.666667 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.666667 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.666667 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.666667 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.666667 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.666667 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.666667 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28087197.241570, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 23 at  28.08719724157020536381
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cae7d0
% @LO 0.01  28.07832725308718124779 99.9000000000
% @LN 0.01  28.07853152529555629258 99.9000000000
% Resuming node 31 at  28.07853152529555629258
DEBUG CONSTRNT: LP rows=42, pool->nlprows=42, pool->npend=0
DEBUG CONSTRNT: Checking 42 LP rows (pool tracks 42, total LP rows 42)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=41, expected 41
 % @PAP adding 31 rows, 145 nz to LP
DEBUG BB: Processing node 31, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=12, varin=85, theta=2.000000, up=1.000000
ITER 2: row=12, varin=37, theta=0.666667, up=1.000000
ITER 3: row=1, varin=29, theta=0.500000, up=999999999999999983222784.000000
ITER 4: row=24, varin=49, theta=0.333333, up=1.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=31)
DEBUG SOLUTION: LP solution array indices: FST[32-71], not_covered[72-91]
DEBUG SOLUTION: lp->best_solution[0] = 28078531.525296
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 31 rows, 60 cols, 205 nonzeros, 1 slack, 30 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 7 rows, 67 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=38, varin=39, theta=4.360256, up=1.000000
ITER 2: row=38, varin=53, theta=2.302224, up=1.000000
ITER 3: row=38, varin=16, theta=0.611381, up=999999999999999983222784.000000
ITER 4: row=2, varin=39, theta=1.000000, up=1.000000
ITER 5: row=12, varin=53, theta=1.000000, up=1.000000
ITER 6: row=14, varin=92, theta=6.819725, up=1.000000
ITER 7: row=14, varin=65, theta=1.299644, up=1.000000
ITER 8: row=14, varin=63, theta=0.288956, up=1.000000
ITER 9: row=3, varin=62, theta=0.265634, up=1.000000
ITER 10: row=32, varin=92, theta=0.613009, up=1.000000
LP PHASE: Switching to primal (iter=10)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=38)
DEBUG SOLUTION: LP solution array indices: FST[39-78], not_covered[79-98]
DEBUG SOLUTION: lp->best_solution[0] = 28287403.709459
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 38 rows, 60 cols, 272 nonzeros, 1 slack, 37 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 6 rows, 18 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=40, varin=98, theta=1.000000, up=1.000000
ITER 2: row=1, varin=70, theta=0.591608, up=1.000000
ITER 3: row=38, varin=65, theta=1.084057, up=1.000000
ITER 4: row=38, varin=73, theta=0.120958, up=1.000000
ITER 5: row=16, varin=46, theta=0.730650, up=1.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 28541363.557303
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 43 rows, 60 cols, 286 nonzeros, 0 slack, 43 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 8 rows, 29 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=48, varin=73, theta=1.000000, up=1.000000
ITER 2: row=44, varin=79, theta=1.541588, up=1.000000
ITER 3: row=44, varin=77, theta=0.487635, up=1.000000
ITER 4: row=51, varin=67, theta=0.102573, up=1.000000
ITER 5: row=12, varin=29, theta=0.108537, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 28625944.225886
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 51 rows, 60 cols, 315 nonzeros, 3 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 4 rows, 10 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=49, varin=16, theta=0.322857, up=999999999999999983222784.000000
ITER 2: row=52, varin=80, theta=0.500000, up=1.000000
ITER 3: row=51, varin=24, theta=2.423794, up=999999999999999983222784.000000
ITER 4: row=49, varin=75, theta=1.730847, up=1.000000
ITER 5: row=49, varin=48, theta=0.791455, up=999999999999999983222784.000000
ITER 6: row=37, varin=75, theta=0.908305, up=1.000000
ITER 7: row=29, varin=37, theta=0.124795, up=999999999999999983222784.000000
ITER 8: row=24, varin=16, theta=0.158710, up=999999999999999983222784.000000
ITER 9: row=14, varin=52, theta=0.646190, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=9)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 28813675.024210
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 52 rows, 60 cols, 316 nonzeros, 3 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 2 rows, 9 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=51, varin=80, theta=0.434340, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 28818576.201578
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 51 rows, 60 cols, 312 nonzeros, 0 slack, 51 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 5 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=52, varin=2, theta=0.714896, up=999999999999999983222784.000000
ITER 2: row=2, varin=14, theta=1.139752, up=999999999999999983222784.000000
ITER 3: row=14, varin=83, theta=3.491764, up=1.000000
ITER 4: row=14, varin=84, theta=5.117306, up=1.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 999999999999999983222784.000000
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 52 rows, 60 cols, 317 nonzeros, 3 slack, 49 tight.
  % Node 31 LP 1 Solution, length = 999999999999999983222784.000000, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.282830 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.500000 (FST 12)
  % DEBUG LP_VARS: x[13] = 1.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 1.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.500000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.500000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.282830 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.434340 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.717170 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.500000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
DEBUG BB: compute_good_lower_bound returned status=1
DEBUG BB: Node 31 is INFEASIBLE
 %      31    17    infeasible               28087197.2416   x13 U     2     2
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cb66c0
% @LO 0.01  28.07853152529555629258 99.9000000000
% @LN 0.01  28.08719724157020536381 99.9000000000
% Resuming node 23 at  28.08719724157020536381
DEBUG CONSTRNT: LP rows=52, pool->nlprows=52, pool->npend=0
DEBUG CONSTRNT: Checking 52 LP rows (pool tracks 52, total LP rows 52)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 65
DEBUG CONSTRNT: Pool row 65 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 141
DEBUG CONSTRNT: Pool row 141 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 145
DEBUG CONSTRNT: Pool row 145 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 159
DEBUG CONSTRNT: Pool row 159 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=51, expected 51
 % @PAP adding 42 rows, 174 nz to LP
DEBUG BB: Processing node 23, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 23 LP 2 Solution, length = 28087197.241570, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.333333 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.333333 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.333333 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.333333 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.333333 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.666667 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.666667 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.666667 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.666667 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.666667 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.666667 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.666667 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28087197.241570, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28087197.241570, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 23 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 23
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.333333
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=1.000000
DEBUG CAREFUL: Skipping var 7: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.333333
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.333333
DEBUG CAREFUL: Adding var 11 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.333333
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.333333
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 11
DEBUG CAREFUL: Calling compare_branch_vars for var 11
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 11
DEBUG CAREFUL: New best var: 11
DEBUG CAREFUL: Testing fvar[1] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[2] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[3] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[4] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
  % Initial guess is x11, Z0 = 28087197.2415702        , Z1 = 28364541.423479         

DEBUG EVAL: Testing var 11 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=21, varin=39, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=39, varin=24, theta=2.000000, up=999999999999999983222784.000000
ITER 3: row=41, varin=36, theta=2.000000, up=999999999999999983222784.000000
ITER 4: row=36, varin=17, theta=2.000000, up=999999999999999983222784.000000
ITER 5: row=17, varin=33, theta=2.000000, up=999999999999999983222784.000000
ITER 6: row=33, varin=25, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=42, varin=29, theta=1.000000, up=999999999999999983222784.000000
ITER 8: row=37, varin=26, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 11 = 1 gives z=28475644.715565
  % 	x11 = 1,	Z1 = 28475644.7155647        
DEBUG EVAL: First branch cutoff check: z=28475644.715565, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 11 = 0
ITER 1: row=21, varin=47, theta=0.500000, up=1.000000
  % 	x11 = 0,	Z0 = 28090690.5937263        
DEBUG EVAL: Second branch cutoff check: z=28090690.593726, best_z=INF, threshold=INF
  %   New best:  x11, Z = 28090690.5937263        
DEBUG EVAL: Testing var 17 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=23, varin=40, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 17 = 1 gives z=28104937.218536
  % 	x17 = 1,	Z1 = 28104937.2185362        
DEBUG EVAL: First branch cutoff check: z=28104937.218536, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 17 = 0
ITER 1: row=23, varin=47, theta=0.500000, up=1.000000
  % 	x17 = 0,	Z0 = 28090690.5937263        
DEBUG EVAL: Second branch cutoff check: z=28090690.593726, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 10 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=16, varin=40, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 1 gives z=28104937.218536
  % 	x10 = 1,	Z1 = 28104937.2185362        
DEBUG EVAL: First branch cutoff check: z=28104937.218536, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 0
ITER 1: row=16, varin=47, theta=0.500000, up=1.000000
  % 	x10 = 0,	Z0 = 28090690.5937263        
DEBUG EVAL: Second branch cutoff check: z=28090690.593726, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 2 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=47, theta=0.500000, up=1.000000
DEBUG EVAL: Branch var 2 = 0 gives z=28090690.593726
  % 	x2 = 0,	Z0 = 28090690.5937263        
DEBUG EVAL: First branch cutoff check: z=28090690.593726, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 1
ITER 1: row=1, varin=40, theta=1.000000, up=999999999999999983222784.000000
  % 	x2 = 1,	Z1 = 28104937.2185362        
DEBUG EVAL: Second branch cutoff check: z=28104937.218536, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 26 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=33, varin=47, theta=0.500000, up=1.000000
DEBUG EVAL: Branch var 26 = 0 gives z=28090690.593726
  % 	x26 = 0,	Z0 = 28090690.5937263        
DEBUG EVAL: First branch cutoff check: z=28090690.593726, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 26 = 1
ITER 1: row=33, varin=40, theta=1.000000, up=999999999999999983222784.000000
  % 	x26 = 1,	Z1 = 28104937.2185362        
DEBUG EVAL: Second branch cutoff check: z=28104937.218536, best_z=INF, threshold=INF
  % Best branch is x11, Z0 = 28090690.5937263        , Z1 = 28475644.7155647        

DEBUG CAREFUL: Final result - returning best.var = 11
DEBUG BB: Branching variable chosen: j=11
 % @NC   35   23	x11 = 0	28090690.593726
 % @NC   36   23	x11 = 1	28475644.715565
 %      23    18 28087197.2416               28090454.5793    x3 D    17     5
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cc9ac0
% @LO 0.01  28.08719724157020536381 99.9000000000
% @LN 0.01  28.09045457925659050602 99.9000000000
% Resuming node 30 at  28.09045457925659050602
DEBUG CONSTRNT: LP rows=42, pool->nlprows=42, pool->npend=0
DEBUG CONSTRNT: Checking 42 LP rows (pool tracks 42, total LP rows 42)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=41, expected 41
 % @PAP adding 38 rows, 166 nz to LP
DEBUG BB: Processing node 30, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=23, varin=63, theta=0.500000, up=1.000000
ITER 2: row=3, varin=62, theta=0.500000, up=1.000000
ITER 3: row=34, varin=50, theta=0.250000, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=38)
DEBUG SOLUTION: LP solution array indices: FST[39-78], not_covered[79-98]
DEBUG SOLUTION: lp->best_solution[0] = 28090454.579257
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 38 rows, 60 cols, 226 nonzeros, 0 slack, 38 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 22 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=39, varin=47, theta=0.250000, up=1.000000
ITER 2: row=40, varin=24, theta=0.031250, up=999999999999999983222784.000000
ITER 3: row=41, varin=39, theta=0.031250, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 28097754.157606
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 42 rows, 60 cols, 248 nonzeros, 3 slack, 39 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 3 rows, 11 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=40, varin=72, theta=0.500000, up=1.000000
ITER 2: row=29, varin=44, theta=0.125000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 28106014.393740
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.875000
DEBUG SOLUTION: lp->best_solution[5] = 2.875000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 42 rows, 60 cols, 253 nonzeros, 3 slack, 39 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 5 rows, 12 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=40, varin=26, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=43, varin=21, theta=0.166667, up=999999999999999983222784.000000
ITER 3: row=33, varin=23, theta=0.125000, up=999999999999999983222784.000000
ITER 4: row=44, varin=72, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28121482.432199
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 44 rows, 60 cols, 254 nonzeros, 0 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=45, varin=34, theta=4.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=46)
DEBUG SOLUTION: LP solution array indices: FST[47-86], not_covered[87-106]
DEBUG SOLUTION: lp->best_solution[0] = 28139368.960675
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 46 rows, 60 cols, 260 nonzeros, 3 slack, 43 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % Node 30 LP 1 Solution, length = 28139368.960675, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.500000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.500000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.500000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.500000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.500000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.500000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.500000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.500000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.500000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.500000 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28139368.960675, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 30 at  28.13936896067523107945
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cae7d0
% @LO 0.01  28.09045457925659050602 99.9000000000
% @LN 0.01  28.09069059372632537475 99.9000000000
% Resuming node 35 at  28.09069059372632537475
DEBUG CONSTRNT: LP rows=43, pool->nlprows=43, pool->npend=0
DEBUG CONSTRNT: Checking 43 LP rows (pool tracks 43, total LP rows 43)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=42, expected 42
 % @PAP adding 42 rows, 174 nz to LP
DEBUG BB: Processing node 35, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=21, varin=47, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 28090690.593726
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 42 rows, 60 cols, 234 nonzeros, 0 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 6 rows, 33 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=43, varin=40, theta=0.333333, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 28095439.468663
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 48 rows, 60 cols, 267 nonzeros, 6 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 6 slack rows
  % Node 35 LP 1 Solution, length = 28095439.468663, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.333333 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.333333 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.333333 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.333333 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.333333 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.666667 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.666667 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.666667 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.666667 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.666667 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.666667 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.666667 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28095439.468663, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 35 at  28.09543946866297048359
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7ccbbd0
% @LO 0.01  28.09069059372632537475 99.9000000000
% @LN 0.01  28.09357325941285665749 99.9000000000
% Resuming node 32 at  28.09357325941285665749
DEBUG CONSTRNT: LP rows=42, pool->nlprows=42, pool->npend=0
DEBUG CONSTRNT: Checking 42 LP rows (pool tracks 42, total LP rows 42)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=41, expected 41
 % @PAP adding 31 rows, 145 nz to LP
DEBUG BB: Processing node 32, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=12, varin=33, theta=2.500000, up=1.000000
ITER 2: row=12, varin=13, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=31)
DEBUG SOLUTION: LP solution array indices: FST[32-71], not_covered[72-91]
DEBUG SOLUTION: lp->best_solution[0] = 28093573.259413
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 31 rows, 60 cols, 205 nonzeros, 1 slack, 30 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 7 rows, 80 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=38, varin=40, theta=0.423914, up=1.000000
ITER 2: row=32, varin=25, theta=1.551703, up=999999999999999983222784.000000
ITER 3: row=35, varin=21, theta=0.230769, up=999999999999999983222784.000000
ITER 4: row=25, varin=19, theta=0.897296, up=999999999999999983222784.000000
ITER 5: row=37, varin=22, theta=0.125000, up=999999999999999983222784.000000
ITER 6: row=34, varin=27, theta=3.111425, up=999999999999999983222784.000000
ITER 7: row=31, varin=35, theta=8.157495, up=999999999999999983222784.000000
ITER 8: row=36, varin=37, theta=4.249170, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=8)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=38)
DEBUG SOLUTION: LP solution array indices: FST[39-78], not_covered[79-98]
DEBUG SOLUTION: lp->best_solution[0] = 28134864.930670
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.687708
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 38 rows, 60 cols, 285 nonzeros, 7 slack, 31 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 7 slack rows
  % Node 32 LP 1 Solution, length = 28134864.930670, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.063123 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.343854 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.343854 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.343854 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.656146 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 1.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.343854 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.936877 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.936877 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.343854 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.343854 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.936877 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.343854 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.656146 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.656146 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28134864.930670, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 32 at  28.13486493067039617699
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cae7d0
% @LO 0.01  28.09357325941285665749 99.9000000000
% @LN 0.01  28.09543946866297048359 99.9000000000
% Resuming node 35 at  28.09543946866297048359
DEBUG CONSTRNT: LP rows=31, pool->nlprows=31, pool->npend=0
DEBUG CONSTRNT: Checking 31 LP rows (pool tracks 31, total LP rows 31)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 49
DEBUG CONSTRNT: Pool row 49 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 68
DEBUG CONSTRNT: Pool row 68 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 82
DEBUG CONSTRNT: Pool row 82 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=30, expected 30
 % @PAP adding 42 rows, 174 nz to LP
DEBUG BB: Processing node 35, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 35 LP 2 Solution, length = 28095439.468663, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.333333 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.333333 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.333333 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.333333 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.333333 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.666667 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.666667 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.666667 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.666667 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.666667 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.666667 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.666667 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28095439.468663, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28095439.468663, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 35 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 35
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.333333
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.333333
DEBUG CAREFUL: Adding var 4 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=1.000000
DEBUG CAREFUL: Skipping var 7: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.333333
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.333333
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.333333
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 4
DEBUG CAREFUL: Calling compare_branch_vars for var 4
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 4
DEBUG CAREFUL: New best var: 4
DEBUG CAREFUL: Testing fvar[1] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[2] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[3] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[4] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
  % Initial guess is x4, Z0 = 28095439.468663         , Z1 = 28391610.3242708        

DEBUG EVAL: Testing var 4 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=21, varin=39, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=39, varin=36, theta=2.000000, up=999999999999999983222784.000000
ITER 3: row=36, varin=17, theta=2.000000, up=999999999999999983222784.000000
ITER 4: row=17, varin=23, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=41, varin=33, theta=2.000000, up=999999999999999983222784.000000
ITER 6: row=33, varin=24, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=42, varin=29, theta=1.000000, up=999999999999999983222784.000000
ITER 8: row=37, varin=26, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 4 = 1 gives z=28500371.396843
  % 	x4 = 1,	Z1 = 28500371.396843         
DEBUG EVAL: First branch cutoff check: z=28500371.396843, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 4 = 0
ITER 1: row=21, varin=40, theta=1.000000, up=999999999999999983222784.000000
  % 	x4 = 0,	Z0 = 28104937.2185362        
DEBUG EVAL: Second branch cutoff check: z=28104937.218536, best_z=INF, threshold=INF
  %   New best:  x4, Z = 28104937.2185362        
DEBUG EVAL: Testing var 17 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=23, varin=40, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 17 = 1 gives z=28104937.218536
  % 	x17 = 1,	Z1 = 28104937.2185362        
DEBUG EVAL: First branch cutoff check: z=28104937.218536, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 17 = 0
ITER 1: row=23, varin=72, theta=1.000000, up=1.000000
ITER 2: row=32, varin=44, theta=0.333333, up=1.000000
ITER 3: row=38, varin=70, theta=1.000000, up=1.000000
  % 	x17 = 0,	Z0 = 28140382.9589715        
DEBUG EVAL: Second branch cutoff check: z=28140382.958971, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 10 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=16, varin=40, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 1 gives z=28104937.218536
  % 	x10 = 1,	Z1 = 28104937.2185362        
DEBUG EVAL: First branch cutoff check: z=28104937.218536, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 0
ITER 1: row=16, varin=72, theta=1.000000, up=1.000000
ITER 2: row=32, varin=44, theta=0.333333, up=1.000000
ITER 3: row=38, varin=70, theta=1.000000, up=1.000000
  % 	x10 = 0,	Z0 = 28140382.9589715        
DEBUG EVAL: Second branch cutoff check: z=28140382.958971, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 2 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=40, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 1 gives z=28104937.218536
  % 	x2 = 1,	Z1 = 28104937.2185362        
DEBUG EVAL: First branch cutoff check: z=28104937.218536, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 0
ITER 1: row=1, varin=72, theta=1.000000, up=1.000000
ITER 2: row=32, varin=44, theta=0.333333, up=1.000000
ITER 3: row=38, varin=70, theta=1.000000, up=1.000000
  % 	x2 = 0,	Z0 = 28140382.9589715        
DEBUG EVAL: Second branch cutoff check: z=28140382.958971, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 26 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=33, varin=40, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 26 = 1 gives z=28104937.218536
  % 	x26 = 1,	Z1 = 28104937.2185362        
DEBUG EVAL: First branch cutoff check: z=28104937.218536, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 26 = 0
ITER 1: row=33, varin=72, theta=1.000000, up=1.000000
ITER 2: row=32, varin=44, theta=0.333333, up=1.000000
ITER 3: row=38, varin=70, theta=1.000000, up=1.000000
  % 	x26 = 0,	Z0 = 28140382.9589715        
DEBUG EVAL: Second branch cutoff check: z=28140382.958971, best_z=INF, threshold=INF
  % Best branch is x4, Z0 = 28104937.2185362        , Z1 = 28500371.396843         

DEBUG CAREFUL: Final result - returning best.var = 4
DEBUG BB: Branching variable chosen: j=4
 % @NC   37   35	x4 = 0	28104937.218536
 % @NC   38   35	x4 = 1	28500371.396843
 %      35    19 28095439.4687               28104851.8160   x11 D    23     6
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7ca0600
% @LO 0.01  28.09543946866297048359 99.9000000000
% @LN 0.01  28.10485181597337245307 99.9000000000
% Resuming node 27 at  28.10485181597337245307
DEBUG CONSTRNT: LP rows=42, pool->nlprows=42, pool->npend=0
DEBUG CONSTRNT: Checking 42 LP rows (pool tracks 42, total LP rows 42)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=41, expected 41
 % @PAP adding 42 rows, 172 nz to LP
DEBUG BB: Processing node 27, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=21, varin=52, theta=1.000000, up=1.000000
ITER 2: row=20, varin=66, theta=1.000000, up=1.000000
ITER 3: row=42, varin=54, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 28104851.815973
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 42 rows, 60 cols, 232 nonzeros, 0 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 6 rows, 34 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=43, varin=36, theta=0.333333, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 28113721.804456
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 48 rows, 60 cols, 266 nonzeros, 6 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 6 slack rows
  % Node 27 LP 1 Solution, length = 28113721.804456, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.333333 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.333333 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.333333 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.333333 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.333333 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.666667 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.666667 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.666667 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.666667 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.666667 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.666667 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.666667 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28113721.804456, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 27 at  28.11372180445638946367
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cb66c0
% @LO 0.01  28.10485181597337245307 99.9000000000
% @LN 0.01  28.10493721853624649043 99.9000000000
% Resuming node 37 at  28.10493721853624649043
DEBUG CONSTRNT: LP rows=42, pool->nlprows=42, pool->npend=0
DEBUG CONSTRNT: Checking 42 LP rows (pool tracks 42, total LP rows 42)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=41, expected 41
 % @PAP adding 42 rows, 174 nz to LP
DEBUG BB: Processing node 37, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=21, varin=40, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 28104937.218536
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 42 rows, 60 cols, 234 nonzeros, 3 slack, 39 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 42 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=44, varin=74, theta=0.419554, up=1.000000
ITER 2: row=32, varin=46, theta=0.169309, up=1.000000
ITER 3: row=38, varin=36, theta=0.168618, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
ITER 4: row=43, varin=72, theta=0.027310, up=1.000000
ITER 5: row=1, varin=44, theta=108342.000000, up=999999999999999983222784.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28122660.088754
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 44 rows, 60 cols, 276 nonzeros, 4 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=54, theta=4.333333, up=1.000000
ITER 2: row=1, varin=57, theta=3.333333, up=1.000000
ITER 3: row=1, varin=56, theta=2.333333, up=1.000000
ITER 4: row=1, varin=55, theta=1.333333, up=1.000000
ITER 5: row=1, varin=49, theta=0.500000, up=1.000000
ITER 6: row=20, varin=51, theta=3.500000, up=1.000000
ITER 7: row=20, varin=42, theta=2.500000, up=1.000000
ITER 8: row=20, varin=46, theta=3.000000, up=1.000000
ITER 9: row=20, varin=81, theta=2.000000, up=1.000000
ITER 10: row=20, varin=82, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=64)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=40)
DEBUG SOLUTION: LP solution array indices: FST[41-80], not_covered[81-100]
DEBUG SOLUTION: lp->best_solution[0] = 28122660.088754
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 40 rows, 60 cols, 230 nonzeros, 0 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 37 LP 1 Solution, length = 28122660.088754, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.500000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.500000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.500000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.500000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.500000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.500000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.500000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.500000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.500000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.500000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.500000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.500000 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28122660.088754, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 37 at  28.12266008875386802401
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7caffe0
% @LO 0.01  28.10493721853624649043 99.9000000000
% @LN 0.01  28.10583836678984681612 99.9000000000
% Resuming node 33 at  28.10583836678984681612
DEBUG CONSTRNT: LP rows=40, pool->nlprows=40, pool->npend=0
DEBUG CONSTRNT: Checking 40 LP rows (pool tracks 40, total LP rows 40)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 158
DEBUG CONSTRNT: Pool row 158 has lprow=39, expected 39
 % @PAP adding 37 rows, 186 nz to LP
DEBUG BB: Processing node 33, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=22, varin=31, theta=0.333333, up=999999999999999983222784.000000
ITER 2: row=31, varin=20, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=1, varin=90, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=37)
DEBUG SOLUTION: LP solution array indices: FST[38-77], not_covered[78-97]
DEBUG SOLUTION: lp->best_solution[0] = 28105838.366790
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 37 rows, 60 cols, 246 nonzeros, 2 slack, 35 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 24 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=38, varin=23, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=40, varin=22, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=37, varin=44, theta=1.125000, up=1.000000
ITER 4: row=37, varin=59, theta=0.040201, up=1.000000
ITER 5: row=20, varin=44, theta=0.956522, up=1.000000
ITER 6: row=31, varin=42, theta=0.500000, up=1.000000
ITER 7: row=2, varin=85, theta=0.533333, up=1.000000
ITER 8: row=34, varin=83, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=8)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=41)
DEBUG SOLUTION: LP solution array indices: FST[42-81], not_covered[82-101]
DEBUG SOLUTION: lp->best_solution[0] = 28275911.222871
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 41 rows, 60 cols, 270 nonzeros, 7 slack, 34 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 7 slack rows
  % @PAP adding 4 rows, 15 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=35, varin=57, theta=0.347826, up=1.000000
ITER 2: row=30, varin=14, theta=0.055172, up=999999999999999983222784.000000
ITER 3: row=28, varin=18, theta=0.055172, up=999999999999999983222784.000000
ITER 4: row=31, varin=29, theta=0.006849, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=38)
DEBUG SOLUTION: LP solution array indices: FST[39-78], not_covered[79-98]
DEBUG SOLUTION: lp->best_solution[0] = 28295898.259224
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.952055
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 0.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.945205
  % @PL 38 rows, 60 cols, 253 nonzeros, 4 slack, 34 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % @PAP adding 5 rows, 14 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=35, varin=28, theta=1.615385, up=999999999999999983222784.000000
ITER 2: row=38, varin=66, theta=1.000000, up=1.000000
ITER 3: row=35, varin=35, theta=0.102041, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=39)
DEBUG SOLUTION: LP solution array indices: FST[40-79], not_covered[80-99]
DEBUG SOLUTION: lp->best_solution[0] = 28309008.543198
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 39 rows, 60 cols, 254 nonzeros, 5 slack, 34 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % @PAP adding 4 rows, 9 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=35, varin=27, theta=2.500000, up=999999999999999983222784.000000
ITER 2: row=37, varin=75, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=38)
DEBUG SOLUTION: LP solution array indices: FST[39-78], not_covered[79-98]
DEBUG SOLUTION: lp->best_solution[0] = 28327867.492204
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 38 rows, 60 cols, 241 nonzeros, 0 slack, 38 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=39, varin=43, theta=0.357143, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=39)
DEBUG SOLUTION: LP solution array indices: FST[40-79], not_covered[80-99]
DEBUG SOLUTION: lp->best_solution[0] = 28331490.883930
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 39 rows, 60 cols, 245 nonzeros, 1 slack, 38 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 3 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=39, varin=25, theta=0.666667, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=41)
DEBUG SOLUTION: LP solution array indices: FST[42-81], not_covered[82-101]
DEBUG SOLUTION: lp->best_solution[0] = 28333224.194839
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 41 rows, 60 cols, 241 nonzeros, 1 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 33 LP 1 Solution, length = 28333224.194839, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.166667 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.166667 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.166667 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 1.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 1.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.166667 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.166667 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.166667 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.833333 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.833333 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.833333 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.833333 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.833333 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.833333 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.833333 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28333224.194839, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 33 at  28.33322419483888765512
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7ca0600
% @LO 0.01  28.10583836678984681612 99.9000000000
% @LN 0.01  28.11372180445638946367 99.9000000000
% Resuming node 27 at  28.11372180445638946367
DEBUG CONSTRNT: LP rows=40, pool->nlprows=40, pool->npend=0
DEBUG CONSTRNT: Checking 40 LP rows (pool tracks 40, total LP rows 40)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 49
DEBUG CONSTRNT: Pool row 49 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 82
DEBUG CONSTRNT: Pool row 82 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=39, expected 39
 % @PAP adding 42 rows, 172 nz to LP
DEBUG BB: Processing node 27, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 27 LP 2 Solution, length = 28113721.804456, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.333333 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.333333 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.333333 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.333333 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.333333 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.666667 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.666667 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.666667 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.666667 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.666667 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.666667 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.666667 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28113721.804456, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28113721.804456, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 27 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 27
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.333333
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=1.000000
DEBUG CAREFUL: Skipping var 5: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.333333
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.333333
DEBUG CAREFUL: Adding var 11 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.333333
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.333333
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 11
DEBUG CAREFUL: Calling compare_branch_vars for var 11
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 11
DEBUG CAREFUL: New best var: 11
DEBUG CAREFUL: Testing fvar[1] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[2] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[3] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[4] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
  % Initial guess is x11, Z0 = 28113721.8044564        , Z1 = 28379387.827957         

DEBUG EVAL: Testing var 11 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=21, varin=39, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=39, varin=24, theta=2.000000, up=999999999999999983222784.000000
ITER 3: row=41, varin=58, theta=2.000000, up=1.000000
ITER 4: row=41, varin=57, theta=1.000000, up=1.000000
ITER 5: row=11, varin=36, theta=2.000000, up=999999999999999983222784.000000
ITER 6: row=36, varin=15, theta=2.000000, up=999999999999999983222784.000000
ITER 7: row=15, varin=33, theta=2.000000, up=999999999999999983222784.000000
ITER 8: row=12, varin=58, theta=1.000000, up=1.000000
ITER 9: row=33, varin=25, theta=1.000000, up=999999999999999983222784.000000
ITER 10: row=42, varin=29, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 11 = 1 gives z=28502169.278451
  % 	x11 = 1,	Z1 = 28502169.2784509        
DEBUG EVAL: First branch cutoff check: z=28502169.278451, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 11 = 0
ITER 1: row=21, varin=47, theta=0.500000, up=1.000000
  % 	x11 = 0,	Z0 = 28117215.1566125        
DEBUG EVAL: Second branch cutoff check: z=28117215.156613, best_z=INF, threshold=INF
  %   New best:  x11, Z = 28117215.1566125        
DEBUG EVAL: Testing var 10 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=14, varin=40, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 1 gives z=28131461.781422
  % 	x10 = 1,	Z1 = 28131461.7814224        
DEBUG EVAL: First branch cutoff check: z=28131461.781422, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 0
ITER 1: row=14, varin=47, theta=0.500000, up=1.000000
  % 	x10 = 0,	Z0 = 28117215.1566125        
DEBUG EVAL: Second branch cutoff check: z=28117215.156613, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 17 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=23, varin=40, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 17 = 1 gives z=28131461.781422
  % 	x17 = 1,	Z1 = 28131461.7814224        
DEBUG EVAL: First branch cutoff check: z=28131461.781422, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 17 = 0
ITER 1: row=23, varin=47, theta=0.500000, up=1.000000
  % 	x17 = 0,	Z0 = 28117215.1566125        
DEBUG EVAL: Second branch cutoff check: z=28117215.156613, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 2 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=47, theta=0.500000, up=1.000000
DEBUG EVAL: Branch var 2 = 0 gives z=28117215.156613
  % 	x2 = 0,	Z0 = 28117215.1566125        
DEBUG EVAL: First branch cutoff check: z=28117215.156613, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 1
ITER 1: row=1, varin=40, theta=1.000000, up=999999999999999983222784.000000
  % 	x2 = 1,	Z1 = 28131461.7814224        
DEBUG EVAL: Second branch cutoff check: z=28131461.781422, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 26 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=33, varin=47, theta=0.500000, up=1.000000
DEBUG EVAL: Branch var 26 = 0 gives z=28117215.156613
  % 	x26 = 0,	Z0 = 28117215.1566125        
DEBUG EVAL: First branch cutoff check: z=28117215.156613, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 26 = 1
ITER 1: row=33, varin=40, theta=1.000000, up=999999999999999983222784.000000
  % 	x26 = 1,	Z1 = 28131461.7814224        
DEBUG EVAL: Second branch cutoff check: z=28131461.781422, best_z=INF, threshold=INF
  % Best branch is x11, Z0 = 28117215.1566125        , Z1 = 28502169.2784509        

DEBUG CAREFUL: Final result - returning best.var = 11
DEBUG BB: Branching variable chosen: j=11
 % @NC   39   27	x11 = 0	28117215.156613
 % @NC   40   27	x11 = 1	28502169.278451
 %      27    20 28113721.8045               28117215.1566    x3 D    19     6
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cae7d0
% @LO 0.01  28.11372180445638946367 99.9000000000
% @LN 0.01  28.11721515661251302731 99.9000000000
% Resuming node 39 at  28.11721515661251302731
DEBUG CONSTRNT: LP rows=42, pool->nlprows=42, pool->npend=0
DEBUG CONSTRNT: Checking 42 LP rows (pool tracks 42, total LP rows 42)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=41, expected 41
 % @PAP adding 42 rows, 172 nz to LP
DEBUG BB: Processing node 39, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=21, varin=47, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 28117215.156613
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 42 rows, 60 cols, 232 nonzeros, 0 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 6 rows, 33 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=43, varin=40, theta=0.333333, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 28121964.031549
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 48 rows, 60 cols, 265 nonzeros, 6 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 6 slack rows
  % Node 39 LP 1 Solution, length = 28121964.031549, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.333333 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.333333 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.333333 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.333333 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.333333 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.666667 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.666667 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.666667 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.666667 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.666667 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.666667 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.666667 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28121964.031549, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 39 at  28.12196403154915458344
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cc24b0
% @LO 0.01  28.11721515661251302731 99.9000000000
% @LN 0.01  28.11821906673902660145 99.9000000000
% Resuming node 12 at  28.11821906673902660145
DEBUG CONSTRNT: LP rows=42, pool->nlprows=42, pool->npend=0
DEBUG CONSTRNT: Checking 42 LP rows (pool tracks 42, total LP rows 42)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=41, expected 41
 % @PAP adding 42 rows, 199 nz to LP
DEBUG BB: Processing node 12, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=7, varin=39, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=2, varin=33, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=31, varin=2, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=39, varin=30, theta=0.588235, up=999999999999999983222784.000000
ITER 5: row=33, varin=28, theta=2.000000, up=999999999999999983222784.000000
ITER 6: row=27, varin=53, theta=2.000000, up=1.000000
ITER 7: row=27, varin=26, theta=0.428571, up=999999999999999983222784.000000
ITER 8: row=1, varin=44, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=8)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 28118219.066739
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 42 rows, 60 cols, 259 nonzeros, 8 slack, 34 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 6 rows, 29 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=43, varin=7, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=45, varin=10, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=42, varin=51, theta=0.642857, up=1.000000
ITER 4: row=47, varin=63, theta=1.000000, up=1.000000
ITER 5: row=44, varin=11, theta=0.100000, up=999999999999999983222784.000000
ITER 6: row=42, varin=42, theta=2.800000, up=999999999999999983222784.000000
ITER 7: row=48, varin=44, theta=0.666667, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=7)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 28168690.898352
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 0.833333
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.833333
DEBUG SOLUTION: lp->best_solution[11] = 0.833333
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.166667
  % @PL 48 rows, 60 cols, 288 nonzeros, 15 slack, 33 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 15 slack rows
  % @PAP adding 4 rows, 12 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=35, varin=33, theta=5.000000, up=999999999999999983222784.000000
ITER 2: row=1, varin=40, theta=1.285714, up=1.000000
ITER 3: row=1, varin=7, theta=0.222222, up=999999999999999983222784.000000
ITER 4: row=21, varin=40, theta=1.000000, up=1.000000
ITER 5: row=35, varin=48, theta=0.333333, up=1.000000
ITER 6: row=34, varin=33, theta=2.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=37)
DEBUG SOLUTION: LP solution array indices: FST[38-77], not_covered[78-97]
DEBUG SOLUTION: lp->best_solution[0] = 28200061.122936
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 0.500000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 37 rows, 60 cols, 240 nonzeros, 3 slack, 34 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % Node 12 LP 1 Solution, length = 28200061.122936, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.500000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.500000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.500000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.500000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.500000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 2 fractional variables
DEBUG CG: LP optimal, z=28200061.122936, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 12 at  28.20006112293601674423
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cae7d0
% @LO 0.01  28.11821906673902660145 99.9000000000
% @LN 0.01  28.12196403154915458344 99.9000000000
% Resuming node 39 at  28.12196403154915458344
DEBUG CONSTRNT: LP rows=34, pool->nlprows=34, pool->npend=0
DEBUG CONSTRNT: Checking 34 LP rows (pool tracks 34, total LP rows 34)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=33, expected 33
 % @PAP adding 42 rows, 172 nz to LP
DEBUG BB: Processing node 39, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 39 LP 2 Solution, length = 28121964.031549, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.333333 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.333333 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.333333 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.333333 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.333333 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.666667 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.666667 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.666667 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.666667 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.666667 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.666667 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.666667 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28121964.031549, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28121964.031549, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 39 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 39
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.333333
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.333333
DEBUG CAREFUL: Adding var 4 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=1.000000
DEBUG CAREFUL: Skipping var 5: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.333333
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.333333
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.333333
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 4
DEBUG CAREFUL: Calling compare_branch_vars for var 4
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 4
DEBUG CAREFUL: New best var: 4
DEBUG CAREFUL: Testing fvar[1] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[2] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[3] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[4] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
  % Initial guess is x4, Z0 = 28121964.0315492        , Z1 = 28404114.5092353        

DEBUG EVAL: Testing var 4 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=21, varin=39, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=39, varin=58, theta=2.000000, up=1.000000
ITER 3: row=39, varin=57, theta=1.000000, up=1.000000
ITER 4: row=11, varin=36, theta=2.000000, up=999999999999999983222784.000000
ITER 5: row=36, varin=15, theta=2.000000, up=999999999999999983222784.000000
ITER 6: row=15, varin=23, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=41, varin=33, theta=2.000000, up=999999999999999983222784.000000
ITER 8: row=12, varin=58, theta=1.000000, up=1.000000
ITER 9: row=33, varin=24, theta=1.000000, up=999999999999999983222784.000000
ITER 10: row=42, varin=29, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 4 = 1 gives z=28526895.959729
  % 	x4 = 1,	Z1 = 28526895.9597292        
DEBUG EVAL: First branch cutoff check: z=28526895.959729, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 4 = 0
ITER 1: row=21, varin=40, theta=1.000000, up=999999999999999983222784.000000
  % 	x4 = 0,	Z0 = 28131461.7814224        
DEBUG EVAL: Second branch cutoff check: z=28131461.781422, best_z=INF, threshold=INF
  %   New best:  x4, Z = 28131461.7814224        
DEBUG EVAL: Testing var 10 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=14, varin=40, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 1 gives z=28131461.781422
  % 	x10 = 1,	Z1 = 28131461.7814224        
DEBUG EVAL: First branch cutoff check: z=28131461.781422, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 0
ITER 1: row=14, varin=72, theta=1.000000, up=1.000000
ITER 2: row=32, varin=44, theta=0.333333, up=1.000000
ITER 3: row=38, varin=70, theta=1.000000, up=1.000000
  % 	x10 = 0,	Z0 = 28166907.5218577        
DEBUG EVAL: Second branch cutoff check: z=28166907.521858, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 17 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=23, varin=40, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 17 = 1 gives z=28131461.781422
  % 	x17 = 1,	Z1 = 28131461.7814224        
DEBUG EVAL: First branch cutoff check: z=28131461.781422, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 17 = 0
ITER 1: row=23, varin=72, theta=1.000000, up=1.000000
ITER 2: row=32, varin=44, theta=0.333333, up=1.000000
ITER 3: row=38, varin=70, theta=1.000000, up=1.000000
  % 	x17 = 0,	Z0 = 28166907.5218577        
DEBUG EVAL: Second branch cutoff check: z=28166907.521858, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 2 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=40, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 1 gives z=28131461.781422
  % 	x2 = 1,	Z1 = 28131461.7814224        
DEBUG EVAL: First branch cutoff check: z=28131461.781422, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 0
ITER 1: row=1, varin=72, theta=1.000000, up=1.000000
ITER 2: row=32, varin=44, theta=0.333333, up=1.000000
ITER 3: row=38, varin=70, theta=1.000000, up=1.000000
  % 	x2 = 0,	Z0 = 28166907.5218577        
DEBUG EVAL: Second branch cutoff check: z=28166907.521858, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 26 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=33, varin=40, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 26 = 1 gives z=28131461.781422
  % 	x26 = 1,	Z1 = 28131461.7814224        
DEBUG EVAL: First branch cutoff check: z=28131461.781422, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 26 = 0
ITER 1: row=33, varin=72, theta=1.000000, up=1.000000
ITER 2: row=32, varin=44, theta=0.333333, up=1.000000
ITER 3: row=38, varin=70, theta=1.000000, up=1.000000
  % 	x26 = 0,	Z0 = 28166907.5218577        
DEBUG EVAL: Second branch cutoff check: z=28166907.521858, best_z=INF, threshold=INF
  % Best branch is x4, Z0 = 28131461.7814224        , Z1 = 28526895.9597292        

DEBUG CAREFUL: Final result - returning best.var = 4
DEBUG BB: Branching variable chosen: j=4
 % @NC   41   39	x4 = 0	28131461.781422
 % @NC   42   39	x4 = 1	28526895.959729
 %      39    21 28121964.0315               28122660.0888   x11 D    27     7
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cb66c0
% @LO 0.01  28.12196403154915458344 99.9000000000
% @LN 0.01  28.12266008875386802401 99.9000000000
% Resuming node 37 at  28.12266008875386802401
DEBUG CONSTRNT: LP rows=42, pool->nlprows=42, pool->npend=0
DEBUG CONSTRNT: Checking 42 LP rows (pool tracks 42, total LP rows 42)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=41, expected 41
 % @PAP adding 40 rows, 170 nz to LP
DEBUG BB: Processing node 37, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 37 LP 2 Solution, length = 28122660.088754, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.500000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.500000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.500000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.500000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.500000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.500000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.500000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.500000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.500000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.500000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.500000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.500000 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28122660.088754, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28122660.088754, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 37 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 37
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.500000
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=1.000000
DEBUG CAREFUL: Skipping var 7: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.500000
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.500000
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.500000
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.500000
DEBUG CAREFUL: Adding var 27 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 27
DEBUG CAREFUL: Calling compare_branch_vars for var 27
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 27
DEBUG CAREFUL: New best var: 27
DEBUG CAREFUL: Testing fvar[1] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[2] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[3] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[4] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
  % Initial guess is x27, Z0 = 28122660.0887539        , Z1 = 28140382.9589715        

DEBUG EVAL: Testing var 27 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=32, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=32, varin=40, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 27 = 1 gives z=28140382.958971
  % 	x27 = 1,	Z1 = 28140382.9589715        
DEBUG EVAL: First branch cutoff check: z=28140382.958971, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 27 = 0
ITER 1: row=1, varin=37, theta=0.333333, up=999999999999999983222784.000000
  % 	x27 = 0,	Z0 = 28124928.4713945        
DEBUG EVAL: Second branch cutoff check: z=28124928.471394, best_z=INF, threshold=INF
  %   New best:  x27, Z = 28124928.4713945        
DEBUG EVAL: Testing var 17 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=26, varin=19, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 17 = 1 gives z=28227493.887988
  % 	x17 = 1,	Z1 = 28227493.8879881        
DEBUG EVAL: First branch cutoff check: z=28227493.887988, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 17 = 0
ITER 1: row=26, varin=40, theta=1.000000, up=999999999999999983222784.000000
  % 	x17 = 0,	Z0 = 28140382.9589715        
DEBUG EVAL: Second branch cutoff check: z=28140382.958971, best_z=INF, threshold=INF
  %   New best:  x17, Z = 28140382.9589715        
DEBUG EVAL: Testing var 10 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=18, varin=33, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 1 gives z=28313968.801762
  % 	x10 = 1,	Z1 = 28313968.8017619        
DEBUG EVAL: First branch cutoff check: z=28313968.801762, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 0
ITER 1: row=18, varin=40, theta=1.000000, up=999999999999999983222784.000000
  % 	x10 = 0,	Z0 = 28140382.9589715        
DEBUG EVAL: Second branch cutoff check: z=28140382.958971, best_z=INF, threshold=INF
  %   New best:  x10, Z = 28140382.9589715        
DEBUG EVAL: Testing var 2 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=22, varin=24, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 1 gives z=28140546.617230
  % 	x2 = 1,	Z1 = 28140546.6172304        
DEBUG EVAL: First branch cutoff check: z=28140546.617230, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 0
ITER 1: row=22, varin=40, theta=1.000000, up=999999999999999983222784.000000
  % 	x2 = 0,	Z0 = 28140382.9589715        
DEBUG EVAL: Second branch cutoff check: z=28140382.958971, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 26 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=33, varin=18, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=35, varin=19, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 26 = 1 gives z=28513753.570543
  % 	x26 = 1,	Z1 = 28513753.5705435        
DEBUG EVAL: First branch cutoff check: z=28513753.570543, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 26 = 0
ITER 1: row=33, varin=40, theta=1.000000, up=999999999999999983222784.000000
  % 	x26 = 0,	Z0 = 28140382.9589715        
DEBUG EVAL: Second branch cutoff check: z=28140382.958971, best_z=INF, threshold=INF
  %   New best:  x26, Z = 28140382.9589715        
  % Best branch is x26, Z0 = 28140382.9589715        , Z1 = 28513753.5705435        

DEBUG CAREFUL: Final result - returning best.var = 26
DEBUG BB: Branching variable chosen: j=26
 % @NC   43   37	x26 = 0	28140382.958971
 % @NC   44   37	x26 = 1	28513753.570543
 %      37    22 28122660.0888               28131461.7814    x4 D    35     7
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7ca0600
% @LO 0.01  28.12266008875386802401 99.9000000000
% @LN 0.01  28.13146178142243414300 99.9000000000
% Resuming node 41 at  28.13146178142243414300
DEBUG CONSTRNT: LP rows=40, pool->nlprows=40, pool->npend=0
DEBUG CONSTRNT: Checking 40 LP rows (pool tracks 40, total LP rows 40)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 158
DEBUG CONSTRNT: Pool row 158 has lprow=39, expected 39
 % @PAP adding 42 rows, 172 nz to LP
DEBUG BB: Processing node 41, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=21, varin=40, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 28131461.781422
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 42 rows, 60 cols, 232 nonzeros, 3 slack, 39 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 42 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=44, varin=74, theta=0.440127, up=1.000000
ITER 2: row=32, varin=46, theta=0.177612, up=1.000000
ITER 3: row=38, varin=36, theta=0.176886, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
ITER 4: row=43, varin=72, theta=0.143037, up=1.000000
ITER 5: row=4, varin=44, theta=81817.000000, up=999999999999999983222784.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28149184.651640
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 44 rows, 60 cols, 274 nonzeros, 4 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=54, theta=4.333333, up=1.000000
ITER 2: row=1, varin=57, theta=3.333333, up=1.000000
ITER 3: row=1, varin=56, theta=2.333333, up=1.000000
ITER 4: row=1, varin=55, theta=1.333333, up=1.000000
ITER 5: row=1, varin=49, theta=0.500000, up=1.000000
ITER 6: row=20, varin=51, theta=3.500000, up=1.000000
ITER 7: row=20, varin=42, theta=2.500000, up=1.000000
ITER 8: row=20, varin=81, theta=3.000000, up=1.000000
ITER 9: row=20, varin=82, theta=2.000000, up=1.000000
ITER 10: row=20, varin=83, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=61)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=40)
DEBUG SOLUTION: LP solution array indices: FST[41-80], not_covered[81-100]
DEBUG SOLUTION: lp->best_solution[0] = 28149184.651640
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 40 rows, 60 cols, 228 nonzeros, 0 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 41 LP 1 Solution, length = 28149184.651640, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.500000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.500000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.500000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.500000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.500000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.500000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.500000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.500000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.500000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.500000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.500000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.500000 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28149184.651640, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 41 at  28.14918465164005922929
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7ccbbd0
% @LO 0.01  28.13146178142243414300 99.9000000000
% @LN 0.01  28.13486493067039617699 99.9000000000
% Resuming node 32 at  28.13486493067039617699
DEBUG CONSTRNT: LP rows=40, pool->nlprows=40, pool->npend=0
DEBUG CONSTRNT: Checking 40 LP rows (pool tracks 40, total LP rows 40)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 158
DEBUG CONSTRNT: Pool row 158 has lprow=39, expected 39
 % @PAP adding 31 rows, 183 nz to LP
DEBUG BB: Processing node 32, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 32 LP 2 Solution, length = 28134864.930670, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.063123 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.343854 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.343854 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.343854 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.656146 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 1.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.343854 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.936877 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.936877 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.343854 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.343854 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.936877 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.343854 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.656146 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.656146 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28134864.930670, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28134864.930670, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 3 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 32 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 32
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.063123
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.063123)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.343854
DEBUG CAREFUL: Adding var 7 to fractional list (xi=0.343854)
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.343854
DEBUG CAREFUL: Adding var 12 to fractional list (xi=0.343854)
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.343854
DEBUG CAREFUL: Adding var 15 to fractional list (xi=0.343854)
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.656146
DEBUG CAREFUL: Adding var 16 to fractional list (xi=0.656146)
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=1.000000
DEBUG CAREFUL: Skipping var 20: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 15
DEBUG CAREFUL: Calling compare_branch_vars for var 15
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 15
DEBUG CAREFUL: New best var: 15
DEBUG CAREFUL: Testing fvar[1] = var 7
DEBUG CAREFUL: Calling compare_branch_vars for var 7
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 7
DEBUG CAREFUL: Testing fvar[2] = var 16
DEBUG CAREFUL: Calling compare_branch_vars for var 16
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 16
DEBUG CAREFUL: Testing fvar[3] = var 12
DEBUG CAREFUL: Calling compare_branch_vars for var 12
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 12
DEBUG CAREFUL: Testing fvar[4] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 1
  % Initial guess is x15, Z0 = 28134864.9306704        , Z1 = 28169816.4201466        

DEBUG EVAL: Testing var 15 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
DEBUG EVAL: Branch var 15 = 1 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x15 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=12, varin=27, theta=1.659211, up=999999999999999983222784.000000
ITER 2: row=23, varin=46, theta=0.358126, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=31)
DEBUG SOLUTION: LP solution array indices: FST[32-71], not_covered[72-91]
DEBUG SOLUTION: lp->best_solution[0] = 28146225.505463
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 31 rows, 60 cols, 243 nonzeros, 0 slack, 31 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @PAP adding 4 rows, 17 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=32, varin=18, theta=0.420128, up=999999999999999983222784.000000
ITER 2: row=34, varin=26, theta=0.388978, up=999999999999999983222784.000000
ITER 3: row=8, varin=7, theta=0.068763, up=999999999999999983222784.000000
ITER 4: row=10, varin=24, theta=0.320079, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=35)
DEBUG SOLUTION: LP solution array indices: FST[36-75], not_covered[76-95]
DEBUG SOLUTION: lp->best_solution[0] = 28161342.105685
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 35 rows, 60 cols, 260 nonzeros, 6 slack, 29 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 6 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 32 at  28.16134210568468532188
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cc9ac0
% @LO 0.01  28.13486493067039617699 99.9000000000
% @LN 0.01  28.13936896067523107945 99.9000000000
% Resuming node 30 at  28.13936896067523107945
DEBUG CONSTRNT: LP rows=29, pool->nlprows=29, pool->npend=0
DEBUG CONSTRNT: Checking 29 LP rows (pool tracks 29, total LP rows 29)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 49
DEBUG CONSTRNT: Pool row 49 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 68
DEBUG CONSTRNT: Pool row 68 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 82
DEBUG CONSTRNT: Pool row 82 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=28, expected 28
 % @PAP adding 43 rows, 184 nz to LP
DEBUG BB: Processing node 30, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 30 LP 2 Solution, length = 28139368.960675, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.500000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.500000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.500000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.500000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.500000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.500000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.500000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.500000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.500000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.500000 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28139368.960675, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28139368.960675, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 30 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 30
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.500000
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.500000
DEBUG CAREFUL: Adding var 9 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.500000
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.500000
DEBUG CAREFUL: Adding var 27 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.500000
DEBUG CAREFUL: Adding var 34 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 9
DEBUG CAREFUL: Calling compare_branch_vars for var 9
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 9
DEBUG CAREFUL: New best var: 9
DEBUG CAREFUL: Testing fvar[1] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[2] = var 27
DEBUG CAREFUL: Calling compare_branch_vars for var 27
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 27
DEBUG CAREFUL: New best var: 27
DEBUG CAREFUL: Testing fvar[3] = var 34
DEBUG CAREFUL: Calling compare_branch_vars for var 34
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 34
DEBUG CAREFUL: Testing fvar[4] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
  % Initial guess is x27, Z0 = 28139368.9606752        , Z1 = 28214728.6170056        

DEBUG EVAL: Testing var 9 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=17, varin=60, theta=1.000000, up=1.000000
ITER 2: row=13, varin=27, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 9 = 0 gives z=28254707.559040
  % 	x9 = 0,	Z0 = 28254707.5590403        
DEBUG EVAL: First branch cutoff check: z=28254707.559040, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 9 = 1
ITER 1: row=17, varin=31, theta=1.000000, up=999999999999999983222784.000000
  % 	x9 = 1,	Z1 = 28249646.3025014        
DEBUG EVAL: Second branch cutoff check: z=28249646.302501, best_z=INF, threshold=INF
  %   New best:  x9, Z = 28249646.3025014        
DEBUG EVAL: Testing var 10 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=14, varin=14, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 0 gives z=28157409.838514
  % 	x10 = 0,	Z0 = 28157409.8385142        
DEBUG EVAL: First branch cutoff check: z=28157409.838514, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 27 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=19, varin=42, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=42, varin=41, theta=0.250000, up=999999999999999983222784.000000
ITER 3: row=26, varin=38, theta=0.250000, up=999999999999999983222784.000000
ITER 4: row=38, varin=33, theta=0.166667, up=999999999999999983222784.000000
ITER 5: row=37, varin=60, theta=1.000000, up=1.000000
ITER 6: row=13, varin=36, theta=0.181818, up=999999999999999983222784.000000
ITER 7: row=36, varin=34, theta=0.250000, up=999999999999999983222784.000000
ITER 8: row=34, varin=3, theta=0.500000, up=999999999999999983222784.000000
ITER 9: row=41, varin=29, theta=0.500000, up=999999999999999983222784.000000
ITER 10: row=29, varin=32, theta=0.227273, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 27 = 1 gives z=28249646.302501
  % 	x27 = 1,	Z1 = 28249646.3025014        
DEBUG EVAL: First branch cutoff check: z=28249646.302501, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 27 = 0
ITER 1: row=19, varin=22, theta=0.125000, up=999999999999999983222784.000000
  % 	x27 = 0,	Z0 = 28140613.1089864        
DEBUG EVAL: Second branch cutoff check: z=28140613.108986, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 34 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=27, varin=60, theta=1.000000, up=1.000000
ITER 2: row=13, varin=31, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 34 = 0 gives z=28249646.302501
  % 	x34 = 0,	Z0 = 28249646.3025014        
DEBUG EVAL: First branch cutoff check: z=28249646.302501, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 34 = 1
ITER 1: row=27, varin=19, theta=1.000000, up=999999999999999983222784.000000
  % 	x34 = 1,	Z1 = 28437599.2721313        
DEBUG EVAL: Second branch cutoff check: z=28437599.272131, best_z=INF, threshold=INF
  %   New best:  x34, Z = 28249646.3025014        
DEBUG EVAL: Testing var 2 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=22, theta=0.125000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 0 gives z=28140613.108986
  % 	x2 = 0,	Z0 = 28140613.1089864        
DEBUG EVAL: First branch cutoff check: z=28140613.108986, best_z=INF, threshold=INF
  % Best branch is x34, Z0 = 28249646.3025014        , Z1 = 28437599.2721313        

DEBUG CAREFUL: Final result - returning best.var = 34
DEBUG BB: Branching variable chosen: j=34
 % @NC   45   30	x34 = 0	28249646.302501
 % @NC   46   30	x34 = 1	28437599.272131
 %      30    23 28139368.9607               28140382.9590   x17 D    25     9
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cae7d0
% @LO 0.01  28.13936896067523107945 99.9000000000
% @LN 0.01  28.14038295897149311031 99.9000000000
% Resuming node 43 at  28.14038295897149311031
DEBUG CONSTRNT: LP rows=43, pool->nlprows=43, pool->npend=0
DEBUG CONSTRNT: Checking 43 LP rows (pool tracks 43, total LP rows 43)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=42, expected 42
 % @PAP adding 40 rows, 170 nz to LP
DEBUG BB: Processing node 43, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=33, varin=40, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=40)
DEBUG SOLUTION: LP solution array indices: FST[41-80], not_covered[81-100]
DEBUG SOLUTION: lp->best_solution[0] = 28140382.958971
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 40 rows, 60 cols, 230 nonzeros, 1 slack, 39 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=41, varin=37, theta=0.666667, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 28144919.724253
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 42 rows, 60 cols, 236 nonzeros, 4 slack, 38 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % @PAP adding 4 rows, 9 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=39, varin=24, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 28176156.015924
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 42 rows, 60 cols, 232 nonzeros, 3 slack, 39 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=40, varin=73, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=40)
DEBUG SOLUTION: LP solution array indices: FST[41-80], not_covered[81-100]
DEBUG SOLUTION: lp->best_solution[0] = 28190937.018029
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 40 rows, 60 cols, 226 nonzeros, 0 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 7 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=41, varin=64, theta=0.500000, up=1.000000
ITER 2: row=13, varin=30, theta=0.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 28194384.246138
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 42 rows, 60 cols, 233 nonzeros, 2 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % Node 43 LP 1 Solution, length = 28194384.246138, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.250000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.250000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.500000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.500000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.250000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.250000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.750000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.750000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.750000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.500000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.750000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.500000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28194384.246138, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 43 at  28.19438424613762705917
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cbfd10
% @LO 0.01  28.14038295897149311031 99.9000000000
% @LN 0.01  28.14474362962521070131 99.9000000000
% Resuming node 14 at  28.14474362962521070131
DEBUG CONSTRNT: LP rows=40, pool->nlprows=40, pool->npend=0
DEBUG CONSTRNT: Checking 40 LP rows (pool tracks 40, total LP rows 40)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 133
DEBUG CONSTRNT: Pool row 133 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=39, expected 39
 % @PAP adding 42 rows, 197 nz to LP
DEBUG BB: Processing node 14, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=7, varin=39, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=2, varin=33, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=31, varin=2, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=39, varin=30, theta=0.588235, up=999999999999999983222784.000000
ITER 5: row=33, varin=28, theta=2.000000, up=999999999999999983222784.000000
ITER 6: row=27, varin=53, theta=2.000000, up=1.000000
ITER 7: row=27, varin=26, theta=0.428571, up=999999999999999983222784.000000
ITER 8: row=1, varin=44, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=8)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 28144743.629625
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 42 rows, 60 cols, 257 nonzeros, 8 slack, 34 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 6 rows, 32 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=43, varin=8, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=45, varin=10, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=42, varin=51, theta=0.642857, up=1.000000
ITER 4: row=47, varin=63, theta=1.000000, up=1.000000
ITER 5: row=44, varin=11, theta=0.076923, up=999999999999999983222784.000000
ITER 6: row=48, varin=44, theta=1.166667, up=999999999999999983222784.000000
ITER 7: row=42, varin=42, theta=2.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=7)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 28195215.461239
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.833333
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.833333
DEBUG SOLUTION: lp->best_solution[11] = 0.833333
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.166667
  % @PL 48 rows, 60 cols, 289 nonzeros, 15 slack, 33 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 15 slack rows
  % @PAP adding 4 rows, 12 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=34, varin=33, theta=5.000000, up=999999999999999983222784.000000
ITER 2: row=1, varin=40, theta=1.285714, up=1.000000
ITER 3: row=1, varin=7, theta=0.222222, up=999999999999999983222784.000000
ITER 4: row=21, varin=40, theta=1.000000, up=1.000000
ITER 5: row=34, varin=48, theta=0.333333, up=1.000000
ITER 6: row=36, varin=33, theta=2.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=37)
DEBUG SOLUTION: LP solution array indices: FST[38-77], not_covered[78-97]
DEBUG SOLUTION: lp->best_solution[0] = 28226585.685822
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 0.500000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 37 rows, 60 cols, 238 nonzeros, 3 slack, 34 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % Node 14 LP 1 Solution, length = 28226585.685822, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.500000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.500000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.500000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.500000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.500000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 2 fractional variables
DEBUG CG: LP optimal, z=28226585.685822, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 14 at  28.22658568582220439680
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cad710
% @LO 0.01  28.14474362962521070131 99.9000000000
% @LN 0.01  28.14502129669888574881 99.9000000000
% Resuming node 34 at  28.14502129669888574881
DEBUG CONSTRNT: LP rows=34, pool->nlprows=34, pool->npend=0
DEBUG CONSTRNT: Checking 34 LP rows (pool tracks 34, total LP rows 34)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=33, expected 33
 % @PAP adding 37 rows, 186 nz to LP
DEBUG BB: Processing node 34, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=22, varin=38, theta=0.500000, up=1.000000
ITER 2: row=2, varin=81, theta=0.500000, up=1.000000
ITER 3: row=34, varin=79, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=37)
DEBUG SOLUTION: LP solution array indices: FST[38-77], not_covered[78-97]
DEBUG SOLUTION: lp->best_solution[0] = 28145021.296699
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 37 rows, 60 cols, 246 nonzeros, 3 slack, 34 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 15 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=38, varin=60, theta=0.333333, up=1.000000
ITER 2: row=35, varin=17, theta=0.052632, up=999999999999999983222784.000000
ITER 3: row=37, varin=94, theta=0.048276, up=1.000000
ITER 4: row=33, varin=21, theta=0.055172, up=999999999999999983222784.000000
ITER 5: row=36, varin=34, theta=0.006849, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=41)
DEBUG SOLUTION: LP solution array indices: FST[42-81], not_covered[82-101]
DEBUG SOLUTION: lp->best_solution[0] = 28165008.333052
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.952055
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 41 rows, 60 cols, 261 nonzeros, 4 slack, 37 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % @PAP adding 5 rows, 14 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=38, varin=33, theta=1.615385, up=999999999999999983222784.000000
ITER 2: row=41, varin=69, theta=1.000000, up=1.000000
ITER 3: row=38, varin=38, theta=0.102041, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 28178118.617026
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 42 rows, 60 cols, 262 nonzeros, 5 slack, 37 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % @PAP adding 4 rows, 9 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=38, varin=32, theta=2.500000, up=999999999999999983222784.000000
ITER 2: row=40, varin=78, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=41)
DEBUG SOLUTION: LP solution array indices: FST[42-81], not_covered[82-101]
DEBUG SOLUTION: lp->best_solution[0] = 28196977.566032
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 41 rows, 60 cols, 249 nonzeros, 0 slack, 41 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=42, varin=47, theta=0.357143, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 28200600.957758
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 43 rows, 60 cols, 257 nonzeros, 1 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 3 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=43, varin=30, theta=0.666667, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 28202334.268667
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 45 rows, 60 cols, 253 nonzeros, 1 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 34 LP 1 Solution, length = 28202334.268667, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.166667 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.166667 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.166667 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 1.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 1.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.166667 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.166667 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.166667 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.833333 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.833333 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.833333 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.833333 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.833333 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.833333 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.833333 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28202334.268667, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 34 at  28.20233426866689185886
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7ca0600
% @LO 0.03  28.14502129669888574881 99.9000000000
% @LN 0.03  28.14918465164005922929 99.9000000000
% Resuming node 41 at  28.14918465164005922929
DEBUG CONSTRNT: LP rows=44, pool->nlprows=44, pool->npend=0
DEBUG CONSTRNT: Checking 44 LP rows (pool tracks 44, total LP rows 44)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=43, expected 43
 % @PAP adding 40 rows, 168 nz to LP
DEBUG BB: Processing node 41, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 41 LP 2 Solution, length = 28149184.651640, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.500000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.500000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.500000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.500000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.500000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.500000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.500000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.500000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.500000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.500000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.500000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.500000 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28149184.651640, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28149184.651640, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 41 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 41
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.500000
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=1.000000
DEBUG CAREFUL: Skipping var 5: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.500000
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.500000
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.500000
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.500000
DEBUG CAREFUL: Adding var 27 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 27
DEBUG CAREFUL: Calling compare_branch_vars for var 27
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 27
DEBUG CAREFUL: New best var: 27
DEBUG CAREFUL: Testing fvar[1] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[2] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[3] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[4] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
  % Initial guess is x27, Z0 = 28149184.6516401        , Z1 = 28166907.5218577        

DEBUG EVAL: Testing var 27 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=32, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=32, varin=40, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 27 = 1 gives z=28166907.521858
  % 	x27 = 1,	Z1 = 28166907.5218577        
DEBUG EVAL: First branch cutoff check: z=28166907.521858, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 27 = 0
ITER 1: row=1, varin=42, theta=0.166667, up=1.000000
  % 	x27 = 0,	Z0 = 28151453.0342807        
DEBUG EVAL: Second branch cutoff check: z=28151453.034281, best_z=INF, threshold=INF
  %   New best:  x27, Z = 28151453.0342807        
DEBUG EVAL: Testing var 10 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=17, varin=35, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=16, varin=34, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 1 gives z=28340493.364648
  % 	x10 = 1,	Z1 = 28340493.364648         
DEBUG EVAL: First branch cutoff check: z=28340493.364648, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 0
ITER 1: row=17, varin=40, theta=1.000000, up=999999999999999983222784.000000
  % 	x10 = 0,	Z0 = 28166907.5218577        
DEBUG EVAL: Second branch cutoff check: z=28166907.521858, best_z=INF, threshold=INF
  %   New best:  x10, Z = 28166907.5218577        
DEBUG EVAL: Testing var 17 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=26, varin=35, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=16, varin=17, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 17 = 1 gives z=28254018.450874
  % 	x17 = 1,	Z1 = 28254018.4508743        
DEBUG EVAL: First branch cutoff check: z=28254018.450874, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 17 = 0
ITER 1: row=26, varin=40, theta=1.000000, up=999999999999999983222784.000000
  % 	x17 = 0,	Z0 = 28166907.5218577        
DEBUG EVAL: Second branch cutoff check: z=28166907.521858, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 2 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=22, varin=35, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=16, varin=24, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 1 gives z=28167071.180117
  % 	x2 = 1,	Z1 = 28167071.1801165        
DEBUG EVAL: First branch cutoff check: z=28167071.180117, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 0
ITER 1: row=22, varin=40, theta=1.000000, up=999999999999999983222784.000000
  % 	x2 = 0,	Z0 = 28166907.5218577        
DEBUG EVAL: Second branch cutoff check: z=28166907.521858, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 26 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=35, varin=17, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=33, varin=34, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 26 = 1 gives z=28540278.133430
  % 	x26 = 1,	Z1 = 28540278.1334297        
DEBUG EVAL: First branch cutoff check: z=28540278.133430, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 26 = 0
ITER 1: row=35, varin=35, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=16, varin=40, theta=1.000000, up=999999999999999983222784.000000
  % 	x26 = 0,	Z0 = 28166907.5218577        
DEBUG EVAL: Second branch cutoff check: z=28166907.521858, best_z=INF, threshold=INF
  %   New best:  x26, Z = 28166907.5218577        
  % Best branch is x26, Z0 = 28166907.5218577        , Z1 = 28540278.1334297        

DEBUG CAREFUL: Final result - returning best.var = 26
DEBUG BB: Branching variable chosen: j=26
 % @NC   47   41	x26 = 0	28166907.521858
 % @NC   48   41	x26 = 1	28540278.133430
 %      41    24 28149184.6516               28161342.1057    x4 D    39     8
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7ccbbd0
% @LO 0.03  28.14918465164005922929 99.9000000000
% @LN 0.03  28.16134210568468532188 99.9000000000
% Resuming node 32 at  28.16134210568468532188
DEBUG CONSTRNT: LP rows=40, pool->nlprows=40, pool->npend=0
DEBUG CONSTRNT: Checking 40 LP rows (pool tracks 40, total LP rows 40)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 158
DEBUG CONSTRNT: Pool row 158 has lprow=39, expected 39
 % @PAP adding 29 rows, 179 nz to LP
DEBUG BB: Processing node 32, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 32 LP 3 Solution, length = 28161342.105685, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.464016 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.143937 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.464016 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.535984 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 1.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.464016 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.464016 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.535984 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.464016 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.464016 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.856063 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.535984 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=28161342.105685, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28161342.105685, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 32 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 32
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.464016
DEBUG CAREFUL: Adding var 7 to fractional list (xi=0.464016)
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.143937
DEBUG CAREFUL: Adding var 12 to fractional list (xi=0.143937)
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.464016
DEBUG CAREFUL: Adding var 14 to fractional list (xi=0.464016)
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.535984
DEBUG CAREFUL: Adding var 16 to fractional list (xi=0.535984)
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=1.000000
DEBUG CAREFUL: Skipping var 20: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 4 fractional variables

  %  Carefully choosing branching variable, nfrac = 4
DEBUG CAREFUL: Testing fvar[0] = var 14
DEBUG CAREFUL: Calling compare_branch_vars for var 14
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 14
DEBUG CAREFUL: New best var: 14
DEBUG CAREFUL: Testing fvar[1] = var 7
DEBUG CAREFUL: Calling compare_branch_vars for var 7
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 7
DEBUG CAREFUL: Testing fvar[2] = var 16
DEBUG CAREFUL: Calling compare_branch_vars for var 16
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 16
DEBUG CAREFUL: Testing fvar[3] = var 12
DEBUG CAREFUL: Calling compare_branch_vars for var 12
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 12
  % Initial guess is x14, Z0 = 28161342.1056847        , Z1 = 28224630.8613793        

DEBUG EVAL: Testing var 14 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=12, varin=75, theta=0.575728, up=1.000000
ITER 2: row=19, varin=22, theta=2.000000, up=999999999999999983222784.000000
ITER 3: row=28, varin=23, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=8, varin=15, theta=0.239288, up=999999999999999983222784.000000
ITER 5: row=13, varin=13, theta=0.239288, up=999999999999999983222784.000000
ITER 6: row=15, varin=19, theta=0.184345, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 14 = 1 gives z=28224630.861379
  % 	x14 = 1,	Z1 = 28224630.8613793        
DEBUG EVAL: First branch cutoff check: z=28224630.861379, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 14 = 0
ITER 1: row=12, varin=15, theta=0.499660, up=999999999999999983222784.000000
ITER 2: row=19, varin=32, theta=0.772727, up=1.000000
ITER 3: row=20, varin=12, theta=0.241218, up=999999999999999983222784.000000
ITER 4: row=18, varin=35, theta=0.245239, up=1.000000
ITER 5: row=13, varin=38, theta=0.165790, up=1.000000
  % 	x14 = 0,	Z0 = 28197873.5503233        
DEBUG EVAL: Second branch cutoff check: z=28197873.550323, best_z=INF, threshold=INF
  %   New best:  x14, Z = 28197873.5503233        
DEBUG EVAL: Testing var 7 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=15, theta=0.499660, up=999999999999999983222784.000000
ITER 2: row=19, varin=35, theta=0.301446, up=1.000000
ITER 3: row=15, varin=8, theta=0.327074, up=999999999999999983222784.000000
ITER 4: row=10, varin=19, theta=0.163861, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 7 = 0 gives z=28177045.144396
  % 	x7 = 0,	Z0 = 28177045.1443955        
DEBUG EVAL: First branch cutoff check: z=28177045.144396, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 16 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=22, varin=15, theta=0.499660, up=999999999999999983222784.000000
ITER 2: row=19, varin=32, theta=0.772727, up=1.000000
ITER 3: row=20, varin=12, theta=1.315247, up=999999999999999983222784.000000
ITER 4: row=25, varin=30, theta=1.075600, up=1.000000
ITER 5: row=25, varin=83, theta=0.220959, up=1.000000
ITER 6: row=13, varin=47, theta=1.571957, up=1.000000
ITER 7: row=13, varin=56, theta=0.313233, up=1.000000
ITER 8: row=21, varin=47, theta=1.758817, up=1.000000
ITER 9: row=21, varin=30, theta=1.379069, up=1.000000
ITER 10: row=21, varin=8, theta=0.499822, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 16 = 1 gives z=28839070.054520
  % 	x16 = 1,	Z1 = 28839070.0545201        
DEBUG EVAL: First branch cutoff check: z=28839070.054520, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 16 = 0
ITER 1: row=22, varin=75, theta=0.575728, up=1.000000
ITER 2: row=19, varin=22, theta=2.000000, up=999999999999999983222784.000000
ITER 3: row=28, varin=23, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=8, varin=15, theta=0.239288, up=999999999999999983222784.000000
ITER 5: row=13, varin=13, theta=0.239288, up=999999999999999983222784.000000
ITER 6: row=15, varin=19, theta=0.184345, up=999999999999999983222784.000000
  % 	x16 = 0,	Z0 = 28224630.8613793        
DEBUG EVAL: Second branch cutoff check: z=28224630.861379, best_z=INF, threshold=INF
  %   New best:  x16, Z = 28224630.8613793        
DEBUG EVAL: Testing var 12 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=19, varin=75, theta=0.038652, up=1.000000
ITER 2: row=7, varin=32, theta=0.064832, up=1.000000
ITER 3: row=20, varin=27, theta=10084.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 12 = 0 gives z=28162916.913569
  % 	x12 = 0,	Z0 = 28162916.9135686        
DEBUG EVAL: First branch cutoff check: z=28162916.913569, best_z=INF, threshold=INF
  % Best branch is x16, Z0 = 28224630.8613793        , Z1 = 28839070.0545201        

DEBUG CAREFUL: Final result - returning best.var = 16
DEBUG BB: Branching variable chosen: j=16
 % @NC   49   32	x16 = 0	28224630.861379
 % @NC   50   32	x16 = 1	28839070.054520
 %      32    25 28161342.1057               28166907.5219   x13 D     2     2
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cc9ac0
% @LO 0.03  28.16134210568468532188 99.9000000000
% @LN 0.03  28.16690752185767721016 99.9000000000
% Resuming node 47 at  28.16690752185767721016
DEBUG CONSTRNT: LP rows=29, pool->nlprows=29, pool->npend=0
DEBUG CONSTRNT: Checking 29 LP rows (pool tracks 29, total LP rows 29)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 49
DEBUG CONSTRNT: Pool row 49 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 68
DEBUG CONSTRNT: Pool row 68 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 82
DEBUG CONSTRNT: Pool row 82 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=28, expected 28
 % @PAP adding 40 rows, 168 nz to LP
DEBUG BB: Processing node 47, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=35, varin=35, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=16, varin=40, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=40)
DEBUG SOLUTION: LP solution array indices: FST[41-80], not_covered[81-100]
DEBUG SOLUTION: lp->best_solution[0] = 28166907.521858
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 40 rows, 60 cols, 228 nonzeros, 1 slack, 39 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=41, varin=44, theta=0.333333, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 28171444.287139
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 42 rows, 60 cols, 234 nonzeros, 4 slack, 38 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % @PAP adding 4 rows, 9 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=39, varin=24, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 28202680.578811
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 42 rows, 60 cols, 230 nonzeros, 3 slack, 39 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=40, varin=73, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=40)
DEBUG SOLUTION: LP solution array indices: FST[41-80], not_covered[81-100]
DEBUG SOLUTION: lp->best_solution[0] = 28217461.580915
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 40 rows, 60 cols, 224 nonzeros, 0 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 7 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=41, varin=64, theta=0.500000, up=1.000000
ITER 2: row=13, varin=30, theta=0.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 28220908.809024
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 42 rows, 60 cols, 231 nonzeros, 2 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % Node 47 LP 1 Solution, length = 28220908.809024, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.250000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.250000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.500000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.500000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.250000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.250000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.750000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.750000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.750000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.500000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.750000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.500000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28220908.809024, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 47 at  28.22090880902381115902
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cc2570
% @LO 0.03  28.16690752185767721016 99.9000000000
% @LN 0.03  28.16946340102352053236 99.9000000000
% Resuming node 16 at  28.16946340102352053236
DEBUG CONSTRNT: LP rows=40, pool->nlprows=40, pool->npend=0
DEBUG CONSTRNT: Checking 40 LP rows (pool tracks 40, total LP rows 40)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 133
DEBUG CONSTRNT: Pool row 133 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=39, expected 39
 % @PAP adding 37 rows, 178 nz to LP
DEBUG BB: Processing node 16, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 16 LP 2 Solution, length = 28169463.401024, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.333333 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.333333 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.333333 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.666667 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.333333 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.333333 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.333333 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.333333 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.666667 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.666667 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.666667 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.666667 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.666667 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=28169463.401024, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28169463.401024, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 16 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 16
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.333333
DEBUG CAREFUL: Adding var 9 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.333333
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.333333
DEBUG CAREFUL: Adding var 15 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.666667
DEBUG CAREFUL: Adding var 16 to fractional list (xi=0.666667)
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 4 fractional variables

  %  Carefully choosing branching variable, nfrac = 4
DEBUG CAREFUL: Testing fvar[0] = var 15
DEBUG CAREFUL: Calling compare_branch_vars for var 15
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 15
DEBUG CAREFUL: New best var: 15
DEBUG CAREFUL: Testing fvar[1] = var 16
DEBUG CAREFUL: Calling compare_branch_vars for var 16
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 16
DEBUG CAREFUL: Testing fvar[2] = var 9
DEBUG CAREFUL: Calling compare_branch_vars for var 9
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 9
DEBUG CAREFUL: Testing fvar[3] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
  % Initial guess is x15, Z0 = 28169463.4010235        , Z1 = 28174660.321925         

DEBUG EVAL: Testing var 15 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=13, varin=37, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=14, varin=35, theta=0.333333, up=999999999999999983222784.000000
ITER 3: row=35, varin=20, theta=1.142857, up=999999999999999983222784.000000
ITER 4: row=1, varin=39, theta=2.000000, up=1.000000
ITER 5: row=1, varin=22, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 15 = 1 gives z=28212280.859424
  % 	x15 = 1,	Z1 = 28212280.8594244        
DEBUG EVAL: First branch cutoff check: z=28212280.859424, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 15 = 0
ITER 1: row=13, varin=10, theta=0.250000, up=999999999999999983222784.000000
  % 	x15 = 0,	Z0 = 28171233.6578305        
DEBUG EVAL: Second branch cutoff check: z=28171233.657831, best_z=INF, threshold=INF
  %   New best:  x15, Z = 28171233.6578305        
DEBUG EVAL: Testing var 16 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=22, varin=10, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=13, varin=21, theta=12.000000, up=999999999999999983222784.000000
ITER 3: row=18, varin=55, theta=0.352941, up=1.000000
ITER 4: row=13, varin=19, theta=0.088235, up=999999999999999983222784.000000
ITER 5: row=27, varin=38, theta=0.500000, up=1.000000
ITER 6: row=2, varin=16, theta=0.545455, up=999999999999999983222784.000000
ITER 7: row=26, varin=21, theta=3.818182, up=999999999999999983222784.000000
ITER 8: row=24, varin=79, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 16 = 1 gives z=28263235.503476
  % 	x16 = 1,	Z1 = 28263235.5034764        
DEBUG EVAL: First branch cutoff check: z=28263235.503476, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 16 = 0
ITER 1: row=22, varin=37, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=14, varin=35, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=13, varin=20, theta=1.142857, up=999999999999999983222784.000000
ITER 4: row=1, varin=39, theta=2.000000, up=1.000000
ITER 5: row=1, varin=22, theta=0.500000, up=999999999999999983222784.000000
  % 	x16 = 0,	Z0 = 28212280.8594244        
DEBUG EVAL: Second branch cutoff check: z=28212280.859424, best_z=INF, threshold=INF
  %   New best:  x16, Z = 28212280.8594244        
DEBUG EVAL: Testing var 9 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=19, varin=10, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=13, varin=21, theta=12.000000, up=999999999999999983222784.000000
ITER 3: row=18, varin=22, theta=0.333333, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 9 = 0 gives z=28186917.161596
  % 	x9 = 0,	Z0 = 28186917.1615959        
DEBUG EVAL: First branch cutoff check: z=28186917.161596, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 10 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=14, varin=37, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 1 gives z=28171532.022160
  % 	x10 = 1,	Z1 = 28171532.0221596        
DEBUG EVAL: First branch cutoff check: z=28171532.022160, best_z=INF, threshold=INF
  % Best branch is x16, Z0 = 28212280.8594244        , Z1 = 28263235.5034764        

DEBUG CAREFUL: Final result - returning best.var = 16
DEBUG BB: Branching variable chosen: j=16
 % @NC   51   16	x16 = 0	28212280.859424
 % @NC   52   16	x16 = 1	28263235.503476
 %      16    26 28169463.4010               28189658.5493   x19 D     9     6
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cb6f50
% @LO 0.03  28.16946340102352053236 99.9000000000
% @LN 0.03  28.18965854927236591720 99.9000000000
% Resuming node 10 at  28.18965854927236591720
DEBUG CONSTRNT: LP rows=37, pool->nlprows=37, pool->npend=0
DEBUG CONSTRNT: Checking 37 LP rows (pool tracks 37, total LP rows 37)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 49
DEBUG CONSTRNT: Pool row 49 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 68
DEBUG CONSTRNT: Pool row 68 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 82
DEBUG CONSTRNT: Pool row 82 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=36, expected 36
 % @PAP adding 41 rows, 176 nz to LP
DEBUG BB: Processing node 10, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 10 LP 2 Solution, length = 28189658.549272, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.166667 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.166667 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.166667 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 1.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.166667 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.166667 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.166667 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.833333 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.833333 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.833333 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.833333 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.833333 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.833333 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.833333 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28189658.549272, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28189658.549272, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 10 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 10
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.166667
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.166667
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.166667
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=1.000000
DEBUG CAREFUL: Skipping var 13: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.166667
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.166667
DEBUG CAREFUL: Adding var 18 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.166667
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 6 fractional variables

  %  Carefully choosing branching variable, nfrac = 6
DEBUG CAREFUL: Testing fvar[0] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 2
DEBUG CAREFUL: New best var: 2
DEBUG CAREFUL: Testing fvar[1] = var 18
DEBUG CAREFUL: Calling compare_branch_vars for var 18
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 18
DEBUG CAREFUL: New best var: 18
DEBUG CAREFUL: Testing fvar[2] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[3] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 3
DEBUG CAREFUL: Testing fvar[4] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[5] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
  % Initial guess is x18, Z0 = 28189658.5492724        , Z1 = 28374156.455065         

DEBUG EVAL: Testing var 2 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=35, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 0 gives z=28215351.487787
  % 	x2 = 0,	Z0 = 28215351.4877872        
DEBUG EVAL: First branch cutoff check: z=28215351.487787, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 1
ITER 1: row=1, varin=39, theta=2.500000, up=999999999999999983222784.000000
ITER 2: row=17, varin=37, theta=3.000000, up=999999999999999983222784.000000
ITER 3: row=37, varin=26, theta=0.750000, up=999999999999999983222784.000000
  % 	x2 = 1,	Z1 = 28218004.9890325        
DEBUG EVAL: Second branch cutoff check: z=28218004.989032, best_z=INF, threshold=INF
  %   New best:  x2, Z = 28215351.4877872        
DEBUG EVAL: Testing var 18 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=32, varin=39, theta=2.500000, up=999999999999999983222784.000000
ITER 2: row=17, varin=37, theta=3.000000, up=999999999999999983222784.000000
ITER 3: row=37, varin=35, theta=1.500000, up=999999999999999983222784.000000
ITER 4: row=1, varin=33, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=33, varin=26, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=1, varin=28, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=2, varin=27, theta=0.500000, up=999999999999999983222784.000000
ITER 8: row=25, varin=2, theta=0.500000, up=999999999999999983222784.000000
ITER 9: row=28, varin=33, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 18 = 1 gives z=28396266.742995
  % 	x18 = 1,	Z1 = 28396266.7429949        
DEBUG EVAL: First branch cutoff check: z=28396266.742995, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 18 = 0
ITER 1: row=32, varin=66, theta=1.000000, up=1.000000
  % 	x18 = 0,	Z0 = 28233734.4697178        
DEBUG EVAL: Second branch cutoff check: z=28233734.469718, best_z=INF, threshold=INF
  %   New best:  x18, Z = 28233734.4697178        
DEBUG EVAL: Testing var 17 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=25, varin=35, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 17 = 0 gives z=28215351.487787
  % 	x17 = 0,	Z0 = 28215351.4877872        
DEBUG EVAL: First branch cutoff check: z=28215351.487787, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 3 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=17, varin=37, theta=5.000000, up=999999999999999983222784.000000
ITER 2: row=37, varin=33, theta=5.000000, up=999999999999999983222784.000000
ITER 3: row=33, varin=25, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=40, varin=32, theta=1.333333, up=999999999999999983222784.000000
ITER 5: row=32, varin=26, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=41, varin=28, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=2, varin=35, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 3 = 1 gives z=28479575.483333
  % 	x3 = 1,	Z1 = 28479575.4833335        
DEBUG EVAL: First branch cutoff check: z=28479575.483333, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 3 = 0
ITER 1: row=17, varin=39, theta=0.250000, up=999999999999999983222784.000000
  % 	x3 = 0,	Z0 = 28191175.1963178        
DEBUG EVAL: Second branch cutoff check: z=28191175.196318, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 10 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=13, varin=39, theta=2.500000, up=999999999999999983222784.000000
ITER 2: row=17, varin=37, theta=3.000000, up=999999999999999983222784.000000
ITER 3: row=37, varin=33, theta=3.000000, up=999999999999999983222784.000000
ITER 4: row=33, varin=27, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 1 gives z=28284103.531343
  % 	x10 = 1,	Z1 = 28284103.5313433        
DEBUG EVAL: First branch cutoff check: z=28284103.531343, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 0
ITER 1: row=13, varin=15, theta=0.200000, up=999999999999999983222784.000000
  % 	x10 = 0,	Z0 = 28202395.1122615        
DEBUG EVAL: Second branch cutoff check: z=28202395.112261, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 26 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=33, varin=33, theta=0.200000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 26 = 0 gives z=28195178.761126
  % 	x26 = 0,	Z0 = 28195178.7611258        
DEBUG EVAL: First branch cutoff check: z=28195178.761126, best_z=INF, threshold=INF
  % Best branch is x18, Z0 = 28233734.4697178        , Z1 = 28396266.7429949        

DEBUG CAREFUL: Final result - returning best.var = 18
DEBUG BB: Branching variable chosen: j=18
 % @NC   53   10	x18 = 0	28233734.469718
 % @NC   54   10	x18 = 1	28396266.742995
 %      10    27 28189658.5493               28194384.2461   x13 U     7     5
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cae7d0
% @LO 0.03  28.18965854927236591720 99.9000000000
% @LN 0.03  28.19438424613762705917 99.9000000000
% Resuming node 43 at  28.19438424613762705917
DEBUG CONSTRNT: LP rows=41, pool->nlprows=41, pool->npend=0
DEBUG CONSTRNT: Checking 41 LP rows (pool tracks 41, total LP rows 41)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 65
DEBUG CONSTRNT: Pool row 65 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=40, expected 40
 % @PAP adding 40 rows, 162 nz to LP
DEBUG BB: Processing node 43, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 43 LP 2 Solution, length = 28194384.246138, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.250000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.250000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.500000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.500000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.250000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.250000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.750000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.750000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.750000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.500000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.750000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.500000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28194384.246138, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28194384.246138, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 43 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 43
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.250000
DEBUG CAREFUL: Adding var 0 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.250000
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.500000
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=1.000000
DEBUG CAREFUL: Skipping var 7: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.500000
DEBUG CAREFUL: Adding var 27 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.250000
DEBUG CAREFUL: Adding var 29 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.250000
DEBUG CAREFUL: Adding var 32 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 6 fractional variables

  %  Carefully choosing branching variable, nfrac = 6
DEBUG CAREFUL: Testing fvar[0] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 2
DEBUG CAREFUL: New best var: 2
DEBUG CAREFUL: Testing fvar[1] = var 27
DEBUG CAREFUL: Calling compare_branch_vars for var 27
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 27
DEBUG CAREFUL: Testing fvar[2] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 1
DEBUG CAREFUL: Testing fvar[3] = var 0
DEBUG CAREFUL: Calling compare_branch_vars for var 0
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 0
DEBUG CAREFUL: Testing fvar[4] = var 32
DEBUG CAREFUL: Calling compare_branch_vars for var 32
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 32
DEBUG CAREFUL: New best var: 32
DEBUG CAREFUL: Testing fvar[5] = var 29
DEBUG CAREFUL: Calling compare_branch_vars for var 29
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 29
  % Initial guess is x32, Z0 = 28194384.2461376        , Z1 = 28205718.0201334        

DEBUG EVAL: Testing var 2 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=3, varin=39, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 0 gives z=28212612.476351
  % 	x2 = 0,	Z0 = 28212612.4763508        
DEBUG EVAL: First branch cutoff check: z=28212612.476351, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 1
ITER 1: row=3, varin=35, theta=1.000000, up=999999999999999983222784.000000
  % 	x2 = 1,	Z1 = 28248385.5333038        
DEBUG EVAL: Second branch cutoff check: z=28248385.533304, best_z=INF, threshold=INF
  %   New best:  x2, Z = 28212612.4763508        
DEBUG EVAL: Testing var 27 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=21, varin=39, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 27 = 0 gives z=28212612.476351
  % 	x27 = 0,	Z0 = 28212612.4763508        
DEBUG EVAL: First branch cutoff check: z=28212612.476351, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 27 = 1
ITER 1: row=21, varin=21, theta=1.000000, up=999999999999999983222784.000000
  % 	x27 = 1,	Z1 = 28585347.07268          
DEBUG EVAL: Second branch cutoff check: z=28585347.072680, best_z=INF, threshold=INF
  %   New best:  x27, Z = 28212612.4763508        
DEBUG EVAL: Testing var 1 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=2, varin=74, theta=0.500000, up=1.000000
DEBUG EVAL: Branch var 1 = 0 gives z=28216631.432122
  % 	x1 = 0,	Z0 = 28216631.4321219        
DEBUG EVAL: First branch cutoff check: z=28216631.432122, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 1 = 1
ITER 1: row=2, varin=13, theta=1.500000, up=999999999999999983222784.000000
ITER 2: row=13, varin=40, theta=1.500000, up=999999999999999983222784.000000
ITER 3: row=36, varin=39, theta=1.000000, up=999999999999999983222784.000000
  % 	x1 = 1,	Z1 = 28219506.9325681        
DEBUG EVAL: Second branch cutoff check: z=28219506.932568, best_z=INF, threshold=INF
  %   New best:  x1, Z = 28216631.4321219        
DEBUG EVAL: Testing var 0 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=74, theta=0.500000, up=1.000000
DEBUG EVAL: Branch var 0 = 0 gives z=28216631.432122
  % 	x0 = 0,	Z0 = 28216631.4321219        
DEBUG EVAL: First branch cutoff check: z=28216631.432122, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 0 = 1
ITER 1: row=1, varin=13, theta=1.500000, up=999999999999999983222784.000000
ITER 2: row=13, varin=40, theta=1.500000, up=999999999999999983222784.000000
ITER 3: row=36, varin=39, theta=1.000000, up=999999999999999983222784.000000
  % 	x0 = 1,	Z1 = 28219506.9325681        
DEBUG EVAL: Second branch cutoff check: z=28219506.932568, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 32 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=36, varin=13, theta=1.500000, up=999999999999999983222784.000000
ITER 2: row=13, varin=39, theta=3.000000, up=999999999999999983222784.000000
ITER 3: row=3, varin=35, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=21, varin=36, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 32 = 1 gives z=28317598.832607
  % 	x32 = 1,	Z1 = 28317598.8326065        
DEBUG EVAL: First branch cutoff check: z=28317598.832607, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 32 = 0
ITER 1: row=36, varin=40, theta=0.500000, up=999999999999999983222784.000000
  % 	x32 = 0,	Z0 = 28197831.4742463        
DEBUG EVAL: Second branch cutoff check: z=28197831.474246, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 29 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=35, varin=74, theta=0.500000, up=1.000000
DEBUG EVAL: Branch var 29 = 0 gives z=28216631.432122
  % 	x29 = 0,	Z0 = 28216631.4321219        
DEBUG EVAL: First branch cutoff check: z=28216631.432122, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 29 = 1
ITER 1: row=35, varin=13, theta=1.500000, up=999999999999999983222784.000000
ITER 2: row=13, varin=40, theta=1.500000, up=999999999999999983222784.000000
ITER 3: row=36, varin=39, theta=1.000000, up=999999999999999983222784.000000
  % 	x29 = 1,	Z1 = 28219506.9325681        
DEBUG EVAL: Second branch cutoff check: z=28219506.932568, best_z=INF, threshold=INF
  % Best branch is x1, Z0 = 28216631.4321219        , Z1 = 28219506.9325681        

DEBUG CAREFUL: Final result - returning best.var = 1
DEBUG BB: Branching variable chosen: j=1
 % @NC   55   43	x1 = 0	28216631.432122
 % @NC   56   43	x1 = 1	28219506.932568
 %      43    28 28194384.2461               28200061.1229   x26 D    37     8
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cc24b0
% @LO 0.03  28.19438424613762705917 99.9000000000
% @LN 0.03  28.20006112293601674423 99.9000000000
% Resuming node 12 at  28.20006112293601674423
DEBUG CONSTRNT: LP rows=40, pool->nlprows=40, pool->npend=0
DEBUG CONSTRNT: Checking 40 LP rows (pool tracks 40, total LP rows 40)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 133
DEBUG CONSTRNT: Pool row 133 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=39, expected 39
 % @PAP adding 34 rows, 165 nz to LP
DEBUG BB: Processing node 12, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 12 LP 2 Solution, length = 28200061.122936, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.500000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.500000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.500000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.500000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.500000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 2 fractional variables
DEBUG CG: LP optimal, z=28200061.122936, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28200061.122936, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 12 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 12
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=1.000000
DEBUG CAREFUL: Skipping var 7: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.500000
DEBUG CAREFUL: Adding var 14 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.500000
DEBUG CAREFUL: Adding var 15 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 2 fractional variables

  %  Carefully choosing branching variable, nfrac = 2
DEBUG CAREFUL: Testing fvar[0] = var 14
DEBUG CAREFUL: Calling compare_branch_vars for var 14
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 14
DEBUG CAREFUL: New best var: 14
DEBUG CAREFUL: Testing fvar[1] = var 15
DEBUG CAREFUL: Calling compare_branch_vars for var 15
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 15
  % Initial guess is x14, Z0 = 28200061.122936         , Z1 = 28200061.122936         

DEBUG EVAL: Testing var 14 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=17, varin=32, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=12, varin=40, theta=0.250000, up=1.000000
ITER 3: row=13, varin=21, theta=12.000000, up=999999999999999983222784.000000
ITER 4: row=18, varin=52, theta=0.352941, up=1.000000
ITER 5: row=25, varin=35, theta=0.500000, up=1.000000
ITER 6: row=2, varin=15, theta=0.545455, up=999999999999999983222784.000000
ITER 7: row=24, varin=19, theta=1.090909, up=999999999999999983222784.000000
ITER 8: row=22, varin=17, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 14 = 0 gives z=28305267.643313
  % 	x14 = 0,	Z0 = 28305267.6433128        
DEBUG EVAL: First branch cutoff check: z=28305267.643313, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 14 = 1
ITER 1: row=17, varin=29, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=34, varin=31, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=12, varin=21, theta=12.000000, up=999999999999999983222784.000000
ITER 4: row=18, varin=52, theta=0.352941, up=1.000000
ITER 5: row=25, varin=35, theta=0.500000, up=1.000000
ITER 6: row=2, varin=15, theta=0.545455, up=999999999999999983222784.000000
ITER 7: row=24, varin=40, theta=0.500000, up=1.000000
ITER 8: row=13, varin=19, theta=1.090909, up=999999999999999983222784.000000
ITER 9: row=22, varin=76, theta=1.000000, up=1.000000
  % 	x14 = 1,	Z1 = 28357702.2359281        
DEBUG EVAL: Second branch cutoff check: z=28357702.235928, best_z=INF, threshold=INF
  %   New best:  x14, Z = 28305267.6433128        
DEBUG EVAL: Testing var 15 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=29, varin=29, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=34, varin=31, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=12, varin=40, theta=0.250000, up=1.000000
ITER 4: row=13, varin=21, theta=12.000000, up=999999999999999983222784.000000
ITER 5: row=18, varin=52, theta=0.352941, up=1.000000
ITER 6: row=25, varin=35, theta=0.500000, up=1.000000
ITER 7: row=2, varin=15, theta=0.545455, up=999999999999999983222784.000000
ITER 8: row=24, varin=17, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 15 = 0 gives z=28328917.655902
  % 	x15 = 0,	Z0 = 28328917.6559019        
DEBUG EVAL: First branch cutoff check: z=28328917.655902, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 15 = 1
ITER 1: row=29, varin=32, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=12, varin=21, theta=12.000000, up=999999999999999983222784.000000
ITER 3: row=18, varin=52, theta=0.352941, up=1.000000
ITER 4: row=25, varin=35, theta=0.500000, up=1.000000
ITER 5: row=2, varin=40, theta=0.500000, up=1.000000
ITER 6: row=13, varin=15, theta=0.545455, up=999999999999999983222784.000000
ITER 7: row=24, varin=19, theta=1.090909, up=999999999999999983222784.000000
ITER 8: row=22, varin=76, theta=1.000000, up=1.000000
  % 	x15 = 1,	Z1 = 28310402.21075          
DEBUG EVAL: Second branch cutoff check: z=28310402.210750, best_z=INF, threshold=INF
  %   New best:  x15, Z = 28310402.21075          
  % Best branch is x15, Z0 = 28328917.6559019        , Z1 = 28310402.21075          

DEBUG CAREFUL: Final result - returning best.var = 15
DEBUG BB: Branching variable chosen: j=15
 % @NC   57   12	x15 = 1	28310402.210750
 % @NC   58   12	x15 = 0	28328917.655902
 %      12    29 28200061.1229               28202334.2687   x19 D     3     3
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cad710
% @LO 0.03  28.20006112293601674423 99.9000000000
% @LN 0.03  28.20233426866689185886 99.9000000000
% Resuming node 34 at  28.20233426866689185886
DEBUG CONSTRNT: LP rows=34, pool->nlprows=34, pool->npend=0
DEBUG CONSTRNT: Checking 34 LP rows (pool tracks 34, total LP rows 34)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=33, expected 33
 % @PAP adding 44 rows, 185 nz to LP
DEBUG BB: Processing node 34, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 34 LP 2 Solution, length = 28202334.268667, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.166667 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.166667 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.166667 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 1.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 1.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.166667 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.166667 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.166667 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.833333 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.833333 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.833333 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.833333 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.833333 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.833333 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.833333 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28202334.268667, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28202334.268667, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 34 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 34
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.166667
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.166667
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.166667
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=1.000000
DEBUG CAREFUL: Skipping var 12: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=1.000000
DEBUG CAREFUL: Skipping var 13: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.166667
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.166667
DEBUG CAREFUL: Adding var 18 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.166667
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 6 fractional variables

  %  Carefully choosing branching variable, nfrac = 6
DEBUG CAREFUL: Testing fvar[0] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 2
DEBUG CAREFUL: New best var: 2
DEBUG CAREFUL: Testing fvar[1] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[2] = var 18
DEBUG CAREFUL: Calling compare_branch_vars for var 18
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 18
DEBUG CAREFUL: New best var: 18
DEBUG CAREFUL: Testing fvar[3] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[4] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 3
DEBUG CAREFUL: Testing fvar[5] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
  % Initial guess is x18, Z0 = 28202334.2686669        , Z1 = 28386832.1744595        

DEBUG EVAL: Testing var 2 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=53, theta=0.500000, up=1.000000
DEBUG EVAL: Branch var 2 = 0 gives z=28213305.717361
  % 	x2 = 0,	Z0 = 28213305.7173609        
DEBUG EVAL: First branch cutoff check: z=28213305.717361, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 1
ITER 1: row=1, varin=42, theta=2.500000, up=999999999999999983222784.000000
ITER 2: row=17, varin=40, theta=3.000000, up=999999999999999983222784.000000
ITER 3: row=40, varin=29, theta=0.750000, up=999999999999999983222784.000000
  % 	x2 = 1,	Z1 = 28230680.708427         
DEBUG EVAL: Second branch cutoff check: z=28230680.708427, best_z=INF, threshold=INF
  %   New best:  x2, Z = 28213305.7173609        
DEBUG EVAL: Testing var 17 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=28, varin=53, theta=0.500000, up=1.000000
DEBUG EVAL: Branch var 17 = 0 gives z=28213305.717361
  % 	x17 = 0,	Z0 = 28213305.7173609        
DEBUG EVAL: First branch cutoff check: z=28213305.717361, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 17 = 1
ITER 1: row=28, varin=42, theta=2.500000, up=999999999999999983222784.000000
ITER 2: row=17, varin=40, theta=3.000000, up=999999999999999983222784.000000
ITER 3: row=40, varin=36, theta=3.000000, up=999999999999999983222784.000000
ITER 4: row=36, varin=35, theta=0.666667, up=999999999999999983222784.000000
  % 	x17 = 1,	Z1 = 28329280.7130101        
DEBUG EVAL: Second branch cutoff check: z=28329280.713010, best_z=INF, threshold=INF
  %   New best:  x17, Z = 28213305.7173609        
DEBUG EVAL: Testing var 18 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=35, varin=42, theta=2.500000, up=999999999999999983222784.000000
ITER 2: row=17, varin=40, theta=3.000000, up=999999999999999983222784.000000
ITER 3: row=40, varin=38, theta=1.500000, up=999999999999999983222784.000000
ITER 4: row=1, varin=36, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=36, varin=29, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=1, varin=31, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=5, varin=30, theta=0.500000, up=999999999999999983222784.000000
ITER 8: row=28, varin=2, theta=0.400000, up=999999999999999983222784.000000
ITER 9: row=31, varin=36, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 18 = 1 gives z=28408942.462389
  % 	x18 = 1,	Z1 = 28408942.4623895        
DEBUG EVAL: First branch cutoff check: z=28408942.462389, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 18 = 0
ITER 1: row=35, varin=53, theta=0.500000, up=1.000000
  % 	x18 = 0,	Z0 = 28213305.7173609        
DEBUG EVAL: Second branch cutoff check: z=28213305.717361, best_z=INF, threshold=INF
  %   New best:  x18, Z = 28213305.7173609        
DEBUG EVAL: Testing var 10 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=14, varin=53, theta=0.500000, up=1.000000
DEBUG EVAL: Branch var 10 = 0 gives z=28213305.717361
  % 	x10 = 0,	Z0 = 28213305.7173609        
DEBUG EVAL: First branch cutoff check: z=28213305.717361, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 1
ITER 1: row=14, varin=42, theta=2.500000, up=999999999999999983222784.000000
ITER 2: row=17, varin=40, theta=3.000000, up=999999999999999983222784.000000
ITER 3: row=40, varin=36, theta=3.000000, up=999999999999999983222784.000000
ITER 4: row=36, varin=30, theta=0.500000, up=999999999999999983222784.000000
  % 	x10 = 1,	Z1 = 28296779.2507378        
DEBUG EVAL: Second branch cutoff check: z=28296779.250738, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 3 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=17, varin=40, theta=5.000000, up=999999999999999983222784.000000
ITER 2: row=40, varin=36, theta=5.000000, up=999999999999999983222784.000000
ITER 3: row=36, varin=28, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=43, varin=35, theta=1.333333, up=999999999999999983222784.000000
ITER 5: row=35, varin=29, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=44, varin=31, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=5, varin=2, theta=0.400000, up=999999999999999983222784.000000
ITER 8: row=31, varin=38, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 3 = 1 gives z=28492251.202728
  % 	x3 = 1,	Z1 = 28492251.202728         
DEBUG EVAL: First branch cutoff check: z=28492251.202728, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 3 = 0
ITER 1: row=17, varin=42, theta=0.250000, up=999999999999999983222784.000000
  % 	x3 = 0,	Z0 = 28203850.9157123        
DEBUG EVAL: Second branch cutoff check: z=28203850.915712, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 26 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=36, varin=36, theta=0.200000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 26 = 0 gives z=28207854.480520
  % 	x26 = 0,	Z0 = 28207854.4805204        
DEBUG EVAL: First branch cutoff check: z=28207854.480520, best_z=INF, threshold=INF
  % Best branch is x18, Z0 = 28213305.7173609        , Z1 = 28408942.4623895        

DEBUG CAREFUL: Final result - returning best.var = 18
DEBUG BB: Branching variable chosen: j=18
 % @NC   59   34	x18 = 0	28213305.717361
 % @NC   60   34	x18 = 1	28408942.462389
 %      34    30 28202334.2687               28206791.6281   x16 D     8     5
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cc5d40
% @LO 0.03  28.20233426866689185886 99.9000000000
% @LN 0.03  28.20679162812701790131 99.9000000000
% Resuming node 18 at  28.20679162812701790131
DEBUG CONSTRNT: LP rows=44, pool->nlprows=44, pool->npend=0
DEBUG CONSTRNT: Checking 44 LP rows (pool tracks 44, total LP rows 44)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=43, expected 43
 % @PAP adding 42 rows, 171 nz to LP
DEBUG BB: Processing node 18, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=33, varin=40, theta=2.500000, up=999999999999999983222784.000000
ITER 2: row=21, varin=17, theta=3.000000, up=999999999999999983222784.000000
ITER 3: row=17, varin=37, theta=3.000000, up=999999999999999983222784.000000
ITER 4: row=37, varin=25, theta=2.000000, up=999999999999999983222784.000000
ITER 5: row=34, varin=29, theta=2.000000, up=999999999999999983222784.000000
ITER 6: row=2, varin=26, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 28201333.685689
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 42 rows, 60 cols, 231 nonzeros, 8 slack, 34 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 44 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=44, varin=16, theta=1.891042, up=999999999999999983222784.000000
ITER 2: row=36, varin=71, theta=2.811118, up=1.000000
ITER 3: row=36, varin=69, theta=1.774254, up=1.000000
ITER 4: row=36, varin=48, theta=0.681076, up=1.000000
ITER 5: row=40, varin=68, theta=1.753057, up=1.000000
ITER 6: row=40, varin=74, theta=0.945067, up=1.000000
ITER 7: row=43, varin=19, theta=1.000000, up=999999999999999983222784.000000
ITER 8: row=37, varin=71, theta=1.000000, up=1.000000
ITER 9: row=32, varin=72, theta=1.269931, up=1.000000
ITER 10: row=32, varin=66, theta=0.211284, up=1.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 999999999999999983222784.000000
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 44 rows, 60 cols, 275 nonzeros, 10 slack, 34 tight.
  % Node 18 LP 1 Solution, length = 999999999999999983222784.000000, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 1.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 1.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
DEBUG BB: compute_good_lower_bound returned status=1
DEBUG BB: Node 18 is INFEASIBLE
 %      18    29    infeasible               28212280.8594   x18 U    11     4
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7ccbbd0
% @LO 0.03  28.20679162812701790131 99.9000000000
% @LN 0.03  28.21228085942440344525 99.9000000000
% Resuming node 51 at  28.21228085942440344525
DEBUG CONSTRNT: LP rows=44, pool->nlprows=44, pool->npend=0
DEBUG CONSTRNT: Checking 44 LP rows (pool tracks 44, total LP rows 44)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=43, expected 43
 % @PAP adding 37 rows, 178 nz to LP
DEBUG BB: Processing node 51, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=22, varin=37, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=14, varin=35, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=13, varin=20, theta=1.142857, up=999999999999999983222784.000000
ITER 4: row=1, varin=39, theta=2.000000, up=1.000000
ITER 5: row=1, varin=22, theta=0.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=37)
DEBUG SOLUTION: LP solution array indices: FST[38-77], not_covered[78-97]
DEBUG SOLUTION: lp->best_solution[0] = 28212280.859424
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 37 rows, 60 cols, 238 nonzeros, 3 slack, 34 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 7 rows, 42 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=42, varin=31, theta=0.120000, up=999999999999999983222784.000000
ITER 2: row=38, varin=60, theta=1.000000, up=1.000000
ITER 3: row=35, varin=30, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=43, varin=46, theta=2.076923, up=1.000000
ITER 5: row=43, varin=47, theta=0.692308, up=1.000000
ITER 6: row=41, varin=10, theta=0.923077, up=999999999999999983222784.000000
ITER 7: row=43, varin=46, theta=0.769231, up=1.000000
ITER 8: row=39, varin=42, theta=0.300000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=8)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28245973.718894
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.100000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 44 rows, 60 cols, 280 nonzeros, 9 slack, 35 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 9 slack rows
  % @PAP adding 4 rows, 13 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=36, varin=32, theta=4.000000, up=999999999999999983222784.000000
ITER 2: row=1, varin=42, theta=0.321429, up=1.000000
ITER 3: row=19, varin=27, theta=0.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=39)
DEBUG SOLUTION: LP solution array indices: FST[40-79], not_covered[80-99]
DEBUG SOLUTION: lp->best_solution[0] = 28258041.159943
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 39 rows, 60 cols, 245 nonzeros, 4 slack, 35 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % Node 51 LP 1 Solution, length = 28258041.159943, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.500000 (FST 9)
  % DEBUG LP_VARS: x[10] = 1.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.500000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.500000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.500000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.500000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.500000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.500000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 3 fractional variables
DEBUG CG: LP optimal, z=28258041.159943, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 51 at  28.25804115994336029871
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cc24b0
% @LO 0.03  28.21228085942440344525 99.9000000000
% @LN 0.03  28.21330571736086767487 99.9000000000
% Resuming node 59 at  28.21330571736086767487
DEBUG CONSTRNT: LP rows=35, pool->nlprows=35, pool->npend=0
DEBUG CONSTRNT: Checking 35 LP rows (pool tracks 35, total LP rows 35)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=34, expected 34
 % @PAP adding 44 rows, 185 nz to LP
DEBUG BB: Processing node 59, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=35, varin=53, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28213305.717361
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 44 rows, 60 cols, 245 nonzeros, 0 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 59 LP 1 Solution, length = 28213305.717361, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.500000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 1.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.500000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.500000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.500000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 2 fractional variables
DEBUG CG: LP optimal, z=28213305.717361, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28213305.717361, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 59 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 59
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.500000
DEBUG CAREFUL: Adding var 8 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=1.000000
DEBUG CAREFUL: Skipping var 12: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.500000
DEBUG CAREFUL: Adding var 13 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 2 fractional variables

  %  Carefully choosing branching variable, nfrac = 2
DEBUG CAREFUL: Testing fvar[0] = var 8
DEBUG CAREFUL: Calling compare_branch_vars for var 8
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 8
DEBUG CAREFUL: New best var: 8
DEBUG CAREFUL: Testing fvar[1] = var 13
DEBUG CAREFUL: Calling compare_branch_vars for var 13
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 13
  % Initial guess is x8, Z0 = 28213305.7173609        , Z1 = 28371951.2630352        

DEBUG EVAL: Testing var 8 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=42, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=42, varin=40, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=40, varin=38, theta=0.500000, up=999999999999999983222784.000000
ITER 4: row=1, varin=36, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=36, varin=31, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=5, varin=28, theta=0.500000, up=999999999999999983222784.000000
ITER 7: row=1, varin=2, theta=0.400000, up=999999999999999983222784.000000
ITER 8: row=31, varin=30, theta=0.333333, up=999999999999999983222784.000000
ITER 9: row=18, varin=29, theta=0.333333, up=999999999999999983222784.000000
ITER 10: row=38, varin=36, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 8 = 1 gives z=28379499.482748
  % 	x8 = 1,	Z1 = 28379499.4827478        
DEBUG EVAL: First branch cutoff check: z=28379499.482748, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 8 = 0
ITER 1: row=1, varin=51, theta=0.250000, up=1.000000
  % 	x8 = 0,	Z0 = 28227840.4973189        
DEBUG EVAL: Second branch cutoff check: z=28227840.497319, best_z=INF, threshold=INF
  %   New best:  x8, Z = 28227840.4973189        
DEBUG EVAL: Testing var 13 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=19, varin=42, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=42, varin=40, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=40, varin=38, theta=0.500000, up=999999999999999983222784.000000
ITER 4: row=14, varin=36, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=36, varin=31, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=5, varin=30, theta=0.500000, up=999999999999999983222784.000000
ITER 7: row=17, varin=29, theta=0.500000, up=999999999999999983222784.000000
ITER 8: row=19, varin=2, theta=0.400000, up=999999999999999983222784.000000
ITER 9: row=31, varin=28, theta=0.333333, up=999999999999999983222784.000000
ITER 10: row=38, varin=97, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 13 = 0 gives z=28379499.482748
  % 	x13 = 0,	Z0 = 28379499.4827478        
DEBUG EVAL: First branch cutoff check: z=28379499.482748, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 13 = 1
ITER 1: row=19, varin=51, theta=0.500000, up=1.000000
ITER 2: row=1, varin=69, theta=1.000000, up=1.000000
ITER 3: row=3, varin=35, theta=0.333333, up=999999999999999983222784.000000
  % 	x13 = 1,	Z1 = 28248973.667114         
DEBUG EVAL: Second branch cutoff check: z=28248973.667114, best_z=INF, threshold=INF
  %   New best:  x13, Z = 28248973.667114         
  % Best branch is x13, Z0 = 28379499.4827478        , Z1 = 28248973.667114         

DEBUG CAREFUL: Final result - returning best.var = 13
DEBUG BB: Branching variable chosen: j=13
 % @NC   61   59	x13 = 1	28248973.667114
 % @NC   62   59	x13 = 0	28379499.482748
 %      59    30 28213305.7174               28216631.4321   x18 D    34     6
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cb6f50
% @LO 0.03  28.21330571736086767487 99.9000000000
% @LN 0.03  28.21663143212192537135 99.9000000000
% Resuming node 55 at  28.21663143212192537135
DEBUG CONSTRNT: LP rows=44, pool->nlprows=44, pool->npend=0
DEBUG CONSTRNT: Checking 44 LP rows (pool tracks 44, total LP rows 44)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=43, expected 43
 % @PAP adding 40 rows, 162 nz to LP
DEBUG BB: Processing node 55, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=2, varin=74, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=40)
DEBUG SOLUTION: LP solution array indices: FST[41-80], not_covered[81-100]
DEBUG SOLUTION: lp->best_solution[0] = 28216631.432122
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 40 rows, 60 cols, 222 nonzeros, 0 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 14 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=41, varin=75, theta=0.500000, up=1.000000
ITER 2: row=44, varin=101, theta=0.500000, up=1.000000
ITER 3: row=42, varin=41, theta=0.500000, up=999999999999999983222784.000000
ITER 4: row=1, varin=67, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28248233.281575
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 44 rows, 60 cols, 236 nonzeros, 0 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 19 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=45, varin=58, theta=1.000000, up=1.000000
ITER 2: row=20, varin=3, theta=0.250000, up=999999999999999983222784.000000
ITER 3: row=29, varin=4, theta=0.083333, up=999999999999999983222784.000000
ITER 4: row=37, varin=77, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 28269628.478360
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 48 rows, 60 cols, 255 nonzeros, 0 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 5 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=49, varin=33, theta=0.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 28274177.528423
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 49 rows, 60 cols, 260 nonzeros, 1 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=49, varin=35, theta=0.083333, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 28275959.116072
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.916667
DEBUG SOLUTION: lp->best_solution[4] = 0.916667
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 49 rows, 60 cols, 260 nonzeros, 5 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % @PAP adding 4 rows, 11 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=46, varin=82, theta=0.500000, up=1.000000
ITER 2: row=19, varin=80, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 28307112.202926
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 48 rows, 60 cols, 261 nonzeros, 0 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 55 LP 1 Solution, length = 28307112.202926, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.500000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.500000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.500000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.500000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.500000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 3 fractional variables
DEBUG CG: LP optimal, z=28307112.202926, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 55 at  28.30711220292613816696
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cd3d20
% @LO 0.03  28.21663143212192537135 99.9000000000
% @LN 0.03  28.21950693256812670029 99.9000000000
% Resuming node 56 at  28.21950693256812670029
DEBUG CONSTRNT: LP rows=48, pool->nlprows=48, pool->npend=0
DEBUG CONSTRNT: Checking 48 LP rows (pool tracks 48, total LP rows 48)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 133
DEBUG CONSTRNT: Pool row 133 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=47, expected 47
 % @PAP adding 40 rows, 162 nz to LP
DEBUG BB: Processing node 56, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=2, varin=13, theta=1.500000, up=999999999999999983222784.000000
ITER 2: row=13, varin=40, theta=1.500000, up=999999999999999983222784.000000
ITER 3: row=36, varin=39, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=40)
DEBUG SOLUTION: LP solution array indices: FST[41-80], not_covered[81-100]
DEBUG SOLUTION: lp->best_solution[0] = 28219506.932568
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 40 rows, 60 cols, 222 nonzeros, 2 slack, 38 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 5 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=41, varin=28, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=39, varin=75, theta=0.500000, up=1.000000
ITER 3: row=42, varin=36, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=39, varin=64, theta=0.500000, up=1.000000
ITER 5: row=13, varin=76, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 28632590.801683
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 42 rows, 60 cols, 227 nonzeros, 5 slack, 37 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % @PAP adding 4 rows, 12 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=38, varin=98, theta=0.500000, up=1.000000
ITER 2: row=39, varin=64, theta=0.500000, up=1.000000
ITER 3: row=40, varin=74, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=41)
DEBUG SOLUTION: LP solution array indices: FST[42-81], not_covered[82-101]
DEBUG SOLUTION: lp->best_solution[0] = 28721488.914682
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 41 rows, 60 cols, 228 nonzeros, 1 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 4 rows, 19 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=41, varin=54, theta=2.000000, up=1.000000
ITER 2: row=41, varin=73, theta=0.500000, up=1.000000
ITER 3: row=20, varin=54, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28764279.308252
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 44 rows, 60 cols, 245 nonzeros, 0 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 5 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=45, varin=31, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=32, varin=77, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 28806312.082882
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 45 rows, 60 cols, 250 nonzeros, 1 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=45, varin=69, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 28839246.757385
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 45 rows, 60 cols, 250 nonzeros, 0 slack, 45 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=46, varin=28, theta=0.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 28849274.228952
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 47 rows, 60 cols, 254 nonzeros, 5 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % @PAP adding 1 rows, 40 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=43, varin=19, theta=0.822411, up=999999999999999983222784.000000
ITER 2: row=16, varin=2, theta=0.130188, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 28881851.299777
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 0.869812
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 43 rows, 60 cols, 272 nonzeros, 2 slack, 41 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=42, varin=80, theta=0.297011, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 28893008.457156
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 42 rows, 60 cols, 270 nonzeros, 0 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 3 rows, 10 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=43, varin=27, theta=1.147626, up=999999999999999983222784.000000
ITER 2: row=40, varin=84, theta=0.297844, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 28893424.921537
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 45 rows, 60 cols, 280 nonzeros, 1 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 2 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=45, varin=86, theta=0.102103, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=46)
DEBUG SOLUTION: LP solution array indices: FST[47-86], not_covered[87-106]
DEBUG SOLUTION: lp->best_solution[0] = 28895028.861731
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 46 rows, 60 cols, 282 nonzeros, 0 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 56 LP 1 Solution, length = 28895028.861731, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 1.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.500000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.198948 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.198948 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.500000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.500000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.500000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.198948 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.102103 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.801052 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.500000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.500000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.801052 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.801052 (terminal 19)
 % 8 fractional variables
DEBUG CG: LP optimal, z=28895028.861731, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 56 at  28.89502886173106688261
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cc9ac0
% @LO 0.03  28.21950693256812670029 99.9000000000
% @LN 0.03  28.22090880902381115902 99.9000000000
% Resuming node 47 at  28.22090880902381115902
DEBUG CONSTRNT: LP rows=46, pool->nlprows=46, pool->npend=0
DEBUG CONSTRNT: Checking 46 LP rows (pool tracks 46, total LP rows 46)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 133
DEBUG CONSTRNT: Pool row 133 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 142
DEBUG CONSTRNT: Pool row 142 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 143
DEBUG CONSTRNT: Pool row 143 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 134
DEBUG CONSTRNT: Pool row 134 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 90
DEBUG CONSTRNT: Pool row 90 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 91
DEBUG CONSTRNT: Pool row 91 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 105
DEBUG CONSTRNT: Pool row 105 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 130
DEBUG CONSTRNT: Pool row 130 has lprow=45, expected 45
 % @PAP adding 40 rows, 160 nz to LP
DEBUG BB: Processing node 47, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 47 LP 2 Solution, length = 28220908.809024, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.250000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.250000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.500000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.500000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.250000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.250000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.750000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.750000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.750000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.500000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.750000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.500000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28220908.809024, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28220908.809024, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 47 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 47
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.250000
DEBUG CAREFUL: Adding var 0 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.250000
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.500000
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=1.000000
DEBUG CAREFUL: Skipping var 5: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.500000
DEBUG CAREFUL: Adding var 27 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.250000
DEBUG CAREFUL: Adding var 29 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.250000
DEBUG CAREFUL: Adding var 32 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 6 fractional variables

  %  Carefully choosing branching variable, nfrac = 6
DEBUG CAREFUL: Testing fvar[0] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 2
DEBUG CAREFUL: New best var: 2
DEBUG CAREFUL: Testing fvar[1] = var 27
DEBUG CAREFUL: Calling compare_branch_vars for var 27
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 27
DEBUG CAREFUL: Testing fvar[2] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 1
DEBUG CAREFUL: Testing fvar[3] = var 0
DEBUG CAREFUL: Calling compare_branch_vars for var 0
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 0
DEBUG CAREFUL: Testing fvar[4] = var 32
DEBUG CAREFUL: Calling compare_branch_vars for var 32
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 32
DEBUG CAREFUL: New best var: 32
DEBUG CAREFUL: Testing fvar[5] = var 29
DEBUG CAREFUL: Calling compare_branch_vars for var 29
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 29
  % Initial guess is x32, Z0 = 28220908.8090238        , Z1 = 28232242.5830196        

DEBUG EVAL: Testing var 2 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=3, varin=35, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 1 gives z=28274910.096190
  % 	x2 = 1,	Z1 = 28274910.0961899        
DEBUG EVAL: First branch cutoff check: z=28274910.096190, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 0
ITER 1: row=3, varin=39, theta=1.000000, up=999999999999999983222784.000000
  % 	x2 = 0,	Z0 = 28239137.039237         
DEBUG EVAL: Second branch cutoff check: z=28239137.039237, best_z=INF, threshold=INF
  %   New best:  x2, Z = 28239137.039237         
DEBUG EVAL: Testing var 27 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=23, varin=39, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 27 = 0 gives z=28239137.039237
  % 	x27 = 0,	Z0 = 28239137.039237         
DEBUG EVAL: First branch cutoff check: z=28239137.039237, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 27 = 1
ITER 1: row=23, varin=21, theta=1.000000, up=999999999999999983222784.000000
  % 	x27 = 1,	Z1 = 28611871.6355662        
DEBUG EVAL: Second branch cutoff check: z=28611871.635566, best_z=INF, threshold=INF
  %   New best:  x27, Z = 28239137.039237         
DEBUG EVAL: Testing var 1 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=2, varin=65, theta=1.000000, up=1.000000
ITER 2: row=33, varin=74, theta=0.500000, up=1.000000
DEBUG EVAL: Branch var 1 = 0 gives z=28243155.995008
  % 	x1 = 0,	Z0 = 28243155.9950081        
DEBUG EVAL: First branch cutoff check: z=28243155.995008, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 1 = 1
ITER 1: row=2, varin=13, theta=1.500000, up=999999999999999983222784.000000
ITER 2: row=13, varin=40, theta=1.500000, up=999999999999999983222784.000000
ITER 3: row=36, varin=39, theta=1.000000, up=999999999999999983222784.000000
  % 	x1 = 1,	Z1 = 28246031.4954543        
DEBUG EVAL: Second branch cutoff check: z=28246031.495454, best_z=INF, threshold=INF
  %   New best:  x1, Z = 28243155.9950081        
DEBUG EVAL: Testing var 0 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=65, theta=1.000000, up=1.000000
ITER 2: row=33, varin=74, theta=0.500000, up=1.000000
DEBUG EVAL: Branch var 0 = 0 gives z=28243155.995008
  % 	x0 = 0,	Z0 = 28243155.9950081        
DEBUG EVAL: First branch cutoff check: z=28243155.995008, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 0 = 1
ITER 1: row=1, varin=13, theta=1.500000, up=999999999999999983222784.000000
ITER 2: row=13, varin=40, theta=1.500000, up=999999999999999983222784.000000
ITER 3: row=36, varin=39, theta=1.000000, up=999999999999999983222784.000000
  % 	x0 = 1,	Z1 = 28246031.4954543        
DEBUG EVAL: Second branch cutoff check: z=28246031.495454, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 32 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=36, varin=13, theta=1.500000, up=999999999999999983222784.000000
ITER 2: row=13, varin=39, theta=3.000000, up=999999999999999983222784.000000
ITER 3: row=22, varin=35, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=23, varin=36, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 32 = 1 gives z=28344123.395493
  % 	x32 = 1,	Z1 = 28344123.3954927        
DEBUG EVAL: First branch cutoff check: z=28344123.395493, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 32 = 0
ITER 1: row=36, varin=40, theta=0.500000, up=999999999999999983222784.000000
  % 	x32 = 0,	Z0 = 28224356.0371325        
DEBUG EVAL: Second branch cutoff check: z=28224356.037132, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 29 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=35, varin=65, theta=1.000000, up=1.000000
ITER 2: row=33, varin=74, theta=0.500000, up=1.000000
DEBUG EVAL: Branch var 29 = 0 gives z=28243155.995008
  % 	x29 = 0,	Z0 = 28243155.9950081        
DEBUG EVAL: First branch cutoff check: z=28243155.995008, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 29 = 1
ITER 1: row=35, varin=13, theta=1.500000, up=999999999999999983222784.000000
ITER 2: row=13, varin=40, theta=1.500000, up=999999999999999983222784.000000
ITER 3: row=36, varin=39, theta=1.000000, up=999999999999999983222784.000000
  % 	x29 = 1,	Z1 = 28246031.4954543        
DEBUG EVAL: Second branch cutoff check: z=28246031.495454, best_z=INF, threshold=INF
  % Best branch is x1, Z0 = 28243155.9950081        , Z1 = 28246031.4954543        

DEBUG CAREFUL: Final result - returning best.var = 1
DEBUG BB: Branching variable chosen: j=1
 % @NC   63   47	x1 = 0	28243155.995008
 % @NC   64   47	x1 = 1	28246031.495454
 %      47    31 28220908.8090               28224630.8614   x26 D    41     9
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7ca0600
% @LO 0.03  28.22090880902381115902 99.9000000000
% @LN 0.03  28.22463086137931753683 99.9000000000
% Resuming node 49 at  28.22463086137931753683
DEBUG CONSTRNT: LP rows=40, pool->nlprows=40, pool->npend=0
DEBUG CONSTRNT: Checking 40 LP rows (pool tracks 40, total LP rows 40)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 133
DEBUG CONSTRNT: Pool row 133 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=39, expected 39
 % @PAP adding 29 rows, 179 nz to LP
DEBUG BB: Processing node 49, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=22, varin=75, theta=0.575728, up=1.000000
ITER 2: row=19, varin=22, theta=2.000000, up=999999999999999983222784.000000
ITER 3: row=28, varin=23, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=8, varin=15, theta=0.239288, up=999999999999999983222784.000000
ITER 5: row=13, varin=13, theta=0.239288, up=999999999999999983222784.000000
ITER 6: row=15, varin=19, theta=0.184345, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=29)
DEBUG SOLUTION: LP solution array indices: FST[30-69], not_covered[70-89]
DEBUG SOLUTION: lp->best_solution[0] = 28224630.861379
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 29 rows, 60 cols, 239 nonzeros, 4 slack, 25 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 8 rows, 44 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=35, varin=25, theta=0.139666, up=999999999999999983222784.000000
ITER 2: row=31, varin=24, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=30, varin=95, theta=1.324011, up=1.000000
ITER 4: row=30, varin=50, theta=0.190843, up=1.000000
ITER 5: row=34, varin=35, theta=10.674479, up=999999999999999983222784.000000
ITER 6: row=22, varin=48, theta=0.963188, up=1.000000
ITER 7: row=13, varin=43, theta=1.251482, up=1.000000
ITER 8: row=13, varin=46, theta=0.081849, up=1.000000
ITER 9: row=37, varin=26, theta=0.108783, up=999999999999999983222784.000000
ITER 10: row=1, varin=43, theta=0.243602, up=1.000000
LP PHASE: Switching to primal (iter=10)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=37)
DEBUG SOLUTION: LP solution array indices: FST[38-77], not_covered[78-97]
DEBUG SOLUTION: lp->best_solution[0] = 28269713.652055
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 37 rows, 60 cols, 283 nonzeros, 9 slack, 28 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 9 slack rows
  % @PAP adding 4 rows, 12 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=29, varin=75, theta=0.382344, up=1.000000
ITER 2: row=31, varin=29, theta=0.474910, up=999999999999999983222784.000000
ITER 3: row=32, varin=90, theta=1.303910, up=1.000000
ITER 4: row=32, varin=28, theta=0.501046, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=32)
DEBUG SOLUTION: LP solution array indices: FST[33-72], not_covered[73-92]
DEBUG SOLUTION: lp->best_solution[0] = 28277287.252951
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 32 rows, 60 cols, 242 nonzeros, 4 slack, 28 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % @PAP adding 4 rows, 11 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=32, varin=90, theta=0.671925, up=1.000000
ITER 2: row=30, varin=32, theta=0.123044, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=32)
DEBUG SOLUTION: LP solution array indices: FST[33-72], not_covered[73-92]
DEBUG SOLUTION: lp->best_solution[0] = 28281034.870783
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 32 rows, 60 cols, 234 nonzeros, 3 slack, 29 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 1 rows, 12 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=30, varin=28, theta=0.020015, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=30)
DEBUG SOLUTION: LP solution array indices: FST[31-70], not_covered[71-90]
DEBUG SOLUTION: lp->best_solution[0] = 28281072.673918
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 30 rows, 60 cols, 237 nonzeros, 1 slack, 29 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 1 rows, 5 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=30, varin=85, theta=0.018973, up=1.000000
ITER 2: row=15, varin=33, theta=0.019378, up=1.000000
ITER 3: row=18, varin=32, theta=0.035977, up=1.000000
ITER 4: row=7, varin=84, theta=0.025329, up=1.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=30)
DEBUG SOLUTION: LP solution array indices: FST[31-70], not_covered[71-90]
DEBUG SOLUTION: lp->best_solution[0] = 28282346.623201
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 30 rows, 60 cols, 240 nonzeros, 1 slack, 29 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 49 LP 1 Solution, length = 28282346.623201, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.025329 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.337555 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.337555 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.324890 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.324890 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.675110 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 1.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.662445 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.324890 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.324890 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.324890 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.662445 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.974671 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.675110 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.324890 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28282346.623201, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 49 at  28.28234662320145531567
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cbfd10
% @LO 0.03  28.22463086137931753683 99.9000000000
% @LN 0.03  28.22658568582220439680 99.9000000000
% Resuming node 14 at  28.22658568582220439680
DEBUG CONSTRNT: LP rows=29, pool->nlprows=29, pool->npend=0
DEBUG CONSTRNT: Checking 29 LP rows (pool tracks 29, total LP rows 29)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=28, expected 28
 % @PAP adding 34 rows, 163 nz to LP
DEBUG BB: Processing node 14, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 14 LP 2 Solution, length = 28226585.685822, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.500000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.500000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.500000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.500000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.500000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 2 fractional variables
DEBUG CG: LP optimal, z=28226585.685822, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28226585.685822, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 14 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 14
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=1.000000
DEBUG CAREFUL: Skipping var 5: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.500000
DEBUG CAREFUL: Adding var 14 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.500000
DEBUG CAREFUL: Adding var 15 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 2 fractional variables

  %  Carefully choosing branching variable, nfrac = 2
DEBUG CAREFUL: Testing fvar[0] = var 14
DEBUG CAREFUL: Calling compare_branch_vars for var 14
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 14
DEBUG CAREFUL: New best var: 14
DEBUG CAREFUL: Testing fvar[1] = var 15
DEBUG CAREFUL: Calling compare_branch_vars for var 15
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 15
  % Initial guess is x14, Z0 = 28226585.6858222        , Z1 = 28226585.6858222        

DEBUG EVAL: Testing var 14 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=17, varin=33, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=10, varin=21, theta=12.000000, up=999999999999999983222784.000000
ITER 3: row=18, varin=52, theta=0.352941, up=1.000000
ITER 4: row=25, varin=35, theta=0.500000, up=1.000000
ITER 5: row=2, varin=44, theta=0.250000, up=1.000000
DEBUG EVAL: Branch var 14 = 0 gives z=28275119.064501
  % 	x14 = 0,	Z0 = 28275119.0645009        
DEBUG EVAL: First branch cutoff check: z=28275119.064501, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 14 = 1
ITER 1: row=17, varin=29, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=34, varin=31, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=10, varin=21, theta=12.000000, up=999999999999999983222784.000000
ITER 4: row=18, varin=52, theta=0.352941, up=1.000000
ITER 5: row=25, varin=35, theta=0.500000, up=1.000000
ITER 6: row=2, varin=13, theta=0.545455, up=999999999999999983222784.000000
ITER 7: row=24, varin=19, theta=1.090909, up=999999999999999983222784.000000
ITER 8: row=22, varin=76, theta=1.000000, up=1.000000
  % 	x14 = 1,	Z1 = 28384226.7988142        
DEBUG EVAL: Second branch cutoff check: z=28384226.798814, best_z=INF, threshold=INF
  %   New best:  x14, Z = 28275119.0645009        
DEBUG EVAL: Testing var 15 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=29, varin=29, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=34, varin=31, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=10, varin=21, theta=12.000000, up=999999999999999983222784.000000
ITER 4: row=18, varin=44, theta=0.250000, up=1.000000
DEBUG EVAL: Branch var 15 = 0 gives z=28310594.083384
  % 	x15 = 0,	Z0 = 28310594.0833844        
DEBUG EVAL: First branch cutoff check: z=28310594.083384, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 15 = 1
ITER 1: row=29, varin=33, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=10, varin=21, theta=12.000000, up=999999999999999983222784.000000
ITER 3: row=18, varin=52, theta=0.352941, up=1.000000
ITER 4: row=25, varin=35, theta=0.500000, up=1.000000
ITER 5: row=2, varin=13, theta=0.545455, up=999999999999999983222784.000000
ITER 6: row=24, varin=19, theta=1.090909, up=999999999999999983222784.000000
ITER 7: row=22, varin=44, theta=0.500000, up=1.000000
ITER 8: row=17, varin=76, theta=1.000000, up=1.000000
  % 	x15 = 1,	Z1 = 28336926.7736362        
DEBUG EVAL: Second branch cutoff check: z=28336926.773636, best_z=INF, threshold=INF
  %   New best:  x15, Z = 28310594.0833844        
  % Best branch is x15, Z0 = 28310594.0833844        , Z1 = 28336926.7736362        

DEBUG CAREFUL: Final result - returning best.var = 15
DEBUG BB: Branching variable chosen: j=15
 % @NC   65   14	x15 = 0	28310594.083384
 % @NC   66   14	x15 = 1	28336926.773636
 %      14    32 28226585.6858               28227858.2486   x19 D     6     4
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cc7030
% @LO 0.03  28.22658568582220439680 99.9000000000
% @LN 0.03  28.22785824857500358576 99.9000000000
% Resuming node 20 at  28.22785824857500358576
DEBUG CONSTRNT: LP rows=34, pool->nlprows=34, pool->npend=0
DEBUG CONSTRNT: Checking 34 LP rows (pool tracks 34, total LP rows 34)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=33, expected 33
 % @PAP adding 42 rows, 169 nz to LP
DEBUG BB: Processing node 20, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=33, varin=40, theta=2.500000, up=999999999999999983222784.000000
ITER 2: row=21, varin=15, theta=3.000000, up=999999999999999983222784.000000
ITER 3: row=15, varin=37, theta=3.000000, up=999999999999999983222784.000000
ITER 4: row=37, varin=25, theta=2.000000, up=999999999999999983222784.000000
ITER 5: row=34, varin=29, theta=2.000000, up=999999999999999983222784.000000
ITER 6: row=2, varin=26, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 28227858.248575
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 42 rows, 60 cols, 229 nonzeros, 8 slack, 34 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 44 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=44, varin=14, theta=1.960677, up=999999999999999983222784.000000
ITER 2: row=36, varin=71, theta=2.914632, up=1.000000
ITER 3: row=36, varin=69, theta=1.875661, up=1.000000
ITER 4: row=36, varin=48, theta=0.770280, up=1.000000
ITER 5: row=40, varin=68, theta=1.885461, up=1.000000
ITER 6: row=40, varin=74, theta=1.111231, up=1.000000
ITER 7: row=40, varin=72, theta=0.105143, up=1.000000
ITER 8: row=1, varin=66, theta=14.789440, up=1.000000
ITER 9: row=1, varin=17, theta=2.250752, up=999999999999999983222784.000000
ITER 10: row=40, varin=66, theta=2.363475, up=1.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 999999999999999983222784.000000
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 44 rows, 60 cols, 273 nonzeros, 10 slack, 34 tight.
  % Node 20 LP 1 Solution, length = 999999999999999983222784.000000, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 1.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 1.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
DEBUG BB: compute_good_lower_bound returned status=1
DEBUG BB: Node 20 is INFEASIBLE
 %      20    31    infeasible               28233734.4697   x18 U    13     5
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cc2570
% @LO 0.03  28.22785824857500358576 99.9000000000
% @LN 0.03  28.23373446971775990733 99.9000000000
% Resuming node 53 at  28.23373446971775990733
DEBUG CONSTRNT: LP rows=44, pool->nlprows=44, pool->npend=0
DEBUG CONSTRNT: Checking 44 LP rows (pool tracks 44, total LP rows 44)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=43, expected 43
 % @PAP adding 41 rows, 176 nz to LP
DEBUG BB: Processing node 53, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=32, varin=66, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=41)
DEBUG SOLUTION: LP solution array indices: FST[42-81], not_covered[82-101]
DEBUG SOLUTION: lp->best_solution[0] = 28233734.469718
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 41 rows, 60 cols, 236 nonzeros, 0 slack, 41 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 11 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=42, varin=32, theta=0.333333, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 28236297.947720
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 45 rows, 60 cols, 247 nonzeros, 1 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 53 LP 1 Solution, length = 28236297.947720, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.333333 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.333333 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.333333 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 1.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.333333 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.333333 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.666667 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.666667 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.666667 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.666667 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.666667 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.666667 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.666667 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28236297.947720, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
 % @LO 0.03  28.23373446971775990733 99.9000000000
 % @LN 0.03  28.23629794771950685117 99.9000000000
DEBUG CG: Second cutoff check: z=28236297.947720, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 53 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 53
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.333333
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.333333
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.333333
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=1.000000
DEBUG CAREFUL: Skipping var 13: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.333333
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.333333
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 2
DEBUG CAREFUL: New best var: 2
DEBUG CAREFUL: Testing fvar[1] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[2] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 3
DEBUG CAREFUL: New best var: 3
DEBUG CAREFUL: Testing fvar[3] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[4] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
  % Initial guess is x3, Z0 = 28236297.9477195        , Z1 = 28479575.4833335        

DEBUG EVAL: Testing var 2 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=68, theta=1.000000, up=1.000000
ITER 2: row=37, varin=56, theta=0.500000, up=1.000000
DEBUG EVAL: Branch var 2 = 0 gives z=28309033.367346
  % 	x2 = 0,	Z0 = 28309033.3673463        
DEBUG EVAL: First branch cutoff check: z=28309033.367346, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 1
ITER 1: row=1, varin=41, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=41, varin=26, theta=0.666667, up=999999999999999983222784.000000
  % 	x2 = 1,	Z1 = 28260146.6523548        
DEBUG EVAL: Second branch cutoff check: z=28260146.652355, best_z=INF, threshold=INF
  %   New best:  x2, Z = 28260146.6523548        
DEBUG EVAL: Testing var 17 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=25, varin=68, theta=1.000000, up=1.000000
ITER 2: row=37, varin=56, theta=0.500000, up=1.000000
DEBUG EVAL: Branch var 17 = 0 gives z=28309033.367346
  % 	x17 = 0,	Z0 = 28309033.3673463        
DEBUG EVAL: First branch cutoff check: z=28309033.367346, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 17 = 1
ITER 1: row=25, varin=41, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=41, varin=38, theta=1.000000, up=999999999999999983222784.000000
  % 	x17 = 1,	Z1 = 28335643.3327953        
DEBUG EVAL: Second branch cutoff check: z=28335643.332795, best_z=INF, threshold=INF
  %   New best:  x17, Z = 28309033.3673463        
DEBUG EVAL: Testing var 3 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=17, varin=41, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=41, varin=36, theta=2.000000, up=999999999999999983222784.000000
ITER 3: row=36, varin=25, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=39, varin=32, theta=2.000000, up=999999999999999983222784.000000
ITER 5: row=32, varin=26, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=40, varin=28, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=42, varin=2, theta=0.400000, up=999999999999999983222784.000000
ITER 8: row=28, varin=34, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 3 = 1 gives z=28479575.483333
  % 	x3 = 1,	Z1 = 28479575.4833335        
DEBUG EVAL: First branch cutoff check: z=28479575.483333, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 3 = 0
ITER 1: row=17, varin=68, theta=1.000000, up=1.000000
ITER 2: row=37, varin=56, theta=0.500000, up=1.000000
  % 	x3 = 0,	Z0 = 28309033.3673463        
DEBUG EVAL: Second branch cutoff check: z=28309033.367346, best_z=INF, threshold=INF
  %   New best:  x3, Z = 28309033.3673463        
DEBUG EVAL: Testing var 10 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=13, varin=41, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=41, varin=27, theta=0.666667, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 1 gives z=28321378.786003
  % 	x10 = 1,	Z1 = 28321378.7860032        
DEBUG EVAL: First branch cutoff check: z=28321378.786003, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 0
ITER 1: row=13, varin=15, theta=0.500000, up=999999999999999983222784.000000
  % 	x10 = 0,	Z0 = 28291459.0544158        
DEBUG EVAL: Second branch cutoff check: z=28291459.054416, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 26 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=32, varin=32, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 26 = 0 gives z=28273418.176577
  % 	x26 = 0,	Z0 = 28273418.1765768        
DEBUG EVAL: First branch cutoff check: z=28273418.176577, best_z=INF, threshold=INF
  % Best branch is x3, Z0 = 28309033.3673463        , Z1 = 28479575.4833335        

DEBUG CAREFUL: Final result - returning best.var = 3
DEBUG BB: Branching variable chosen: j=3
 % @NC   67   53	x3 = 0	28309033.367346
 % @NC   68   53	x3 = 1	28479575.483333
 %      53    32 28236297.9477               28243155.9950   x18 D    10     6
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cc24b0
% @LO 0.03  28.23629794771950685117 99.9000000000
% @LN 0.03  28.24315599500810947120 99.9000000000
% Resuming node 63 at  28.24315599500810947120
DEBUG CONSTRNT: LP rows=44, pool->nlprows=44, pool->npend=0
DEBUG CONSTRNT: Checking 44 LP rows (pool tracks 44, total LP rows 44)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 65
DEBUG CONSTRNT: Pool row 65 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=43, expected 43
 % @PAP adding 40 rows, 160 nz to LP
DEBUG BB: Processing node 63, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=2, varin=65, theta=1.000000, up=1.000000
ITER 2: row=33, varin=74, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=40)
DEBUG SOLUTION: LP solution array indices: FST[41-80], not_covered[81-100]
DEBUG SOLUTION: lp->best_solution[0] = 28243155.995008
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 40 rows, 60 cols, 220 nonzeros, 0 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 14 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=41, varin=75, theta=0.500000, up=1.000000
ITER 2: row=44, varin=68, theta=0.500000, up=1.000000
ITER 3: row=42, varin=41, theta=0.500000, up=999999999999999983222784.000000
ITER 4: row=1, varin=67, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28274757.844461
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 44 rows, 60 cols, 234 nonzeros, 0 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 19 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=45, varin=58, theta=1.000000, up=1.000000
ITER 2: row=20, varin=3, theta=0.250000, up=999999999999999983222784.000000
ITER 3: row=29, varin=4, theta=0.083333, up=999999999999999983222784.000000
ITER 4: row=37, varin=77, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 28296153.041246
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 48 rows, 60 cols, 253 nonzeros, 0 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 5 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=49, varin=33, theta=0.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 28300702.091310
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 49 rows, 60 cols, 258 nonzeros, 1 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=49, varin=35, theta=0.083333, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 28302483.678958
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.916667
DEBUG SOLUTION: lp->best_solution[4] = 0.916667
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 49 rows, 60 cols, 258 nonzeros, 5 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % @PAP adding 4 rows, 11 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=46, varin=82, theta=0.500000, up=1.000000
ITER 2: row=31, varin=80, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 28333636.765812
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 48 rows, 60 cols, 259 nonzeros, 0 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 63 LP 1 Solution, length = 28333636.765812, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.500000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.500000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.500000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.500000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.500000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 3 fractional variables
DEBUG CG: LP optimal, z=28333636.765812, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 63 at  28.33363676581232937224
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cc5c00
% @LO 0.03  28.24315599500810947120 99.9000000000
% @LN 0.03  28.24603149545431080014 99.9000000000
% Resuming node 64 at  28.24603149545431080014
DEBUG CONSTRNT: LP rows=48, pool->nlprows=48, pool->npend=0
DEBUG CONSTRNT: Checking 48 LP rows (pool tracks 48, total LP rows 48)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 133
DEBUG CONSTRNT: Pool row 133 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=47, expected 47
 % @PAP adding 40 rows, 160 nz to LP
DEBUG BB: Processing node 64, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=2, varin=13, theta=1.500000, up=999999999999999983222784.000000
ITER 2: row=13, varin=40, theta=1.500000, up=999999999999999983222784.000000
ITER 3: row=36, varin=39, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=40)
DEBUG SOLUTION: LP solution array indices: FST[41-80], not_covered[81-100]
DEBUG SOLUTION: lp->best_solution[0] = 28246031.495454
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 40 rows, 60 cols, 220 nonzeros, 2 slack, 38 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 5 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=41, varin=28, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=39, varin=75, theta=0.500000, up=1.000000
ITER 3: row=42, varin=36, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=39, varin=64, theta=0.500000, up=1.000000
ITER 5: row=13, varin=67, theta=1.000000, up=1.000000
ITER 6: row=33, varin=76, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 28659115.364569
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 42 rows, 60 cols, 225 nonzeros, 5 slack, 37 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % @PAP adding 4 rows, 12 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=38, varin=65, theta=0.500000, up=1.000000
ITER 2: row=39, varin=64, theta=0.500000, up=1.000000
ITER 3: row=40, varin=74, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=41)
DEBUG SOLUTION: LP solution array indices: FST[42-81], not_covered[82-101]
DEBUG SOLUTION: lp->best_solution[0] = 28748013.477568
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 41 rows, 60 cols, 226 nonzeros, 1 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 4 rows, 19 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=41, varin=54, theta=2.000000, up=1.000000
ITER 2: row=41, varin=73, theta=0.500000, up=1.000000
ITER 3: row=20, varin=54, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28790803.871138
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 44 rows, 60 cols, 243 nonzeros, 0 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 5 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=45, varin=31, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=32, varin=77, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 28832836.645768
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 45 rows, 60 cols, 248 nonzeros, 1 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=45, varin=69, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 28865771.320271
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 45 rows, 60 cols, 248 nonzeros, 0 slack, 45 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=46, varin=29, theta=0.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 28875798.791838
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 47 rows, 60 cols, 252 nonzeros, 5 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % @PAP adding 1 rows, 40 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=43, varin=17, theta=0.892045, up=999999999999999983222784.000000
ITER 2: row=16, varin=2, theta=0.158306, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 28911515.397227
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 0.841694
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 43 rows, 60 cols, 270 nonzeros, 2 slack, 41 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=42, varin=80, theta=0.361160, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 28925082.283293
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 42 rows, 60 cols, 268 nonzeros, 0 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 3 rows, 10 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=43, varin=27, theta=1.395490, up=999999999999999983222784.000000
ITER 2: row=40, varin=84, theta=0.362172, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 28925588.695869
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 45 rows, 60 cols, 278 nonzeros, 1 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 2 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=45, varin=86, theta=0.239387, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=46)
DEBUG SOLUTION: LP solution array indices: FST[47-86], not_covered[87-106]
DEBUG SOLUTION: lp->best_solution[0] = 28929349.218221
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 46 rows, 60 cols, 280 nonzeros, 0 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=47, varin=40, theta=0.496967, up=999999999999999983222784.000000
ITER 2: row=27, varin=32, theta=0.167525, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 28965056.694874
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 47 rows, 60 cols, 282 nonzeros, 1 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 64 LP 1 Solution, length = 28965056.694874, 0.01 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 1.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.500000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.110825 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.110825 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.167525 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.167525 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.500000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.500000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.500000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.167525 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.110825 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.110825 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.832475 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.889175 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.500000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.500000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.889175 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 0.832475 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.889175 (terminal 19)
 % 11 fractional variables
DEBUG CG: LP optimal, z=28965056.694874, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 64 at  28.96505669487380885130
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cc2630
% @LO 0.04  28.24603149545431080014 99.9000000000
% @LN 0.04  28.24886936907441992162 99.9000000000
% Resuming node 24 at  28.24886936907441992162
DEBUG CONSTRNT: LP rows=46, pool->nlprows=46, pool->npend=0
DEBUG CONSTRNT: Checking 46 LP rows (pool tracks 46, total LP rows 46)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 133
DEBUG CONSTRNT: Pool row 133 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 142
DEBUG CONSTRNT: Pool row 142 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 143
DEBUG CONSTRNT: Pool row 143 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 134
DEBUG CONSTRNT: Pool row 134 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 90
DEBUG CONSTRNT: Pool row 90 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 91
DEBUG CONSTRNT: Pool row 91 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 105
DEBUG CONSTRNT: Pool row 105 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 130
DEBUG CONSTRNT: Pool row 130 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 20
DEBUG CONSTRNT: Pool row 20 has lprow=45, expected 45
 % @PAP adding 42 rows, 174 nz to LP
DEBUG BB: Processing node 24, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=21, varin=39, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=39, varin=17, theta=2.000000, up=999999999999999983222784.000000
ITER 3: row=17, varin=23, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=37, varin=33, theta=2.000000, up=999999999999999983222784.000000
ITER 5: row=33, varin=24, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=38, varin=29, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=40, varin=2, theta=0.400000, up=999999999999999983222784.000000
ITER 8: row=29, varin=25, theta=0.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=8)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 28248869.369074
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 42 rows, 60 cols, 234 nonzeros, 6 slack, 36 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 54 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=46, varin=47, theta=0.644489, up=1.000000
ITER 2: row=29, varin=19, theta=0.812162, up=999999999999999983222784.000000
ITER 3: row=43, varin=73, theta=1.000000, up=1.000000
ITER 4: row=35, varin=83, theta=1.000000, up=1.000000
ITER 5: row=17, varin=3, theta=1.500000, up=999999999999999983222784.000000
ITER 6: row=31, varin=48, theta=1.500000, up=1.000000
ITER 7: row=31, varin=70, theta=0.333333, up=1.000000
ITER 8: row=18, varin=48, theta=0.748103, up=1.000000
ITER 9: row=42, varin=76, theta=0.870257, up=1.000000
ITER 10: row=32, varin=31, theta=0.120239, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=16)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=46)
DEBUG SOLUTION: LP solution array indices: FST[47-86], not_covered[87-106]
DEBUG SOLUTION: lp->best_solution[0] = 28552697.572485
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 46 rows, 60 cols, 288 nonzeros, 4 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=43, varin=37, theta=0.666667, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 28557234.337766
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 43 rows, 60 cols, 244 nonzeros, 3 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 5 rows, 49 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=45, varin=19, theta=0.275382, up=999999999999999983222784.000000
ITER 2: row=41, varin=67, theta=1.000000, up=1.000000
ITER 3: row=13, varin=78, theta=1.000000, up=1.000000
ITER 4: row=45, varin=13, theta=0.294758, up=999999999999999983222784.000000
ITER 5: row=41, varin=45, theta=38970.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 28618032.633647
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 45 rows, 60 cols, 282 nonzeros, 2 slack, 43 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 2 rows, 7 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=44, varin=67, theta=1.000000, up=1.000000
ITER 2: row=13, varin=28, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 28624927.089864
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 45 rows, 60 cols, 247 nonzeros, 2 slack, 43 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 1 rows, 40 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=44, varin=101, theta=0.789881, up=1.000000
ITER 2: row=34, varin=19, theta=0.663985, up=999999999999999983222784.000000
ITER 3: row=16, varin=59, theta=0.671235, up=1.000000
ITER 4: row=20, varin=75, theta=0.827533, up=1.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28670742.493106
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 44 rows, 60 cols, 276 nonzeros, 0 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 15 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=45, varin=82, theta=1.121960, up=1.000000
ITER 2: row=45, varin=72, theta=0.070946, up=1.000000
ITER 3: row=48, varin=82, theta=0.898388, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 28690090.850271
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 48 rows, 60 cols, 291 nonzeros, 0 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=50, varin=48, theta=0.804037, up=999999999999999983222784.000000
ITER 2: row=49, varin=79, theta=0.388353, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28706924.135263
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 50 rows, 60 cols, 297 nonzeros, 0 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 5 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=51, varin=34, theta=0.454311, up=999999999999999983222784.000000
ITER 2: row=3, varin=83, theta=0.011699, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 28719593.393319
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 51 rows, 60 cols, 302 nonzeros, 1 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 2 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=51, varin=76, theta=0.924085, up=1.000000
ITER 2: row=52, varin=22, theta=0.269796, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 28804785.160085
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 52 rows, 60 cols, 304 nonzeros, 1 slack, 51 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 24 LP 1 Solution, length = 28804785.160085, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.146041 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.146041 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.730204 (FST 2)
  % DEBUG LP_VARS: x[3] = 1.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.146041 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.146041 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.269796 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.146041 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.146041 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.269796 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.146041 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.146041 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.853959 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.853959 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.853959 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.853959 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.269796 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 0.853959 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 11 fractional variables
DEBUG CG: LP optimal, z=28804785.160085, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 24 at  28.80478516008477285482
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cc5d40
% @LO 0.04  28.24886936907441992162 99.9000000000
% @LN 0.04  28.24897366711403279282 99.9000000000
% Resuming node 61 at  28.24897366711403279282
DEBUG CONSTRNT: LP rows=51, pool->nlprows=51, pool->npend=0
DEBUG CONSTRNT: Checking 51 LP rows (pool tracks 51, total LP rows 51)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 133
DEBUG CONSTRNT: Pool row 133 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 134
DEBUG CONSTRNT: Pool row 134 has lprow=50, expected 50
 % @PAP adding 44 rows, 185 nz to LP
DEBUG BB: Processing node 61, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=19, varin=51, theta=0.500000, up=1.000000
ITER 2: row=1, varin=69, theta=1.000000, up=1.000000
ITER 3: row=3, varin=35, theta=0.333333, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28248973.667114
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 44 rows, 60 cols, 245 nonzeros, 1 slack, 43 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 61 LP 1 Solution, length = 28248973.667114, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.333333 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.333333 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.333333 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 1.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 1.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.333333 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.333333 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.666667 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.666667 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.666667 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.666667 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.666667 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.666667 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.666667 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28248973.667114, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28248973.667114, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 61 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 61
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.333333
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.333333
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.333333
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=1.000000
DEBUG CAREFUL: Skipping var 12: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=1.000000
DEBUG CAREFUL: Skipping var 13: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.333333
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.333333
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 2
DEBUG CAREFUL: New best var: 2
DEBUG CAREFUL: Testing fvar[1] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 17
DEBUG CAREFUL: New best var: 17
DEBUG CAREFUL: Testing fvar[2] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[3] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 3
DEBUG CAREFUL: New best var: 3
DEBUG CAREFUL: Testing fvar[4] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
  % Initial guess is x3, Z0 = 28248973.667114         , Z1 = 28492251.202728         

DEBUG EVAL: Testing var 2 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=68, theta=1.000000, up=1.000000
ITER 2: row=41, varin=56, theta=0.500000, up=1.000000
DEBUG EVAL: Branch var 2 = 0 gives z=28321709.086741
  % 	x2 = 0,	Z0 = 28321709.0867408        
DEBUG EVAL: First branch cutoff check: z=28321709.086741, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 1
ITER 1: row=1, varin=3, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=3, varin=53, theta=1.000000, up=1.000000
ITER 3: row=10, varin=29, theta=0.666667, up=999999999999999983222784.000000
  % 	x2 = 1,	Z1 = 28272822.3717494        
DEBUG EVAL: Second branch cutoff check: z=28272822.371749, best_z=INF, threshold=INF
  %   New best:  x2, Z = 28272822.3717494        
DEBUG EVAL: Testing var 17 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=28, varin=3, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=3, varin=53, theta=1.000000, up=1.000000
ITER 3: row=10, varin=42, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 17 = 1 gives z=28348319.052190
  % 	x17 = 1,	Z1 = 28348319.0521899        
DEBUG EVAL: First branch cutoff check: z=28348319.052190, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 17 = 0
ITER 1: row=28, varin=68, theta=1.000000, up=1.000000
ITER 2: row=41, varin=56, theta=0.500000, up=1.000000
  % 	x17 = 0,	Z0 = 28321709.0867408        
DEBUG EVAL: Second branch cutoff check: z=28321709.086741, best_z=INF, threshold=INF
  %   New best:  x17, Z = 28321709.0867408        
DEBUG EVAL: Testing var 10 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=14, varin=3, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=3, varin=53, theta=1.000000, up=1.000000
ITER 3: row=10, varin=30, theta=0.666667, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 1 gives z=28334054.505398
  % 	x10 = 1,	Z1 = 28334054.5053977        
DEBUG EVAL: First branch cutoff check: z=28334054.505398, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 0
ITER 1: row=14, varin=16, theta=0.500000, up=999999999999999983222784.000000
  % 	x10 = 0,	Z0 = 28304134.7738103        
DEBUG EVAL: Second branch cutoff check: z=28304134.773810, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 3 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=17, varin=3, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=3, varin=53, theta=1.000000, up=1.000000
ITER 3: row=10, varin=40, theta=2.000000, up=999999999999999983222784.000000
ITER 4: row=40, varin=28, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=43, varin=36, theta=2.000000, up=999999999999999983222784.000000
ITER 6: row=36, varin=29, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=44, varin=31, theta=1.000000, up=999999999999999983222784.000000
ITER 8: row=5, varin=2, theta=0.400000, up=999999999999999983222784.000000
ITER 9: row=31, varin=38, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 3 = 1 gives z=28492251.202728
  % 	x3 = 1,	Z1 = 28492251.202728         
DEBUG EVAL: First branch cutoff check: z=28492251.202728, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 3 = 0
ITER 1: row=17, varin=68, theta=1.000000, up=1.000000
ITER 2: row=41, varin=56, theta=0.500000, up=1.000000
  % 	x3 = 0,	Z0 = 28321709.0867408        
DEBUG EVAL: Second branch cutoff check: z=28321709.086741, best_z=INF, threshold=INF
  %   New best:  x3, Z = 28321709.0867408        
DEBUG EVAL: Testing var 26 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=36, varin=36, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 26 = 0 gives z=28286093.895971
  % 	x26 = 0,	Z0 = 28286093.8959713        
DEBUG EVAL: First branch cutoff check: z=28286093.895971, best_z=INF, threshold=INF
  % Best branch is x3, Z0 = 28321709.0867408        , Z1 = 28492251.202728         

DEBUG CAREFUL: Final result - returning best.var = 3
DEBUG BB: Branching variable chosen: j=3
 % @NC   69   61	x3 = 0	28321709.086741
 % @NC   70   61	x3 = 1	28492251.202728
 %      61    33 28248973.6671               28249646.3025   x13 U    59     7
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cb66c0
% @LO 0.04  28.24897366711403279282 99.9000000000
% @LN 0.04  28.24964630250135400047 99.9000000000
% Resuming node 45 at  28.24964630250135400047
DEBUG CONSTRNT: LP rows=44, pool->nlprows=44, pool->npend=0
DEBUG CONSTRNT: Checking 44 LP rows (pool tracks 44, total LP rows 44)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=43, expected 43
 % @PAP adding 43 rows, 184 nz to LP
DEBUG BB: Processing node 45, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=27, varin=60, theta=1.000000, up=1.000000
ITER 2: row=13, varin=31, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 28249646.302501
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 43 rows, 60 cols, 244 nonzeros, 1 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=44, varin=22, theta=0.125000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28250890.450813
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 44 rows, 60 cols, 246 nonzeros, 5 slack, 39 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % Node 45 LP 1 Solution, length = 28250890.450813, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.500000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.125000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.125000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 1.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 1.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.125000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.500000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.875000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.500000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.500000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.875000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28250890.450813, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
 % @LO 0.04  28.24964630250135400047 99.9000000000
 % @LN 0.04  28.25089045081255534342 99.9000000000
DEBUG CG: Second cutoff check: z=28250890.450813, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 45 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 45
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.500000
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.125000
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.125000)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.125000
DEBUG CAREFUL: Adding var 4 to fractional list (xi=0.125000)
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=1.000000
DEBUG CAREFUL: Skipping var 9: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=1.000000
DEBUG CAREFUL: Skipping var 10: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.125000
DEBUG CAREFUL: Adding var 11 to fractional list (xi=0.125000)
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.500000
DEBUG CAREFUL: Adding var 27 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 27
DEBUG CAREFUL: Calling compare_branch_vars for var 27
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 27
DEBUG CAREFUL: New best var: 27
DEBUG CAREFUL: Testing fvar[1] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[2] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 3
DEBUG CAREFUL: New best var: 3
DEBUG CAREFUL: Testing fvar[3] = var 11
DEBUG CAREFUL: Calling compare_branch_vars for var 11
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 11
DEBUG CAREFUL: New best var: 11
DEBUG CAREFUL: Testing fvar[4] = var 4
DEBUG CAREFUL: Calling compare_branch_vars for var 4
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 4
DEBUG CAREFUL: New best var: 4
  % Initial guess is x4, Z0 = 28250890.4508126        , Z1 = 28456202.6122482        

DEBUG EVAL: Testing var 27 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=32, varin=39, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 27 = 0 gives z=28252134.599124
  % 	x27 = 0,	Z0 = 28252134.5991238        
DEBUG EVAL: First branch cutoff check: z=28252134.599124, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 27 = 1
ITER 1: row=32, varin=17, theta=1.000000, up=999999999999999983222784.000000
  % 	x27 = 1,	Z1 = 28624869.195453         
DEBUG EVAL: Second branch cutoff check: z=28624869.195453, best_z=INF, threshold=INF
  %   New best:  x27, Z = 28252134.5991238        
DEBUG EVAL: Testing var 2 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=39, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 0 gives z=28252134.599124
  % 	x2 = 0,	Z0 = 28252134.5991238        
DEBUG EVAL: First branch cutoff check: z=28252134.599124, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 1
ITER 1: row=1, varin=38, theta=1.000000, up=999999999999999983222784.000000
  % 	x2 = 1,	Z1 = 28287907.6560767        
DEBUG EVAL: Second branch cutoff check: z=28287907.656077, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 3 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=17, varin=39, theta=7.000000, up=999999999999999983222784.000000
ITER 2: row=1, varin=38, theta=3.000000, up=999999999999999983222784.000000
ITER 3: row=32, varin=37, theta=3.000000, up=999999999999999983222784.000000
ITER 4: row=37, varin=36, theta=1.500000, up=999999999999999983222784.000000
ITER 5: row=24, varin=33, theta=1.500000, up=999999999999999983222784.000000
ITER 6: row=33, varin=32, theta=1.500000, up=999999999999999983222784.000000
ITER 7: row=29, varin=31, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 3 = 1 gives z=28528359.096225
  % 	x3 = 1,	Z1 = 28528359.0962245        
DEBUG EVAL: First branch cutoff check: z=28528359.096225, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 3 = 0
ITER 1: row=17, varin=72, theta=0.500000, up=1.000000
  % 	x3 = 0,	Z0 = 28264427.3046058        
DEBUG EVAL: Second branch cutoff check: z=28264427.304606, best_z=INF, threshold=INF
  %   New best:  x3, Z = 28264427.3046058        
DEBUG EVAL: Testing var 11 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=31, varin=39, theta=7.000000, up=999999999999999983222784.000000
ITER 2: row=1, varin=38, theta=3.000000, up=999999999999999983222784.000000
ITER 3: row=32, varin=37, theta=3.000000, up=999999999999999983222784.000000
ITER 4: row=37, varin=36, theta=1.500000, up=999999999999999983222784.000000
ITER 5: row=24, varin=33, theta=1.500000, up=999999999999999983222784.000000
ITER 6: row=33, varin=30, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 11 = 1 gives z=28462496.430109
  % 	x11 = 1,	Z1 = 28462496.430109         
DEBUG EVAL: First branch cutoff check: z=28462496.430109, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 11 = 0
ITER 1: row=31, varin=72, theta=0.500000, up=1.000000
  % 	x11 = 0,	Z0 = 28264427.3046058        
DEBUG EVAL: Second branch cutoff check: z=28264427.304606, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 4 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=29, varin=39, theta=7.000000, up=999999999999999983222784.000000
ITER 2: row=1, varin=38, theta=3.000000, up=999999999999999983222784.000000
ITER 3: row=32, varin=37, theta=3.000000, up=999999999999999983222784.000000
ITER 4: row=37, varin=36, theta=1.500000, up=999999999999999983222784.000000
ITER 5: row=24, varin=33, theta=1.500000, up=999999999999999983222784.000000
ITER 6: row=33, varin=29, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 4 = 1 gives z=28487223.111387
  % 	x4 = 1,	Z1 = 28487223.1113873        
DEBUG EVAL: First branch cutoff check: z=28487223.111387, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 4 = 0
ITER 1: row=29, varin=72, theta=0.500000, up=1.000000
  % 	x4 = 0,	Z0 = 28264427.3046058        
DEBUG EVAL: Second branch cutoff check: z=28264427.304606, best_z=INF, threshold=INF
  % Best branch is x3, Z0 = 28264427.3046058        , Z1 = 28528359.0962245        

DEBUG CAREFUL: Final result - returning best.var = 3
DEBUG BB: Branching variable chosen: j=3
 % @NC   71   45	x3 = 0	28264427.304606
 % @NC   72   45	x3 = 1	28528359.096225
 %      45    34 28250890.4508               28258041.1599   x34 D    30    10
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7ccbbd0
% @LO 0.04  28.25089045081255534342 99.9000000000
% @LN 0.04  28.25804115994336029871 99.9000000000
% Resuming node 51 at  28.25804115994336029871
DEBUG CONSTRNT: LP rows=39, pool->nlprows=39, pool->npend=0
DEBUG CONSTRNT: Checking 39 LP rows (pool tracks 39, total LP rows 39)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 133
DEBUG CONSTRNT: Pool row 133 has lprow=38, expected 38
 % @PAP adding 35 rows, 156 nz to LP
DEBUG BB: Processing node 51, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 51 LP 2 Solution, length = 28258041.159943, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.500000 (FST 9)
  % DEBUG LP_VARS: x[10] = 1.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.500000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.500000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.500000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.500000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.500000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.500000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 3 fractional variables
DEBUG CG: LP optimal, z=28258041.159943, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28258041.159943, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 51 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 51
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.500000
DEBUG CAREFUL: Adding var 9 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=1.000000
DEBUG CAREFUL: Skipping var 10: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.500000
DEBUG CAREFUL: Adding var 14 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.500000
DEBUG CAREFUL: Adding var 15 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 3 fractional variables

  %  Carefully choosing branching variable, nfrac = 3
DEBUG CAREFUL: Testing fvar[0] = var 14
DEBUG CAREFUL: Calling compare_branch_vars for var 14
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 14
DEBUG CAREFUL: New best var: 14
DEBUG CAREFUL: Testing fvar[1] = var 9
DEBUG CAREFUL: Calling compare_branch_vars for var 9
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 9
DEBUG CAREFUL: Testing fvar[2] = var 15
DEBUG CAREFUL: Calling compare_branch_vars for var 15
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 15
  % Initial guess is x14, Z0 = 28258041.1599434        , Z1 = 28258041.1599434        

DEBUG EVAL: Testing var 14 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=12, varin=33, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=18, varin=46, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 14 = 0 gives z=28285983.152602
  % 	x14 = 0,	Z0 = 28285983.1526019        
DEBUG EVAL: First branch cutoff check: z=28285983.152602, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 14 = 1
ITER 1: row=12, varin=30, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=34, varin=31, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=35, varin=28, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=18, varin=46, theta=1.000000, up=1.000000
  % 	x14 = 1,	Z1 = 28333283.17778          
DEBUG EVAL: Second branch cutoff check: z=28333283.177780, best_z=INF, threshold=INF
  %   New best:  x14, Z = 28285983.1526019        
DEBUG EVAL: Testing var 9 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=18, varin=46, theta=0.500000, up=1.000000
DEBUG EVAL: Branch var 9 = 0 gives z=28260571.788213
  % 	x9 = 0,	Z0 = 28260571.7882128        
DEBUG EVAL: First branch cutoff check: z=28260571.788213, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 15 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=27, varin=30, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=34, varin=31, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=35, varin=28, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=18, varin=44, theta=0.333333, up=1.000000
DEBUG EVAL: Branch var 15 = 0 gives z=28330749.035565
  % 	x15 = 0,	Z0 = 28330749.0355654        
DEBUG EVAL: First branch cutoff check: z=28330749.035565, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 15 = 1
ITER 1: row=27, varin=33, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=18, varin=46, theta=1.000000, up=1.000000
  % 	x15 = 1,	Z1 = 28285983.1526019        
DEBUG EVAL: Second branch cutoff check: z=28285983.152602, best_z=INF, threshold=INF
  % Best branch is x14, Z0 = 28285983.1526019        , Z1 = 28333283.17778          

DEBUG CAREFUL: Final result - returning best.var = 14
DEBUG BB: Branching variable chosen: j=14
 % @NC   73   51	x14 = 0	28285983.152602
 % @NC   74   51	x14 = 1	28333283.177780
 %      51    35 28258041.1599               28263235.5035   x16 D    16     7
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cd3ea0
% @LO 0.04  28.25804115994336029871 99.9000000000
% @LN 0.04  28.26323550347635205071 99.9000000000
% Resuming node 52 at  28.26323550347635205071
DEBUG CONSTRNT: LP rows=35, pool->nlprows=35, pool->npend=0
DEBUG CONSTRNT: Checking 35 LP rows (pool tracks 35, total LP rows 35)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=34, expected 34
 % @PAP adding 37 rows, 178 nz to LP
DEBUG BB: Processing node 52, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=22, varin=10, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=13, varin=21, theta=12.000000, up=999999999999999983222784.000000
ITER 3: row=18, varin=55, theta=0.352941, up=1.000000
ITER 4: row=13, varin=19, theta=0.088235, up=999999999999999983222784.000000
ITER 5: row=27, varin=38, theta=0.500000, up=1.000000
ITER 6: row=2, varin=16, theta=0.545455, up=999999999999999983222784.000000
ITER 7: row=26, varin=21, theta=3.818182, up=999999999999999983222784.000000
ITER 8: row=24, varin=79, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=8)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=37)
DEBUG SOLUTION: LP solution array indices: FST[38-77], not_covered[78-97]
DEBUG SOLUTION: lp->best_solution[0] = 28263235.503476
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 37 rows, 60 cols, 238 nonzeros, 3 slack, 34 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 15 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=38, varin=60, theta=0.333333, up=1.000000
ITER 2: row=21, varin=26, theta=0.041667, up=999999999999999983222784.000000
ITER 3: row=28, varin=25, theta=0.263158, up=999999999999999983222784.000000
ITER 4: row=21, varin=21, theta=0.052632, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=41)
DEBUG SOLUTION: LP solution array indices: FST[42-81], not_covered[82-101]
DEBUG SOLUTION: lp->best_solution[0] = 28277330.283552
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.947368
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.947368
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 41 rows, 60 cols, 253 nonzeros, 6 slack, 35 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 6 slack rows
  % @PAP adding 7 rows, 26 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=42, varin=31, theta=0.048276, up=999999999999999983222784.000000
ITER 2: row=37, varin=69, theta=0.759259, up=1.000000
ITER 3: row=36, varin=20, theta=0.092593, up=999999999999999983222784.000000
ITER 4: row=39, varin=22, theta=0.555556, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 28305888.618983
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 42 rows, 60 cols, 252 nonzeros, 3 slack, 39 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 3 rows, 7 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=40, varin=36, theta=0.555556, up=999999999999999983222784.000000
ITER 2: row=20, varin=79, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 28315191.772809
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 42 rows, 60 cols, 243 nonzeros, 0 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=43, varin=47, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 28317515.181354
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 43 rows, 60 cols, 247 nonzeros, 0 slack, 43 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 6 rows, 31 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=44, varin=39, theta=0.833333, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 28320548.475444
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 49 rows, 60 cols, 278 nonzeros, 4 slack, 45 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % Node 52 LP 1 Solution, length = 28320548.475444, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.166667 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.166667 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.166667 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 1.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.166667 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.166667 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.166667 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.833333 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.833333 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.833333 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.833333 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.833333 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.833333 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.833333 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28320548.475444, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 52 at  28.32054847544436171347
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cc5d40
% @LO 0.04  28.26323550347635205071 99.9000000000
% @LN 0.04  28.26442730460584229490 99.9000000000
% Resuming node 71 at  28.26442730460584229490
DEBUG CONSTRNT: LP rows=45, pool->nlprows=45, pool->npend=0
DEBUG CONSTRNT: Checking 45 LP rows (pool tracks 45, total LP rows 45)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 49
DEBUG CONSTRNT: Pool row 49 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 68
DEBUG CONSTRNT: Pool row 68 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 82
DEBUG CONSTRNT: Pool row 82 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=44, expected 44
 % @PAP adding 39 rows, 165 nz to LP
DEBUG BB: Processing node 71, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=17, varin=72, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=39)
DEBUG SOLUTION: LP solution array indices: FST[40-79], not_covered[80-99]
DEBUG SOLUTION: lp->best_solution[0] = 28264427.304606
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 39 rows, 60 cols, 225 nonzeros, 0 slack, 39 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 7 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=40, varin=63, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=41)
DEBUG SOLUTION: LP solution array indices: FST[42-81], not_covered[82-101]
DEBUG SOLUTION: lp->best_solution[0] = 28264822.100532
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 41 rows, 60 cols, 232 nonzeros, 0 slack, 41 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=42, varin=3, theta=0.250000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 28267874.532715
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.750000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 42 rows, 60 cols, 236 nonzeros, 3 slack, 39 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 1 rows, 40 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=40, varin=23, theta=0.030957, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=40)
DEBUG SOLUTION: LP solution array indices: FST[41-80], not_covered[81-100]
DEBUG SOLUTION: lp->best_solution[0] = 28268031.216206
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 40 rows, 60 cols, 263 nonzeros, 2 slack, 38 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % Node 71 LP 1 Solution, length = 28268031.216206, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.250000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.250000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.500000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.969043 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.969043 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.500000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.250000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.250000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.750000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.750000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.750000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.500000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.750000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.030957 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.030957 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.500000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.030957 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.030957 (terminal 19)
 % 8 fractional variables
DEBUG CG: LP optimal, z=28268031.216206, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
 % @LO 0.04  28.26442730460584229490 99.9000000000
 % @LN 0.04  28.26803121620643821643 99.9000000000
DEBUG CG: Second cutoff check: z=28268031.216206, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 71 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 71
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.250000
DEBUG CAREFUL: Adding var 0 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.250000
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.500000
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.969043
DEBUG CAREFUL: Adding var 9 to fractional list (xi=0.969043)
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.969043
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.969043)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.500000
DEBUG CAREFUL: Adding var 27 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.250000
DEBUG CAREFUL: Adding var 29 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.250000
DEBUG CAREFUL: Adding var 32 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 8 fractional variables

  %  Carefully choosing branching variable, nfrac = 8
DEBUG CAREFUL: Testing fvar[0] = var 27
DEBUG CAREFUL: Calling compare_branch_vars for var 27
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 27
DEBUG CAREFUL: New best var: 27
DEBUG CAREFUL: Testing fvar[1] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[2] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 1
DEBUG CAREFUL: Testing fvar[3] = var 0
DEBUG CAREFUL: Calling compare_branch_vars for var 0
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 0
DEBUG CAREFUL: Testing fvar[4] = var 29
DEBUG CAREFUL: Calling compare_branch_vars for var 29
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 29
DEBUG CAREFUL: Testing fvar[5] = var 32
DEBUG CAREFUL: Calling compare_branch_vars for var 32
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 32
DEBUG CAREFUL: Testing fvar[6] = var 9
DEBUG CAREFUL: Calling compare_branch_vars for var 9
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 9
DEBUG CAREFUL: Testing fvar[7] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
  % Initial guess is x27, Z0 = 28268031.2162064        , Z1 = 28624869.195453         

DEBUG EVAL: Testing var 27 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=18, varin=16, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 27 = 1 gives z=28659801.598446
  % 	x27 = 1,	Z1 = 28659801.5984459        
DEBUG EVAL: First branch cutoff check: z=28659801.598446, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 27 = 0
ITER 1: row=18, varin=35, theta=1.000000, up=999999999999999983222784.000000
  % 	x27 = 0,	Z0 = 28286575.3520621        
DEBUG EVAL: Second branch cutoff check: z=28286575.352062, best_z=INF, threshold=INF
  %   New best:  x27, Z = 28286575.3520621        
DEBUG EVAL: Testing var 2 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=3, varin=34, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 1 gives z=28323695.225106
  % 	x2 = 1,	Z1 = 28323695.2251061        
DEBUG EVAL: First branch cutoff check: z=28323695.225106, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 0
ITER 1: row=3, varin=35, theta=1.000000, up=999999999999999983222784.000000
  % 	x2 = 0,	Z0 = 28286575.3520621        
DEBUG EVAL: Second branch cutoff check: z=28286575.352062, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 1 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=2, varin=64, theta=0.500000, up=1.000000
ITER 2: row=13, varin=38, theta=167762.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 1 = 0 gives z=28279240.398690
  % 	x1 = 0,	Z0 = 28279240.3986897        
DEBUG EVAL: First branch cutoff check: z=28279240.398690, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 0 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=64, theta=0.500000, up=1.000000
ITER 2: row=13, varin=38, theta=167762.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 0 = 0 gives z=28279240.398690
  % 	x0 = 0,	Z0 = 28279240.3986897        
DEBUG EVAL: First branch cutoff check: z=28279240.398690, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 29 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=29, varin=64, theta=0.500000, up=1.000000
ITER 2: row=13, varin=38, theta=167762.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 29 = 0 gives z=28279240.398690
  % 	x29 = 0,	Z0 = 28279240.3986897        
DEBUG EVAL: First branch cutoff check: z=28279240.398690, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 32 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=34, varin=37, theta=1.500000, up=999999999999999983222784.000000
ITER 2: row=37, varin=35, theta=3.000000, up=999999999999999983222784.000000
ITER 3: row=3, varin=34, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=18, varin=33, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=33, varin=29, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 32 = 1 gives z=28393491.854657
  % 	x32 = 1,	Z1 = 28393491.8546575        
DEBUG EVAL: First branch cutoff check: z=28393491.854657, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 32 = 0
ITER 1: row=34, varin=36, theta=0.500000, up=999999999999999983222784.000000
  % 	x32 = 0,	Z0 = 28272243.9600354        
DEBUG EVAL: Second branch cutoff check: z=28272243.960035, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 9 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=16, varin=64, theta=0.075574, up=1.000000
DEBUG EVAL: Branch var 9 = 1 gives z=28269592.461555
  % 	x9 = 1,	Z1 = 28269592.4615547        
DEBUG EVAL: First branch cutoff check: z=28269592.461555, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 10 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=13, varin=64, theta=0.075574, up=1.000000
DEBUG EVAL: Branch var 10 = 1 gives z=28269592.461555
  % 	x10 = 1,	Z1 = 28269592.4615547        
DEBUG EVAL: First branch cutoff check: z=28269592.461555, best_z=INF, threshold=INF
  % Best branch is x27, Z0 = 28286575.3520621        , Z1 = 28659801.5984459        

DEBUG CAREFUL: Final result - returning best.var = 27
DEBUG BB: Branching variable chosen: j=27
 % @NC   75   71	x27 = 0	28286575.352062
 % @NC   76   71	x27 = 1	28659801.598446
 %      71    36 28268031.2162               28275393.9320    x3 D    45    11
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cc9b80
% @LO 0.04  28.26803121620643821643 99.9000000000
% @LN 0.04  28.27539393196060402147 99.9000000000
% Resuming node 28 at  28.27539393196060402147
DEBUG CONSTRNT: LP rows=38, pool->nlprows=38, pool->npend=0
DEBUG CONSTRNT: Checking 38 LP rows (pool tracks 38, total LP rows 38)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 133
DEBUG CONSTRNT: Pool row 133 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=37, expected 37
 % @PAP adding 42 rows, 172 nz to LP
DEBUG BB: Processing node 28, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=21, varin=39, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=39, varin=15, theta=2.000000, up=999999999999999983222784.000000
ITER 3: row=15, varin=23, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=37, varin=33, theta=2.000000, up=999999999999999983222784.000000
ITER 5: row=33, varin=24, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=38, varin=29, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=40, varin=2, theta=0.400000, up=999999999999999983222784.000000
ITER 8: row=29, varin=25, theta=0.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=8)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 28275393.931961
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 42 rows, 60 cols, 232 nonzeros, 6 slack, 36 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 54 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=46, varin=47, theta=0.699747, up=1.000000
ITER 2: row=29, varin=17, theta=0.881796, up=999999999999999983222784.000000
ITER 3: row=43, varin=73, theta=1.000000, up=1.000000
ITER 4: row=35, varin=83, theta=1.000000, up=1.000000
ITER 5: row=15, varin=3, theta=1.500000, up=999999999999999983222784.000000
ITER 6: row=31, varin=48, theta=1.500000, up=1.000000
ITER 7: row=31, varin=70, theta=0.333333, up=1.000000
ITER 8: row=16, varin=48, theta=0.790998, up=1.000000
ITER 9: row=42, varin=56, theta=1.231788, up=1.000000
ITER 10: row=42, varin=76, theta=0.169386, up=1.000000
LP PHASE: Switching to primal (iter=20)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=46)
DEBUG SOLUTION: LP solution array indices: FST[47-86], not_covered[87-106]
DEBUG SOLUTION: lp->best_solution[0] = 28579222.135371
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 46 rows, 60 cols, 286 nonzeros, 4 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=43, varin=37, theta=0.666667, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 28583758.900652
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 43 rows, 60 cols, 242 nonzeros, 3 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 5 rows, 49 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=45, varin=17, theta=0.345017, up=999999999999999983222784.000000
ITER 2: row=41, varin=67, theta=1.000000, up=1.000000
ITER 3: row=13, varin=78, theta=1.000000, up=1.000000
ITER 4: row=45, varin=13, theta=0.094131, up=999999999999999983222784.000000
ITER 5: row=41, varin=45, theta=12445.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 28644557.196533
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 45 rows, 60 cols, 280 nonzeros, 2 slack, 43 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 2 rows, 7 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=44, varin=67, theta=1.000000, up=1.000000
ITER 2: row=13, varin=28, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 28651451.652750
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 45 rows, 60 cols, 245 nonzeros, 2 slack, 43 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 1 rows, 40 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=44, varin=101, theta=0.872719, up=1.000000
ITER 2: row=34, varin=17, theta=0.733620, up=999999999999999983222784.000000
ITER 3: row=14, varin=75, theta=0.914320, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28702071.873134
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 44 rows, 60 cols, 274 nonzeros, 0 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 15 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=45, varin=82, theta=1.318987, up=1.000000
ITER 2: row=45, varin=72, theta=0.185559, up=1.000000
ITER 3: row=48, varin=82, theta=0.931917, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 28725698.772232
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 48 rows, 60 cols, 289 nonzeros, 0 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=50, varin=48, theta=1.078044, up=999999999999999983222784.000000
ITER 2: row=49, varin=79, theta=0.520699, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28748268.661850
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 50 rows, 60 cols, 295 nonzeros, 0 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 5 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=51, varin=34, theta=0.609136, up=999999999999999983222784.000000
ITER 2: row=3, varin=83, theta=0.195278, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 28782906.829512
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 51 rows, 60 cols, 300 nonzeros, 1 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 2 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=51, varin=76, theta=0.966371, up=1.000000
ITER 2: row=52, varin=67, theta=2.213200, up=1.000000
ITER 3: row=52, varin=22, theta=0.198293, up=999999999999999983222784.000000
ITER 4: row=11, varin=67, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 28879479.683889
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 52 rows, 60 cols, 302 nonzeros, 1 slack, 51 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 28 LP 1 Solution, length = 28879479.683889, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.127652 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.127652 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.638260 (FST 2)
  % DEBUG LP_VARS: x[3] = 1.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.127652 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.127652 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.361740 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.127652 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.127652 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.361740 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.127652 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.127652 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.872348 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.872348 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.872348 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.872348 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.361740 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 0.872348 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 11 fractional variables
DEBUG CG: LP optimal, z=28879479.683889, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 28 at  28.87947968388858299704
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cac0a0
% @LO 0.04  28.27539393196060402147 99.9000000000
% @LN 0.04  28.28019392752971583604 99.9000000000
% Resuming node 22 at  28.28019392752971583604
DEBUG CONSTRNT: LP rows=51, pool->nlprows=51, pool->npend=0
DEBUG CONSTRNT: Checking 51 LP rows (pool tracks 51, total LP rows 51)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 133
DEBUG CONSTRNT: Pool row 133 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 134
DEBUG CONSTRNT: Pool row 134 has lprow=50, expected 50
 % @PAP adding 33 rows, 140 nz to LP
DEBUG BB: Processing node 22, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=23, varin=27, theta=3.000000, up=999999999999999983222784.000000
ITER 2: row=5, varin=50, theta=3.000000, up=1.000000
ITER 3: row=5, varin=25, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=15, varin=50, theta=1.000000, up=1.000000
ITER 5: row=25, varin=2, theta=0.400000, up=999999999999999983222784.000000
ITER 6: row=27, varin=23, theta=0.333333, up=999999999999999983222784.000000
ITER 7: row=21, varin=20, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=7)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=33)
DEBUG SOLUTION: LP solution array indices: FST[34-73], not_covered[74-93]
DEBUG SOLUTION: lp->best_solution[0] = 28280193.927530
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 33 rows, 60 cols, 200 nonzeros, 3 slack, 30 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 20 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=34, varin=16, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=36, varin=18, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=37)
DEBUG SOLUTION: LP solution array indices: FST[38-77], not_covered[78-97]
DEBUG SOLUTION: lp->best_solution[0] = 28346987.483622
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 37 rows, 60 cols, 220 nonzeros, 6 slack, 31 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 6 slack rows
  % @PAP adding 1 rows, 40 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=32, varin=20, theta=1.310894, up=999999999999999983222784.000000
ITER 2: row=1, varin=50, theta=0.397885, up=1.000000
ITER 3: row=21, varin=33, theta=0.746874, up=1.000000
ITER 4: row=23, varin=48, theta=0.464622, up=1.000000
ITER 5: row=15, varin=76, theta=0.868136, up=1.000000
ITER 6: row=20, varin=59, theta=0.709921, up=1.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=32)
DEBUG SOLUTION: LP solution array indices: FST[33-72], not_covered[73-92]
DEBUG SOLUTION: lp->best_solution[0] = 28457404.769584
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 32 rows, 60 cols, 236 nonzeros, 1 slack, 31 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 5 rows, 20 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=32, varin=40, theta=0.611775, up=1.000000
ITER 2: row=34, varin=71, theta=1.000000, up=1.000000
ITER 3: row=1, varin=60, theta=0.465723, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=36)
DEBUG SOLUTION: LP solution array indices: FST[37-76], not_covered[77-96]
DEBUG SOLUTION: lp->best_solution[0] = 28554458.422550
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 36 rows, 60 cols, 254 nonzeros, 0 slack, 36 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 6 rows, 24 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=39, varin=60, theta=0.311949, up=1.000000
ITER 2: row=37, varin=79, theta=1.000000, up=1.000000
ITER 3: row=38, varin=52, theta=0.500000, up=1.000000
ITER 4: row=20, varin=72, theta=0.830421, up=1.000000
ITER 5: row=25, varin=67, theta=1.287972, up=1.000000
ITER 6: row=25, varin=70, theta=0.180243, up=1.000000
ITER 7: row=42, varin=67, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=7)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 28637180.031992
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 42 rows, 60 cols, 278 nonzeros, 1 slack, 41 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=42, varin=64, theta=0.702076, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 28655944.469560
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 42 rows, 60 cols, 271 nonzeros, 0 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=43, varin=69, theta=0.762643, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 28698038.802787
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 43 rows, 60 cols, 275 nonzeros, 0 slack, 43 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 5 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=44, varin=7, theta=0.226610, up=999999999999999983222784.000000
ITER 2: row=25, varin=59, theta=0.094789, up=1.000000
ITER 3: row=15, varin=67, theta=0.083780, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28714677.281496
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 0.800000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 44 rows, 60 cols, 280 nonzeros, 2 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 5 rows, 16 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=46, varin=77, theta=1.000000, up=1.000000
ITER 2: row=43, varin=20, theta=0.741408, up=999999999999999983222784.000000
ITER 3: row=36, varin=80, theta=0.731801, up=1.000000
ITER 4: row=22, varin=76, theta=0.537237, up=1.000000
ITER 5: row=38, varin=35, theta=0.200000, up=999999999999999983222784.000000
ITER 6: row=1, varin=84, theta=0.673676, up=1.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 28816650.275356
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 47 rows, 60 cols, 292 nonzeros, 2 slack, 45 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 4 rows, 18 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=49, varin=51, theta=0.863458, up=1.000000
ITER 2: row=28, varin=52, theta=0.739826, up=1.000000
ITER 3: row=2, varin=86, theta=1.250000, up=1.000000
ITER 4: row=2, varin=36, theta=0.105263, up=999999999999999983222784.000000
ITER 5: row=47, varin=86, theta=1.000000, up=1.000000
ITER 6: row=36, varin=59, theta=0.357143, up=1.000000
ITER 7: row=16, varin=20, theta=0.138332, up=999999999999999983222784.000000
ITER 8: row=46, varin=47, theta=0.212251, up=999999999999999983222784.000000
ITER 9: row=43, varin=81, theta=0.383586, up=1.000000
LP PHASE: Switching to primal (iter=9)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 28976021.585611
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 49 rows, 60 cols, 306 nonzeros, 3 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 2 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=47, varin=102, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 28999300.689185
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 48 rows, 60 cols, 299 nonzeros, 1 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=48, varin=65, theta=0.183650, up=1.000000
ITER 2: row=14, varin=53, theta=0.308550, up=1.000000
ITER 3: row=31, varin=43, theta=0.099072, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 29012658.389369
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 48 rows, 60 cols, 297 nonzeros, 3 slack, 45 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 2 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=46, varin=104, theta=0.247682, up=1.000000
ITER 2: row=3, varin=78, theta=0.280792, up=1.000000
ITER 3: row=47, varin=6, theta=0.033033, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 29068869.129449
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.966967
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 47 rows, 60 cols, 294 nonzeros, 1 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 2 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=48, varin=72, theta=0.687918, up=1.000000
ITER 2: row=33, varin=82, theta=0.106065, up=1.000000
ITER 3: row=15, varin=46, theta=0.112645, up=999999999999999983222784.000000
ITER 4: row=2, varin=29, theta=0.015433, up=999999999999999983222784.000000
ITER 5: row=47, varin=50, theta=0.143127, up=1.000000
ITER 6: row=29, varin=41, theta=0.206324, up=999999999999999983222784.000000
ITER 7: row=31, varin=48, theta=0.036655, up=999999999999999983222784.000000
ITER 8: row=47, varin=57, theta=0.647666, up=1.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 999999999999999983222784.000000
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.966967
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 48 rows, 60 cols, 296 nonzeros, 2 slack, 46 tight.
  % Node 22 LP 1 Solution, length = 999999999999999983222784.000000, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.099099 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.500000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.051801 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 1.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.500000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.099099 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.297298 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.500000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.132133 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.051801 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.867867 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.900901 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.900901 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.948199 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.500000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
DEBUG BB: compute_good_lower_bound returned status=1
DEBUG BB: Node 22 is INFEASIBLE
 %      22    35    infeasible               28282346.6232   x18 U    15     7
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7ca0600
% @LO 0.04  28.28019392752971583604 99.9000000000
% @LN 0.04  28.28234662320145531567 99.9000000000
% Resuming node 49 at  28.28234662320145531567
DEBUG CONSTRNT: LP rows=48, pool->nlprows=48, pool->npend=0
DEBUG CONSTRNT: Checking 48 LP rows (pool tracks 48, total LP rows 48)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 145
DEBUG CONSTRNT: Pool row 145 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 159
DEBUG CONSTRNT: Pool row 159 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 133
DEBUG CONSTRNT: Pool row 133 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 134
DEBUG CONSTRNT: Pool row 134 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=47, expected 47
 % @PAP adding 29 rows, 176 nz to LP
DEBUG BB: Processing node 49, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 49 LP 2 Solution, length = 28282346.623201, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.025329 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.337555 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.337555 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.324890 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.324890 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.675110 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 1.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.662445 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.324890 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.324890 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.324890 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.662445 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.974671 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.675110 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.324890 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28282346.623201, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28282346.623201, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 49 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 49
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.025329
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.025329)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.337555
DEBUG CAREFUL: Adding var 5 to fractional list (xi=0.337555)
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.337555
DEBUG CAREFUL: Adding var 7 to fractional list (xi=0.337555)
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.324890
DEBUG CAREFUL: Adding var 8 to fractional list (xi=0.324890)
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.324890
DEBUG CAREFUL: Adding var 12 to fractional list (xi=0.324890)
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.675110
DEBUG CAREFUL: Adding var 14 to fractional list (xi=0.675110)
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=1.000000
DEBUG CAREFUL: Skipping var 20: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 6 fractional variables

  %  Carefully choosing branching variable, nfrac = 6
DEBUG CAREFUL: Testing fvar[0] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 2
DEBUG CAREFUL: New best var: 2
DEBUG CAREFUL: Testing fvar[1] = var 8
DEBUG CAREFUL: Calling compare_branch_vars for var 8
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 8
DEBUG CAREFUL: New best var: 8
DEBUG CAREFUL: Testing fvar[2] = var 14
DEBUG CAREFUL: Calling compare_branch_vars for var 14
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 14
DEBUG CAREFUL: Testing fvar[3] = var 5
DEBUG CAREFUL: Calling compare_branch_vars for var 5
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 5
DEBUG CAREFUL: Testing fvar[4] = var 7
DEBUG CAREFUL: Calling compare_branch_vars for var 7
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 7
DEBUG CAREFUL: Testing fvar[5] = var 12
DEBUG CAREFUL: Calling compare_branch_vars for var 12
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 12
  % Initial guess is x8, Z0 = 28282346.6232015        , Z1 = 28367234.3753708        

DEBUG EVAL: Testing var 2 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=7, theta=1.384437, up=999999999999999983222784.000000
ITER 2: row=8, varin=15, theta=0.730085, up=999999999999999983222784.000000
ITER 3: row=13, varin=29, theta=1.540413, up=999999999999999983222784.000000
ITER 4: row=19, varin=28, theta=0.488917, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 1 gives z=28331670.136333
  % 	x2 = 1,	Z1 = 28331670.1363326        
DEBUG EVAL: First branch cutoff check: z=28331670.136333, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 0
ITER 1: row=1, varin=12, theta=0.016775, up=999999999999999983222784.000000
  % 	x2 = 0,	Z0 = 28282386.7997851        
DEBUG EVAL: Second branch cutoff check: z=28282386.799785, best_z=INF, threshold=INF
  %   New best:  x2, Z = 28282386.7997851        
DEBUG EVAL: Testing var 8 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=12, varin=26, theta=3.082114, up=999999999999999983222784.000000
ITER 2: row=18, varin=20, theta=750527.000000, up=999999999999999983222784.000000
ITER 3: row=27, varin=74, theta=2.000000, up=1.000000
ITER 4: row=27, varin=18, theta=0.500000, up=999999999999999983222784.000000
ITER 5: row=1, varin=29, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 8 = 1 gives z=28367234.375371
  % 	x8 = 1,	Z1 = 28367234.3753708        
DEBUG EVAL: First branch cutoff check: z=28367234.375371, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 8 = 0
ITER 1: row=12, varin=12, theta=0.654088, up=999999999999999983222784.000000
ITER 2: row=27, varin=7, theta=0.678907, up=999999999999999983222784.000000
ITER 3: row=7, varin=28, theta=0.407168, up=999999999999999983222784.000000
  % 	x8 = 0,	Z0 = 28318067.4824353        
DEBUG EVAL: Second branch cutoff check: z=28318067.482435, best_z=INF, threshold=INF
  %   New best:  x8, Z = 28318067.4824353        
DEBUG EVAL: Testing var 14 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=21, varin=39, theta=2.001427, up=1.000000
ITER 2: row=21, varin=28, theta=0.720183, up=999999999999999983222784.000000
ITER 3: row=18, varin=7, theta=0.692712, up=999999999999999983222784.000000
ITER 4: row=7, varin=27, theta=0.760370, up=999999999999999983222784.000000
ITER 5: row=20, varin=30, theta=1.577592, up=1.000000
ITER 6: row=20, varin=39, theta=0.938871, up=1.000000
ITER 7: row=2, varin=30, theta=1.000000, up=1.000000
ITER 8: row=27, varin=15, theta=1.636343, up=999999999999999983222784.000000
ITER 9: row=13, varin=47, theta=0.719733, up=1.000000
ITER 10: row=20, varin=83, theta=2.430034, up=1.000000
DEBUG EVAL: Branch var 14 = 1 gives z=28438399.113253
  % 	x14 = 1,	Z1 = 28438399.1132531        
DEBUG EVAL: First branch cutoff check: z=28438399.113253, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 14 = 0
ITER 1: row=21, varin=12, theta=1.341386, up=999999999999999983222784.000000
ITER 2: row=27, varin=18, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=1, varin=29, theta=2.000000, up=999999999999999983222784.000000
ITER 4: row=19, varin=26, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=26, varin=74, theta=0.164577, up=1.000000
  % 	x14 = 0,	Z0 = 28355128.8428709        
DEBUG EVAL: Second branch cutoff check: z=28355128.842871, best_z=INF, threshold=INF
  %   New best:  x14, Z = 28355128.8428709        
DEBUG EVAL: Testing var 5 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=18, varin=26, theta=0.553804, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 5 = 0 gives z=28303460.899572
  % 	x5 = 0,	Z0 = 28303460.8995724        
DEBUG EVAL: First branch cutoff check: z=28303460.899572, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 7 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=20, varin=27, theta=0.667151, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 7 = 0 gives z=28291761.945870
  % 	x7 = 0,	Z0 = 28291761.9458705        
DEBUG EVAL: First branch cutoff check: z=28291761.945870, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 12 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=19, varin=29, theta=0.370213, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 12 = 0 gives z=28294128.508935
  % 	x12 = 0,	Z0 = 28294128.5089352        
DEBUG EVAL: First branch cutoff check: z=28294128.508935, best_z=INF, threshold=INF
  % Best branch is x14, Z0 = 28355128.8428709        , Z1 = 28438399.1132531        

DEBUG CAREFUL: Final result - returning best.var = 14
DEBUG BB: Branching variable chosen: j=14
 % @NC   77   49	x14 = 0	28355128.842871
 % @NC   78   49	x14 = 1	28438399.113253
 %      49    36 28282346.6232               28285983.1526   x16 D    32     3
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cb66c0
% @LO 0.04  28.28234662320145531567 99.9000000000
% @LN 0.04  28.28598315260189366427 99.9000000000
% Resuming node 73 at  28.28598315260189366427
DEBUG CONSTRNT: LP rows=29, pool->nlprows=29, pool->npend=0
DEBUG CONSTRNT: Checking 29 LP rows (pool tracks 29, total LP rows 29)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=28, expected 28
 % @PAP adding 35 rows, 156 nz to LP
DEBUG BB: Processing node 73, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=12, varin=33, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=18, varin=46, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=35)
DEBUG SOLUTION: LP solution array indices: FST[36-75], not_covered[76-95]
DEBUG SOLUTION: lp->best_solution[0] = 28285983.152602
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 35 rows, 60 cols, 216 nonzeros, 3 slack, 32 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=36, varin=46, theta=0.333333, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=37)
DEBUG SOLUTION: LP solution array indices: FST[38-77], not_covered[78-97]
DEBUG SOLUTION: lp->best_solution[0] = 28299215.685447
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 37 rows, 60 cols, 224 nonzeros, 4 slack, 33 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % @PAP adding 3 rows, 20 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=34, varin=46, theta=0.333333, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=36)
DEBUG SOLUTION: LP solution array indices: FST[37-76], not_covered[77-96]
DEBUG SOLUTION: lp->best_solution[0] = 28300902.770960
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 36 rows, 60 cols, 232 nonzeros, 0 slack, 36 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 73 LP 1 Solution, length = 28300902.770960, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.333333 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.666667 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.666667 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.666667 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.333333 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.333333 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.333333 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.333333 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.333333 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.333333 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.333333 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.333333 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=28300902.770960, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 73 at  28.30090277095968431809
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7ccbbd0
% @LO 0.04  28.28598315260189366427 99.9000000000
% @LN 0.04  28.28657535206206219414 99.9000000000
% Resuming node 75 at  28.28657535206206219414
DEBUG CONSTRNT: LP rows=36, pool->nlprows=36, pool->npend=0
DEBUG CONSTRNT: Checking 36 LP rows (pool tracks 36, total LP rows 36)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 63
DEBUG CONSTRNT: Pool row 63 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=35, expected 35
 % @PAP adding 38 rows, 185 nz to LP
DEBUG BB: Processing node 75, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=18, varin=35, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=38)
DEBUG SOLUTION: LP solution array indices: FST[39-78], not_covered[79-98]
DEBUG SOLUTION: lp->best_solution[0] = 28286575.352062
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 38 rows, 60 cols, 245 nonzeros, 1 slack, 37 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=39, varin=36, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=40)
DEBUG SOLUTION: LP solution array indices: FST[41-80], not_covered[81-100]
DEBUG SOLUTION: lp->best_solution[0] = 28295000.839720
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 40 rows, 60 cols, 251 nonzeros, 2 slack, 38 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 2 rows, 5 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=39, varin=66, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=40)
DEBUG SOLUTION: LP solution array indices: FST[41-80], not_covered[81-100]
DEBUG SOLUTION: lp->best_solution[0] = 28301117.339436
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 40 rows, 60 cols, 252 nonzeros, 0 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 5 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=41, varin=34, theta=0.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=41)
DEBUG SOLUTION: LP solution array indices: FST[42-81], not_covered[82-101]
DEBUG SOLUTION: lp->best_solution[0] = 28305135.288584
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 41 rows, 60 cols, 257 nonzeros, 2 slack, 39 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % Node 75 LP 1 Solution, length = 28305135.288584, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.500000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.500000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.500000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.773575 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.773575 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.500000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.500000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.500000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.500000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.500000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.500000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.500000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.226425 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.226425 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.500000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.226425 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.226425 (terminal 19)
 % 7 fractional variables
DEBUG CG: LP optimal, z=28305135.288584, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 75 at  28.30513528858408278666
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cb66c0
% @LO 0.04  28.28657535206206219414 99.9000000000
% @LN 0.04  28.30090277095968431809 99.9000000000
% Resuming node 73 at  28.30090277095968431809
DEBUG CONSTRNT: LP rows=39, pool->nlprows=39, pool->npend=0
DEBUG CONSTRNT: Checking 39 LP rows (pool tracks 39, total LP rows 39)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 142
DEBUG CONSTRNT: Pool row 142 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 143
DEBUG CONSTRNT: Pool row 143 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=38, expected 38
 % @PAP adding 36 rows, 172 nz to LP
DEBUG BB: Processing node 73, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 73 LP 2 Solution, length = 28300902.770960, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.333333 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.666667 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.666667 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.666667 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.333333 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.333333 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.333333 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.333333 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.333333 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.333333 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.333333 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.333333 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=28300902.770960, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28300902.770960, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 73 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 73
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.333333
DEBUG CAREFUL: Adding var 8 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.666667
DEBUG CAREFUL: Adding var 9 to fractional list (xi=0.666667)
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.666667
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.666667)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.666667
DEBUG CAREFUL: Adding var 15 to fractional list (xi=0.666667)
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 4 fractional variables

  %  Carefully choosing branching variable, nfrac = 4
DEBUG CAREFUL: Testing fvar[0] = var 8
DEBUG CAREFUL: Calling compare_branch_vars for var 8
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 8
DEBUG CAREFUL: New best var: 8
DEBUG CAREFUL: Testing fvar[1] = var 9
DEBUG CAREFUL: Calling compare_branch_vars for var 9
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 9
DEBUG CAREFUL: Testing fvar[2] = var 15
DEBUG CAREFUL: Calling compare_branch_vars for var 15
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 15
DEBUG CAREFUL: Testing fvar[3] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
  % Initial guess is x8, Z0 = 28300902.7709597        , Z1 = 28346616.5592845        

DEBUG EVAL: Testing var 8 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=12, varin=33, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=13, varin=34, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=18, varin=19, theta=0.571429, up=999999999999999983222784.000000
ITER 4: row=1, varin=38, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 8 = 1 gives z=28344713.475423
  % 	x8 = 1,	Z1 = 28346616.5592845        
DEBUG EVAL: First branch cutoff check: z=28346616.559285, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 8 = 0
ITER 1: row=12, varin=20, theta=12.000000, up=999999999999999983222784.000000
ITER 2: row=17, varin=54, theta=0.352941, up=1.000000
ITER 3: row=24, varin=37, theta=0.500000, up=1.000000
ITER 4: row=2, varin=15, theta=0.545455, up=999999999999999983222784.000000
ITER 5: row=23, varin=18, theta=1.090909, up=999999999999999983222784.000000
ITER 6: row=21, varin=78, theta=1.000000, up=1.000000
  % 	x8 = 0,	Z0 = 28383892.4973269        
DEBUG EVAL: Second branch cutoff check: z=28383892.497327, best_z=INF, threshold=INF
  %   New best:  x8, Z = 28346616.5592845        
DEBUG EVAL: Testing var 9 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=18, varin=20, theta=12.000000, up=999999999999999983222784.000000
ITER 2: row=17, varin=54, theta=0.352941, up=1.000000
ITER 3: row=24, varin=37, theta=0.500000, up=1.000000
ITER 4: row=2, varin=31, theta=0.500000, up=999999999999999983222784.000000
ITER 5: row=35, varin=15, theta=0.545455, up=999999999999999983222784.000000
ITER 6: row=23, varin=18, theta=1.090909, up=999999999999999983222784.000000
ITER 7: row=21, varin=78, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 9 = 1 gives z=28383892.497327
  % 	x9 = 1,	Z1 = 28383892.4973269        
DEBUG EVAL: First branch cutoff check: z=28383892.497327, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 9 = 0
ITER 1: row=18, varin=34, theta=0.666667, up=999999999999999983222784.000000
  % 	x9 = 0,	Z0 = 28304276.9419857        
DEBUG EVAL: Second branch cutoff check: z=28304276.941986, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 15 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=27, varin=20, theta=12.000000, up=999999999999999983222784.000000
ITER 2: row=17, varin=54, theta=0.352941, up=1.000000
ITER 3: row=24, varin=37, theta=0.500000, up=1.000000
ITER 4: row=2, varin=15, theta=0.545455, up=999999999999999983222784.000000
ITER 5: row=23, varin=18, theta=1.090909, up=999999999999999983222784.000000
ITER 6: row=21, varin=78, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 15 = 1 gives z=28383892.497327
  % 	x15 = 1,	Z1 = 28383892.4973269        
DEBUG EVAL: First branch cutoff check: z=28383892.497327, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 15 = 0
ITER 1: row=27, varin=33, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=13, varin=34, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=18, varin=19, theta=0.571429, up=999999999999999983222784.000000
ITER 4: row=1, varin=38, theta=1.000000, up=1.000000
  % 	x15 = 0,	Z0 = 28344713.4754234        
DEBUG EVAL: Second branch cutoff check: z=28344713.475423, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 10 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=13, varin=20, theta=12.000000, up=999999999999999983222784.000000
ITER 2: row=17, varin=33, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 1 gives z=28308362.580139
  % 	x10 = 1,	Z1 = 28308362.5801386        
DEBUG EVAL: First branch cutoff check: z=28308362.580139, best_z=INF, threshold=INF
  % Best branch is x8, Z0 = 28383892.4973269        , Z1 = 28346616.5592845        

DEBUG CAREFUL: Final result - returning best.var = 8
DEBUG BB: Branching variable chosen: j=8
 % @NC   79   73	x8 = 1	28346616.559285
 % @NC   80   73	x8 = 0	28383892.497327
 %      73    37 28300902.7710               28305135.2886   x14 D    51     8
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7ccbbd0
% @LO 0.04  28.30090277095968431809 99.9000000000
% @LN 0.04  28.30513528858408278666 99.9000000000
% Resuming node 75 at  28.30513528858408278666
DEBUG CONSTRNT: LP rows=36, pool->nlprows=36, pool->npend=0
DEBUG CONSTRNT: Checking 36 LP rows (pool tracks 36, total LP rows 36)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 63
DEBUG CONSTRNT: Pool row 63 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=35, expected 35
 % @PAP adding 39 rows, 191 nz to LP
DEBUG BB: Processing node 75, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 75 LP 2 Solution, length = 28305135.288584, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.500000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.500000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.500000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.773575 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.773575 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.500000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.500000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.500000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.500000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.500000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.500000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.500000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.226425 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.226425 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.500000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.226425 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.226425 (terminal 19)
 % 7 fractional variables
DEBUG CG: LP optimal, z=28305135.288584, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28305135.288584, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 75 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 75
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.500000
DEBUG CAREFUL: Adding var 0 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.500000
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.500000
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.773575
DEBUG CAREFUL: Adding var 9 to fractional list (xi=0.773575)
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.773575
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.773575)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.500000
DEBUG CAREFUL: Adding var 29 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.500000
DEBUG CAREFUL: Adding var 32 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 7 fractional variables

  %  Carefully choosing branching variable, nfrac = 7
DEBUG CAREFUL: Testing fvar[0] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 1
DEBUG CAREFUL: New best var: 1
DEBUG CAREFUL: Testing fvar[1] = var 0
DEBUG CAREFUL: Calling compare_branch_vars for var 0
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 0
DEBUG CAREFUL: Testing fvar[2] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 2
DEBUG CAREFUL: New best var: 2
DEBUG CAREFUL: Testing fvar[3] = var 29
DEBUG CAREFUL: Calling compare_branch_vars for var 29
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 29
DEBUG CAREFUL: Testing fvar[4] = var 32
DEBUG CAREFUL: Calling compare_branch_vars for var 32
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 32
DEBUG CAREFUL: New best var: 32
DEBUG CAREFUL: Testing fvar[5] = var 9
DEBUG CAREFUL: Calling compare_branch_vars for var 9
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 9
DEBUG CAREFUL: Testing fvar[6] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
  % Initial guess is x32, Z0 = 28305135.2885841        , Z1 = 28393491.8546575        

DEBUG EVAL: Testing var 1 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=2, varin=37, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 1 = 0 gives z=28315269.737448
  % 	x1 = 0,	Z0 = 28315269.7374482        
DEBUG EVAL: First branch cutoff check: z=28315269.737448, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 1 = 1
ITER 1: row=2, varin=21, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=38, varin=29, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=3, varin=73, theta=1.000000, up=1.000000
  % 	x1 = 1,	Z1 = 28785216.1106666        
DEBUG EVAL: Second branch cutoff check: z=28785216.110667, best_z=INF, threshold=INF
  %   New best:  x1, Z = 28315269.7374482        
DEBUG EVAL: Testing var 0 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=37, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 0 = 0 gives z=28315269.737448
  % 	x0 = 0,	Z0 = 28315269.7374482        
DEBUG EVAL: First branch cutoff check: z=28315269.737448, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 0 = 1
ITER 1: row=1, varin=3, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=22, varin=4, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=30, varin=29, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=3, varin=73, theta=1.000000, up=1.000000
  % 	x0 = 1,	Z1 = 28942041.8664205        
DEBUG EVAL: Second branch cutoff check: z=28942041.866421, best_z=INF, threshold=INF
  %   New best:  x0, Z = 28315269.7374482        
DEBUG EVAL: Testing var 2 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=3, varin=39, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=39, varin=37, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 1 gives z=28315269.737448
  % 	x2 = 1,	Z1 = 28323695.2251061        
DEBUG EVAL: First branch cutoff check: z=28323695.225106, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 0
ITER 1: row=3, varin=73, theta=0.500000, up=1.000000
  % 	x2 = 0,	Z0 = 28312415.0283058        
DEBUG EVAL: Second branch cutoff check: z=28312415.028306, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 29 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=18, varin=37, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 29 = 0 gives z=28315269.737448
  % 	x29 = 0,	Z0 = 28315269.7374482        
DEBUG EVAL: First branch cutoff check: z=28315269.737448, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 29 = 1
ITER 1: row=18, varin=4, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=30, varin=21, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=38, varin=8, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=30, varin=37, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=3, varin=73, theta=1.000000, up=1.000000
  % 	x29 = 1,	Z1 = 29146475.8819606        
DEBUG EVAL: Second branch cutoff check: z=29146475.881961, best_z=INF, threshold=INF
  %   New best:  x29, Z = 28315269.7374482        
DEBUG EVAL: Testing var 32 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=29, varin=39, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=39, varin=37, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 32 = 1 gives z=28315269.737448
  % 	x32 = 1,	Z1 = 28393491.8546575        
DEBUG EVAL: First branch cutoff check: z=28393491.854657, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 32 = 0
ITER 1: row=29, varin=73, theta=0.500000, up=1.000000
  % 	x32 = 0,	Z0 = 28312415.0283058        
DEBUG EVAL: Second branch cutoff check: z=28312415.028306, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 9 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=16, varin=37, theta=1.336248, up=999999999999999983222784.000000
ITER 2: row=1, varin=73, theta=0.273006, up=1.000000
DEBUG EVAL: Branch var 9 = 1 gives z=28319244.559779
  % 	x9 = 1,	Z1 = 28319244.5597793        
DEBUG EVAL: First branch cutoff check: z=28319244.559779, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 9 = 0
ITER 1: row=16, varin=35, theta=746451.500000, up=999999999999999983222784.000000
  % 	x9 = 0,	Z0 = 28309050.5479431        
DEBUG EVAL: Second branch cutoff check: z=28309050.547943, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 10 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=13, varin=37, theta=1.336248, up=999999999999999983222784.000000
ITER 2: row=1, varin=73, theta=0.273006, up=1.000000
DEBUG EVAL: Branch var 10 = 1 gives z=28319244.559779
  % 	x10 = 1,	Z1 = 28319244.5597793        
DEBUG EVAL: First branch cutoff check: z=28319244.559779, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 0
ITER 1: row=13, varin=35, theta=746451.500000, up=999999999999999983222784.000000
  % 	x10 = 0,	Z0 = 28309050.5479431        
DEBUG EVAL: Second branch cutoff check: z=28309050.547943, best_z=INF, threshold=INF
  % Best branch is x29, Z0 = 28315269.7374482        , Z1 = 29146475.8819606        

DEBUG CAREFUL: Final result - returning best.var = 29
DEBUG BB: Branching variable chosen: j=29
 % @NC   81   75	x29 = 0	28315269.737448
 % @NC   82   75	x29 = 1	29146475.881961
 %      75    38 28305135.2886               28307112.2029   x27 D    71    12
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cb6f50
% @LO 0.04  28.30513528858408278666 99.9000000000
% @LN 0.04  28.30711220292613816696 99.9000000000
% Resuming node 55 at  28.30711220292613816696
DEBUG CONSTRNT: LP rows=39, pool->nlprows=39, pool->npend=0
DEBUG CONSTRNT: Checking 39 LP rows (pool tracks 39, total LP rows 39)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 142
DEBUG CONSTRNT: Pool row 142 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 143
DEBUG CONSTRNT: Pool row 143 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=38, expected 38
 % @PAP adding 48 rows, 201 nz to LP
DEBUG BB: Processing node 55, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 55 LP 2 Solution, length = 28307112.202926, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.500000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.500000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.500000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.500000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.500000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 3 fractional variables
DEBUG CG: LP optimal, z=28307112.202926, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28307112.202926, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 55 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 55
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.500000
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=1.000000
DEBUG CAREFUL: Skipping var 7: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.500000
DEBUG CAREFUL: Adding var 27 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.500000
DEBUG CAREFUL: Adding var 31 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 3 fractional variables

  %  Carefully choosing branching variable, nfrac = 3
DEBUG CAREFUL: Testing fvar[0] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 2
DEBUG CAREFUL: New best var: 2
DEBUG CAREFUL: Testing fvar[1] = var 27
DEBUG CAREFUL: Calling compare_branch_vars for var 27
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 27
DEBUG CAREFUL: New best var: 27
DEBUG CAREFUL: Testing fvar[2] = var 31
DEBUG CAREFUL: Calling compare_branch_vars for var 31
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 31
  % Initial guess is x27, Z0 = 28307112.2029261        , Z1 = 28585347.07268          

DEBUG EVAL: Testing var 2 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=19, varin=35, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 0 gives z=28438068.389928
  % 	x2 = 0,	Z0 = 28438068.3899278        
DEBUG EVAL: First branch cutoff check: z=28438068.389928, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 1
ITER 1: row=19, varin=32, theta=1.000000, up=999999999999999983222784.000000
  % 	x2 = 1,	Z1 = 28473841.4468808        
DEBUG EVAL: Second branch cutoff check: z=28473841.446881, best_z=INF, threshold=INF
  %   New best:  x2, Z = 28438068.3899278        
DEBUG EVAL: Testing var 27 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=32, varin=19, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 27 = 1 gives z=28810802.986257
  % 	x27 = 1,	Z1 = 28810802.986257         
DEBUG EVAL: First branch cutoff check: z=28810802.986257, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 27 = 0
ITER 1: row=32, varin=35, theta=1.000000, up=999999999999999983222784.000000
  % 	x27 = 0,	Z0 = 28438068.3899278        
DEBUG EVAL: Second branch cutoff check: z=28438068.389928, best_z=INF, threshold=INF
  %   New best:  x27, Z = 28438068.3899278        
DEBUG EVAL: Testing var 31 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=72, theta=0.166667, up=1.000000
ITER 2: row=37, varin=46, theta=0.250000, up=999999999999999983222784.000000
ITER 3: row=38, varin=44, theta=0.500000, up=999999999999999983222784.000000
ITER 4: row=1, varin=43, theta=0.500000, up=999999999999999983222784.000000
ITER 5: row=43, varin=27, theta=0.222222, up=999999999999999983222784.000000
ITER 6: row=31, varin=62, theta=0.500000, up=1.000000
ITER 7: row=18, varin=39, theta=0.500000, up=999999999999999983222784.000000
ITER 8: row=39, varin=11, theta=0.500000, up=999999999999999983222784.000000
ITER 9: row=11, varin=36, theta=0.500000, up=999999999999999983222784.000000
ITER 10: row=36, varin=33, theta=0.625000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 31 = 1 gives z=28438068.389928
  % 	x31 = 1,	Z1 = 28442540.0220469        
DEBUG EVAL: First branch cutoff check: z=28442540.022047, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 31 = 0
ITER 1: row=1, varin=38, theta=0.166667, up=999999999999999983222784.000000
  % 	x31 = 0,	Z0 = 28313786.4649769        
DEBUG EVAL: Second branch cutoff check: z=28313786.464977, best_z=INF, threshold=INF
  % Best branch is x27, Z0 = 28438068.3899278        , Z1 = 28810802.986257         

DEBUG CAREFUL: Final result - returning best.var = 27
DEBUG BB: Branching variable chosen: j=27
 % @NC   83   55	x27 = 0	28438068.389928
 % @NC   84   55	x27 = 1	28810802.986257
 %      55    39 28307112.2029               28309033.3673    x1 D    43     9
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cc7030
% @LO 0.04  28.30711220292613816696 99.9000000000
% @LN 0.04  28.30903336734626307702 99.9000000000
% Resuming node 67 at  28.30903336734626307702
DEBUG CONSTRNT: LP rows=48, pool->nlprows=48, pool->npend=0
DEBUG CONSTRNT: Checking 48 LP rows (pool tracks 48, total LP rows 48)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 133
DEBUG CONSTRNT: Pool row 133 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=47, expected 47
 % @PAP adding 44 rows, 185 nz to LP
DEBUG BB: Processing node 67, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=17, varin=68, theta=1.000000, up=1.000000
ITER 2: row=37, varin=56, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28309033.367346
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 44 rows, 60 cols, 245 nonzeros, 0 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 6 rows, 34 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=45, varin=38, theta=0.333333, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28317903.355829
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 50 rows, 60 cols, 279 nonzeros, 6 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 6 slack rows
  % Node 67 LP 1 Solution, length = 28317903.355829, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.333333 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.333333 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.333333 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 1.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.333333 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.333333 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.666667 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.666667 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.666667 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.666667 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.666667 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.666667 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.666667 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28317903.355829, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 67 at  28.31790335582928364033
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cae7d0
% @LO 0.04  28.30903336734626307702 99.9000000000
% @LN 0.04  28.31040221074997020878 99.9000000000
% Resuming node 57 at  28.31040221074997020878
DEBUG CONSTRNT: LP rows=44, pool->nlprows=44, pool->npend=0
DEBUG CONSTRNT: Checking 44 LP rows (pool tracks 44, total LP rows 44)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 65
DEBUG CONSTRNT: Pool row 65 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=43, expected 43
 % @PAP adding 34 rows, 165 nz to LP
DEBUG BB: Processing node 57, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=29, varin=32, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=12, varin=21, theta=12.000000, up=999999999999999983222784.000000
ITER 3: row=18, varin=52, theta=0.352941, up=1.000000
ITER 4: row=25, varin=35, theta=0.500000, up=1.000000
ITER 5: row=2, varin=40, theta=0.500000, up=1.000000
ITER 6: row=13, varin=15, theta=0.545455, up=999999999999999983222784.000000
ITER 7: row=24, varin=19, theta=1.090909, up=999999999999999983222784.000000
ITER 8: row=22, varin=76, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=8)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=34)
DEBUG SOLUTION: LP solution array indices: FST[35-74], not_covered[75-94]
DEBUG SOLUTION: lp->best_solution[0] = 28310402.210750
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 34 rows, 60 cols, 225 nonzeros, 2 slack, 32 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 15 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=35, varin=57, theta=0.333333, up=1.000000
ITER 2: row=21, varin=24, theta=0.041667, up=999999999999999983222784.000000
ITER 3: row=26, varin=23, theta=0.263158, up=999999999999999983222784.000000
ITER 4: row=21, varin=21, theta=0.052632, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=38)
DEBUG SOLUTION: LP solution array indices: FST[39-78], not_covered[79-98]
DEBUG SOLUTION: lp->best_solution[0] = 28324496.990826
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.947368
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.947368
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 38 rows, 60 cols, 240 nonzeros, 8 slack, 30 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 8 slack rows
  % @PAP adding 7 rows, 26 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=37, varin=48, theta=0.048276, up=1.000000
ITER 2: row=32, varin=64, theta=0.759259, up=1.000000
ITER 3: row=31, varin=18, theta=0.092593, up=999999999999999983222784.000000
ITER 4: row=34, varin=20, theta=0.555556, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=37)
DEBUG SOLUTION: LP solution array indices: FST[38-77], not_covered[78-97]
DEBUG SOLUTION: lp->best_solution[0] = 28353055.326256
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
  % @PL 37 rows, 60 cols, 235 nonzeros, 2 slack, 35 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 3 rows, 7 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=36, varin=32, theta=0.555556, up=999999999999999983222784.000000
ITER 2: row=18, varin=42, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=38)
DEBUG SOLUTION: LP solution array indices: FST[39-78], not_covered[79-98]
DEBUG SOLUTION: lp->best_solution[0] = 28364681.888627
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
  % @PL 38 rows, 60 cols, 228 nonzeros, 0 slack, 38 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 6 rows, 31 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=39, varin=35, theta=0.833333, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28367715.182718
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
  % @PL 44 rows, 60 cols, 259 nonzeros, 4 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % Node 57 LP 1 Solution, length = 28367715.182718, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.166667 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.166667 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.166667 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 1.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.166667 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.166667 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.166667 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.833333 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.833333 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.833333 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.833333 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.833333 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.833333 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.833333 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28367715.182718, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 57 at  28.36771518271797987154
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cc9ac0
% @LO 0.04  28.31040221074997020878 99.9000000000
% @LN 0.04  28.31059408338442295872 99.9000000000
% Resuming node 65 at  28.31059408338442295872
DEBUG CONSTRNT: LP rows=40, pool->nlprows=40, pool->npend=0
DEBUG CONSTRNT: Checking 40 LP rows (pool tracks 40, total LP rows 40)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=39, expected 39
 % @PAP adding 34 rows, 163 nz to LP
DEBUG BB: Processing node 65, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=29, varin=29, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=34, varin=31, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=10, varin=21, theta=12.000000, up=999999999999999983222784.000000
ITER 4: row=18, varin=44, theta=0.250000, up=1.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=34)
DEBUG SOLUTION: LP solution array indices: FST[35-74], not_covered[75-94]
DEBUG SOLUTION: lp->best_solution[0] = 28310594.083384
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 34 rows, 60 cols, 223 nonzeros, 2 slack, 32 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 15 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=35, varin=56, theta=0.352941, up=1.000000
ITER 2: row=21, varin=19, theta=0.088235, up=999999999999999983222784.000000
ITER 3: row=25, varin=39, theta=0.500000, up=1.000000
ITER 4: row=2, varin=49, theta=0.333333, up=1.000000
ITER 5: row=37, varin=13, theta=0.545455, up=999999999999999983222784.000000
ITER 6: row=24, varin=30, theta=0.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=38)
DEBUG SOLUTION: LP solution array indices: FST[39-78], not_covered[79-98]
DEBUG SOLUTION: lp->best_solution[0] = 28352911.590519
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 38 rows, 60 cols, 238 nonzeros, 5 slack, 33 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % Node 65 LP 1 Solution, length = 28352911.590519, 0.01 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.500000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.500000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.500000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.500000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.500000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.500000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.500000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.500000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.500000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.500000 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=28352911.590519, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 65 at  28.35291159051858045359
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cb66c0
% @LO 0.05  28.31059408338442295872 99.9000000000
% @LN 0.05  28.31526973744820097068 99.9000000000
% Resuming node 81 at  28.31526973744820097068
DEBUG CONSTRNT: LP rows=33, pool->nlprows=33, pool->npend=0
DEBUG CONSTRNT: Checking 33 LP rows (pool tracks 33, total LP rows 33)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=32, expected 32
 % @PAP adding 39 rows, 191 nz to LP
DEBUG BB: Processing node 81, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=18, varin=37, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=39)
DEBUG SOLUTION: LP solution array indices: FST[40-79], not_covered[80-99]
DEBUG SOLUTION: lp->best_solution[0] = 28315269.737448
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 39 rows, 60 cols, 251 nonzeros, 2 slack, 37 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 7 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=40, varin=75, theta=1.000000, up=1.000000
ITER 2: row=13, varin=35, theta=146405.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=41)
DEBUG SOLUTION: LP solution array indices: FST[42-81], not_covered[82-101]
DEBUG SOLUTION: lp->best_solution[0] = 28330597.134896
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 41 rows, 60 cols, 258 nonzeros, 3 slack, 38 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 4 rows, 14 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=39, varin=73, theta=1.000000, up=1.000000
ITER 2: row=38, varin=3, theta=0.250000, up=999999999999999983222784.000000
ITER 3: row=42, varin=29, theta=0.250000, up=999999999999999983222784.000000
ITER 4: row=22, varin=42, theta=0.333333, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 28366308.628388
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 42 rows, 60 cols, 227 nonzeros, 5 slack, 37 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % @PAP adding 1 rows, 40 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=38, varin=49, theta=0.121914, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=38)
DEBUG SOLUTION: LP solution array indices: FST[39-78], not_covered[79-98]
DEBUG SOLUTION: lp->best_solution[0] = 28366925.665799
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 38 rows, 60 cols, 250 nonzeros, 0 slack, 38 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 81 LP 1 Solution, length = 28366925.665799, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.333333 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.333333 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.333333 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.878086 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.878086 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.333333 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.333333 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.333333 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.666667 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.666667 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.666667 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.666667 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.666667 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.121914 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.121914 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.666667 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.121914 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.121914 (terminal 19)
 % 8 fractional variables
DEBUG CG: LP optimal, z=28366925.665799, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 81 at  28.36692566579900542934
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cc7030
% @LO 0.05  28.31526973744820097068 99.9000000000
% @LN 0.05  28.31790335582928364033 99.9000000000
% Resuming node 67 at  28.31790335582928364033
DEBUG CONSTRNT: LP rows=38, pool->nlprows=38, pool->npend=0
DEBUG CONSTRNT: Checking 38 LP rows (pool tracks 38, total LP rows 38)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=37, expected 37
 % @PAP adding 44 rows, 185 nz to LP
DEBUG BB: Processing node 67, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 67 LP 2 Solution, length = 28317903.355829, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.333333 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.333333 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.333333 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 1.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.333333 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.333333 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.666667 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.666667 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.666667 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.666667 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.666667 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.666667 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.666667 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28317903.355829, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28317903.355829, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 67 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 67
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.333333
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.333333
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.333333
DEBUG CAREFUL: Adding var 11 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=1.000000
DEBUG CAREFUL: Skipping var 13: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.333333
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.333333
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 11
DEBUG CAREFUL: Calling compare_branch_vars for var 11
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 11
DEBUG CAREFUL: New best var: 11
DEBUG CAREFUL: Testing fvar[1] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[2] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[3] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[4] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
  % Initial guess is x11, Z0 = 28317903.3558293        , Z1 = 28564728.4986988        

DEBUG EVAL: Testing var 11 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=17, varin=37, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=37, varin=26, theta=2.000000, up=999999999999999983222784.000000
ITER 3: row=43, varin=38, theta=2.000000, up=999999999999999983222784.000000
ITER 4: row=38, varin=36, theta=2.000000, up=999999999999999983222784.000000
ITER 5: row=36, varin=32, theta=2.000000, up=999999999999999983222784.000000
ITER 6: row=32, varin=34, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=44, varin=28, theta=1.000000, up=999999999999999983222784.000000
ITER 8: row=39, varin=27, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 11 = 1 gives z=28706350.829824
  % 	x11 = 1,	Z1 = 28706350.8298238        
DEBUG EVAL: First branch cutoff check: z=28706350.829824, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 11 = 0
ITER 1: row=17, varin=49, theta=0.500000, up=1.000000
  % 	x11 = 0,	Z0 = 28321396.7079854        
DEBUG EVAL: Second branch cutoff check: z=28321396.707985, best_z=INF, threshold=INF
  %   New best:  x11, Z = 28321396.7079854        
DEBUG EVAL: Testing var 2 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=49, theta=0.500000, up=1.000000
DEBUG EVAL: Branch var 2 = 0 gives z=28321396.707985
  % 	x2 = 0,	Z0 = 28321396.7079854        
DEBUG EVAL: First branch cutoff check: z=28321396.707985, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 1
ITER 1: row=1, varin=42, theta=1.000000, up=999999999999999983222784.000000
  % 	x2 = 1,	Z1 = 28335643.3327953        
DEBUG EVAL: Second branch cutoff check: z=28335643.332795, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 17 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=25, varin=42, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 17 = 1 gives z=28335643.332795
  % 	x17 = 1,	Z1 = 28335643.3327953        
DEBUG EVAL: First branch cutoff check: z=28335643.332795, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 17 = 0
ITER 1: row=25, varin=49, theta=0.500000, up=1.000000
  % 	x17 = 0,	Z0 = 28321396.7079854        
DEBUG EVAL: Second branch cutoff check: z=28321396.707985, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 10 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=13, varin=42, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 1 gives z=28335643.332795
  % 	x10 = 1,	Z1 = 28335643.3327953        
DEBUG EVAL: First branch cutoff check: z=28335643.332795, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 0
ITER 1: row=13, varin=49, theta=0.500000, up=1.000000
  % 	x10 = 0,	Z0 = 28321396.7079854        
DEBUG EVAL: Second branch cutoff check: z=28321396.707985, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 26 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=32, varin=49, theta=0.500000, up=1.000000
DEBUG EVAL: Branch var 26 = 0 gives z=28321396.707985
  % 	x26 = 0,	Z0 = 28321396.7079854        
DEBUG EVAL: First branch cutoff check: z=28321396.707985, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 26 = 1
ITER 1: row=32, varin=42, theta=1.000000, up=999999999999999983222784.000000
  % 	x26 = 1,	Z1 = 28335643.3327953        
DEBUG EVAL: Second branch cutoff check: z=28335643.332795, best_z=INF, threshold=INF
  % Best branch is x11, Z0 = 28321396.7079854        , Z1 = 28706350.8298238        

DEBUG CAREFUL: Final result - returning best.var = 11
DEBUG BB: Branching variable chosen: j=11
 % @NC   85   67	x11 = 0	28321396.707985
 % @NC   86   67	x11 = 1	28706350.829824
 %      67    40 28317903.3558               28320548.4754    x3 D    53     7
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cd3ea0
% @LO 0.05  28.31790335582928364033 99.9000000000
% @LN 0.05  28.32054847544436171347 99.9000000000
% Resuming node 52 at  28.32054847544436171347
DEBUG CONSTRNT: LP rows=44, pool->nlprows=44, pool->npend=0
DEBUG CONSTRNT: Checking 44 LP rows (pool tracks 44, total LP rows 44)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 65
DEBUG CONSTRNT: Pool row 65 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=43, expected 43
 % @PAP adding 45 rows, 183 nz to LP
DEBUG BB: Processing node 52, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 52 LP 2 Solution, length = 28320548.475444, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.166667 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.166667 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.166667 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 1.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.166667 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.166667 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.166667 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.833333 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.833333 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.833333 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.833333 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.833333 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.833333 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.833333 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28320548.475444, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28320548.475444, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 52 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 52
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.166667
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.166667
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.166667
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=1.000000
DEBUG CAREFUL: Skipping var 16: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.166667
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.166667
DEBUG CAREFUL: Adding var 18 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.166667
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 6 fractional variables

  %  Carefully choosing branching variable, nfrac = 6
DEBUG CAREFUL: Testing fvar[0] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 2
DEBUG CAREFUL: New best var: 2
DEBUG CAREFUL: Testing fvar[1] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[2] = var 18
DEBUG CAREFUL: Calling compare_branch_vars for var 18
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 18
DEBUG CAREFUL: New best var: 18
DEBUG CAREFUL: Testing fvar[3] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[4] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 3
DEBUG CAREFUL: Testing fvar[5] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
  % Initial guess is x18, Z0 = 28320548.4754444        , Z1 = 28503328.2492878        

DEBUG EVAL: Testing var 2 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=16, theta=0.200000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 0 gives z=28351654.678528
  % 	x2 = 0,	Z0 = 28351654.678528         
DEBUG EVAL: First branch cutoff check: z=28351654.678528, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 1
ITER 1: row=1, varin=43, theta=2.500000, up=999999999999999983222784.000000
ITER 2: row=15, varin=34, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=37, varin=42, theta=3.000000, up=999999999999999983222784.000000
ITER 4: row=42, varin=20, theta=0.750000, up=999999999999999983222784.000000
  % 	x2 = 1,	Z1 = 28348894.9152045        
DEBUG EVAL: Second branch cutoff check: z=28348894.915204, best_z=INF, threshold=INF
  %   New best:  x2, Z = 28348894.9152045        
DEBUG EVAL: Testing var 17 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=19, varin=20, theta=0.333333, up=999999999999999983222784.000000
ITER 2: row=36, varin=70, theta=1.000000, up=1.000000
ITER 3: row=3, varin=21, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 17 = 0 gives z=28427938.571148
  % 	x17 = 0,	Z0 = 28427938.5711484        
DEBUG EVAL: First branch cutoff check: z=28427938.571148, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 17 = 1
ITER 1: row=19, varin=43, theta=2.500000, up=999999999999999983222784.000000
ITER 2: row=15, varin=34, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=37, varin=42, theta=3.000000, up=999999999999999983222784.000000
ITER 4: row=42, varin=39, theta=3.000000, up=999999999999999983222784.000000
ITER 5: row=39, varin=35, theta=0.666667, up=999999999999999983222784.000000
  % 	x17 = 1,	Z1 = 28447494.9197876        
DEBUG EVAL: Second branch cutoff check: z=28447494.919788, best_z=INF, threshold=INF
  %   New best:  x17, Z = 28427938.5711484        
DEBUG EVAL: Testing var 18 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=34, varin=43, theta=2.500000, up=999999999999999983222784.000000
ITER 2: row=15, varin=42, theta=3.000000, up=999999999999999983222784.000000
ITER 3: row=42, varin=20, theta=3.000000, up=999999999999999983222784.000000
ITER 4: row=36, varin=39, theta=3.000000, up=999999999999999983222784.000000
ITER 5: row=39, varin=30, theta=2.000000, up=999999999999999983222784.000000
ITER 6: row=5, varin=21, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 18 = 1 gives z=28562929.726120
  % 	x18 = 1,	Z1 = 28562929.7261199        
DEBUG EVAL: First branch cutoff check: z=28562929.726120, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 18 = 0
ITER 1: row=34, varin=34, theta=0.333333, up=999999999999999983222784.000000
ITER 2: row=37, varin=70, theta=1.000000, up=1.000000
ITER 3: row=3, varin=35, theta=0.333333, up=999999999999999983222784.000000
  % 	x18 = 0,	Z0 = 28367187.8738915        
DEBUG EVAL: Second branch cutoff check: z=28367187.873891, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 10 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=12, varin=34, theta=0.333333, up=999999999999999983222784.000000
ITER 2: row=37, varin=12, theta=0.500000, up=999999999999999983222784.000000
ITER 3: row=12, varin=20, theta=0.500000, up=999999999999999983222784.000000
ITER 4: row=36, varin=70, theta=1.000000, up=1.000000
ITER 5: row=3, varin=14, theta=0.250000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 0 gives z=28384295.197273
  % 	x10 = 0,	Z0 = 28384295.1972735        
DEBUG EVAL: First branch cutoff check: z=28384295.197273, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 3 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=15, varin=34, theta=1.666667, up=999999999999999983222784.000000
ITER 2: row=37, varin=42, theta=5.000000, up=999999999999999983222784.000000
ITER 3: row=42, varin=39, theta=5.000000, up=999999999999999983222784.000000
ITER 4: row=39, varin=19, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=44, varin=35, theta=1.333333, up=999999999999999983222784.000000
ITER 6: row=34, varin=20, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=45, varin=30, theta=1.000000, up=999999999999999983222784.000000
ITER 8: row=5, varin=2, theta=0.400000, up=999999999999999983222784.000000
ITER 9: row=30, varin=21, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 3 = 1 gives z=28610465.409505
  % 	x3 = 1,	Z1 = 28610465.4095055        
DEBUG EVAL: First branch cutoff check: z=28610465.409505, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 3 = 0
ITER 1: row=15, varin=43, theta=0.250000, up=999999999999999983222784.000000
  % 	x3 = 0,	Z0 = 28322065.1224897        
DEBUG EVAL: Second branch cutoff check: z=28322065.122490, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 26 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=39, varin=34, theta=0.333333, up=999999999999999983222784.000000
ITER 2: row=37, varin=39, theta=0.200000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 26 = 0 gives z=28326068.687298
  % 	x26 = 0,	Z0 = 28326068.6872978        
DEBUG EVAL: First branch cutoff check: z=28326068.687298, best_z=INF, threshold=INF
  % Best branch is x17, Z0 = 28427938.5711484        , Z1 = 28447494.9197876        

DEBUG CAREFUL: Final result - returning best.var = 17
DEBUG BB: Branching variable chosen: j=17
 % @NC   87   52	x17 = 0	28427938.571148
 % @NC   88   52	x17 = 1	28447494.919788
 %      52    41 28320548.4754               28321396.7080   x16 U    16     7
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cb6f50
% @LO 0.05  28.32054847544436171347 99.9000000000
% @LN 0.05  28.32139670798540720398 99.9000000000
% Resuming node 85 at  28.32139670798540720398
DEBUG CONSTRNT: LP rows=45, pool->nlprows=45, pool->npend=0
DEBUG CONSTRNT: Checking 45 LP rows (pool tracks 45, total LP rows 45)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 49
DEBUG CONSTRNT: Pool row 49 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 68
DEBUG CONSTRNT: Pool row 68 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 82
DEBUG CONSTRNT: Pool row 82 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=44, expected 44
 % @PAP adding 44 rows, 185 nz to LP
DEBUG BB: Processing node 85, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=17, varin=49, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28321396.707985
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 44 rows, 60 cols, 245 nonzeros, 0 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 6 rows, 33 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=45, varin=42, theta=0.333333, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28326145.582922
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 50 rows, 60 cols, 278 nonzeros, 6 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 6 slack rows
  % Node 85 LP 1 Solution, length = 28326145.582922, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.333333 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.333333 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.333333 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 1.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.333333 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.333333 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.666667 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.666667 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.666667 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.666667 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.666667 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.666667 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.666667 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28326145.582922, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 85 at  28.32614558292204876011
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cc2570
% @LO 0.05  28.32139670798540720398 99.9000000000
% @LN 0.05  28.32170908674079257139 99.9000000000
% Resuming node 69 at  28.32170908674079257139
DEBUG CONSTRNT: LP rows=44, pool->nlprows=44, pool->npend=0
DEBUG CONSTRNT: Checking 44 LP rows (pool tracks 44, total LP rows 44)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 65
DEBUG CONSTRNT: Pool row 65 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=43, expected 43
 % @PAP adding 44 rows, 185 nz to LP
DEBUG BB: Processing node 69, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=17, varin=68, theta=1.000000, up=1.000000
ITER 2: row=41, varin=56, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28321709.086741
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 44 rows, 60 cols, 245 nonzeros, 0 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 6 rows, 34 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=45, varin=42, theta=0.333333, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28330579.075224
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 50 rows, 60 cols, 279 nonzeros, 7 slack, 43 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 7 slack rows
  % Node 69 LP 1 Solution, length = 28330579.075224, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.333333 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.333333 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.333333 (FST 11)
  % DEBUG LP_VARS: x[12] = 1.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 1.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.333333 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.333333 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.666667 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.666667 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.666667 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.666667 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.666667 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.666667 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.666667 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28330579.075224, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 69 at  28.33057907522380958198
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cb6f50
% @LO 0.05  28.32170908674079257139 99.9000000000
% @LN 0.05  28.32614558292204876011 99.9000000000
% Resuming node 85 at  28.32614558292204876011
DEBUG CONSTRNT: LP rows=43, pool->nlprows=43, pool->npend=0
DEBUG CONSTRNT: Checking 43 LP rows (pool tracks 43, total LP rows 43)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=42, expected 42
 % @PAP adding 44 rows, 185 nz to LP
DEBUG BB: Processing node 85, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 85 LP 2 Solution, length = 28326145.582922, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.333333 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.333333 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.333333 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 1.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.333333 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.333333 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.666667 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.666667 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.666667 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.666667 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.666667 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.666667 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.666667 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28326145.582922, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28326145.582922, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 85 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 85
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.333333
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.333333
DEBUG CAREFUL: Adding var 4 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.333333
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=1.000000
DEBUG CAREFUL: Skipping var 13: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.333333
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.333333
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 4
DEBUG CAREFUL: Calling compare_branch_vars for var 4
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 4
DEBUG CAREFUL: New best var: 4
DEBUG CAREFUL: Testing fvar[1] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[2] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[3] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[4] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
  % Initial guess is x4, Z0 = 28326145.582922         , Z1 = 28589455.1799771        

DEBUG EVAL: Testing var 4 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=17, varin=37, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=37, varin=38, theta=2.000000, up=999999999999999983222784.000000
ITER 3: row=38, varin=36, theta=2.000000, up=999999999999999983222784.000000
ITER 4: row=36, varin=25, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=43, varin=32, theta=2.000000, up=999999999999999983222784.000000
ITER 6: row=32, varin=26, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=44, varin=28, theta=1.000000, up=999999999999999983222784.000000
ITER 8: row=39, varin=27, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 4 = 1 gives z=28731077.511102
  % 	x4 = 1,	Z1 = 28731077.5111021        
DEBUG EVAL: First branch cutoff check: z=28731077.511102, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 4 = 0
ITER 1: row=17, varin=42, theta=1.000000, up=999999999999999983222784.000000
  % 	x4 = 0,	Z0 = 28335643.3327953        
DEBUG EVAL: Second branch cutoff check: z=28335643.332795, best_z=INF, threshold=INF
  %   New best:  x4, Z = 28335643.3327953        
DEBUG EVAL: Testing var 2 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=42, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 1 gives z=28335643.332795
  % 	x2 = 1,	Z1 = 28335643.3327953        
DEBUG EVAL: First branch cutoff check: z=28335643.332795, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 0
ITER 1: row=1, varin=74, theta=1.000000, up=1.000000
ITER 2: row=31, varin=46, theta=0.250000, up=1.000000
ITER 3: row=40, varin=16, theta=0.250000, up=999999999999999983222784.000000
ITER 4: row=41, varin=72, theta=1.000000, up=1.000000
  % 	x2 = 0,	Z0 = 28371089.0732306        
DEBUG EVAL: Second branch cutoff check: z=28371089.073231, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 17 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=25, varin=42, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 17 = 1 gives z=28335643.332795
  % 	x17 = 1,	Z1 = 28335643.3327953        
DEBUG EVAL: First branch cutoff check: z=28335643.332795, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 17 = 0
ITER 1: row=25, varin=74, theta=1.000000, up=1.000000
ITER 2: row=31, varin=46, theta=0.250000, up=1.000000
ITER 3: row=40, varin=16, theta=0.250000, up=999999999999999983222784.000000
ITER 4: row=41, varin=72, theta=1.000000, up=1.000000
  % 	x17 = 0,	Z0 = 28371089.0732306        
DEBUG EVAL: Second branch cutoff check: z=28371089.073231, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 10 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=13, varin=42, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 1 gives z=28335643.332795
  % 	x10 = 1,	Z1 = 28335643.3327953        
DEBUG EVAL: First branch cutoff check: z=28335643.332795, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 0
ITER 1: row=13, varin=74, theta=1.000000, up=1.000000
ITER 2: row=31, varin=46, theta=0.250000, up=1.000000
ITER 3: row=40, varin=16, theta=0.250000, up=999999999999999983222784.000000
ITER 4: row=41, varin=72, theta=1.000000, up=1.000000
  % 	x10 = 0,	Z0 = 28371089.0732306        
DEBUG EVAL: Second branch cutoff check: z=28371089.073231, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 26 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=32, varin=42, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 26 = 1 gives z=28335643.332795
  % 	x26 = 1,	Z1 = 28335643.3327953        
DEBUG EVAL: First branch cutoff check: z=28335643.332795, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 26 = 0
ITER 1: row=32, varin=74, theta=1.000000, up=1.000000
ITER 2: row=31, varin=46, theta=0.250000, up=1.000000
ITER 3: row=40, varin=16, theta=0.250000, up=999999999999999983222784.000000
ITER 4: row=41, varin=72, theta=1.000000, up=1.000000
  % 	x26 = 0,	Z0 = 28371089.0732306        
DEBUG EVAL: Second branch cutoff check: z=28371089.073231, best_z=INF, threshold=INF
  % Best branch is x4, Z0 = 28335643.3327953        , Z1 = 28731077.5111021        

DEBUG CAREFUL: Final result - returning best.var = 4
DEBUG BB: Branching variable chosen: j=4
 % @NC   89   85	x4 = 0	28335643.332795
 % @NC   90   85	x4 = 1	28731077.511102
 %      85    42 28326145.5829               28328917.6559   x11 D    67     8
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cd1940
% @LO 0.05  28.32614558292204876011 99.9000000000
% @LN 0.05  28.32891765590187205248 99.9000000000
% Resuming node 58 at  28.32891765590187205248
DEBUG CONSTRNT: LP rows=44, pool->nlprows=44, pool->npend=0
DEBUG CONSTRNT: Checking 44 LP rows (pool tracks 44, total LP rows 44)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 65
DEBUG CONSTRNT: Pool row 65 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=43, expected 43
 % @PAP adding 34 rows, 165 nz to LP
DEBUG BB: Processing node 58, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=29, varin=29, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=34, varin=31, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=12, varin=40, theta=0.250000, up=1.000000
ITER 4: row=13, varin=21, theta=12.000000, up=999999999999999983222784.000000
ITER 5: row=18, varin=52, theta=0.352941, up=1.000000
ITER 6: row=25, varin=35, theta=0.500000, up=1.000000
ITER 7: row=2, varin=15, theta=0.545455, up=999999999999999983222784.000000
ITER 8: row=24, varin=17, theta=0.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=8)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=34)
DEBUG SOLUTION: LP solution array indices: FST[35-74], not_covered[75-94]
DEBUG SOLUTION: lp->best_solution[0] = 28328917.655902
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 34 rows, 60 cols, 225 nonzeros, 3 slack, 31 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 2 rows, 7 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=32, varin=18, theta=1.090909, up=999999999999999983222784.000000
ITER 2: row=21, varin=75, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=33)
DEBUG SOLUTION: LP solution array indices: FST[34-73], not_covered[74-93]
DEBUG SOLUTION: lp->best_solution[0] = 28357702.235928
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 33 rows, 60 cols, 216 nonzeros, 0 slack, 33 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 15 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=34, varin=56, theta=0.333333, up=1.000000
ITER 2: row=20, varin=23, theta=0.041667, up=999999999999999983222784.000000
ITER 3: row=25, varin=22, theta=0.263158, up=999999999999999983222784.000000
ITER 4: row=20, varin=20, theta=0.052632, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=37)
DEBUG SOLUTION: LP solution array indices: FST[38-77], not_covered[78-97]
DEBUG SOLUTION: lp->best_solution[0] = 28371797.016004
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.947368
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.947368
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 37 rows, 60 cols, 231 nonzeros, 6 slack, 31 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 6 slack rows
  % @PAP adding 7 rows, 26 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=38, varin=49, theta=0.048276, up=1.000000
ITER 2: row=33, varin=45, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=38)
DEBUG SOLUTION: LP solution array indices: FST[39-78], not_covered[79-98]
DEBUG SOLUTION: lp->best_solution[0] = 28390998.726452
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 38 rows, 60 cols, 230 nonzeros, 0 slack, 38 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 29 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=39, varin=69, theta=0.759259, up=1.000000
ITER 2: row=32, varin=17, theta=0.092593, up=999999999999999983222784.000000
ITER 3: row=35, varin=19, theta=0.555556, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 28400355.351434
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 42 rows, 60 cols, 259 nonzeros, 2 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 3 rows, 7 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=41, varin=21, theta=0.333333, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 28405373.876394
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 43 rows, 60 cols, 252 nonzeros, 2 slack, 41 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % Node 58 LP 1 Solution, length = 28405373.876394, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.333333 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.333333 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.666667 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.333333 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.333333 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.666667 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.333333 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 3 fractional variables
DEBUG CG: LP optimal, z=28405373.876394, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 58 at  28.40537387639442457044
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cc2570
% @LO 0.05  28.32891765590187205248 99.9000000000
% @LN 0.05  28.33057907522380958198 99.9000000000
% Resuming node 69 at  28.33057907522380958198
DEBUG CONSTRNT: LP rows=41, pool->nlprows=41, pool->npend=0
DEBUG CONSTRNT: Checking 41 LP rows (pool tracks 41, total LP rows 41)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=40, expected 40
 % @PAP adding 43 rows, 183 nz to LP
DEBUG BB: Processing node 69, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 69 LP 2 Solution, length = 28330579.075224, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.333333 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.333333 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.333333 (FST 11)
  % DEBUG LP_VARS: x[12] = 1.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 1.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.333333 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.333333 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.666667 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.666667 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.666667 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.666667 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.666667 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.666667 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.666667 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28330579.075224, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28330579.075224, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 69 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 69
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.333333
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.333333
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.333333
DEBUG CAREFUL: Adding var 11 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=1.000000
DEBUG CAREFUL: Skipping var 12: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=1.000000
DEBUG CAREFUL: Skipping var 13: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.333333
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.333333
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 11
DEBUG CAREFUL: Calling compare_branch_vars for var 11
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 11
DEBUG CAREFUL: New best var: 11
DEBUG CAREFUL: Testing fvar[1] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[2] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[3] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[4] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
  % Initial guess is x11, Z0 = 28330579.0752238        , Z1 = 28588758.001795         

DEBUG EVAL: Testing var 11 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=17, varin=40, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=40, varin=29, theta=2.000000, up=999999999999999983222784.000000
ITER 3: row=42, varin=3, theta=2.000000, up=999999999999999983222784.000000
ITER 4: row=3, varin=52, theta=1.000000, up=1.000000
ITER 5: row=10, varin=39, theta=2.000000, up=999999999999999983222784.000000
ITER 6: row=39, varin=35, theta=2.000000, up=999999999999999983222784.000000
ITER 7: row=35, varin=37, theta=1.000000, up=999999999999999983222784.000000
ITER 8: row=43, varin=31, theta=1.000000, up=999999999999999983222784.000000
ITER 9: row=5, varin=30, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 11 = 1 gives z=28719026.549218
  % 	x11 = 1,	Z1 = 28719026.5492183        
DEBUG EVAL: First branch cutoff check: z=28719026.549218, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 11 = 0
ITER 1: row=17, varin=48, theta=0.500000, up=1.000000
  % 	x11 = 0,	Z0 = 28334072.4273799        
DEBUG EVAL: Second branch cutoff check: z=28334072.427380, best_z=INF, threshold=INF
  %   New best:  x11, Z = 28334072.4273799        
DEBUG EVAL: Testing var 2 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=48, theta=0.500000, up=1.000000
DEBUG EVAL: Branch var 2 = 0 gives z=28334072.427380
  % 	x2 = 0,	Z0 = 28334072.4273799        
DEBUG EVAL: First branch cutoff check: z=28334072.427380, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 1
ITER 1: row=1, varin=41, theta=1.000000, up=999999999999999983222784.000000
  % 	x2 = 1,	Z1 = 28348319.0521899        
DEBUG EVAL: Second branch cutoff check: z=28348319.052190, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 17 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=28, varin=41, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 17 = 1 gives z=28348319.052190
  % 	x17 = 1,	Z1 = 28348319.0521899        
DEBUG EVAL: First branch cutoff check: z=28348319.052190, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 17 = 0
ITER 1: row=28, varin=48, theta=0.500000, up=1.000000
  % 	x17 = 0,	Z0 = 28334072.4273799        
DEBUG EVAL: Second branch cutoff check: z=28334072.427380, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 10 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=14, varin=41, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 1 gives z=28348319.052190
  % 	x10 = 1,	Z1 = 28348319.0521899        
DEBUG EVAL: First branch cutoff check: z=28348319.052190, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 0
ITER 1: row=14, varin=48, theta=0.500000, up=1.000000
  % 	x10 = 0,	Z0 = 28334072.4273799        
DEBUG EVAL: Second branch cutoff check: z=28334072.427380, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 26 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=35, varin=48, theta=0.500000, up=1.000000
DEBUG EVAL: Branch var 26 = 0 gives z=28334072.427380
  % 	x26 = 0,	Z0 = 28334072.4273799        
DEBUG EVAL: First branch cutoff check: z=28334072.427380, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 26 = 1
ITER 1: row=35, varin=41, theta=1.000000, up=999999999999999983222784.000000
  % 	x26 = 1,	Z1 = 28348319.0521899        
DEBUG EVAL: Second branch cutoff check: z=28348319.052190, best_z=INF, threshold=INF
  % Best branch is x11, Z0 = 28334072.4273799        , Z1 = 28719026.5492183        

DEBUG CAREFUL: Final result - returning best.var = 11
DEBUG BB: Branching variable chosen: j=11
 % @NC   91   69	x11 = 0	28334072.427380
 % @NC   92   69	x11 = 1	28719026.549218
 %      69    43 28330579.0752               28333224.1948    x3 D    61     8
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7caffe0
% @LO 0.05  28.33057907522380958198 99.9000000000
% @LN 0.05  28.33322419483888765512 99.9000000000
% Resuming node 33 at  28.33322419483888765512
DEBUG CONSTRNT: LP rows=43, pool->nlprows=43, pool->npend=0
DEBUG CONSTRNT: Checking 43 LP rows (pool tracks 43, total LP rows 43)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=42, expected 42
 % @PAP adding 40 rows, 173 nz to LP
DEBUG BB: Processing node 33, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 33 LP 2 Solution, length = 28333224.194839, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.166667 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.166667 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.166667 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 1.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 1.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.166667 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.166667 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.166667 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.833333 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.833333 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.833333 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.833333 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.833333 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.833333 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.833333 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28333224.194839, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28333224.194839, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 33 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 33
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.166667
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.166667
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.166667
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=1.000000
DEBUG CAREFUL: Skipping var 12: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=1.000000
DEBUG CAREFUL: Skipping var 16: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.166667
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.166667
DEBUG CAREFUL: Adding var 18 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.166667
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 6 fractional variables

  %  Carefully choosing branching variable, nfrac = 6
DEBUG CAREFUL: Testing fvar[0] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 2
DEBUG CAREFUL: New best var: 2
DEBUG CAREFUL: Testing fvar[1] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[2] = var 18
DEBUG CAREFUL: Calling compare_branch_vars for var 18
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 18
DEBUG CAREFUL: New best var: 18
DEBUG CAREFUL: Testing fvar[3] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 3
DEBUG CAREFUL: Testing fvar[4] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[5] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
  % Initial guess is x18, Z0 = 28333224.1948389        , Z1 = 28435596.2054916        

DEBUG EVAL: Testing var 2 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=35, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 0 gives z=28358917.133354
  % 	x2 = 0,	Z0 = 28358917.1333537        
DEBUG EVAL: First branch cutoff check: z=28358917.133354, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 1
ITER 1: row=1, varin=38, theta=2.500000, up=999999999999999983222784.000000
ITER 2: row=14, varin=37, theta=3.000000, up=999999999999999983222784.000000
ITER 3: row=37, varin=24, theta=0.750000, up=999999999999999983222784.000000
  % 	x2 = 1,	Z1 = 28361570.634599         
DEBUG EVAL: Second branch cutoff check: z=28361570.634599, best_z=INF, threshold=INF
  %   New best:  x2, Z = 28358917.1333537        
DEBUG EVAL: Testing var 17 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=23, varin=35, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 17 = 0 gives z=28358917.133354
  % 	x17 = 0,	Z0 = 28358917.1333537        
DEBUG EVAL: First branch cutoff check: z=28358917.133354, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 17 = 1
ITER 1: row=23, varin=38, theta=2.500000, up=999999999999999983222784.000000
ITER 2: row=14, varin=37, theta=3.000000, up=999999999999999983222784.000000
ITER 3: row=37, varin=33, theta=3.000000, up=999999999999999983222784.000000
ITER 4: row=33, varin=32, theta=0.666667, up=999999999999999983222784.000000
  % 	x17 = 1,	Z1 = 28460170.6391821        
DEBUG EVAL: Second branch cutoff check: z=28460170.639182, best_z=INF, threshold=INF
  %   New best:  x17, Z = 28358917.1333537        
DEBUG EVAL: Testing var 18 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=32, varin=38, theta=2.500000, up=999999999999999983222784.000000
ITER 2: row=14, varin=37, theta=3.000000, up=999999999999999983222784.000000
ITER 3: row=37, varin=35, theta=1.500000, up=999999999999999983222784.000000
ITER 4: row=1, varin=33, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=33, varin=24, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=1, varin=28, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=2, varin=25, theta=0.500000, up=999999999999999983222784.000000
ITER 8: row=23, varin=2, theta=0.500000, up=999999999999999983222784.000000
ITER 9: row=28, varin=33, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 18 = 1 gives z=28539832.388561
  % 	x18 = 1,	Z1 = 28539832.3885614        
DEBUG EVAL: First branch cutoff check: z=28539832.388561, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 18 = 0
ITER 1: row=32, varin=65, theta=1.000000, up=1.000000
  % 	x18 = 0,	Z0 = 28377300.1152843        
DEBUG EVAL: Second branch cutoff check: z=28377300.115284, best_z=INF, threshold=INF
  %   New best:  x18, Z = 28377300.1152843        
DEBUG EVAL: Testing var 3 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=14, varin=37, theta=5.000000, up=999999999999999983222784.000000
ITER 2: row=37, varin=33, theta=5.000000, up=999999999999999983222784.000000
ITER 3: row=33, varin=23, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=39, varin=32, theta=1.333333, up=999999999999999983222784.000000
ITER 5: row=32, varin=24, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=40, varin=28, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=2, varin=35, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 3 = 1 gives z=28623141.128900
  % 	x3 = 1,	Z1 = 28623141.1289           
DEBUG EVAL: First branch cutoff check: z=28623141.128900, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 3 = 0
ITER 1: row=14, varin=38, theta=0.250000, up=999999999999999983222784.000000
  % 	x3 = 0,	Z0 = 28334740.8418843        
DEBUG EVAL: Second branch cutoff check: z=28334740.841884, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 10 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=11, varin=13, theta=0.200000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 0 gives z=28345960.757828
  % 	x10 = 0,	Z0 = 28345960.757828         
DEBUG EVAL: First branch cutoff check: z=28345960.757828, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 26 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=33, varin=33, theta=0.200000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 26 = 0 gives z=28338744.406692
  % 	x26 = 0,	Z0 = 28338744.4066924        
DEBUG EVAL: First branch cutoff check: z=28338744.406692, best_z=INF, threshold=INF
  % Best branch is x18, Z0 = 28377300.1152843        , Z1 = 28539832.3885614        

DEBUG CAREFUL: Final result - returning best.var = 18
DEBUG BB: Branching variable chosen: j=18
 % @NC   93   33	x18 = 0	28377300.115284
 % @NC   94   33	x18 = 1	28539832.388561
 %      33    44 28333224.1948               28333283.1778   x16 U     8     5
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cdaf50
% @LO 0.05  28.33322419483888765512 99.9000000000
% @LN 0.05  28.33328317777997895632 99.9000000000
% Resuming node 74 at  28.33328317777997895632
DEBUG CONSTRNT: LP rows=40, pool->nlprows=40, pool->npend=0
DEBUG CONSTRNT: Checking 40 LP rows (pool tracks 40, total LP rows 40)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 49
DEBUG CONSTRNT: Pool row 49 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 82
DEBUG CONSTRNT: Pool row 82 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=39, expected 39
 % @PAP adding 35 rows, 156 nz to LP
DEBUG BB: Processing node 74, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=12, varin=30, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=34, varin=31, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=35, varin=28, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=18, varin=46, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=35)
DEBUG SOLUTION: LP solution array indices: FST[36-75], not_covered[76-95]
DEBUG SOLUTION: lp->best_solution[0] = 28333283.177780
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 35 rows, 60 cols, 216 nonzeros, 3 slack, 32 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=36, varin=20, theta=12.000000, up=999999999999999983222784.000000
ITER 2: row=17, varin=55, theta=0.352941, up=1.000000
ITER 3: row=24, varin=38, theta=0.500000, up=1.000000
ITER 4: row=2, varin=15, theta=0.545455, up=999999999999999983222784.000000
ITER 5: row=23, varin=18, theta=1.090909, up=999999999999999983222784.000000
ITER 6: row=21, varin=79, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=37)
DEBUG SOLUTION: LP solution array indices: FST[38-77], not_covered[78-97]
DEBUG SOLUTION: lp->best_solution[0] = 28431192.522505
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 37 rows, 60 cols, 224 nonzeros, 7 slack, 30 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 7 slack rows
  % @PAP adding 4 rows, 15 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=31, varin=53, theta=0.333333, up=1.000000
ITER 2: row=17, varin=20, theta=0.041667, up=999999999999999983222784.000000
ITER 3: row=22, varin=19, theta=0.263158, up=999999999999999983222784.000000
ITER 4: row=17, varin=17, theta=0.052632, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=34)
DEBUG SOLUTION: LP solution array indices: FST[35-74], not_covered[75-94]
DEBUG SOLUTION: lp->best_solution[0] = 28445287.302581
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.947368
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.947368
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.947368
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 34 rows, 60 cols, 219 nonzeros, 6 slack, 28 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 6 slack rows
  % @PAP adding 3 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=31, varin=41, theta=0.315789, up=1.000000
ITER 2: row=29, varin=14, theta=0.263158, up=999999999999999983222784.000000
ITER 3: row=30, varin=16, theta=1.250000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=31)
DEBUG SOLUTION: LP solution array indices: FST[32-71], not_covered[72-91]
DEBUG SOLUTION: lp->best_solution[0] = 28459382.141297
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 31 rows, 60 cols, 200 nonzeros, 1 slack, 30 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 74 LP 1 Solution, length = 28459382.141297, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.250000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.750000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.750000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 1.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.250000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.250000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.750000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.750000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.250000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.250000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.750000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.250000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.750000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.250000 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28459382.141297, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 74 at  28.45938214129668253349
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cc24b0
% @LO 0.05  28.33328317777997895632 99.9000000000
% @LN 0.05  28.33363676581232937224 99.9000000000
% Resuming node 63 at  28.33363676581232937224
DEBUG CONSTRNT: LP rows=30, pool->nlprows=30, pool->npend=0
DEBUG CONSTRNT: Checking 30 LP rows (pool tracks 30, total LP rows 30)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=29, expected 29
 % @PAP adding 48 rows, 199 nz to LP
DEBUG BB: Processing node 63, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 63 LP 2 Solution, length = 28333636.765812, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.500000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.500000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.500000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.500000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.500000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 3 fractional variables
DEBUG CG: LP optimal, z=28333636.765812, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28333636.765812, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 63 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 63
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.500000
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=1.000000
DEBUG CAREFUL: Skipping var 5: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.500000
DEBUG CAREFUL: Adding var 27 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.500000
DEBUG CAREFUL: Adding var 31 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 3 fractional variables

  %  Carefully choosing branching variable, nfrac = 3
DEBUG CAREFUL: Testing fvar[0] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 2
DEBUG CAREFUL: New best var: 2
DEBUG CAREFUL: Testing fvar[1] = var 27
DEBUG CAREFUL: Calling compare_branch_vars for var 27
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 27
DEBUG CAREFUL: New best var: 27
DEBUG CAREFUL: Testing fvar[2] = var 31
DEBUG CAREFUL: Calling compare_branch_vars for var 31
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 31
  % Initial guess is x27, Z0 = 28333636.7658123        , Z1 = 28611871.6355662        

DEBUG EVAL: Testing var 2 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=19, varin=35, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 0 gives z=28464592.952814
  % 	x2 = 0,	Z0 = 28464592.952814         
DEBUG EVAL: First branch cutoff check: z=28464592.952814, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 1
ITER 1: row=19, varin=32, theta=1.000000, up=999999999999999983222784.000000
  % 	x2 = 1,	Z1 = 28500366.009767         
DEBUG EVAL: Second branch cutoff check: z=28500366.009767, best_z=INF, threshold=INF
  %   New best:  x2, Z = 28464592.952814         
DEBUG EVAL: Testing var 27 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=32, varin=19, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 27 = 1 gives z=28837327.549143
  % 	x27 = 1,	Z1 = 28837327.5491432        
DEBUG EVAL: First branch cutoff check: z=28837327.549143, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 27 = 0
ITER 1: row=32, varin=35, theta=1.000000, up=999999999999999983222784.000000
  % 	x27 = 0,	Z0 = 28464592.952814         
DEBUG EVAL: Second branch cutoff check: z=28464592.952814, best_z=INF, threshold=INF
  %   New best:  x27, Z = 28464592.952814         
DEBUG EVAL: Testing var 31 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=72, theta=0.166667, up=1.000000
ITER 2: row=37, varin=46, theta=0.250000, up=999999999999999983222784.000000
ITER 3: row=38, varin=44, theta=0.500000, up=999999999999999983222784.000000
ITER 4: row=1, varin=43, theta=0.500000, up=999999999999999983222784.000000
ITER 5: row=43, varin=27, theta=0.222222, up=999999999999999983222784.000000
ITER 6: row=31, varin=62, theta=0.500000, up=1.000000
ITER 7: row=18, varin=39, theta=0.500000, up=999999999999999983222784.000000
ITER 8: row=39, varin=11, theta=0.500000, up=999999999999999983222784.000000
ITER 9: row=11, varin=36, theta=0.500000, up=999999999999999983222784.000000
ITER 10: row=36, varin=33, theta=0.625000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 31 = 1 gives z=28464592.952814
  % 	x31 = 1,	Z1 = 28469064.5849331        
DEBUG EVAL: First branch cutoff check: z=28469064.584933, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 31 = 0
ITER 1: row=1, varin=38, theta=0.166667, up=999999999999999983222784.000000
  % 	x31 = 0,	Z0 = 28340311.0278631        
DEBUG EVAL: Second branch cutoff check: z=28340311.027863, best_z=INF, threshold=INF
  % Best branch is x27, Z0 = 28464592.952814         , Z1 = 28837327.5491432        

DEBUG CAREFUL: Final result - returning best.var = 27
DEBUG BB: Branching variable chosen: j=27
 % @NC   95   63	x27 = 0	28464592.952814
 % @NC   96   63	x27 = 1	28837327.549143
 %      63    45 28333636.7658               28334072.4274    x1 D    47    10
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cb6f50
% @LO 0.05  28.33363676581232937224 99.9000000000
% @LN 0.05  28.33407242737993314563 99.9000000000
% Resuming node 91 at  28.33407242737993314563
DEBUG CONSTRNT: LP rows=48, pool->nlprows=48, pool->npend=0
DEBUG CONSTRNT: Checking 48 LP rows (pool tracks 48, total LP rows 48)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 133
DEBUG CONSTRNT: Pool row 133 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=47, expected 47
 % @PAP adding 43 rows, 183 nz to LP
DEBUG BB: Processing node 91, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=17, varin=48, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 28334072.427380
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 43 rows, 60 cols, 243 nonzeros, 0 slack, 43 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 6 rows, 33 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=44, varin=41, theta=0.333333, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 28338821.302317
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 49 rows, 60 cols, 276 nonzeros, 6 slack, 43 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 6 slack rows
  % Node 91 LP 1 Solution, length = 28338821.302317, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.333333 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.333333 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.333333 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 1.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 1.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.333333 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.333333 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.666667 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.666667 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.666667 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.666667 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.666667 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.666667 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.666667 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28338821.302317, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 91 at  28.33882130231657470176
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cd3ea0
% @LO 0.05  28.33407242737993314563 99.9000000000
% @LN 0.05  28.33564333279532476695 99.9000000000
% Resuming node 89 at  28.33564333279532476695
DEBUG CONSTRNT: LP rows=43, pool->nlprows=43, pool->npend=0
DEBUG CONSTRNT: Checking 43 LP rows (pool tracks 43, total LP rows 43)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=42, expected 42
 % @PAP adding 44 rows, 185 nz to LP
DEBUG BB: Processing node 89, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=17, varin=42, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28335643.332795
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 44 rows, 60 cols, 245 nonzeros, 3 slack, 41 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 42 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=46, varin=76, theta=0.111410, up=1.000000
ITER 2: row=45, varin=46, theta=501013.500000, up=999999999999999983222784.000000
ITER 3: row=31, varin=48, theta=0.031744, up=1.000000
ITER 4: row=40, varin=38, theta=0.044775, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
ITER 5: row=41, varin=16, theta=0.000000, up=999999999999999983222784.000000
ITER 6: row=4, varin=74, theta=0.500000, up=1.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=46)
DEBUG SOLUTION: LP solution array indices: FST[47-86], not_covered[87-106]
DEBUG SOLUTION: lp->best_solution[0] = 28353366.203013
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 46 rows, 60 cols, 287 nonzeros, 4 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % Node 89 LP 1 Solution, length = 28353366.203013, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.500000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.500000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 1.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.500000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.500000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.500000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.500000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.500000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.500000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.500000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.500000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.500000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.500000 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28353366.203013, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 89 at  28.35336620301294985325
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cd5610
% @LO 0.05  28.33564333279532476695 99.9000000000
% @LN 0.05  28.33692677363615430863 99.9000000000
% Resuming node 66 at  28.33692677363615430863
DEBUG CONSTRNT: LP rows=42, pool->nlprows=42, pool->npend=0
DEBUG CONSTRNT: Checking 42 LP rows (pool tracks 42, total LP rows 42)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 65
DEBUG CONSTRNT: Pool row 65 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 158
DEBUG CONSTRNT: Pool row 158 has lprow=41, expected 41
 % @PAP adding 34 rows, 163 nz to LP
DEBUG BB: Processing node 66, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=29, varin=33, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=10, varin=21, theta=12.000000, up=999999999999999983222784.000000
ITER 3: row=18, varin=52, theta=0.352941, up=1.000000
ITER 4: row=25, varin=35, theta=0.500000, up=1.000000
ITER 5: row=2, varin=13, theta=0.545455, up=999999999999999983222784.000000
ITER 6: row=24, varin=19, theta=1.090909, up=999999999999999983222784.000000
ITER 7: row=22, varin=44, theta=0.500000, up=1.000000
ITER 8: row=17, varin=76, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=8)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=34)
DEBUG SOLUTION: LP solution array indices: FST[35-74], not_covered[75-94]
DEBUG SOLUTION: lp->best_solution[0] = 28336926.773636
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 34 rows, 60 cols, 223 nonzeros, 2 slack, 32 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 15 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=35, varin=57, theta=0.333333, up=1.000000
ITER 2: row=21, varin=24, theta=0.041667, up=999999999999999983222784.000000
ITER 3: row=26, varin=23, theta=0.263158, up=999999999999999983222784.000000
ITER 4: row=21, varin=21, theta=0.052632, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=38)
DEBUG SOLUTION: LP solution array indices: FST[39-78], not_covered[79-98]
DEBUG SOLUTION: lp->best_solution[0] = 28351021.553712
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.947368
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.947368
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.947368
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 38 rows, 60 cols, 238 nonzeros, 8 slack, 30 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 8 slack rows
  % @PAP adding 7 rows, 26 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=37, varin=48, theta=0.048276, up=1.000000
ITER 2: row=32, varin=64, theta=0.759259, up=1.000000
ITER 3: row=31, varin=18, theta=0.092593, up=999999999999999983222784.000000
ITER 4: row=34, varin=20, theta=0.555556, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=37)
DEBUG SOLUTION: LP solution array indices: FST[38-77], not_covered[78-97]
DEBUG SOLUTION: lp->best_solution[0] = 28379579.889142
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
  % @PL 37 rows, 60 cols, 233 nonzeros, 2 slack, 35 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 3 rows, 7 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=36, varin=32, theta=0.555556, up=999999999999999983222784.000000
ITER 2: row=18, varin=75, theta=1.000000, up=1.000000
ITER 3: row=9, varin=42, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=38)
DEBUG SOLUTION: LP solution array indices: FST[39-78], not_covered[79-98]
DEBUG SOLUTION: lp->best_solution[0] = 28391206.451513
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
  % @PL 38 rows, 60 cols, 226 nonzeros, 0 slack, 38 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 6 rows, 31 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=39, varin=35, theta=0.833333, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28394239.745604
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
  % @PL 44 rows, 60 cols, 257 nonzeros, 4 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % Node 66 LP 1 Solution, length = 28394239.745604, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.166667 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.166667 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.166667 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 1.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.166667 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.166667 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.166667 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.833333 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.833333 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.833333 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.833333 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.833333 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.833333 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.833333 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28394239.745604, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 66 at  28.39423974560416397139
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cb6f50
% @LO 0.05  28.33692677363615430863 99.9000000000
% @LN 0.05  28.33882130231657470176 99.9000000000
% Resuming node 91 at  28.33882130231657470176
DEBUG CONSTRNT: LP rows=40, pool->nlprows=40, pool->npend=0
DEBUG CONSTRNT: Checking 40 LP rows (pool tracks 40, total LP rows 40)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=39, expected 39
 % @PAP adding 43 rows, 183 nz to LP
DEBUG BB: Processing node 91, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 91 LP 2 Solution, length = 28338821.302317, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.333333 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.333333 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.333333 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 1.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 1.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.333333 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.333333 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.666667 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.666667 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.666667 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.666667 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.666667 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.666667 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.666667 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28338821.302317, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28338821.302317, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 91 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 91
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.333333
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.333333
DEBUG CAREFUL: Adding var 4 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.333333
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=1.000000
DEBUG CAREFUL: Skipping var 12: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=1.000000
DEBUG CAREFUL: Skipping var 13: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.333333
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.333333
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 4
DEBUG CAREFUL: Calling compare_branch_vars for var 4
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 4
DEBUG CAREFUL: New best var: 4
DEBUG CAREFUL: Testing fvar[1] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[2] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[3] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[4] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
  % Initial guess is x4, Z0 = 28338821.3023166        , Z1 = 28613484.6830733        

DEBUG EVAL: Testing var 4 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=17, varin=40, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=40, varin=3, theta=2.000000, up=999999999999999983222784.000000
ITER 3: row=3, varin=52, theta=1.000000, up=1.000000
ITER 4: row=10, varin=39, theta=2.000000, up=999999999999999983222784.000000
ITER 5: row=39, varin=28, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=42, varin=35, theta=2.000000, up=999999999999999983222784.000000
ITER 7: row=35, varin=29, theta=1.000000, up=999999999999999983222784.000000
ITER 8: row=43, varin=31, theta=1.000000, up=999999999999999983222784.000000
ITER 9: row=5, varin=30, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 4 = 1 gives z=28743753.230497
  % 	x4 = 1,	Z1 = 28743753.2304966        
DEBUG EVAL: First branch cutoff check: z=28743753.230497, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 4 = 0
ITER 1: row=17, varin=41, theta=1.000000, up=999999999999999983222784.000000
  % 	x4 = 0,	Z0 = 28348319.0521899        
DEBUG EVAL: Second branch cutoff check: z=28348319.052190, best_z=INF, threshold=INF
  %   New best:  x4, Z = 28348319.0521899        
DEBUG EVAL: Testing var 2 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=41, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 1 gives z=28348319.052190
  % 	x2 = 1,	Z1 = 28348319.0521899        
DEBUG EVAL: First branch cutoff check: z=28348319.052190, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 0
ITER 1: row=1, varin=73, theta=1.000000, up=1.000000
ITER 2: row=34, varin=88, theta=0.250000, up=1.000000
  % 	x2 = 0,	Z0 = 28352828.7157078        
DEBUG EVAL: Second branch cutoff check: z=28352828.715708, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 17 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=28, varin=41, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 17 = 1 gives z=28348319.052190
  % 	x17 = 1,	Z1 = 28348319.0521899        
DEBUG EVAL: First branch cutoff check: z=28348319.052190, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 17 = 0
ITER 1: row=28, varin=73, theta=1.000000, up=1.000000
ITER 2: row=34, varin=88, theta=0.250000, up=1.000000
  % 	x17 = 0,	Z0 = 28352828.7157078        
DEBUG EVAL: Second branch cutoff check: z=28352828.715708, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 10 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=14, varin=41, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 1 gives z=28348319.052190
  % 	x10 = 1,	Z1 = 28348319.0521899        
DEBUG EVAL: First branch cutoff check: z=28348319.052190, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 0
ITER 1: row=14, varin=73, theta=1.000000, up=1.000000
ITER 2: row=34, varin=88, theta=0.250000, up=1.000000
  % 	x10 = 0,	Z0 = 28352828.7157078        
DEBUG EVAL: Second branch cutoff check: z=28352828.715708, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 26 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=35, varin=41, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 26 = 1 gives z=28348319.052190
  % 	x26 = 1,	Z1 = 28348319.0521899        
DEBUG EVAL: First branch cutoff check: z=28348319.052190, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 26 = 0
ITER 1: row=35, varin=73, theta=1.000000, up=1.000000
ITER 2: row=34, varin=88, theta=0.250000, up=1.000000
  % 	x26 = 0,	Z0 = 28352828.7157078        
DEBUG EVAL: Second branch cutoff check: z=28352828.715708, best_z=INF, threshold=INF
  % Best branch is x4, Z0 = 28348319.0521899        , Z1 = 28743753.2304966        

DEBUG CAREFUL: Final result - returning best.var = 4
DEBUG BB: Branching variable chosen: j=4
 % @NC   97   91	x4 = 0	28348319.052190
 % @NC   98   91	x4 = 1	28743753.230497
 %      91    46 28338821.3023               28346616.5593   x11 D    69     9
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7ca0600
% @LO 0.05  28.33882130231657470176 99.9000000000
% @LN 0.05  28.34661655928454138120 99.9000000000
% Resuming node 79 at  28.34661655928454138120
DEBUG CONSTRNT: LP rows=43, pool->nlprows=43, pool->npend=0
DEBUG CONSTRNT: Checking 43 LP rows (pool tracks 43, total LP rows 43)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=42, expected 42
 % @PAP adding 36 rows, 172 nz to LP
DEBUG BB: Processing node 79, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=12, varin=33, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=13, varin=34, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=18, varin=19, theta=0.571429, up=999999999999999983222784.000000
ITER 4: row=1, varin=38, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=36)
DEBUG SOLUTION: LP solution array indices: FST[37-76], not_covered[77-96]
DEBUG SOLUTION: lp->best_solution[0] = 28344713.475423
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 36 rows, 60 cols, 232 nonzeros, 1 slack, 35 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 6 rows, 40 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=37, varin=30, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=39, varin=31, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=1, varin=45, theta=0.642857, up=1.000000
ITER 4: row=41, varin=52, theta=1.000000, up=1.000000
ITER 5: row=35, varin=32, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=19, varin=53, theta=2.000000, up=1.000000
ITER 7: row=19, varin=20, theta=12.000000, up=999999999999999983222784.000000
ITER 8: row=17, varin=60, theta=0.352941, up=1.000000
ITER 9: row=24, varin=43, theta=0.500000, up=1.000000
ITER 10: row=2, varin=15, theta=0.545455, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=12)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 28536896.619434
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 42 rows, 60 cols, 272 nonzeros, 10 slack, 32 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 10 slack rows
  % @PAP adding 4 rows, 15 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=33, varin=55, theta=0.333333, up=1.000000
ITER 2: row=17, varin=20, theta=0.041667, up=999999999999999983222784.000000
ITER 3: row=22, varin=19, theta=0.263158, up=999999999999999983222784.000000
ITER 4: row=17, varin=17, theta=0.052632, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=36)
DEBUG SOLUTION: LP solution array indices: FST[37-76], not_covered[77-96]
DEBUG SOLUTION: lp->best_solution[0] = 28550991.399510
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.947368
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.947368
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.947368
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 36 rows, 60 cols, 237 nonzeros, 6 slack, 30 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 6 slack rows
  % @PAP adding 7 rows, 26 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=37, varin=48, theta=0.048276, up=1.000000
ITER 2: row=32, varin=64, theta=0.759259, up=1.000000
ITER 3: row=31, varin=14, theta=0.092593, up=999999999999999983222784.000000
ITER 4: row=34, varin=16, theta=0.555556, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=37)
DEBUG SOLUTION: LP solution array indices: FST[38-77], not_covered[78-97]
DEBUG SOLUTION: lp->best_solution[0] = 28579549.734941
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 37 rows, 60 cols, 236 nonzeros, 3 slack, 34 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 3 rows, 7 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=35, varin=31, theta=0.555556, up=999999999999999983222784.000000
ITER 2: row=14, varin=74, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=37)
DEBUG SOLUTION: LP solution array indices: FST[38-77], not_covered[78-97]
DEBUG SOLUTION: lp->best_solution[0] = 28588852.888767
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 37 rows, 60 cols, 227 nonzeros, 0 slack, 37 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=38, varin=43, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=39)
DEBUG SOLUTION: LP solution array indices: FST[40-79], not_covered[80-99]
DEBUG SOLUTION: lp->best_solution[0] = 28591176.297312
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 39 rows, 60 cols, 235 nonzeros, 0 slack, 39 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 6 rows, 31 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=40, varin=34, theta=0.833333, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 28594209.591402
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 45 rows, 60 cols, 266 nonzeros, 4 slack, 41 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % Node 79 LP 1 Solution, length = 28594209.591402, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.166667 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.166667 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 1.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.166667 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.166667 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.166667 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.166667 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.833333 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.833333 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.833333 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.833333 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.833333 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.833333 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.833333 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28594209.591402, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 79 at  28.59420959140232909590
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cc24b0
% @LO 0.05  28.34661655928454138120 99.9000000000
% @LN 0.05  28.34831905218985426131 99.9000000000
% Resuming node 97 at  28.34831905218985426131
DEBUG CONSTRNT: LP rows=41, pool->nlprows=41, pool->npend=0
DEBUG CONSTRNT: Checking 41 LP rows (pool tracks 41, total LP rows 41)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 45
DEBUG CONSTRNT: Pool row 45 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 62
DEBUG CONSTRNT: Pool row 62 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 79
DEBUG CONSTRNT: Pool row 79 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=40, expected 40
 % @PAP adding 43 rows, 183 nz to LP
DEBUG BB: Processing node 97, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=17, varin=41, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 28348319.052190
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 43 rows, 60 cols, 243 nonzeros, 3 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 42 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=45, varin=75, theta=0.205006, up=1.000000
ITER 2: row=44, varin=45, theta=380338.500000, up=999999999999999983222784.000000
ITER 3: row=34, varin=90, theta=0.058413, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 28350573.883949
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.875000
DEBUG SOLUTION: lp->best_solution[5] = 2.875000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 45 rows, 60 cols, 285 nonzeros, 7 slack, 38 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 7 slack rows
  % @PAP adding 5 rows, 12 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=39, varin=31, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=42, varin=25, theta=0.125000, up=999999999999999983222784.000000
ITER 3: row=43, varin=71, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 28366041.922407
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 0.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 43 rows, 60 cols, 240 nonzeros, 0 slack, 43 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 97 LP 1 Solution, length = 28366041.922407, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.500000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.500000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 1.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 1.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.500000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.500000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.500000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.500000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.500000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.500000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.500000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.500000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.500000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.500000 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28366041.922407, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 97 at  28.36604192240747934761
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cc9ac0
% @LO 0.05  28.34831905218985426131 99.9000000000
% @LN 0.05  28.35291159051858045359 99.9000000000
% Resuming node 65 at  28.35291159051858045359
DEBUG CONSTRNT: LP rows=43, pool->nlprows=43, pool->npend=0
DEBUG CONSTRNT: Checking 43 LP rows (pool tracks 43, total LP rows 43)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 158
DEBUG CONSTRNT: Pool row 158 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=42, expected 42
 % @PAP adding 33 rows, 161 nz to LP
DEBUG BB: Processing node 65, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 65 LP 2 Solution, length = 28352911.590519, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.500000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.500000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.500000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.500000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.500000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.500000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.500000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.500000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.500000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.500000 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=28352911.590519, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28352911.590519, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 65 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 65
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=1.000000
DEBUG CAREFUL: Skipping var 5: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.500000
DEBUG CAREFUL: Adding var 9 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.500000
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.500000
DEBUG CAREFUL: Adding var 12 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.500000
DEBUG CAREFUL: Adding var 14 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 4 fractional variables

  %  Carefully choosing branching variable, nfrac = 4
DEBUG CAREFUL: Testing fvar[0] = var 9
DEBUG CAREFUL: Calling compare_branch_vars for var 9
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 9
DEBUG CAREFUL: New best var: 9
DEBUG CAREFUL: Testing fvar[1] = var 12
DEBUG CAREFUL: Calling compare_branch_vars for var 12
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 12
DEBUG CAREFUL: Testing fvar[2] = var 14
DEBUG CAREFUL: Calling compare_branch_vars for var 14
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 14
DEBUG CAREFUL: Testing fvar[3] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
  % Initial guess is x9, Z0 = 28352911.5905186        , Z1 = 28414538.7132014        

DEBUG EVAL: Testing var 9 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=17, varin=24, theta=0.477273, up=999999999999999983222784.000000
ITER 2: row=26, varin=2, theta=0.500000, up=999999999999999983222784.000000
ITER 3: row=2, varin=25, theta=0.318584, up=999999999999999983222784.000000
ITER 4: row=21, varin=20, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=19, varin=32, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=10, varin=18, theta=0.428571, up=999999999999999983222784.000000
ITER 7: row=1, varin=35, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 9 = 1 gives z=28433477.194696
  % 	x9 = 1,	Z1 = 28433477.194696         
DEBUG EVAL: First branch cutoff check: z=28433477.194696, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 9 = 0
ITER 1: row=17, varin=21, theta=3.818182, up=999999999999999983222784.000000
ITER 2: row=22, varin=75, theta=1.000000, up=1.000000
  % 	x9 = 0,	Z0 = 28384226.7988142        
DEBUG EVAL: Second branch cutoff check: z=28384226.798814, best_z=INF, threshold=INF
  %   New best:  x9, Z = 28384226.7988142        
DEBUG EVAL: Testing var 12 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=9, varin=21, theta=3.818182, up=999999999999999983222784.000000
ITER 2: row=22, varin=75, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 12 = 0 gives z=28384226.798814
  % 	x12 = 0,	Z0 = 28384226.7988142        
DEBUG EVAL: First branch cutoff check: z=28384226.798814, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 12 = 1
ITER 1: row=9, varin=24, theta=0.477273, up=999999999999999983222784.000000
ITER 2: row=26, varin=2, theta=0.500000, up=999999999999999983222784.000000
ITER 3: row=2, varin=25, theta=0.318584, up=999999999999999983222784.000000
ITER 4: row=21, varin=20, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=19, varin=32, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=10, varin=18, theta=0.428571, up=999999999999999983222784.000000
ITER 7: row=1, varin=35, theta=1.000000, up=1.000000
  % 	x12 = 1,	Z1 = 28433477.194696         
DEBUG EVAL: Second branch cutoff check: z=28433477.194696, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 14 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=18, varin=21, theta=3.818182, up=999999999999999983222784.000000
ITER 2: row=22, varin=75, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 14 = 1 gives z=28384226.798814
  % 	x14 = 1,	Z1 = 28384226.7988142        
DEBUG EVAL: First branch cutoff check: z=28384226.798814, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 14 = 0
ITER 1: row=18, varin=24, theta=0.477273, up=999999999999999983222784.000000
ITER 2: row=26, varin=2, theta=0.500000, up=999999999999999983222784.000000
ITER 3: row=2, varin=25, theta=0.318584, up=999999999999999983222784.000000
ITER 4: row=21, varin=20, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=19, varin=32, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=12, varin=18, theta=0.428571, up=999999999999999983222784.000000
ITER 7: row=1, varin=35, theta=1.000000, up=1.000000
  % 	x14 = 0,	Z0 = 28433477.194696         
DEBUG EVAL: Second branch cutoff check: z=28433477.194696, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 10 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=10, varin=21, theta=3.818182, up=999999999999999983222784.000000
ITER 2: row=22, varin=10, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 0 gives z=28370952.468358
  % 	x10 = 0,	Z0 = 28370952.4683576        
DEBUG EVAL: First branch cutoff check: z=28370952.468358, best_z=INF, threshold=INF
  % Best branch is x9, Z0 = 28384226.7988142        , Z1 = 28433477.194696         

DEBUG CAREFUL: Final result - returning best.var = 9
DEBUG BB: Branching variable chosen: j=9
 % @NC   99   65	x9 = 0	28384226.798814
 % @NC  100   65	x9 = 1	28433477.194696
 %      65    47 28352911.5905               28353366.2030   x15 D    14     5
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cd3ea0
% @LO 0.05  28.35291159051858045359 99.9000000000
% @LN 0.05  28.35336620301294985325 99.9000000000
% Resuming node 89 at  28.35336620301294985325
DEBUG CONSTRNT: LP rows=33, pool->nlprows=33, pool->npend=0
DEBUG CONSTRNT: Checking 33 LP rows (pool tracks 33, total LP rows 33)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=32, expected 32
 % @PAP adding 42 rows, 181 nz to LP
DEBUG BB: Processing node 89, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 89 LP 2 Solution, length = 28353366.203013, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.500000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.500000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 1.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.500000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.500000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.500000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.500000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.500000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.500000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.500000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.500000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.500000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.500000 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28353366.203013, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28353366.203013, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 89 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 89
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.500000
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.500000
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=1.000000
DEBUG CAREFUL: Skipping var 13: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.500000
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.500000
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.500000
DEBUG CAREFUL: Adding var 27 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 27
DEBUG CAREFUL: Calling compare_branch_vars for var 27
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 27
DEBUG CAREFUL: New best var: 27
DEBUG CAREFUL: Testing fvar[1] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[2] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[3] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[4] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
  % Initial guess is x27, Z0 = 28353366.203013         , Z1 = 28371089.0732306        

DEBUG EVAL: Testing var 27 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=41, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=41, varin=31, theta=0.500000, up=999999999999999983222784.000000
ITER 3: row=31, varin=42, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 27 = 1 gives z=28371089.073231
  % 	x27 = 1,	Z1 = 28371089.0732306        
DEBUG EVAL: First branch cutoff check: z=28371089.073231, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 27 = 0
ITER 1: row=1, varin=87, theta=0.166667, up=1.000000
  % 	x27 = 0,	Z0 = 28355634.5856536        
DEBUG EVAL: Second branch cutoff check: z=28355634.585654, best_z=INF, threshold=INF
  %   New best:  x27, Z = 28355634.5856536        
DEBUG EVAL: Testing var 2 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=18, varin=26, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 1 gives z=28371252.731489
  % 	x2 = 1,	Z1 = 28371252.7314894        
DEBUG EVAL: First branch cutoff check: z=28371252.731489, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 0
ITER 1: row=18, varin=42, theta=1.000000, up=999999999999999983222784.000000
  % 	x2 = 0,	Z0 = 28371089.0732306        
DEBUG EVAL: Second branch cutoff check: z=28371089.073231, best_z=INF, threshold=INF
  %   New best:  x2, Z = 28371089.0732306        
DEBUG EVAL: Testing var 17 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=27, varin=15, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 17 = 1 gives z=28458200.002247
  % 	x17 = 1,	Z1 = 28458200.0022471        
DEBUG EVAL: First branch cutoff check: z=28458200.002247, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 17 = 0
ITER 1: row=27, varin=42, theta=1.000000, up=999999999999999983222784.000000
  % 	x17 = 0,	Z0 = 28371089.0732306        
DEBUG EVAL: Second branch cutoff check: z=28371089.073231, best_z=INF, threshold=INF
  %   New best:  x17, Z = 28371089.0732306        
DEBUG EVAL: Testing var 10 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=14, varin=32, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 1 gives z=28544674.916021
  % 	x10 = 1,	Z1 = 28544674.9160209        
DEBUG EVAL: First branch cutoff check: z=28544674.916021, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 0
ITER 1: row=14, varin=42, theta=1.000000, up=999999999999999983222784.000000
  % 	x10 = 0,	Z0 = 28371089.0732306        
DEBUG EVAL: Second branch cutoff check: z=28371089.073231, best_z=INF, threshold=INF
  %   New best:  x10, Z = 28371089.0732306        
DEBUG EVAL: Testing var 26 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=32, varin=14, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=35, varin=15, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 26 = 1 gives z=28744459.684803
  % 	x26 = 1,	Z1 = 28744459.6848026        
DEBUG EVAL: First branch cutoff check: z=28744459.684803, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 26 = 0
ITER 1: row=32, varin=42, theta=1.000000, up=999999999999999983222784.000000
  % 	x26 = 0,	Z0 = 28371089.0732306        
DEBUG EVAL: Second branch cutoff check: z=28371089.073231, best_z=INF, threshold=INF
  %   New best:  x26, Z = 28371089.0732306        
  % Best branch is x26, Z0 = 28371089.0732306        , Z1 = 28744459.6848026        

DEBUG CAREFUL: Final result - returning best.var = 26
DEBUG BB: Branching variable chosen: j=26
 % @NC  101   89	x26 = 0	28371089.073231
 % @NC  102   89	x26 = 1	28744459.684803
 %      89    48 28353366.2030               28355128.8429    x4 D    85     9
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cac0a0
% @LO 0.06  28.35336620301294985325 99.9000000000
% @LN 0.06  28.35512884287092205682 99.9000000000
% Resuming node 77 at  28.35512884287092205682
DEBUG CONSTRNT: LP rows=42, pool->nlprows=42, pool->npend=0
DEBUG CONSTRNT: Checking 42 LP rows (pool tracks 42, total LP rows 42)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 65
DEBUG CONSTRNT: Pool row 65 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 158
DEBUG CONSTRNT: Pool row 158 has lprow=41, expected 41
 % @PAP adding 29 rows, 176 nz to LP
DEBUG BB: Processing node 77, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=21, varin=12, theta=1.341386, up=999999999999999983222784.000000
ITER 2: row=27, varin=18, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=1, varin=29, theta=2.000000, up=999999999999999983222784.000000
ITER 4: row=19, varin=26, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=26, varin=74, theta=0.164577, up=1.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=29)
DEBUG SOLUTION: LP solution array indices: FST[30-69], not_covered[70-89]
DEBUG SOLUTION: lp->best_solution[0] = 28355128.842871
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.417712
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 29 rows, 60 cols, 236 nonzeros, 3 slack, 26 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 8 rows, 43 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=32, varin=24, theta=0.107114, up=999999999999999983222784.000000
ITER 2: row=30, varin=86, theta=0.928310, up=1.000000
ITER 3: row=29, varin=23, theta=0.109434, up=999999999999999983222784.000000
ITER 4: row=31, varin=32, theta=5.656064, up=999999999999999983222784.000000
ITER 5: row=28, varin=31, theta=1.032449, up=999999999999999983222784.000000
ITER 6: row=33, varin=29, theta=3.903734, up=999999999999999983222784.000000
ITER 7: row=27, varin=33, theta=0.147134, up=999999999999999983222784.000000
ITER 8: row=28, varin=47, theta=0.204154, up=1.000000
LP PHASE: Switching to primal (iter=8)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=34)
DEBUG SOLUTION: LP solution array indices: FST[35-74], not_covered[75-94]
DEBUG SOLUTION: lp->best_solution[0] = 28370676.532679
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 34 rows, 60 cols, 264 nonzeros, 4 slack, 30 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % @PAP adding 2 rows, 9 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=31, varin=26, theta=0.274689, up=999999999999999983222784.000000
ITER 2: row=29, varin=35, theta=0.100055, up=1.000000
ITER 3: row=17, varin=19, theta=77898.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=32)
DEBUG SOLUTION: LP solution array indices: FST[33-72], not_covered[73-92]
DEBUG SOLUTION: lp->best_solution[0] = 28372602.642112
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 32 rows, 60 cols, 244 nonzeros, 1 slack, 31 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 77 LP 1 Solution, length = 28372602.642112, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.500000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.500000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.500000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 1.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.500000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.500000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.500000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 3 fractional variables
DEBUG CG: LP optimal, z=28372602.642112, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 77 at  28.37260264211232652087
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cc24b0
% @LO 0.06  28.35512884287092205682 99.9000000000
% @LN 0.06  28.36604192240747934761 99.9000000000
% Resuming node 97 at  28.36604192240747934761
DEBUG CONSTRNT: LP rows=31, pool->nlprows=31, pool->npend=0
DEBUG CONSTRNT: Checking 31 LP rows (pool tracks 31, total LP rows 31)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 45
DEBUG CONSTRNT: Pool row 45 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 62
DEBUG CONSTRNT: Pool row 62 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 121
DEBUG CONSTRNT: Pool row 121 has lprow=30, expected 30
 % @PAP adding 43 rows, 180 nz to LP
DEBUG BB: Processing node 97, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 97 LP 2 Solution, length = 28366041.922407, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.500000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.500000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 1.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 1.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.500000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.500000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.500000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.500000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.500000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.500000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.500000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.500000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.500000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.500000 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28366041.922407, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28366041.922407, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 97 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 97
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.500000
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.500000
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=1.000000
DEBUG CAREFUL: Skipping var 12: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=1.000000
DEBUG CAREFUL: Skipping var 13: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.500000
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.500000
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.500000
DEBUG CAREFUL: Adding var 27 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 27
DEBUG CAREFUL: Calling compare_branch_vars for var 27
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 27
DEBUG CAREFUL: New best var: 27
DEBUG CAREFUL: Testing fvar[1] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[2] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[3] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[4] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
  % Initial guess is x27, Z0 = 28366041.9224075        , Z1 = 28398308.1177553        

DEBUG EVAL: Testing var 27 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=43, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=43, varin=42, theta=0.250000, up=999999999999999983222784.000000
ITER 3: row=31, varin=39, theta=0.250000, up=999999999999999983222784.000000
ITER 4: row=39, varin=38, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 27 = 1 gives z=28383764.792625
  % 	x27 = 1,	Z1 = 28398308.1177553        
DEBUG EVAL: First branch cutoff check: z=28398308.117755, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 27 = 0
ITER 1: row=1, varin=76, theta=0.500000, up=1.000000
  % 	x27 = 0,	Z0 = 28398709.4529884        
DEBUG EVAL: Second branch cutoff check: z=28398709.452988, best_z=INF, threshold=INF
  %   New best:  x27, Z = 28398308.1177553        
DEBUG EVAL: Testing var 2 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=16, varin=38, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 0 gives z=28383764.792625
  % 	x2 = 0,	Z0 = 28383764.7926251        
DEBUG EVAL: First branch cutoff check: z=28383764.792625, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 17 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=28, varin=38, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 17 = 0 gives z=28383764.792625
  % 	x17 = 0,	Z0 = 28383764.7926251        
DEBUG EVAL: First branch cutoff check: z=28383764.792625, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 10 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=13, varin=38, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 0 gives z=28383764.792625
  % 	x10 = 0,	Z0 = 28383764.7926251        
DEBUG EVAL: First branch cutoff check: z=28383764.792625, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 26 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=32, varin=38, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 26 = 0 gives z=28383764.792625
  % 	x26 = 0,	Z0 = 28383764.7926251        
DEBUG EVAL: First branch cutoff check: z=28383764.792625, best_z=INF, threshold=INF
  % Best branch is x27, Z0 = 28398709.4529884        , Z1 = 28398308.1177553        

DEBUG CAREFUL: Final result - returning best.var = 27
DEBUG BB: Branching variable chosen: j=27
 % @NC  103   97	x27 = 1	28398308.117755
 % @NC  104   97	x27 = 0	28398709.452988
 %      97    49 28366041.9224               28366925.6658    x4 D    91    10
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cb66c0
% @LO 0.06  28.36604192240747934761 99.9000000000
% @LN 0.06  28.36692566579900542934 99.9000000000
% Resuming node 81 at  28.36692566579900542934
DEBUG CONSTRNT: LP rows=43, pool->nlprows=43, pool->npend=0
DEBUG CONSTRNT: Checking 43 LP rows (pool tracks 43, total LP rows 43)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 158
DEBUG CONSTRNT: Pool row 158 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=42, expected 42
 % @PAP adding 38 rows, 190 nz to LP
DEBUG BB: Processing node 81, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 81 LP 2 Solution, length = 28366925.665799, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.333333 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.333333 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.333333 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.878086 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.878086 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.333333 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.333333 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.333333 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.666667 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.666667 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.666667 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.666667 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.666667 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.121914 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.121914 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.666667 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.121914 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.121914 (terminal 19)
 % 8 fractional variables
DEBUG CG: LP optimal, z=28366925.665799, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28366925.665799, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 81 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 81
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.333333
DEBUG CAREFUL: Adding var 0 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.333333
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.333333
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.878086
DEBUG CAREFUL: Adding var 9 to fractional list (xi=0.878086)
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.878086
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.878086)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.333333
DEBUG CAREFUL: Adding var 30 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.333333
DEBUG CAREFUL: Adding var 32 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.333333
DEBUG CAREFUL: Adding var 33 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 8 fractional variables

  %  Carefully choosing branching variable, nfrac = 8
DEBUG CAREFUL: Testing fvar[0] = var 30
DEBUG CAREFUL: Calling compare_branch_vars for var 30
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 30
DEBUG CAREFUL: New best var: 30
DEBUG CAREFUL: Testing fvar[1] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 1
DEBUG CAREFUL: New best var: 1
DEBUG CAREFUL: Testing fvar[2] = var 0
DEBUG CAREFUL: Calling compare_branch_vars for var 0
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 0
DEBUG CAREFUL: New best var: 0
DEBUG CAREFUL: Testing fvar[3] = var 33
DEBUG CAREFUL: Calling compare_branch_vars for var 33
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 33
DEBUG CAREFUL: Testing fvar[4] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[5] = var 32
DEBUG CAREFUL: Calling compare_branch_vars for var 32
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 32
DEBUG CAREFUL: Testing fvar[6] = var 9
DEBUG CAREFUL: Calling compare_branch_vars for var 9
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 9
DEBUG CAREFUL: Testing fvar[7] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
  % Initial guess is x0, Z0 = 28366925.665799         , Z1 = 28942041.8664205        

DEBUG EVAL: Testing var 30 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=18, varin=22, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=3, varin=35, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 30 = 0 gives z=28380220.472297
  % 	x30 = 0,	Z0 = 28380220.4722966        
DEBUG EVAL: First branch cutoff check: z=28380220.472297, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 30 = 1
ITER 1: row=18, varin=34, theta=0.666667, up=999999999999999983222784.000000
ITER 2: row=4, varin=32, theta=0.333333, up=999999999999999983222784.000000
ITER 3: row=32, varin=36, theta=0.500000, up=999999999999999983222784.000000
  % 	x30 = 1,	Z1 = 28398007.0479305        
DEBUG EVAL: Second branch cutoff check: z=28398007.047931, best_z=INF, threshold=INF
  %   New best:  x30, Z = 28380220.4722966        
DEBUG EVAL: Testing var 1 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=2, varin=22, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=3, varin=35, theta=2.000000, up=999999999999999983222784.000000
ITER 3: row=18, varin=36, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 1 = 1 gives z=28430611.727702
  % 	x1 = 1,	Z1 = 28785216.1106666        
DEBUG EVAL: First branch cutoff check: z=28785216.110667, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 1 = 0
ITER 1: row=2, varin=61, theta=1.000000, up=1.000000
ITER 2: row=13, varin=38, theta=328201.000000, up=999999999999999983222784.000000
  % 	x1 = 0,	Z0 = 28393800.8338017        
DEBUG EVAL: Second branch cutoff check: z=28393800.833802, best_z=INF, threshold=INF
  %   New best:  x1, Z = 28393800.8338017        
DEBUG EVAL: Testing var 0 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=22, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=2, varin=35, theta=2.000000, up=999999999999999983222784.000000
ITER 3: row=18, varin=36, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 0 = 1 gives z=28430611.727702
  % 	x0 = 1,	Z1 = 28942041.8664205        
DEBUG EVAL: First branch cutoff check: z=28942041.866421, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 0 = 0
ITER 1: row=1, varin=61, theta=1.000000, up=1.000000
ITER 2: row=13, varin=38, theta=328201.000000, up=999999999999999983222784.000000
  % 	x0 = 0,	Z0 = 28393800.8338017        
DEBUG EVAL: Second branch cutoff check: z=28393800.833802, best_z=INF, threshold=INF
  %   New best:  x0, Z = 28393800.8338017        
DEBUG EVAL: Testing var 33 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=35, varin=36, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 33 = 0 gives z=28385473.890253
  % 	x33 = 0,	Z0 = 28385473.8902527        
DEBUG EVAL: First branch cutoff check: z=28385473.890253, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 2 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=4, varin=34, theta=0.333333, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 0 gives z=28375281.104251
  % 	x2 = 0,	Z0 = 28375281.1042509        
DEBUG EVAL: First branch cutoff check: z=28375281.104251, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 32 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=32, varin=22, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=2, varin=35, theta=2.000000, up=999999999999999983222784.000000
ITER 3: row=18, varin=36, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 32 = 1 gives z=28430611.727702
  % 	x32 = 1,	Z1 = 28430611.7277015        
DEBUG EVAL: First branch cutoff check: z=28430611.727702, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 32 = 0
ITER 1: row=32, varin=34, theta=0.333333, up=999999999999999983222784.000000
  % 	x32 = 0,	Z0 = 28375281.1042509        
DEBUG EVAL: Second branch cutoff check: z=28375281.104251, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 9 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=16, varin=61, theta=0.263860, up=1.000000
DEBUG EVAL: Branch var 9 = 1 gives z=28373562.715726
  % 	x9 = 1,	Z1 = 28373562.715726         
DEBUG EVAL: First branch cutoff check: z=28373562.715726, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 10 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=13, varin=61, theta=0.263860, up=1.000000
DEBUG EVAL: Branch var 10 = 1 gives z=28373562.715726
  % 	x10 = 1,	Z1 = 28373562.715726         
DEBUG EVAL: First branch cutoff check: z=28373562.715726, best_z=INF, threshold=INF
  % Best branch is x0, Z0 = 28393800.8338017        , Z1 = 28942041.8664205        

DEBUG CAREFUL: Final result - returning best.var = 0
DEBUG BB: Branching variable chosen: j=0
 % @NC  105   81	x0 = 0	28393800.833802
 % @NC  106   81	x0 = 1	28942041.866421
 %      81    50 28366925.6658               28367715.1827   x29 D    75    13
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cae7d0
% @LO 0.06  28.36692566579900542934 99.9000000000
% @LN 0.06  28.36771518271797987154 99.9000000000
% Resuming node 57 at  28.36771518271797987154
DEBUG CONSTRNT: LP rows=38, pool->nlprows=38, pool->npend=0
DEBUG CONSTRNT: Checking 38 LP rows (pool tracks 38, total LP rows 38)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=37, expected 37
 % @PAP adding 40 rows, 164 nz to LP
DEBUG BB: Processing node 57, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 57 LP 2 Solution, length = 28367715.182718, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.166667 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.166667 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.166667 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 1.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.166667 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.166667 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.166667 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.833333 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.833333 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.833333 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.833333 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.833333 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.833333 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.833333 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28367715.182718, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28367715.182718, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 57 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 57
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.166667
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.166667
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=1.000000
DEBUG CAREFUL: Skipping var 7: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.166667
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=1.000000
DEBUG CAREFUL: Skipping var 15: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.166667
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.166667
DEBUG CAREFUL: Adding var 18 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.166667
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 6 fractional variables

  %  Carefully choosing branching variable, nfrac = 6
DEBUG CAREFUL: Testing fvar[0] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 17
DEBUG CAREFUL: New best var: 17
DEBUG CAREFUL: Testing fvar[1] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[2] = var 18
DEBUG CAREFUL: Calling compare_branch_vars for var 18
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 18
DEBUG CAREFUL: New best var: 18
DEBUG CAREFUL: Testing fvar[3] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 3
DEBUG CAREFUL: Testing fvar[4] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[5] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
  % Initial guess is x18, Z0 = 28367715.182718         , Z1 = 28538810.7549931        

DEBUG EVAL: Testing var 17 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=17, varin=18, theta=0.333333, up=999999999999999983222784.000000
ITER 2: row=32, varin=65, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 17 = 0 gives z=28411791.103163
  % 	x17 = 0,	Z0 = 28411791.1031634        
DEBUG EVAL: First branch cutoff check: z=28411791.103163, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 17 = 1
ITER 1: row=17, varin=38, theta=2.500000, up=999999999999999983222784.000000
ITER 2: row=15, varin=30, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=33, varin=35, theta=3.000000, up=999999999999999983222784.000000
ITER 4: row=35, varin=31, theta=0.666667, up=999999999999999983222784.000000
  % 	x17 = 1,	Z1 = 28494661.6270612        
DEBUG EVAL: Second branch cutoff check: z=28494661.627061, best_z=INF, threshold=INF
  %   New best:  x17, Z = 28411791.1031634        
DEBUG EVAL: Testing var 2 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=16, theta=0.200000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 0 gives z=28398821.385802
  % 	x2 = 0,	Z0 = 28398821.3858016        
DEBUG EVAL: First branch cutoff check: z=28398821.385802, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 18 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=30, varin=38, theta=2.500000, up=999999999999999983222784.000000
ITER 2: row=15, varin=18, theta=3.000000, up=999999999999999983222784.000000
ITER 3: row=32, varin=35, theta=3.000000, up=999999999999999983222784.000000
ITER 4: row=35, varin=26, theta=2.000000, up=999999999999999983222784.000000
ITER 5: row=2, varin=19, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 18 = 1 gives z=28610096.433394
  % 	x18 = 1,	Z1 = 28610096.4333935        
DEBUG EVAL: First branch cutoff check: z=28610096.433394, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 18 = 0
ITER 1: row=30, varin=30, theta=0.333333, up=999999999999999983222784.000000
ITER 2: row=33, varin=65, theta=1.000000, up=1.000000
  % 	x18 = 0,	Z0 = 28411791.1031634        
DEBUG EVAL: Second branch cutoff check: z=28411791.103163, best_z=INF, threshold=INF
  %   New best:  x18, Z = 28411791.1031634        
DEBUG EVAL: Testing var 3 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=15, varin=30, theta=1.666667, up=999999999999999983222784.000000
ITER 2: row=33, varin=35, theta=5.000000, up=999999999999999983222784.000000
ITER 3: row=35, varin=17, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=39, varin=31, theta=1.333333, up=999999999999999983222784.000000
ITER 5: row=30, varin=18, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=40, varin=26, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=2, varin=11, theta=0.500000, up=999999999999999983222784.000000
ITER 8: row=7, varin=19, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 3 = 1 gives z=28657632.116779
  % 	x3 = 1,	Z1 = 28657632.1167791        
DEBUG EVAL: First branch cutoff check: z=28657632.116779, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 3 = 0
ITER 1: row=15, varin=38, theta=0.250000, up=999999999999999983222784.000000
  % 	x3 = 0,	Z0 = 28369231.8297634        
DEBUG EVAL: Second branch cutoff check: z=28369231.829763, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 10 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=10, varin=38, theta=2.500000, up=999999999999999983222784.000000
ITER 2: row=15, varin=18, theta=3.000000, up=999999999999999983222784.000000
ITER 3: row=32, varin=35, theta=3.000000, up=999999999999999983222784.000000
ITER 4: row=35, varin=31, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 1 gives z=28462160.164789
  % 	x10 = 1,	Z1 = 28462160.1647889        
DEBUG EVAL: First branch cutoff check: z=28462160.164789, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 0
ITER 1: row=10, varin=30, theta=0.333333, up=999999999999999983222784.000000
ITER 2: row=33, varin=10, theta=0.500000, up=999999999999999983222784.000000
ITER 3: row=10, varin=18, theta=0.500000, up=999999999999999983222784.000000
ITER 4: row=32, varin=65, theta=1.000000, up=1.000000
  % 	x10 = 0,	Z0 = 28411791.1031634        
DEBUG EVAL: Second branch cutoff check: z=28411791.103163, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 26 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=35, varin=30, theta=0.333333, up=999999999999999983222784.000000
ITER 2: row=33, varin=35, theta=0.200000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 26 = 0 gives z=28373235.394571
  % 	x26 = 0,	Z0 = 28373235.3945715        
DEBUG EVAL: First branch cutoff check: z=28373235.394571, best_z=INF, threshold=INF
  % Best branch is x18, Z0 = 28411791.1031634        , Z1 = 28610096.4333935        

DEBUG CAREFUL: Final result - returning best.var = 18
DEBUG BB: Branching variable chosen: j=18
 % @NC  107   57	x18 = 0	28411791.103163
 % @NC  108   57	x18 = 1	28610096.433394
 %      57    51 28367715.1827               28371089.0732   x15 U    12     4
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cc9ac0
% @LO 0.06  28.36771518271797987154 99.9000000000
% @LN 0.06  28.37108907323057138683 99.9000000000
% Resuming node 101 at  28.37108907323057138683
DEBUG CONSTRNT: LP rows=40, pool->nlprows=40, pool->npend=0
DEBUG CONSTRNT: Checking 40 LP rows (pool tracks 40, total LP rows 40)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=39, expected 39
 % @PAP adding 42 rows, 181 nz to LP
DEBUG BB: Processing node 101, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=32, varin=42, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 28371089.073231
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 42 rows, 60 cols, 241 nonzeros, 1 slack, 41 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=43, varin=89, theta=0.333333, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28375625.838512
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 44 rows, 60 cols, 247 nonzeros, 4 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % @PAP adding 4 rows, 9 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=41, varin=26, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28406862.130184
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 44 rows, 60 cols, 243 nonzeros, 3 slack, 41 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=42, varin=58, theta=0.500000, up=1.000000
ITER 2: row=6, varin=75, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 28421643.132288
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 42 rows, 60 cols, 237 nonzeros, 0 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 7 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=43, varin=66, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28422037.928214
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 44 rows, 60 cols, 244 nonzeros, 0 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 16 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=45, varin=29, theta=0.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 28425090.360397
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 48 rows, 60 cols, 260 nonzeros, 2 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % Node 101 LP 1 Solution, length = 28425090.360397, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.250000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.250000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.500000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 1.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.500000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.250000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.250000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.750000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.750000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.750000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.500000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.750000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.500000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28425090.360397, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 101 at  28.42509036039670533569
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cac0a0
% @LO 0.06  28.37108907323057138683 99.9000000000
% @LN 0.06  28.37260264211232652087 99.9000000000
% Resuming node 77 at  28.37260264211232652087
DEBUG CONSTRNT: LP rows=46, pool->nlprows=46, pool->npend=0
DEBUG CONSTRNT: Checking 46 LP rows (pool tracks 46, total LP rows 46)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 65
DEBUG CONSTRNT: Pool row 65 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 133
DEBUG CONSTRNT: Pool row 133 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 121
DEBUG CONSTRNT: Pool row 121 has lprow=45, expected 45
 % @PAP adding 31 rows, 144 nz to LP
DEBUG BB: Processing node 77, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 77 LP 2 Solution, length = 28372602.642112, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.500000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.500000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.500000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 1.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.500000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.500000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.500000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 3 fractional variables
DEBUG CG: LP optimal, z=28372602.642112, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28372602.642112, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 77 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 77
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.500000
DEBUG CAREFUL: Adding var 5 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.500000
DEBUG CAREFUL: Adding var 7 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.500000
DEBUG CAREFUL: Adding var 8 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=1.000000
DEBUG CAREFUL: Skipping var 20: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 3 fractional variables

  %  Carefully choosing branching variable, nfrac = 3
DEBUG CAREFUL: Testing fvar[0] = var 8
DEBUG CAREFUL: Calling compare_branch_vars for var 8
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 8
DEBUG CAREFUL: New best var: 8
DEBUG CAREFUL: Testing fvar[1] = var 5
DEBUG CAREFUL: Calling compare_branch_vars for var 5
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 5
DEBUG CAREFUL: Testing fvar[2] = var 7
DEBUG CAREFUL: Calling compare_branch_vars for var 7
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 7
  % Initial guess is x8, Z0 = 28372602.6421123        , Z1 = 28372602.6421123        

DEBUG EVAL: Testing var 8 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=23, varin=41, theta=1.000000, up=1.000000
ITER 2: row=1, varin=17, theta=0.500000, up=999999999999999983222784.000000
ITER 3: row=17, varin=23, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 8 = 0 gives z=28427812.125679
  % 	x8 = 0,	Z0 = 28427812.1256794        
DEBUG EVAL: First branch cutoff check: z=28427812.125679, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 8 = 1
ITER 1: row=23, varin=28, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=25, varin=26, theta=2.000000, up=999999999999999983222784.000000
ITER 3: row=21, varin=24, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=1, varin=85, theta=1.000000, up=1.000000
  % 	x8 = 1,	Z1 = 28425117.7202537        
DEBUG EVAL: Second branch cutoff check: z=28425117.720254, best_z=INF, threshold=INF
  %   New best:  x8, Z = 28425117.7202537        
DEBUG EVAL: Testing var 5 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=7, varin=28, theta=0.333333, up=999999999999999983222784.000000
ITER 2: row=25, varin=24, theta=0.666667, up=999999999999999983222784.000000
ITER 3: row=1, varin=85, theta=1.000000, up=1.000000
ITER 4: row=29, varin=26, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 5 = 0 gives z=28425117.720254
  % 	x5 = 0,	Z0 = 28425117.7202537        
DEBUG EVAL: First branch cutoff check: z=28425117.720254, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 5 = 1
ITER 1: row=7, varin=26, theta=0.500000, up=999999999999999983222784.000000
  % 	x5 = 1,	Z1 = 28374809.7795905        
DEBUG EVAL: Second branch cutoff check: z=28374809.779590, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 7 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=21, varin=26, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 7 = 0 gives z=28374809.779590
  % 	x7 = 0,	Z0 = 28374809.7795905        
DEBUG EVAL: First branch cutoff check: z=28374809.779590, best_z=INF, threshold=INF
  % Best branch is x8, Z0 = 28427812.1256794        , Z1 = 28425117.7202537        

DEBUG CAREFUL: Final result - returning best.var = 8
DEBUG BB: Branching variable chosen: j=8
 % @NC  109   77	x8 = 1	28425117.720254
 % @NC  110   77	x8 = 0	28427812.125679
 %      77    52 28372602.6421               28377300.1153   x14 D    49     4
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cc2570
% @LO 0.06  28.37260264211232652087 99.9000000000
% @LN 0.06  28.37730011528427809253 99.9000000000
% Resuming node 93 at  28.37730011528427809253
DEBUG CONSTRNT: LP rows=31, pool->nlprows=31, pool->npend=0
DEBUG CONSTRNT: Checking 31 LP rows (pool tracks 31, total LP rows 31)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 45
DEBUG CONSTRNT: Pool row 45 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 62
DEBUG CONSTRNT: Pool row 62 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 121
DEBUG CONSTRNT: Pool row 121 has lprow=30, expected 30
 % @PAP adding 40 rows, 173 nz to LP
DEBUG BB: Processing node 93, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=32, varin=65, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=40)
DEBUG SOLUTION: LP solution array indices: FST[41-80], not_covered[81-100]
DEBUG SOLUTION: lp->best_solution[0] = 28377300.115284
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 40 rows, 60 cols, 233 nonzeros, 0 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 11 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=41, varin=32, theta=0.333333, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28379863.593286
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 44 rows, 60 cols, 244 nonzeros, 1 slack, 43 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 93 LP 1 Solution, length = 28379863.593286, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.333333 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.333333 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.333333 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 1.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 1.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.333333 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.333333 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.666667 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.666667 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.666667 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.666667 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.666667 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.666667 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.666667 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28379863.593286, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 93 at  28.37986359328602858909
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cb5c00
% @LO 0.06  28.37730011528427809253 99.9000000000
% @LN 0.06  28.37874200168833738189 99.9000000000
% Resuming node 26 at  28.37874200168833738189
DEBUG CONSTRNT: LP rows=43, pool->nlprows=43, pool->npend=0
DEBUG CONSTRNT: Checking 43 LP rows (pool tracks 43, total LP rows 43)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 49
DEBUG CONSTRNT: Pool row 49 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 82
DEBUG CONSTRNT: Pool row 82 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=42, expected 42
 % @PAP adding 36 rows, 145 nz to LP
DEBUG BB: Processing node 26, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=33, varin=17, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=36, varin=18, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=1, varin=73, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=36)
DEBUG SOLUTION: LP solution array indices: FST[37-76], not_covered[77-96]
DEBUG SOLUTION: lp->best_solution[0] = 28378742.001688
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 36 rows, 60 cols, 205 nonzeros, 3 slack, 33 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 5 rows, 21 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=41, varin=45, theta=1.000000, up=1.000000
ITER 2: row=1, varin=16, theta=0.142857, up=999999999999999983222784.000000
ITER 3: row=39, varin=76, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=41)
DEBUG SOLUTION: LP solution array indices: FST[42-81], not_covered[82-101]
DEBUG SOLUTION: lp->best_solution[0] = 28386444.475422
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 41 rows, 60 cols, 226 nonzeros, 3 slack, 38 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 6 rows, 31 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=39, varin=81, theta=1.714286, up=1.000000
ITER 2: row=39, varin=29, theta=0.277778, up=999999999999999983222784.000000
ITER 3: row=34, varin=81, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28400709.022214
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 44 rows, 60 cols, 250 nonzeros, 5 slack, 39 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % @PAP adding 3 rows, 14 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=40, varin=36, theta=3.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 28409963.602491
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 42 rows, 60 cols, 235 nonzeros, 3 slack, 39 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % Node 26 LP 1 Solution, length = 28409963.602491, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.500000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.500000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.500000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.500000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 1.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.500000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.500000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.500000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.500000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.500000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.500000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28409963.602491, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 26 at  28.40996360249118879437
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cad710
% @LO 0.06  28.37874200168833738189 99.9000000000
% @LN 0.06  28.37949948274781419855 99.9000000000
% Resuming node 62 at  28.37949948274781419855
DEBUG CONSTRNT: LP rows=39, pool->nlprows=39, pool->npend=0
DEBUG CONSTRNT: Checking 39 LP rows (pool tracks 39, total LP rows 39)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 158
DEBUG CONSTRNT: Pool row 158 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=38, expected 38
 % @PAP adding 44 rows, 185 nz to LP
DEBUG BB: Processing node 62, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=19, varin=42, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=42, varin=40, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=40, varin=38, theta=0.500000, up=999999999999999983222784.000000
ITER 4: row=14, varin=36, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=36, varin=31, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=5, varin=30, theta=0.500000, up=999999999999999983222784.000000
ITER 7: row=17, varin=29, theta=0.500000, up=999999999999999983222784.000000
ITER 8: row=19, varin=2, theta=0.400000, up=999999999999999983222784.000000
ITER 9: row=31, varin=28, theta=0.333333, up=999999999999999983222784.000000
ITER 10: row=38, varin=97, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=10)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28379499.482748
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 44 rows, 60 cols, 245 nonzeros, 4 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 24 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=45, varin=20, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=47, varin=19, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=1, varin=66, theta=0.333333, up=1.000000
ITER 4: row=30, varin=10, theta=0.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 28479638.728480
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.500000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 48 rows, 60 cols, 269 nonzeros, 6 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 6 slack rows
  % @PAP adding 2 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=43, varin=55, theta=0.250000, up=1.000000
ITER 2: row=24, varin=45, theta=0.600000, up=1.000000
ITER 3: row=27, varin=38, theta=0.333333, up=999999999999999983222784.000000
ITER 4: row=25, varin=26, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28507614.462856
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 44 rows, 60 cols, 233 nonzeros, 5 slack, 39 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % @PAP adding 2 rows, 11 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=40, varin=95, theta=0.250000, up=1.000000
ITER 2: row=31, varin=68, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=41)
DEBUG SOLUTION: LP solution array indices: FST[42-81], not_covered[82-101]
DEBUG SOLUTION: lp->best_solution[0] = 28543449.357193
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 41 rows, 60 cols, 229 nonzeros, 1 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 62 LP 1 Solution, length = 28543449.357193, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.500000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.500000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.500000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 1.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.500000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.500000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.500000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.500000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.500000 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=28543449.357193, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 62 at  28.54344935719251097339
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cc2570
% @LO 0.06  28.37949948274781419855 99.9000000000
% @LN 0.06  28.37986359328602858909 99.9000000000
% Resuming node 93 at  28.37986359328602858909
DEBUG CONSTRNT: LP rows=40, pool->nlprows=40, pool->npend=0
DEBUG CONSTRNT: Checking 40 LP rows (pool tracks 40, total LP rows 40)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 45
DEBUG CONSTRNT: Pool row 45 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 79
DEBUG CONSTRNT: Pool row 79 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=39, expected 39
 % @PAP adding 43 rows, 182 nz to LP
DEBUG BB: Processing node 93, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 93 LP 2 Solution, length = 28379863.593286, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.333333 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.333333 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.333333 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 1.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 1.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.333333 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.333333 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.666667 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.666667 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.666667 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.666667 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.666667 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.666667 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.666667 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28379863.593286, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28379863.593286, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 93 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 93
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.333333
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.333333
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.333333
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=1.000000
DEBUG CAREFUL: Skipping var 12: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=1.000000
DEBUG CAREFUL: Skipping var 16: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.333333
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.333333
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 2
DEBUG CAREFUL: New best var: 2
DEBUG CAREFUL: Testing fvar[1] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 17
DEBUG CAREFUL: New best var: 17
DEBUG CAREFUL: Testing fvar[2] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 3
DEBUG CAREFUL: New best var: 3
DEBUG CAREFUL: Testing fvar[3] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[4] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
  % Initial guess is x3, Z0 = 28379863.593286         , Z1 = 28623141.1289           

DEBUG EVAL: Testing var 2 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=67, theta=1.000000, up=1.000000
ITER 2: row=43, varin=55, theta=0.500000, up=1.000000
DEBUG EVAL: Branch var 2 = 0 gives z=28452599.012913
  % 	x2 = 0,	Z0 = 28452599.0129128        
DEBUG EVAL: First branch cutoff check: z=28452599.012913, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 1
ITER 1: row=1, varin=40, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=40, varin=24, theta=0.666667, up=999999999999999983222784.000000
  % 	x2 = 1,	Z1 = 28403712.2979213        
DEBUG EVAL: Second branch cutoff check: z=28403712.297921, best_z=INF, threshold=INF
  %   New best:  x2, Z = 28403712.2979213        
DEBUG EVAL: Testing var 17 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=23, varin=40, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=40, varin=37, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 17 = 1 gives z=28479208.978362
  % 	x17 = 1,	Z1 = 28479208.9783618        
DEBUG EVAL: First branch cutoff check: z=28479208.978362, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 17 = 0
ITER 1: row=23, varin=67, theta=1.000000, up=1.000000
ITER 2: row=43, varin=55, theta=0.500000, up=1.000000
  % 	x17 = 0,	Z0 = 28452599.0129128        
DEBUG EVAL: Second branch cutoff check: z=28452599.012913, best_z=INF, threshold=INF
  %   New best:  x17, Z = 28452599.0129128        
DEBUG EVAL: Testing var 3 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=14, varin=40, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=40, varin=36, theta=2.000000, up=999999999999999983222784.000000
ITER 3: row=36, varin=23, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=38, varin=32, theta=2.000000, up=999999999999999983222784.000000
ITER 5: row=32, varin=24, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=39, varin=28, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=41, varin=2, theta=0.400000, up=999999999999999983222784.000000
ITER 8: row=28, varin=34, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 3 = 1 gives z=28623141.128900
  % 	x3 = 1,	Z1 = 28623141.1289           
DEBUG EVAL: First branch cutoff check: z=28623141.128900, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 3 = 0
ITER 1: row=14, varin=67, theta=1.000000, up=1.000000
ITER 2: row=43, varin=55, theta=0.500000, up=1.000000
  % 	x3 = 0,	Z0 = 28452599.0129128        
DEBUG EVAL: Second branch cutoff check: z=28452599.012913, best_z=INF, threshold=INF
  %   New best:  x3, Z = 28452599.0129128        
DEBUG EVAL: Testing var 10 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=11, varin=13, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 0 gives z=28435024.699982
  % 	x10 = 0,	Z0 = 28435024.6999823        
DEBUG EVAL: First branch cutoff check: z=28435024.699982, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 26 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=32, varin=32, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 26 = 0 gives z=28416983.822143
  % 	x26 = 0,	Z0 = 28416983.8221433        
DEBUG EVAL: First branch cutoff check: z=28416983.822143, best_z=INF, threshold=INF
  % Best branch is x3, Z0 = 28452599.0129128        , Z1 = 28623141.1289           

DEBUG CAREFUL: Final result - returning best.var = 3
DEBUG BB: Branching variable chosen: j=3
 % @NC  111   93	x3 = 0	28452599.012913
 % @NC  112   93	x3 = 1	28623141.128900
 %      93    53 28379863.5933               28383892.4973   x18 D    33     6
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cdc750
% @LO 0.06  28.37986359328602858909 99.9000000000
% @LN 0.06  28.38389249732685470917 99.9000000000
% Resuming node 80 at  28.38389249732685470917
DEBUG CONSTRNT: LP rows=43, pool->nlprows=43, pool->npend=0
DEBUG CONSTRNT: Checking 43 LP rows (pool tracks 43, total LP rows 43)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 49
DEBUG CONSTRNT: Pool row 49 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 82
DEBUG CONSTRNT: Pool row 82 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=42, expected 42
 % @PAP adding 36 rows, 172 nz to LP
DEBUG BB: Processing node 80, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=12, varin=20, theta=12.000000, up=999999999999999983222784.000000
ITER 2: row=17, varin=54, theta=0.352941, up=1.000000
ITER 3: row=24, varin=37, theta=0.500000, up=1.000000
ITER 4: row=2, varin=15, theta=0.545455, up=999999999999999983222784.000000
ITER 5: row=23, varin=18, theta=1.090909, up=999999999999999983222784.000000
ITER 6: row=21, varin=78, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=36)
DEBUG SOLUTION: LP solution array indices: FST[37-76], not_covered[77-96]
DEBUG SOLUTION: lp->best_solution[0] = 28383892.497327
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 36 rows, 60 cols, 232 nonzeros, 3 slack, 33 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 15 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=37, varin=59, theta=0.333333, up=1.000000
ITER 2: row=20, varin=23, theta=0.041667, up=999999999999999983222784.000000
ITER 3: row=25, varin=22, theta=0.263158, up=999999999999999983222784.000000
ITER 4: row=20, varin=20, theta=0.052632, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=40)
DEBUG SOLUTION: LP solution array indices: FST[41-80], not_covered[81-100]
DEBUG SOLUTION: lp->best_solution[0] = 28397987.277403
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.947368
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.947368
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 40 rows, 60 cols, 247 nonzeros, 6 slack, 34 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 6 slack rows
  % @PAP adding 3 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=37, varin=28, theta=0.315789, up=999999999999999983222784.000000
ITER 2: row=35, varin=17, theta=0.263158, up=999999999999999983222784.000000
ITER 3: row=36, varin=19, theta=1.250000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=37)
DEBUG SOLUTION: LP solution array indices: FST[38-77], not_covered[78-97]
DEBUG SOLUTION: lp->best_solution[0] = 28412082.116119
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 37 rows, 60 cols, 228 nonzeros, 4 slack, 33 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % Node 80 LP 1 Solution, length = 28412082.116119, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.250000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.750000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.750000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 1.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.250000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.250000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.750000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.750000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.250000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.250000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.750000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.250000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.750000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.250000 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28412082.116119, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 80 at  28.41208211611859368873
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cb6f50
% @LO 0.06  28.38389249732685470917 99.9000000000
% @LN 0.06  28.38422679881423604797 99.9000000000
% Resuming node 99 at  28.38422679881423604797
DEBUG CONSTRNT: LP rows=33, pool->nlprows=33, pool->npend=0
DEBUG CONSTRNT: Checking 33 LP rows (pool tracks 33, total LP rows 33)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=32, expected 32
 % @PAP adding 33 rows, 161 nz to LP
DEBUG BB: Processing node 99, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=17, varin=21, theta=3.818182, up=999999999999999983222784.000000
ITER 2: row=22, varin=75, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=33)
DEBUG SOLUTION: LP solution array indices: FST[34-73], not_covered[74-93]
DEBUG SOLUTION: lp->best_solution[0] = 28384226.798814
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 33 rows, 60 cols, 221 nonzeros, 0 slack, 33 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 15 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=34, varin=56, theta=0.333333, up=1.000000
ITER 2: row=21, varin=24, theta=0.041667, up=999999999999999983222784.000000
ITER 3: row=26, varin=23, theta=0.263158, up=999999999999999983222784.000000
ITER 4: row=21, varin=21, theta=0.052632, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=37)
DEBUG SOLUTION: LP solution array indices: FST[38-77], not_covered[78-97]
DEBUG SOLUTION: lp->best_solution[0] = 28398321.578890
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.947368
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.947368
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.947368
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 37 rows, 60 cols, 236 nonzeros, 6 slack, 31 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 6 slack rows
  % @PAP adding 7 rows, 26 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=38, varin=26, theta=0.048276, up=999999999999999983222784.000000
ITER 2: row=33, varin=65, theta=0.759259, up=1.000000
ITER 3: row=32, varin=18, theta=0.092593, up=999999999999999983222784.000000
ITER 4: row=35, varin=20, theta=0.555556, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=38)
DEBUG SOLUTION: LP solution array indices: FST[39-78], not_covered[79-98]
DEBUG SOLUTION: lp->best_solution[0] = 28426879.914321
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
  % @PL 38 rows, 60 cols, 235 nonzeros, 3 slack, 35 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 3 rows, 7 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=36, varin=45, theta=0.333333, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=38)
DEBUG SOLUTION: LP solution array indices: FST[39-78], not_covered[79-98]
DEBUG SOLUTION: lp->best_solution[0] = 28431898.439281
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
  % @PL 38 rows, 60 cols, 226 nonzeros, 0 slack, 38 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 99 LP 1 Solution, length = 28431898.439281, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.333333 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.333333 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.666667 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.333333 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.333333 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.666667 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.333333 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 3 fractional variables
DEBUG CG: LP optimal, z=28431898.439281, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 99 at  28.43189843928061577571
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cc24b0
% @LO 0.06  28.38422679881423604797 99.9000000000
% @LN 0.06  28.39380083380165586959 99.9000000000
% Resuming node 105 at  28.39380083380165586959
DEBUG CONSTRNT: LP rows=38, pool->nlprows=38, pool->npend=0
DEBUG CONSTRNT: Checking 38 LP rows (pool tracks 38, total LP rows 38)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=37, expected 37
 % @PAP adding 38 rows, 190 nz to LP
DEBUG BB: Processing node 105, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=61, theta=1.000000, up=1.000000
ITER 2: row=13, varin=38, theta=328201.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=38)
DEBUG SOLUTION: LP solution array indices: FST[39-78], not_covered[79-98]
DEBUG SOLUTION: lp->best_solution[0] = 28393800.833802
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 38 rows, 60 cols, 250 nonzeros, 1 slack, 37 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 19 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=39, varin=99, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 28425280.823609
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 42 rows, 60 cols, 269 nonzeros, 2 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 3 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=41, varin=72, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 28436591.227372
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 43 rows, 60 cols, 235 nonzeros, 0 slack, 43 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 5 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=44, varin=24, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=39, varin=25, theta=0.333333, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28447840.125099
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 44 rows, 60 cols, 240 nonzeros, 4 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % @PAP adding 4 rows, 54 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=44, varin=55, theta=0.061321, up=1.000000
ITER 2: row=43, varin=29, theta=0.083333, up=999999999999999983222784.000000
ITER 3: row=42, varin=43, theta=2.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28460523.779368
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 44 rows, 60 cols, 275 nonzeros, 2 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % Node 105 LP 1 Solution, length = 28460523.779368, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.333333 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.333333 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.849978 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.849978 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.333333 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.333333 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.666667 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.666667 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.150022 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.150022 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.666667 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.150022 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.666667 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.150022 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28460523.779368, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 105 at  28.46052377936813826409
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cd5610
% @LO 0.06  28.39380083380165586959 99.9000000000
% @LN 0.06  28.39423974560416397139 99.9000000000
% Resuming node 66 at  28.39423974560416397139
DEBUG CONSTRNT: LP rows=42, pool->nlprows=42, pool->npend=0
DEBUG CONSTRNT: Checking 42 LP rows (pool tracks 42, total LP rows 42)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=41, expected 41
 % @PAP adding 40 rows, 162 nz to LP
DEBUG BB: Processing node 66, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 66 LP 2 Solution, length = 28394239.745604, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.166667 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.166667 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.166667 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 1.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.166667 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.166667 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.166667 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.833333 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.833333 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.833333 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.833333 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.833333 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.833333 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.833333 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28394239.745604, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28394239.745604, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 66 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 66
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.166667
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.166667
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=1.000000
DEBUG CAREFUL: Skipping var 5: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.166667
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=1.000000
DEBUG CAREFUL: Skipping var 15: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.166667
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.166667
DEBUG CAREFUL: Adding var 18 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.166667
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 6 fractional variables

  %  Carefully choosing branching variable, nfrac = 6
DEBUG CAREFUL: Testing fvar[0] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 17
DEBUG CAREFUL: New best var: 17
DEBUG CAREFUL: Testing fvar[1] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[2] = var 18
DEBUG CAREFUL: Calling compare_branch_vars for var 18
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 18
DEBUG CAREFUL: New best var: 18
DEBUG CAREFUL: Testing fvar[3] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 3
DEBUG CAREFUL: Testing fvar[4] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[5] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
  % Initial guess is x18, Z0 = 28394239.7456042        , Z1 = 28565335.3178793        

DEBUG EVAL: Testing var 17 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=17, varin=18, theta=0.333333, up=999999999999999983222784.000000
ITER 2: row=32, varin=65, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 17 = 0 gives z=28438315.666050
  % 	x17 = 0,	Z0 = 28438315.6660496        
DEBUG EVAL: First branch cutoff check: z=28438315.666050, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 17 = 1
ITER 1: row=17, varin=38, theta=2.500000, up=999999999999999983222784.000000
ITER 2: row=15, varin=30, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=33, varin=9, theta=3.000000, up=999999999999999983222784.000000
ITER 4: row=9, varin=35, theta=3.000000, up=999999999999999983222784.000000
ITER 5: row=35, varin=31, theta=0.666667, up=999999999999999983222784.000000
  % 	x17 = 1,	Z1 = 28521186.1899474        
DEBUG EVAL: Second branch cutoff check: z=28521186.189947, best_z=INF, threshold=INF
  %   New best:  x17, Z = 28438315.6660496        
DEBUG EVAL: Testing var 2 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=16, theta=0.200000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 0 gives z=28425345.948688
  % 	x2 = 0,	Z0 = 28425345.9486878        
DEBUG EVAL: First branch cutoff check: z=28425345.948688, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 18 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=30, varin=38, theta=2.500000, up=999999999999999983222784.000000
ITER 2: row=15, varin=9, theta=3.000000, up=999999999999999983222784.000000
ITER 3: row=9, varin=18, theta=3.000000, up=999999999999999983222784.000000
ITER 4: row=32, varin=35, theta=3.000000, up=999999999999999983222784.000000
ITER 5: row=35, varin=26, theta=2.000000, up=999999999999999983222784.000000
ITER 6: row=2, varin=55, theta=1.000000, up=1.000000
ITER 7: row=7, varin=19, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 18 = 1 gives z=28636620.996280
  % 	x18 = 1,	Z1 = 28636620.9962797        
DEBUG EVAL: First branch cutoff check: z=28636620.996280, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 18 = 0
ITER 1: row=30, varin=30, theta=0.333333, up=999999999999999983222784.000000
ITER 2: row=33, varin=65, theta=1.000000, up=1.000000
  % 	x18 = 0,	Z0 = 28438315.6660496        
DEBUG EVAL: Second branch cutoff check: z=28438315.666050, best_z=INF, threshold=INF
  %   New best:  x18, Z = 28438315.6660496        
DEBUG EVAL: Testing var 3 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=15, varin=30, theta=1.666667, up=999999999999999983222784.000000
ITER 2: row=33, varin=9, theta=5.000000, up=999999999999999983222784.000000
ITER 3: row=9, varin=35, theta=5.000000, up=999999999999999983222784.000000
ITER 4: row=35, varin=17, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=39, varin=31, theta=1.333333, up=999999999999999983222784.000000
ITER 6: row=30, varin=18, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=40, varin=26, theta=1.000000, up=999999999999999983222784.000000
ITER 8: row=2, varin=55, theta=0.500000, up=1.000000
ITER 9: row=7, varin=19, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 3 = 1 gives z=28684156.679665
  % 	x3 = 1,	Z1 = 28684156.6796653        
DEBUG EVAL: First branch cutoff check: z=28684156.679665, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 3 = 0
ITER 1: row=15, varin=38, theta=0.250000, up=999999999999999983222784.000000
  % 	x3 = 0,	Z0 = 28395756.3926495        
DEBUG EVAL: Second branch cutoff check: z=28395756.392650, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 10 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=8, varin=38, theta=2.500000, up=999999999999999983222784.000000
ITER 2: row=15, varin=9, theta=3.000000, up=999999999999999983222784.000000
ITER 3: row=9, varin=18, theta=3.000000, up=999999999999999983222784.000000
ITER 4: row=32, varin=35, theta=3.000000, up=999999999999999983222784.000000
ITER 5: row=35, varin=31, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 1 gives z=28488684.727675
  % 	x10 = 1,	Z1 = 28488684.7276751        
DEBUG EVAL: First branch cutoff check: z=28488684.727675, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 0
ITER 1: row=8, varin=30, theta=0.333333, up=999999999999999983222784.000000
ITER 2: row=33, varin=8, theta=0.500000, up=999999999999999983222784.000000
ITER 3: row=8, varin=18, theta=0.500000, up=999999999999999983222784.000000
ITER 4: row=32, varin=65, theta=1.000000, up=1.000000
  % 	x10 = 0,	Z0 = 28438315.6660496        
DEBUG EVAL: Second branch cutoff check: z=28438315.666050, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 26 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=35, varin=30, theta=0.333333, up=999999999999999983222784.000000
ITER 2: row=33, varin=35, theta=0.200000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 26 = 0 gives z=28399759.957458
  % 	x26 = 0,	Z0 = 28399759.9574576        
DEBUG EVAL: First branch cutoff check: z=28399759.957458, best_z=INF, threshold=INF
  % Best branch is x18, Z0 = 28438315.6660496        , Z1 = 28636620.9962797        

DEBUG CAREFUL: Final result - returning best.var = 18
DEBUG BB: Branching variable chosen: j=18
 % @NC  113   66	x18 = 0	28438315.666050
 % @NC  114   66	x18 = 1	28636620.996280
 %      66    54 28394239.7456               28396266.7430   x15 U    14     5
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cd3de0
% @LO 0.06  28.39423974560416397139 99.9000000000
% @LN 0.06  28.39626674299492137266 99.9000000000
% Resuming node 54 at  28.39626674299492137266
DEBUG CONSTRNT: LP rows=40, pool->nlprows=40, pool->npend=0
DEBUG CONSTRNT: Checking 40 LP rows (pool tracks 40, total LP rows 40)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=39, expected 39
 % @PAP adding 41 rows, 176 nz to LP
DEBUG BB: Processing node 54, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=32, varin=39, theta=2.500000, up=999999999999999983222784.000000
ITER 2: row=17, varin=37, theta=3.000000, up=999999999999999983222784.000000
ITER 3: row=37, varin=35, theta=1.500000, up=999999999999999983222784.000000
ITER 4: row=1, varin=33, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=33, varin=26, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=1, varin=28, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=2, varin=27, theta=0.500000, up=999999999999999983222784.000000
ITER 8: row=25, varin=2, theta=0.500000, up=999999999999999983222784.000000
ITER 9: row=28, varin=33, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=9)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=41)
DEBUG SOLUTION: LP solution array indices: FST[42-81], not_covered[82-101]
DEBUG SOLUTION: lp->best_solution[0] = 28396266.742995
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 41 rows, 60 cols, 236 nonzeros, 6 slack, 35 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 56 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=45, varin=19, theta=0.049237, up=999999999999999983222784.000000
ITER 2: row=42, varin=18, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=44, varin=47, theta=0.569095, up=1.000000
ITER 4: row=20, varin=48, theta=0.607833, up=1.000000
LP PHASE: Switching to primal (iter=4)
ITER 5: row=29, varin=45, theta=314652.000000, up=999999999999999983222784.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 28432348.498673
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 45 rows, 60 cols, 292 nonzeros, 7 slack, 38 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 7 slack rows
  % @PAP adding 4 rows, 20 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=62, theta=3.250000, up=1.000000
ITER 2: row=1, varin=59, theta=3.000000, up=1.000000
ITER 3: row=1, varin=58, theta=2.000000, up=1.000000
ITER 4: row=1, varin=57, theta=1.000000, up=1.000000
ITER 5: row=19, varin=53, theta=7.500000, up=1.000000
ITER 6: row=19, varin=44, theta=6.500000, up=1.000000
ITER 7: row=19, varin=59, theta=3.666667, up=1.000000
ITER 8: row=19, varin=83, theta=8.000000, up=1.000000
ITER 9: row=19, varin=84, theta=7.000000, up=1.000000
ITER 10: row=19, varin=85, theta=6.000000, up=1.000000
LP PHASE: Switching to primal (iter=45)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 28555068.826384
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 42 rows, 60 cols, 252 nonzeros, 7 slack, 35 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 7 slack rows
  % @PAP adding 4 rows, 55 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=39, varin=4, theta=0.680076, up=999999999999999983222784.000000
ITER 2: row=24, varin=66, theta=1.089071, up=1.000000
ITER 3: row=24, varin=64, theta=0.087258, up=1.000000
ITER 4: row=28, varin=66, theta=1.000000, up=1.000000
ITER 5: row=24, varin=43, theta=0.058853, up=1.000000
ITER 6: row=3, varin=3, theta=0.083418, up=999999999999999983222784.000000
ITER 7: row=26, varin=63, theta=0.138894, up=1.000000
ITER 8: row=31, varin=2, theta=0.163289, up=999999999999999983222784.000000
ITER 9: row=2, varin=82, theta=0.039619, up=1.000000
ITER 10: row=24, varin=93, theta=0.097804, up=1.000000
LP PHASE: Switching to primal (iter=10)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=39)
DEBUG SOLUTION: LP solution array indices: FST[40-79], not_covered[80-99]
DEBUG SOLUTION: lp->best_solution[0] = 28736957.478912
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.975549
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.975549
  % @PL 39 rows, 60 cols, 281 nonzeros, 3 slack, 36 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 6 rows, 15 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=42, varin=64, theta=0.765282, up=1.000000
ITER 2: row=13, varin=67, theta=1.000000, up=1.000000
ITER 3: row=1, varin=46, theta=0.038964, up=1.000000
ITER 4: row=33, varin=43, theta=0.033766, up=1.000000
ITER 5: row=2, varin=70, theta=0.235093, up=1.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 28891435.339876
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 42 rows, 60 cols, 290 nonzeros, 0 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 5 rows, 18 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=43, varin=2, theta=0.141327, up=999999999999999983222784.000000
ITER 2: row=47, varin=50, theta=1.223846, up=1.000000
ITER 3: row=47, varin=73, theta=0.200836, up=1.000000
ITER 4: row=38, varin=50, theta=0.890726, up=1.000000
ITER 5: row=46, varin=70, theta=1.000000, up=1.000000
ITER 6: row=38, varin=71, theta=0.016573, up=1.000000
ITER 7: row=40, varin=77, theta=0.085739, up=1.000000
LP PHASE: Switching to primal (iter=7)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 29012025.322709
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.982852
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 47 rows, 60 cols, 308 nonzeros, 2 slack, 45 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 5 rows, 16 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=46, varin=38, theta=0.333983, up=999999999999999983222784.000000
ITER 2: row=49, varin=53, theta=1.398213, up=1.000000
ITER 3: row=49, varin=109, theta=0.066586, up=1.000000
ITER 4: row=2, varin=53, theta=0.797870, up=1.000000
ITER 5: row=44, varin=101, theta=0.123457, up=1.000000
ITER 6: row=3, varin=79, theta=0.166667, up=1.000000
ITER 7: row=9, varin=92, theta=0.119048, up=1.000000
ITER 8: row=38, varin=87, theta=0.208333, up=1.000000
LP PHASE: Switching to primal (iter=8)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 29122873.521704
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.833333
DEBUG SOLUTION: lp->best_solution[7] = 0.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
  % @PL 50 rows, 60 cols, 320 nonzeros, 3 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 2 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=49, varin=75, theta=1.000000, up=1.000000
ITER 2: row=48, varin=82, theta=0.833333, up=1.000000
ITER 3: row=3, varin=73, theta=0.352456, up=1.000000
ITER 4: row=36, varin=81, theta=0.367811, up=1.000000
ITER 5: row=45, varin=36, theta=0.409564, up=999999999999999983222784.000000
ITER 6: row=3, varin=54, theta=0.165435, up=1.000000
ITER 7: row=31, varin=52, theta=0.309730, up=1.000000
LP PHASE: Switching to primal (iter=7)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 29371136.168274
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 49 rows, 60 cols, 318 nonzeros, 0 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 3 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=50, varin=31, theta=0.101629, up=999999999999999983222784.000000
ITER 2: row=52, varin=46, theta=0.554076, up=999999999999999983222784.000000
ITER 3: row=51, varin=76, theta=1.768996, up=1.000000
ITER 4: row=51, varin=3, theta=0.611004, up=999999999999999983222784.000000
ITER 5: row=36, varin=76, theta=1.000000, up=1.000000
ITER 6: row=2, varin=83, theta=1.478732, up=1.000000
ITER 7: row=2, varin=68, theta=0.424277, up=1.000000
ITER 8: row=40, varin=109, theta=0.833187, up=1.000000
ITER 9: row=31, varin=48, theta=1.719078, up=999999999999999983222784.000000
ITER 10: row=25, varin=2, theta=9.849477, up=999999999999999983222784.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 999999999999999983222784.000000
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 52 rows, 60 cols, 326 nonzeros, 5 slack, 47 tight.
  % Node 54 LP 1 Solution, length = 999999999999999983222784.000000, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.309730 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 1.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 1.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.690270 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 1.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.690270 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
DEBUG BB: compute_good_lower_bound returned status=1
DEBUG BB: Node 54 is INFEASIBLE
 %      54    53    infeasible               28398308.1178   x18 U    10     6
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cd3ea0
% @LO 0.06  28.39626674299492137266 99.9000000000
% @LN 0.06  28.39830811775532026786 99.9000000000
% Resuming node 103 at  28.39830811775532026786
DEBUG CONSTRNT: LP rows=52, pool->nlprows=52, pool->npend=0
DEBUG CONSTRNT: Checking 52 LP rows (pool tracks 52, total LP rows 52)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 65
DEBUG CONSTRNT: Pool row 65 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 145
DEBUG CONSTRNT: Pool row 145 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 159
DEBUG CONSTRNT: Pool row 159 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 121
DEBUG CONSTRNT: Pool row 121 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 133
DEBUG CONSTRNT: Pool row 133 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 134
DEBUG CONSTRNT: Pool row 134 has lprow=51, expected 51
 % @PAP adding 43 rows, 180 nz to LP
DEBUG BB: Processing node 103, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=43, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=43, varin=42, theta=0.250000, up=999999999999999983222784.000000
ITER 3: row=31, varin=39, theta=0.250000, up=999999999999999983222784.000000
ITER 4: row=39, varin=38, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 28383764.792625
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 0.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 43 rows, 60 cols, 240 nonzeros, 1 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=44, varin=27, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 28419537.849578
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 0.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 45 rows, 60 cols, 246 nonzeros, 3 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=43, varin=15, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 28685280.591566
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 0.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 43 rows, 60 cols, 240 nonzeros, 1 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 4 rows, 54 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=46, varin=76, theta=0.086863, up=1.000000
ITER 2: row=43, varin=46, theta=773189.500000, up=999999999999999983222784.000000
ITER 3: row=36, varin=29, theta=0.141371, up=999999999999999983222784.000000
ITER 4: row=39, varin=3, theta=0.271772, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
ITER 5: row=40, varin=70, theta=0.000000, up=1.000000
ITER 6: row=1, varin=79, theta=1.000000, up=1.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=46)
DEBUG SOLUTION: LP solution array indices: FST[47-86], not_covered[87-106]
DEBUG SOLUTION: lp->best_solution[0] = 28821834.450116
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 0.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 46 rows, 60 cols, 292 nonzeros, 2 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 2 rows, 7 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=45, varin=68, theta=1.000000, up=1.000000
ITER 2: row=11, varin=47, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=46)
DEBUG SOLUTION: LP solution array indices: FST[47-86], not_covered[87-106]
DEBUG SOLUTION: lp->best_solution[0] = 28828728.906334
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.500000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 0.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 46 rows, 60 cols, 257 nonzeros, 3 slack, 43 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % Node 103 LP 1 Solution, length = 28828728.906334, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.500000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.500000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 1.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 1.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 1.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.500000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.500000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.500000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.500000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.500000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.500000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=28828728.906334, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 103 at  28.82872890633360185575
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cdfb00
% @LO 0.06  28.39830811775532026786 99.9000000000
% @LN 0.06  28.39870945298844873150 99.9000000000
% Resuming node 104 at  28.39870945298844873150
DEBUG CONSTRNT: LP rows=43, pool->nlprows=43, pool->npend=0
DEBUG CONSTRNT: Checking 43 LP rows (pool tracks 43, total LP rows 43)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 133
DEBUG CONSTRNT: Pool row 133 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=42, expected 42
 % @PAP adding 43 rows, 180 nz to LP
DEBUG BB: Processing node 104, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=76, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 28398709.452988
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 0.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 43 rows, 60 cols, 240 nonzeros, 0 slack, 43 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 7 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=44, varin=67, theta=0.500000, up=1.000000
ITER 2: row=11, varin=3, theta=0.250000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 28402156.681097
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.750000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 0.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 45 rows, 60 cols, 247 nonzeros, 3 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % Node 104 LP 1 Solution, length = 28402156.681097, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.250000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.250000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.500000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.500000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 1.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 1.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.500000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.500000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.250000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.250000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.750000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.500000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.750000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.750000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.500000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.750000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.500000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.500000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.500000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.500000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.500000 (terminal 19)
 % 8 fractional variables
DEBUG CG: LP optimal, z=28402156.681097, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
 % @LO 0.06  28.39870945298844873150 99.9000000000
 % @LN 0.06  28.40215668109712154887 99.9000000000
DEBUG CG: Second cutoff check: z=28402156.681097, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 104 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 104
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.250000
DEBUG CAREFUL: Adding var 0 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.250000
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.500000
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.500000
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=1.000000
DEBUG CAREFUL: Skipping var 12: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=1.000000
DEBUG CAREFUL: Skipping var 13: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.500000
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.500000
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.250000
DEBUG CAREFUL: Adding var 29 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.250000
DEBUG CAREFUL: Adding var 32 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 8 fractional variables

  %  Carefully choosing branching variable, nfrac = 8
DEBUG CAREFUL: Testing fvar[0] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 2
DEBUG CAREFUL: New best var: 2
DEBUG CAREFUL: Testing fvar[1] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[2] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[3] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
DEBUG CAREFUL: Testing fvar[4] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 1
DEBUG CAREFUL: Testing fvar[5] = var 0
DEBUG CAREFUL: Calling compare_branch_vars for var 0
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 0
DEBUG CAREFUL: Testing fvar[6] = var 29
DEBUG CAREFUL: Calling compare_branch_vars for var 29
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 29
DEBUG CAREFUL: Testing fvar[7] = var 32
DEBUG CAREFUL: Calling compare_branch_vars for var 32
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 32
DEBUG CAREFUL: New best var: 32
  % Initial guess is x32, Z0 = 28402156.6810971        , Z1 = 28463643.1789173        

DEBUG EVAL: Testing var 2 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=3, varin=36, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 0 gives z=28455994.310004
  % 	x2 = 0,	Z0 = 28455994.3100044        
DEBUG EVAL: First branch cutoff check: z=28455994.310004, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 1
ITER 1: row=3, varin=26, theta=0.500000, up=999999999999999983222784.000000
  % 	x2 = 1,	Z1 = 28420043.2095736        
DEBUG EVAL: Second branch cutoff check: z=28420043.209574, best_z=INF, threshold=INF
  %   New best:  x2, Z = 28420043.2095736        
DEBUG EVAL: Testing var 17 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=14, varin=36, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 17 = 0 gives z=28455994.310004
  % 	x17 = 0,	Z0 = 28455994.3100044        
DEBUG EVAL: First branch cutoff check: z=28455994.310004, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 17 = 1
ITER 1: row=14, varin=13, theta=0.500000, up=999999999999999983222784.000000
  % 	x17 = 1,	Z1 = 28506990.4803313        
DEBUG EVAL: Second branch cutoff check: z=28506990.480331, best_z=INF, threshold=INF
  %   New best:  x17, Z = 28455994.3100044        
DEBUG EVAL: Testing var 10 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=11, varin=36, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 0 gives z=28455994.310004
  % 	x10 = 0,	Z0 = 28455994.3100044        
DEBUG EVAL: First branch cutoff check: z=28455994.310004, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 1
ITER 1: row=11, varin=30, theta=1.000000, up=999999999999999983222784.000000
  % 	x10 = 1,	Z1 = 28629580.1527948        
DEBUG EVAL: Second branch cutoff check: z=28629580.152795, best_z=INF, threshold=INF
  %   New best:  x10, Z = 28455994.3100044        
DEBUG EVAL: Testing var 26 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=25, varin=36, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 26 = 0 gives z=28455994.310004
  % 	x26 = 0,	Z0 = 28455994.3100044        
DEBUG EVAL: First branch cutoff check: z=28455994.310004, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 26 = 1
ITER 1: row=25, varin=12, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=33, varin=13, theta=1.000000, up=999999999999999983222784.000000
  % 	x26 = 1,	Z1 = 28829364.9215764        
DEBUG EVAL: Second branch cutoff check: z=28829364.921576, best_z=INF, threshold=INF
  %   New best:  x26, Z = 28455994.3100044        
DEBUG EVAL: Testing var 1 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=2, varin=76, theta=0.500000, up=1.000000
DEBUG EVAL: Branch var 1 = 0 gives z=28424403.867081
  % 	x1 = 0,	Z0 = 28424403.8670814        
DEBUG EVAL: First branch cutoff check: z=28424403.867081, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 0 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=76, theta=0.500000, up=1.000000
DEBUG EVAL: Branch var 0 = 0 gives z=28424403.867081
  % 	x0 = 0,	Z0 = 28424403.8670814        
DEBUG EVAL: First branch cutoff check: z=28424403.867081, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 29 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=30, varin=76, theta=0.500000, up=1.000000
DEBUG EVAL: Branch var 29 = 0 gives z=28424403.867081
  % 	x29 = 0,	Z0 = 28424403.8670814        
DEBUG EVAL: First branch cutoff check: z=28424403.867081, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 32 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=37, varin=10, theta=1.500000, up=999999999999999983222784.000000
ITER 2: row=10, varin=41, theta=1.500000, up=999999999999999983222784.000000
ITER 3: row=41, varin=37, theta=1.500000, up=999999999999999983222784.000000
ITER 4: row=30, varin=36, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 32 = 1 gives z=28560980.666260
  % 	x32 = 1,	Z1 = 28560980.6662601        
DEBUG EVAL: First branch cutoff check: z=28560980.666260, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 32 = 0
ITER 1: row=37, varin=42, theta=0.500000, up=999999999999999983222784.000000
  % 	x32 = 0,	Z0 = 28405603.9092058        
DEBUG EVAL: Second branch cutoff check: z=28405603.909206, best_z=INF, threshold=INF
  % Best branch is x26, Z0 = 28455994.3100044        , Z1 = 28829364.9215764        

DEBUG CAREFUL: Final result - returning best.var = 26
DEBUG BB: Branching variable chosen: j=26
 % @NC  115  104	x26 = 0	28455994.310004
 % @NC  116  104	x26 = 1	28829364.921576
 %     104    54 28402156.6811               28405373.8764   x27 D    97    11
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cd1940
% @LO 0.06  28.40215668109712154887 99.9000000000
% @LN 0.06  28.40537387639442457044 99.9000000000
% Resuming node 58 at  28.40537387639442457044
DEBUG CONSTRNT: LP rows=42, pool->nlprows=42, pool->npend=0
DEBUG CONSTRNT: Checking 42 LP rows (pool tracks 42, total LP rows 42)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 158
DEBUG CONSTRNT: Pool row 158 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=41, expected 41
 % @PAP adding 41 rows, 185 nz to LP
DEBUG BB: Processing node 58, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 58 LP 2 Solution, length = 28405373.876394, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.333333 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.333333 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.666667 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.333333 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.333333 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.666667 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.333333 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 3 fractional variables
DEBUG CG: LP optimal, z=28405373.876394, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28405373.876394, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 58 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 58
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.333333
DEBUG CAREFUL: Adding var 6 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=1.000000
DEBUG CAREFUL: Skipping var 7: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.333333
DEBUG CAREFUL: Adding var 12 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.666667
DEBUG CAREFUL: Adding var 14 to fractional list (xi=0.666667)
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 3 fractional variables

  %  Carefully choosing branching variable, nfrac = 3
DEBUG CAREFUL: Testing fvar[0] = var 12
DEBUG CAREFUL: Calling compare_branch_vars for var 12
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 12
DEBUG CAREFUL: New best var: 12
DEBUG CAREFUL: Testing fvar[1] = var 14
DEBUG CAREFUL: Calling compare_branch_vars for var 14
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 14
DEBUG CAREFUL: Testing fvar[2] = var 6
DEBUG CAREFUL: Calling compare_branch_vars for var 6
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 6
DEBUG CAREFUL: New best var: 6
  % Initial guess is x6, Z0 = 28405373.8763944        , Z1 = 28691568.8330306        

DEBUG EVAL: Testing var 12 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=7, varin=31, theta=0.555556, up=999999999999999983222784.000000
ITER 2: row=17, varin=45, theta=0.500000, up=1.000000
DEBUG EVAL: Branch var 12 = 0 gives z=28411981.913805
  % 	x12 = 0,	Z0 = 28411981.9138053        
DEBUG EVAL: First branch cutoff check: z=28411981.913805, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 12 = 1
ITER 1: row=7, varin=39, theta=1.111111, up=999999999999999983222784.000000
ITER 2: row=34, varin=30, theta=0.400000, up=999999999999999983222784.000000
ITER 3: row=1, varin=35, theta=1.000000, up=999999999999999983222784.000000
  % 	x12 = 1,	Z1 = 28434124.1762787        
DEBUG EVAL: Second branch cutoff check: z=28434124.176279, best_z=INF, threshold=INF
  %   New best:  x12, Z = 28411981.9138053        
DEBUG EVAL: Testing var 14 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=21, varin=31, theta=0.555556, up=999999999999999983222784.000000
ITER 2: row=17, varin=45, theta=0.500000, up=1.000000
DEBUG EVAL: Branch var 14 = 1 gives z=28411981.913805
  % 	x14 = 1,	Z1 = 28411981.9138053        
DEBUG EVAL: First branch cutoff check: z=28411981.913805, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 14 = 0
ITER 1: row=21, varin=39, theta=1.111111, up=999999999999999983222784.000000
ITER 2: row=34, varin=30, theta=0.400000, up=999999999999999983222784.000000
ITER 3: row=1, varin=35, theta=1.000000, up=999999999999999983222784.000000
  % 	x14 = 0,	Z0 = 28434124.1762787        
DEBUG EVAL: Second branch cutoff check: z=28434124.176279, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 6 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=14, varin=39, theta=1.111111, up=999999999999999983222784.000000
ITER 2: row=34, varin=30, theta=0.400000, up=999999999999999983222784.000000
ITER 3: row=1, varin=29, theta=0.533333, up=999999999999999983222784.000000
ITER 4: row=16, varin=31, theta=0.695652, up=999999999999999983222784.000000
ITER 5: row=29, varin=25, theta=2.000000, up=999999999999999983222784.000000
ITER 6: row=2, varin=2, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=25, varin=34, theta=16.000000, up=999999999999999983222784.000000
ITER 8: row=12, varin=43, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 6 = 1 gives z=28710507.314525
  % 	x6 = 1,	Z1 = 28710507.3145252        
DEBUG EVAL: First branch cutoff check: z=28710507.314525, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 6 = 0
ITER 1: row=14, varin=31, theta=0.555556, up=999999999999999983222784.000000
ITER 2: row=17, varin=45, theta=0.500000, up=1.000000
  % 	x6 = 0,	Z0 = 28411981.9138053        
DEBUG EVAL: Second branch cutoff check: z=28411981.913805, best_z=INF, threshold=INF
  %   New best:  x6, Z = 28411981.9138053        
  % Best branch is x6, Z0 = 28411981.9138053        , Z1 = 28710507.3145252        

DEBUG CAREFUL: Final result - returning best.var = 6
DEBUG BB: Branching variable chosen: j=6
 % @NC  117   58	x6 = 0	28411981.913805
 % @NC  118   58	x6 = 1	28710507.314525
 %      58    55 28405373.8764               28408942.4624   x15 D    12     4
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cc6320
% @LO 0.06  28.40537387639442457044 99.9000000000
% @LN 0.06  28.40894246238945086702 99.9000000000
% Resuming node 60 at  28.40894246238945086702
DEBUG CONSTRNT: LP rows=41, pool->nlprows=41, pool->npend=0
DEBUG CONSTRNT: Checking 41 LP rows (pool tracks 41, total LP rows 41)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=40, expected 40
 % @PAP adding 44 rows, 185 nz to LP
DEBUG BB: Processing node 60, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=35, varin=42, theta=2.500000, up=999999999999999983222784.000000
ITER 2: row=17, varin=40, theta=3.000000, up=999999999999999983222784.000000
ITER 3: row=40, varin=38, theta=1.500000, up=999999999999999983222784.000000
ITER 4: row=1, varin=36, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=36, varin=29, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=1, varin=31, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=5, varin=30, theta=0.500000, up=999999999999999983222784.000000
ITER 8: row=28, varin=2, theta=0.400000, up=999999999999999983222784.000000
ITER 9: row=31, varin=36, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=9)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28408942.462389
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 44 rows, 60 cols, 245 nonzeros, 6 slack, 38 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 56 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=48, varin=25, theta=0.138901, up=999999999999999983222784.000000
ITER 2: row=45, varin=18, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=47, varin=93, theta=0.350836, up=1.000000
ITER 4: row=26, varin=51, theta=0.374717, up=1.000000
LP PHASE: Switching to primal (iter=4)
ITER 5: row=1, varin=48, theta=193977.000000, up=999999999999999983222784.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 28445024.218067
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 48 rows, 60 cols, 301 nonzeros, 7 slack, 41 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 7 slack rows
  % @PAP adding 4 rows, 20 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=59, theta=4.666667, up=1.000000
ITER 2: row=1, varin=65, theta=2.750000, up=1.000000
ITER 3: row=1, varin=61, theta=2.333333, up=1.000000
ITER 4: row=1, varin=60, theta=1.333333, up=1.000000
ITER 5: row=1, varin=54, theta=0.500000, up=1.000000
ITER 6: row=25, varin=56, theta=2.000000, up=1.000000
ITER 7: row=25, varin=47, theta=1.000000, up=1.000000
ITER 8: row=11, varin=60, theta=3.000000, up=1.000000
ITER 9: row=11, varin=61, theta=2.000000, up=1.000000
ITER 10: row=11, varin=65, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=46)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 28567744.545778
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 45 rows, 60 cols, 261 nonzeros, 7 slack, 38 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 7 slack rows
  % @PAP adding 4 rows, 55 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=42, varin=7, theta=0.974156, up=999999999999999983222784.000000
ITER 2: row=27, varin=56, theta=0.546768, up=1.000000
ITER 3: row=6, varin=51, theta=0.537325, up=1.000000
ITER 4: row=23, varin=2, theta=0.026503, up=999999999999999983222784.000000
ITER 5: row=2, varin=6, theta=0.039367, up=999999999999999983222784.000000
ITER 6: row=1, varin=96, theta=0.049496, up=1.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 28691314.052214
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 42 rows, 60 cols, 290 nonzeros, 0 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=43, varin=36, theta=0.121402, up=999999999999999983222784.000000
ITER 2: row=31, varin=71, theta=0.290255, up=1.000000
ITER 3: row=43, varin=69, theta=0.083087, up=1.000000
ITER 4: row=3, varin=23, theta=0.122107, up=999999999999999983222784.000000
ITER 5: row=1, varin=68, theta=0.034148, up=1.000000
ITER 6: row=34, varin=51, theta=0.022405, up=1.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28703983.743610
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.977595
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 44 rows, 60 cols, 294 nonzeros, 3 slack, 41 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % Node 60 LP 1 Solution, length = 28703983.743610, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.022405 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.477595 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 1.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.477595 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 1.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.522405 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.522405 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.522405 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 3 fractional variables
DEBUG CG: LP optimal, z=28703983.743610, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 60 at  28.70398374361001714306
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cb5c00
% @LO 0.07  28.40894246238945086702 99.9000000000
% @LN 0.07  28.40996360249118879437 99.9000000000
% Resuming node 26 at  28.40996360249118879437
DEBUG CONSTRNT: LP rows=41, pool->nlprows=41, pool->npend=0
DEBUG CONSTRNT: Checking 41 LP rows (pool tracks 41, total LP rows 41)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 145
DEBUG CONSTRNT: Pool row 145 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 159
DEBUG CONSTRNT: Pool row 159 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 45
DEBUG CONSTRNT: Pool row 45 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 79
DEBUG CONSTRNT: Pool row 79 has lprow=40, expected 40
 % @PAP adding 39 rows, 162 nz to LP
DEBUG BB: Processing node 26, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 26 LP 2 Solution, length = 28409963.602491, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.500000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.500000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.500000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.500000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 1.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.500000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.500000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.500000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.500000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.500000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.500000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28409963.602491, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28409963.602491, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 26 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 26
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.500000
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.500000
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.500000
DEBUG CAREFUL: Adding var 9 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.500000
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=1.000000
DEBUG CAREFUL: Skipping var 26: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.500000
DEBUG CAREFUL: Adding var 34 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 2
DEBUG CAREFUL: New best var: 2
DEBUG CAREFUL: Testing fvar[1] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[2] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 3
DEBUG CAREFUL: Testing fvar[3] = var 9
DEBUG CAREFUL: Calling compare_branch_vars for var 9
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 9
DEBUG CAREFUL: Testing fvar[4] = var 34
DEBUG CAREFUL: Calling compare_branch_vars for var 34
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 34
  % Initial guess is x2, Z0 = 28409963.6024912        , Z1 = 28409963.6024912        

DEBUG EVAL: Testing var 2 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=37, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=18, varin=64, theta=1.000000, up=1.000000
ITER 3: row=3, varin=17, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 0 gives z=28499033.180130
  % 	x2 = 0,	Z0 = 28499033.1801297        
DEBUG EVAL: First branch cutoff check: z=28499033.180130, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 1
ITER 1: row=1, varin=21, theta=0.500000, up=999999999999999983222784.000000
  % 	x2 = 1,	Z1 = 28427850.1309677        
DEBUG EVAL: Second branch cutoff check: z=28427850.130968, best_z=INF, threshold=INF
  %   New best:  x2, Z = 28427850.1309677        
DEBUG EVAL: Testing var 17 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=20, varin=37, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=18, varin=64, theta=1.000000, up=1.000000
ITER 3: row=3, varin=63, theta=1.000000, up=1.000000
ITER 4: row=32, varin=51, theta=0.500000, up=1.000000
DEBUG EVAL: Branch var 17 = 0 gives z=28534494.021537
  % 	x17 = 0,	Z0 = 28534494.0215367        
DEBUG EVAL: First branch cutoff check: z=28534494.021537, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 17 = 1
ITER 1: row=20, varin=34, theta=1.000000, up=999999999999999983222784.000000
  % 	x17 = 1,	Z1 = 28433482.7295602        
DEBUG EVAL: Second branch cutoff check: z=28433482.729560, best_z=INF, threshold=INF
  %   New best:  x17, Z = 28433482.7295602        
DEBUG EVAL: Testing var 3 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=16, varin=34, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 3 = 0 gives z=28433482.729560
  % 	x3 = 0,	Z0 = 28433482.7295602        
DEBUG EVAL: First branch cutoff check: z=28433482.729560, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 3 = 1
ITER 1: row=16, varin=20, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=35, varin=21, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=36, varin=22, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=18, varin=64, theta=1.000000, up=1.000000
ITER 5: row=3, varin=63, theta=1.000000, up=1.000000
ITER 6: row=32, varin=51, theta=0.500000, up=1.000000
ITER 7: row=39, varin=56, theta=0.333333, up=1.000000
ITER 8: row=15, varin=44, theta=0.500000, up=1.000000
ITER 9: row=38, varin=69, theta=1.000000, up=1.000000
ITER 10: row=27, varin=41, theta=0.250000, up=1.000000
  % 	x3 = 1,	Z1 = 28977928.2640172        
DEBUG EVAL: Second branch cutoff check: z=28977928.264017, best_z=INF, threshold=INF
  %   New best:  x3, Z = 28433482.7295602        
DEBUG EVAL: Testing var 9 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=18, varin=64, theta=0.500000, up=1.000000
ITER 2: row=3, varin=63, theta=0.500000, up=1.000000
ITER 3: row=32, varin=51, theta=0.250000, up=1.000000
ITER 4: row=39, varin=56, theta=0.166667, up=1.000000
ITER 5: row=15, varin=44, theta=0.250000, up=1.000000
ITER 6: row=38, varin=69, theta=0.500000, up=1.000000
ITER 7: row=27, varin=41, theta=0.125000, up=1.000000
DEBUG EVAL: Branch var 9 = 0 gives z=28473906.756082
  % 	x9 = 0,	Z0 = 28473906.7560821        
DEBUG EVAL: First branch cutoff check: z=28473906.756082, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 9 = 1
ITER 1: row=18, varin=37, theta=0.333333, up=999999999999999983222784.000000
  % 	x9 = 1,	Z1 = 28419218.1827681        
DEBUG EVAL: Second branch cutoff check: z=28419218.182768, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 34 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=33, varin=64, theta=0.500000, up=1.000000
ITER 2: row=3, varin=63, theta=0.500000, up=1.000000
ITER 3: row=32, varin=51, theta=0.250000, up=1.000000
ITER 4: row=39, varin=56, theta=0.166667, up=1.000000
ITER 5: row=15, varin=44, theta=0.250000, up=1.000000
ITER 6: row=38, varin=69, theta=0.500000, up=1.000000
ITER 7: row=27, varin=41, theta=0.125000, up=1.000000
DEBUG EVAL: Branch var 34 = 0 gives z=28473906.756082
  % 	x34 = 0,	Z0 = 28473906.7560821        
DEBUG EVAL: First branch cutoff check: z=28473906.756082, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 34 = 1
ITER 1: row=33, varin=37, theta=0.333333, up=999999999999999983222784.000000
  % 	x34 = 1,	Z1 = 28419218.1827681        
DEBUG EVAL: Second branch cutoff check: z=28419218.182768, best_z=INF, threshold=INF
  % Best branch is x3, Z0 = 28433482.7295602        , Z1 = 28977928.2640172        

DEBUG CAREFUL: Final result - returning best.var = 3
DEBUG BB: Branching variable chosen: j=3
 % @NC  119   26	x3 = 0	28433482.729560
 % @NC  120   26	x3 = 1	28977928.264017
 %      26    56 28409963.6025               28411189.8606   x26 U    21     8
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cb30f0
% @LO 0.07  28.40996360249118879437 99.9000000000
% @LN 0.07  28.41118986057296780245 99.9000000000
% Resuming node 29 at  28.41118986057296780245
DEBUG CONSTRNT: LP rows=39, pool->nlprows=39, pool->npend=0
DEBUG CONSTRNT: Checking 39 LP rows (pool tracks 39, total LP rows 39)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 158
DEBUG CONSTRNT: Pool row 158 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=38, expected 38
 % @PAP adding 45 rows, 220 nz to LP
DEBUG BB: Processing node 29, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 29 LP 2 Solution, length = 28411189.860573, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.174802 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.174802 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.150397 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.150397 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 1.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.174802 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.174802 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.174802 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.174802 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.150397 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.825198 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.825198 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.825198 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.825198 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.849603 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.849603 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.849603 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 9 fractional variables
DEBUG CG: LP optimal, z=28411189.860573, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28411189.860573, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 29 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 29
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.174802
DEBUG CAREFUL: Adding var 0 to fractional list (xi=0.174802)
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.174802
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.174802)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=1.000000
DEBUG CAREFUL: Skipping var 2: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.150397
DEBUG CAREFUL: Adding var 9 to fractional list (xi=0.150397)
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.150397
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.150397)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=1.000000
DEBUG CAREFUL: Skipping var 17: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.174802
DEBUG CAREFUL: Adding var 29 to fractional list (xi=0.174802)
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.174802
DEBUG CAREFUL: Adding var 30 to fractional list (xi=0.174802)
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.174802
DEBUG CAREFUL: Adding var 32 to fractional list (xi=0.174802)
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.174802
DEBUG CAREFUL: Adding var 33 to fractional list (xi=0.174802)
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.150397
DEBUG CAREFUL: Adding var 34 to fractional list (xi=0.150397)
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 9 fractional variables

  %  Carefully choosing branching variable, nfrac = 9
DEBUG CAREFUL: Testing fvar[0] = var 30
DEBUG CAREFUL: Calling compare_branch_vars for var 30
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 30
DEBUG CAREFUL: New best var: 30
DEBUG CAREFUL: Testing fvar[1] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 1
DEBUG CAREFUL: Testing fvar[2] = var 0
DEBUG CAREFUL: Calling compare_branch_vars for var 0
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 0
DEBUG CAREFUL: Testing fvar[3] = var 29
DEBUG CAREFUL: Calling compare_branch_vars for var 29
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 29
DEBUG CAREFUL: Testing fvar[4] = var 32
DEBUG CAREFUL: Calling compare_branch_vars for var 32
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 32
DEBUG CAREFUL: Testing fvar[5] = var 9
DEBUG CAREFUL: Calling compare_branch_vars for var 9
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 9
DEBUG CAREFUL: Testing fvar[6] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[7] = var 33
DEBUG CAREFUL: Calling compare_branch_vars for var 33
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 33
DEBUG CAREFUL: New best var: 33
DEBUG CAREFUL: Testing fvar[8] = var 34
DEBUG CAREFUL: Calling compare_branch_vars for var 34
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 34
  % Initial guess is x33, Z0 = 28411189.860573         , Z1 = 28519939.595461         

DEBUG EVAL: Testing var 30 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=22, varin=42, theta=2.570944, up=999999999999999983222784.000000
ITER 2: row=33, varin=21, theta=1.099540, up=999999999999999983222784.000000
ITER 3: row=21, varin=49, theta=0.339775, up=1.000000
ITER 4: row=28, varin=41, theta=0.677727, up=999999999999999983222784.000000
ITER 5: row=41, varin=32, theta=0.549123, up=999999999999999983222784.000000
ITER 6: row=16, varin=39, theta=0.596312, up=999999999999999983222784.000000
ITER 7: row=26, varin=60, theta=0.190974, up=1.000000
ITER 8: row=11, varin=38, theta=0.254511, up=999999999999999983222784.000000
ITER 9: row=38, varin=40, theta=0.285814, up=999999999999999983222784.000000
ITER 10: row=25, varin=29, theta=0.231671, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 30 = 1 gives z=28571831.355550
  % 	x30 = 1,	Z1 = 28571831.3555504        
DEBUG EVAL: First branch cutoff check: z=28571831.355550, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 30 = 0
ITER 1: row=22, varin=15, theta=0.312428, up=999999999999999983222784.000000
  % 	x30 = 0,	Z0 = 28431737.6893629        
DEBUG EVAL: Second branch cutoff check: z=28431737.689363, best_z=INF, threshold=INF
  %   New best:  x30, Z = 28431737.6893629        
DEBUG EVAL: Testing var 1 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=2, varin=42, theta=2.570944, up=999999999999999983222784.000000
ITER 2: row=33, varin=49, theta=0.623138, up=1.000000
ITER 3: row=28, varin=41, theta=1.242933, up=999999999999999983222784.000000
ITER 4: row=41, varin=32, theta=1.007077, up=999999999999999983222784.000000
ITER 5: row=16, varin=22, theta=1.305638, up=999999999999999983222784.000000
ITER 6: row=3, varin=21, theta=1.216414, up=999999999999999983222784.000000
ITER 7: row=2, varin=60, theta=0.347016, up=1.000000
ITER 8: row=11, varin=29, theta=0.191589, up=999999999999999983222784.000000
ITER 9: row=29, varin=15, theta=0.310160, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 1 = 1 gives z=28661333.456648
  % 	x1 = 1,	Z1 = 28661333.4566477        
DEBUG EVAL: First branch cutoff check: z=28661333.456648, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 1 = 0
ITER 1: row=2, varin=15, theta=0.312428, up=999999999999999983222784.000000
  % 	x1 = 0,	Z0 = 28431737.689363         
DEBUG EVAL: Second branch cutoff check: z=28431737.689363, best_z=INF, threshold=INF
  %   New best:  x1, Z = 28431737.689363         
DEBUG EVAL: Testing var 0 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=21, theta=0.194337, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 0 = 0 gives z=28417797.396058
  % 	x0 = 0,	Z0 = 28417797.3960577        
DEBUG EVAL: First branch cutoff check: z=28417797.396058, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 29 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=23, varin=15, theta=0.312428, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 29 = 0 gives z=28431737.689363
  % 	x29 = 0,	Z0 = 28431737.689363         
DEBUG EVAL: First branch cutoff check: z=28431737.689363, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 29 = 1
ITER 1: row=23, varin=49, theta=1.019803, up=1.000000
ITER 2: row=23, varin=42, theta=0.225788, up=999999999999999983222784.000000
ITER 3: row=28, varin=49, theta=1.000000, up=1.000000
ITER 4: row=33, varin=41, theta=1.800874, up=999999999999999983222784.000000
ITER 5: row=41, varin=32, theta=1.459145, up=999999999999999983222784.000000
ITER 6: row=16, varin=60, theta=1.150681, up=1.000000
ITER 7: row=16, varin=38, theta=0.200812, up=999999999999999983222784.000000
ITER 8: row=38, varin=23, theta=2.282521, up=999999999999999983222784.000000
ITER 9: row=11, varin=60, theta=1.000000, up=1.000000
ITER 10: row=44, varin=22, theta=1.169213, up=999999999999999983222784.000000
  % 	x29 = 1,	Z1 = 29075937.8858227        
DEBUG EVAL: Second branch cutoff check: z=29075937.885823, best_z=INF, threshold=INF
  %   New best:  x29, Z = 28431737.689363         
DEBUG EVAL: Testing var 32 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=26, varin=42, theta=2.570944, up=999999999999999983222784.000000
ITER 2: row=33, varin=49, theta=0.623138, up=1.000000
ITER 3: row=28, varin=41, theta=1.242933, up=999999999999999983222784.000000
ITER 4: row=41, varin=32, theta=1.007077, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 32 = 1 gives z=28518322.999609
  % 	x32 = 1,	Z1 = 28518322.9996086        
DEBUG EVAL: First branch cutoff check: z=28518322.999609, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 32 = 0
ITER 1: row=26, varin=15, theta=0.312428, up=999999999999999983222784.000000
  % 	x32 = 0,	Z0 = 28431737.689363         
DEBUG EVAL: Second branch cutoff check: z=28431737.689363, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 9 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=3, varin=42, theta=1.059564, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 9 = 0 gives z=28415045.989385
  % 	x9 = 0,	Z0 = 28415045.9893847        
DEBUG EVAL: First branch cutoff check: z=28415045.989385, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 10 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=12, varin=42, theta=1.059564, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 0 gives z=28415045.989385
  % 	x10 = 0,	Z0 = 28415045.9893847        
DEBUG EVAL: First branch cutoff check: z=28415045.989385, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 33 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=33, varin=49, theta=1.019803, up=1.000000
DEBUG EVAL: Branch var 33 = 1 gives z=28467597.245791
  % 	x33 = 1,	Z1 = 28519939.595461         
DEBUG EVAL: First branch cutoff check: z=28519939.595461, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 33 = 0
ITER 1: row=33, varin=42, theta=0.257429, up=999999999999999983222784.000000
  % 	x33 = 0,	Z0 = 28412126.7352085        
DEBUG EVAL: Second branch cutoff check: z=28412126.735208, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 34 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=31, varin=42, theta=1.059564, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 34 = 0 gives z=28415045.989385
  % 	x34 = 0,	Z0 = 28415045.9893847        
DEBUG EVAL: First branch cutoff check: z=28415045.989385, best_z=INF, threshold=INF
  % Best branch is x29, Z0 = 28431737.689363         , Z1 = 29075937.8858227        

DEBUG CAREFUL: Final result - returning best.var = 29
DEBUG BB: Branching variable chosen: j=29
 % @NC  121   29	x29 = 0	28431737.689363
 % @NC  122   29	x29 = 1	29075937.885823
 %      29    57 28411189.8606               28411791.1032   x17 U    25     9
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cb66c0
% @LO 0.07  28.41118986057296780245 99.9000000000
% @LN 0.07  28.41179110316337030895 99.9000000000
% Resuming node 107 at  28.41179110316337030895
DEBUG CONSTRNT: LP rows=45, pool->nlprows=45, pool->npend=0
DEBUG CONSTRNT: Checking 45 LP rows (pool tracks 45, total LP rows 45)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 133
DEBUG CONSTRNT: Pool row 133 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 134
DEBUG CONSTRNT: Pool row 134 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=44, expected 44
 % @PAP adding 40 rows, 164 nz to LP
DEBUG BB: Processing node 107, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=30, varin=30, theta=0.333333, up=999999999999999983222784.000000
ITER 2: row=33, varin=65, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=40)
DEBUG SOLUTION: LP solution array indices: FST[41-80], not_covered[81-100]
DEBUG SOLUTION: lp->best_solution[0] = 28411791.103163
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
  % @PL 40 rows, 60 cols, 224 nonzeros, 0 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 11 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=41, varin=31, theta=0.333333, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28414354.581165
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
  % @PL 44 rows, 60 cols, 235 nonzeros, 4 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % Node 107 LP 1 Solution, length = 28414354.581165, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.333333 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.333333 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.333333 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 1.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.333333 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.333333 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.666667 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.666667 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.666667 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.666667 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.666667 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.666667 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.666667 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28414354.581165, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 107 at  28.41435458116511725279
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cdfb00
% @LO 0.07  28.41179110316337030895 99.9000000000
% @LN 0.07  28.41198191380528825789 99.9000000000
% Resuming node 117 at  28.41198191380528825789
DEBUG CONSTRNT: LP rows=40, pool->nlprows=40, pool->npend=0
DEBUG CONSTRNT: Checking 40 LP rows (pool tracks 40, total LP rows 40)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=39, expected 39
 % @PAP adding 41 rows, 185 nz to LP
DEBUG BB: Processing node 117, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=14, varin=31, theta=0.555556, up=999999999999999983222784.000000
ITER 2: row=17, varin=45, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=41)
DEBUG SOLUTION: LP solution array indices: FST[42-81], not_covered[82-101]
DEBUG SOLUTION: lp->best_solution[0] = 28411981.913805
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 41 rows, 60 cols, 245 nonzeros, 0 slack, 41 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 6 rows, 31 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=42, varin=34, theta=0.833333, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 28415015.207896
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 47 rows, 60 cols, 276 nonzeros, 4 slack, 43 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % Node 117 LP 1 Solution, length = 28415015.207896, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.166667 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.166667 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.166667 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 1.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.166667 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.166667 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.166667 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.833333 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.833333 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.833333 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.833333 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.833333 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.833333 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.833333 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28415015.207896, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 117 at  28.41501520789606161088
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cdc750
% @LO 0.07  28.41198191380528825789 99.9000000000
% @LN 0.07  28.41208211611859368873 99.9000000000
% Resuming node 80 at  28.41208211611859368873
DEBUG CONSTRNT: LP rows=43, pool->nlprows=43, pool->npend=0
DEBUG CONSTRNT: Checking 43 LP rows (pool tracks 43, total LP rows 43)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=42, expected 42
 % @PAP adding 33 rows, 140 nz to LP
DEBUG BB: Processing node 80, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 80 LP 2 Solution, length = 28412082.116119, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.250000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.750000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.750000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 1.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.250000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.250000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.750000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.750000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.250000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.250000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.750000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.250000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.750000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.250000 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28412082.116119, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28412082.116119, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 80 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 80
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.250000
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.750000
DEBUG CAREFUL: Adding var 9 to fractional list (xi=0.750000)
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.750000
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.750000)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=1.000000
DEBUG CAREFUL: Skipping var 15: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.250000
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.250000
DEBUG CAREFUL: Adding var 18 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 2
DEBUG CAREFUL: New best var: 2
DEBUG CAREFUL: Testing fvar[1] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[2] = var 18
DEBUG CAREFUL: Calling compare_branch_vars for var 18
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 18
DEBUG CAREFUL: New best var: 18
DEBUG CAREFUL: Testing fvar[3] = var 9
DEBUG CAREFUL: Calling compare_branch_vars for var 9
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 9
DEBUG CAREFUL: Testing fvar[4] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
  % Initial guess is x18, Z0 = 28412082.1161186        , Z1 = 28616093.5755348        

DEBUG EVAL: Testing var 2 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=60, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 2 = 0 gives z=28413604.410027
  % 	x2 = 0,	Z0 = 28413604.4100275        
DEBUG EVAL: First branch cutoff check: z=28413604.410027, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 1
ITER 1: row=1, varin=31, theta=0.750000, up=999999999999999983222784.000000
  % 	x2 = 1,	Z1 = 28438911.9088333        
DEBUG EVAL: Second branch cutoff check: z=28438911.908833, best_z=INF, threshold=INF
  %   New best:  x2, Z = 28413604.4100275        
DEBUG EVAL: Testing var 17 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=16, varin=60, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 17 = 0 gives z=28413604.410027
  % 	x17 = 0,	Z0 = 28413604.4100275        
DEBUG EVAL: First branch cutoff check: z=28413604.410027, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 17 = 1
ITER 1: row=16, varin=32, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=17, varin=31, theta=1.000000, up=999999999999999983222784.000000
  % 	x17 = 1,	Z1 = 28459568.9953923        
DEBUG EVAL: Second branch cutoff check: z=28459568.995392, best_z=INF, threshold=INF
  %   New best:  x17, Z = 28413604.4100275        
DEBUG EVAL: Testing var 18 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=25, varin=27, theta=3.000000, up=999999999999999983222784.000000
ITER 2: row=5, varin=18, theta=1.500000, up=999999999999999983222784.000000
ITER 3: row=16, varin=2, theta=0.400000, up=999999999999999983222784.000000
ITER 4: row=27, varin=15, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 18 = 1 gives z=28688956.675234
  % 	x18 = 1,	Z1 = 28688956.6752344        
DEBUG EVAL: First branch cutoff check: z=28688956.675234, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 18 = 0
ITER 1: row=25, varin=60, theta=1.000000, up=1.000000
  % 	x18 = 0,	Z0 = 28413604.4100275        
DEBUG EVAL: Second branch cutoff check: z=28413604.410027, best_z=INF, threshold=INF
  %   New best:  x18, Z = 28413604.4100275        
DEBUG EVAL: Testing var 9 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=14, varin=60, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 9 = 1 gives z=28413604.410027
  % 	x9 = 1,	Z1 = 28413604.4100275        
DEBUG EVAL: First branch cutoff check: z=28413604.410027, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 9 = 0
ITER 1: row=14, varin=33, theta=0.750000, up=999999999999999983222784.000000
  % 	x9 = 0,	Z0 = 28415878.0585228        
DEBUG EVAL: Second branch cutoff check: z=28415878.058523, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 10 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=11, varin=60, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 10 = 1 gives z=28413604.410027
  % 	x10 = 1,	Z1 = 28413604.4100275        
DEBUG EVAL: First branch cutoff check: z=28413604.410027, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 0
ITER 1: row=11, varin=33, theta=0.750000, up=999999999999999983222784.000000
  % 	x10 = 0,	Z0 = 28415878.0585228        
DEBUG EVAL: Second branch cutoff check: z=28415878.058523, best_z=INF, threshold=INF
  % Best branch is x18, Z0 = 28413604.4100275        , Z1 = 28688956.6752344        

DEBUG CAREFUL: Final result - returning best.var = 18
DEBUG BB: Branching variable chosen: j=18
 % @NC  123   80	x18 = 0	28413604.410027
 % @NC  124   80	x18 = 1	28688956.675234
 %      80    58 28412082.1161               28413604.4100    x8 D    73     9
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cb30f0
% @LO 0.07  28.41208211611859368873 99.9000000000
% @LN 0.07  28.41360441002746028971 99.9000000000
% Resuming node 123 at  28.41360441002746028971
DEBUG CONSTRNT: LP rows=33, pool->nlprows=33, pool->npend=0
DEBUG CONSTRNT: Checking 33 LP rows (pool tracks 33, total LP rows 33)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=32, expected 32
 % @PAP adding 33 rows, 140 nz to LP
DEBUG BB: Processing node 123, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=25, varin=60, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=33)
DEBUG SOLUTION: LP solution array indices: FST[34-73], not_covered[74-93]
DEBUG SOLUTION: lp->best_solution[0] = 28413604.410027
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 33 rows, 60 cols, 200 nonzeros, 0 slack, 33 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=34, varin=33, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=34)
DEBUG SOLUTION: LP solution array indices: FST[35-74], not_covered[75-94]
DEBUG SOLUTION: lp->best_solution[0] = 28418665.666566
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 34 rows, 60 cols, 202 nonzeros, 1 slack, 33 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 4 rows, 17 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=34, varin=32, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=17, varin=72, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=37)
DEBUG SOLUTION: LP solution array indices: FST[38-77], not_covered[78-97]
DEBUG SOLUTION: lp->best_solution[0] = 28425729.388291
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 37 rows, 60 cols, 215 nonzeros, 1 slack, 36 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 123 LP 1 Solution, length = 28425729.388291, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.500000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.500000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 1.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.500000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.500000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.500000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.500000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.500000 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=28425729.388291, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 123 at  28.42572938829063033950
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cb66c0
% @LO 0.07  28.41360441002746028971 99.9000000000
% @LN 0.07  28.41435458116511725279 99.9000000000
% Resuming node 107 at  28.41435458116511725279
DEBUG CONSTRNT: LP rows=36, pool->nlprows=36, pool->npend=0
DEBUG CONSTRNT: Checking 36 LP rows (pool tracks 36, total LP rows 36)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 158
DEBUG CONSTRNT: Pool row 158 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=35, expected 35
 % @PAP adding 40 rows, 167 nz to LP
DEBUG BB: Processing node 107, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 107 LP 2 Solution, length = 28414354.581165, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.333333 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.333333 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.333333 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 1.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.333333 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.333333 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.666667 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.666667 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.666667 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.666667 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.666667 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.666667 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.666667 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28414354.581165, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28414354.581165, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 107 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 107
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.333333
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.333333
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=1.000000
DEBUG CAREFUL: Skipping var 7: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.333333
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=1.000000
DEBUG CAREFUL: Skipping var 15: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.333333
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.333333
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 17
DEBUG CAREFUL: New best var: 17
DEBUG CAREFUL: Testing fvar[1] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[2] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 3
DEBUG CAREFUL: New best var: 3
DEBUG CAREFUL: Testing fvar[3] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[4] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
  % Initial guess is x3, Z0 = 28414354.5811651        , Z1 = 28657632.1167791        

DEBUG EVAL: Testing var 17 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=17, varin=37, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=37, varin=34, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 17 = 1 gives z=28513699.966241
  % 	x17 = 1,	Z1 = 28513699.9662409        
DEBUG EVAL: First branch cutoff check: z=28513699.966241, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 17 = 0
ITER 1: row=17, varin=47, theta=0.500000, up=1.000000
ITER 2: row=14, varin=64, theta=1.000000, up=1.000000
ITER 3: row=40, varin=52, theta=0.500000, up=1.000000
  % 	x17 = 0,	Z0 = 28487090.0007919        
DEBUG EVAL: Second branch cutoff check: z=28487090.000792, best_z=INF, threshold=INF
  %   New best:  x17, Z = 28487090.0007919        
DEBUG EVAL: Testing var 2 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=47, theta=0.500000, up=1.000000
ITER 2: row=14, varin=64, theta=1.000000, up=1.000000
ITER 3: row=40, varin=52, theta=0.500000, up=1.000000
DEBUG EVAL: Branch var 2 = 0 gives z=28487090.000792
  % 	x2 = 0,	Z0 = 28487090.0007919        
DEBUG EVAL: First branch cutoff check: z=28487090.000792, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 1
ITER 1: row=1, varin=37, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=37, varin=18, theta=0.666667, up=999999999999999983222784.000000
  % 	x2 = 1,	Z1 = 28438203.2858004        
DEBUG EVAL: Second branch cutoff check: z=28438203.285800, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 3 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=15, varin=37, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=37, varin=17, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=35, varin=31, theta=2.000000, up=999999999999999983222784.000000
ITER 4: row=31, varin=18, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=36, varin=26, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=38, varin=2, theta=0.400000, up=999999999999999983222784.000000
ITER 7: row=26, varin=11, theta=0.500000, up=999999999999999983222784.000000
ITER 8: row=7, varin=19, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 3 = 1 gives z=28657632.116779
  % 	x3 = 1,	Z1 = 28657632.1167791        
DEBUG EVAL: First branch cutoff check: z=28657632.116779, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 3 = 0
ITER 1: row=15, varin=47, theta=0.500000, up=1.000000
ITER 2: row=25, varin=64, theta=1.000000, up=1.000000
ITER 3: row=40, varin=52, theta=0.500000, up=1.000000
  % 	x3 = 0,	Z0 = 28487090.0007919        
DEBUG EVAL: Second branch cutoff check: z=28487090.000792, best_z=INF, threshold=INF
  %   New best:  x3, Z = 28487090.0007919        
DEBUG EVAL: Testing var 10 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=10, varin=37, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=37, varin=30, theta=0.666667, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 1 gives z=28499435.419449
  % 	x10 = 1,	Z1 = 28499435.4194488        
DEBUG EVAL: First branch cutoff check: z=28499435.419449, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 0
ITER 1: row=10, varin=47, theta=0.500000, up=1.000000
ITER 2: row=14, varin=13, theta=0.500000, up=999999999999999983222784.000000
  % 	x10 = 0,	Z0 = 28469515.6878614        
DEBUG EVAL: Second branch cutoff check: z=28469515.687861, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 26 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=31, varin=47, theta=0.500000, up=1.000000
ITER 2: row=14, varin=31, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 26 = 0 gives z=28451474.810022
  % 	x26 = 0,	Z0 = 28451474.8100224        
DEBUG EVAL: First branch cutoff check: z=28451474.810022, best_z=INF, threshold=INF
  % Best branch is x3, Z0 = 28487090.0007919        , Z1 = 28657632.1167791        

DEBUG CAREFUL: Final result - returning best.var = 3
DEBUG BB: Branching variable chosen: j=3
 % @NC  125  107	x3 = 0	28487090.000792
 % @NC  126  107	x3 = 1	28657632.116779
 %     107    59 28414354.5812               28415015.2079   x18 D    57     5
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cdfb00
% @LO 0.07  28.41435458116511725279 99.9000000000
% @LN 0.07  28.41501520789606161088 99.9000000000
% Resuming node 117 at  28.41501520789606161088
DEBUG CONSTRNT: LP rows=40, pool->nlprows=40, pool->npend=0
DEBUG CONSTRNT: Checking 40 LP rows (pool tracks 40, total LP rows 40)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=39, expected 39
 % @PAP adding 43 rows, 181 nz to LP
DEBUG BB: Processing node 117, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 117 LP 2 Solution, length = 28415015.207896, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.166667 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.166667 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.166667 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 1.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.166667 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.166667 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.166667 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.833333 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.833333 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.833333 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.833333 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.833333 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.833333 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.833333 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28415015.207896, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28415015.207896, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 117 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 117
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.166667
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.166667
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=1.000000
DEBUG CAREFUL: Skipping var 7: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.166667
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=1.000000
DEBUG CAREFUL: Skipping var 14: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.166667
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.166667
DEBUG CAREFUL: Adding var 18 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.166667
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 6 fractional variables

  %  Carefully choosing branching variable, nfrac = 6
DEBUG CAREFUL: Testing fvar[0] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 17
DEBUG CAREFUL: New best var: 17
DEBUG CAREFUL: Testing fvar[1] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[2] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 10
DEBUG CAREFUL: New best var: 10
DEBUG CAREFUL: Testing fvar[3] = var 18
DEBUG CAREFUL: Calling compare_branch_vars for var 18
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 18
DEBUG CAREFUL: New best var: 18
DEBUG CAREFUL: Testing fvar[4] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 3
DEBUG CAREFUL: Testing fvar[5] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
  % Initial guess is x18, Z0 = 28415015.2078961        , Z1 = 28538810.7549931        

DEBUG EVAL: Testing var 17 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=16, varin=17, theta=0.333333, up=999999999999999983222784.000000
ITER 2: row=31, varin=34, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 17 = 0 gives z=28434124.176279
  % 	x17 = 0,	Z0 = 28434124.1762787        
DEBUG EVAL: First branch cutoff check: z=28434124.176279, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 17 = 1
ITER 1: row=16, varin=41, theta=2.500000, up=999999999999999983222784.000000
ITER 2: row=14, varin=29, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=32, varin=38, theta=3.000000, up=999999999999999983222784.000000
ITER 4: row=38, varin=30, theta=0.666667, up=999999999999999983222784.000000
  % 	x17 = 1,	Z1 = 28541961.6522393        
DEBUG EVAL: Second branch cutoff check: z=28541961.652239, best_z=INF, threshold=INF
  %   New best:  x17, Z = 28434124.1762787        
DEBUG EVAL: Testing var 2 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=34, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 0 gives z=28434124.176279
  % 	x2 = 0,	Z0 = 28434124.1762787        
DEBUG EVAL: First branch cutoff check: z=28434124.176279, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 1
ITER 1: row=1, varin=41, theta=2.500000, up=999999999999999983222784.000000
ITER 2: row=14, varin=29, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=32, varin=17, theta=0.750000, up=999999999999999983222784.000000
  % 	x2 = 1,	Z1 = 28443361.6476562        
DEBUG EVAL: Second branch cutoff check: z=28443361.647656, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 10 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=10, varin=41, theta=2.500000, up=999999999999999983222784.000000
ITER 2: row=14, varin=17, theta=3.000000, up=999999999999999983222784.000000
ITER 3: row=31, varin=38, theta=3.000000, up=999999999999999983222784.000000
ITER 4: row=38, varin=30, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 1 gives z=28509460.189967
  % 	x10 = 1,	Z1 = 28509460.189967         
DEBUG EVAL: First branch cutoff check: z=28509460.189967, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 0
ITER 1: row=10, varin=29, theta=0.333333, up=999999999999999983222784.000000
ITER 2: row=32, varin=34, theta=1.000000, up=999999999999999983222784.000000
  % 	x10 = 0,	Z0 = 28434124.1762787        
DEBUG EVAL: Second branch cutoff check: z=28434124.176279, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 18 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=29, varin=41, theta=2.500000, up=999999999999999983222784.000000
ITER 2: row=14, varin=17, theta=3.000000, up=999999999999999983222784.000000
ITER 3: row=31, varin=38, theta=3.000000, up=999999999999999983222784.000000
ITER 4: row=38, varin=25, theta=2.000000, up=999999999999999983222784.000000
ITER 5: row=2, varin=18, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 18 = 1 gives z=28657396.458572
  % 	x18 = 1,	Z1 = 28657396.4585716        
DEBUG EVAL: First branch cutoff check: z=28657396.458572, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 18 = 0
ITER 1: row=29, varin=29, theta=0.333333, up=999999999999999983222784.000000
ITER 2: row=32, varin=34, theta=1.000000, up=999999999999999983222784.000000
  % 	x18 = 0,	Z0 = 28434124.1762787        
DEBUG EVAL: Second branch cutoff check: z=28434124.176279, best_z=INF, threshold=INF
  %   New best:  x18, Z = 28434124.1762787        
DEBUG EVAL: Testing var 3 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=14, varin=29, theta=1.666667, up=999999999999999983222784.000000
ITER 2: row=32, varin=38, theta=5.000000, up=999999999999999983222784.000000
ITER 3: row=38, varin=16, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=42, varin=30, theta=1.333333, up=999999999999999983222784.000000
ITER 5: row=29, varin=17, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=43, varin=25, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=2, varin=18, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 3 = 1 gives z=28704932.141957
  % 	x3 = 1,	Z1 = 28704932.1419572        
DEBUG EVAL: First branch cutoff check: z=28704932.141957, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 3 = 0
ITER 1: row=14, varin=41, theta=0.250000, up=999999999999999983222784.000000
  % 	x3 = 0,	Z0 = 28416531.8549415        
DEBUG EVAL: Second branch cutoff check: z=28416531.854941, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 26 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=38, varin=29, theta=0.333333, up=999999999999999983222784.000000
ITER 2: row=32, varin=38, theta=0.200000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 26 = 0 gives z=28420535.419750
  % 	x26 = 0,	Z0 = 28420535.4197495        
DEBUG EVAL: First branch cutoff check: z=28420535.419750, best_z=INF, threshold=INF
  % Best branch is x18, Z0 = 28434124.1762787        , Z1 = 28657396.4585716        

DEBUG CAREFUL: Final result - returning best.var = 18
DEBUG BB: Branching variable chosen: j=18
 % @NC  127  117	x18 = 0	28434124.176279
 % @NC  128  117	x18 = 1	28657396.458572
 %     117    60 28415015.2079               28425090.3604    x6 D    58     5
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cc9ac0
% @LO 0.07  28.41501520789606161088 99.9000000000
% @LN 0.07  28.42509036039670533569 99.9000000000
% Resuming node 101 at  28.42509036039670533569
DEBUG CONSTRNT: LP rows=43, pool->nlprows=43, pool->npend=0
DEBUG CONSTRNT: Checking 43 LP rows (pool tracks 43, total LP rows 43)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=42, expected 42
 % @PAP adding 46 rows, 189 nz to LP
DEBUG BB: Processing node 101, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 101 LP 2 Solution, length = 28425090.360397, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.250000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.250000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.500000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 1.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.500000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.250000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.250000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.750000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.750000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.750000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.500000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.750000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.500000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28425090.360397, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28425090.360397, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 101 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 101
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.250000
DEBUG CAREFUL: Adding var 0 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.250000
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.500000
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=1.000000
DEBUG CAREFUL: Skipping var 13: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.500000
DEBUG CAREFUL: Adding var 27 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.250000
DEBUG CAREFUL: Adding var 29 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.250000
DEBUG CAREFUL: Adding var 32 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 6 fractional variables

  %  Carefully choosing branching variable, nfrac = 6
DEBUG CAREFUL: Testing fvar[0] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 2
DEBUG CAREFUL: New best var: 2
DEBUG CAREFUL: Testing fvar[1] = var 27
DEBUG CAREFUL: Calling compare_branch_vars for var 27
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 27
DEBUG CAREFUL: Testing fvar[2] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 1
DEBUG CAREFUL: Testing fvar[3] = var 0
DEBUG CAREFUL: Calling compare_branch_vars for var 0
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 0
DEBUG CAREFUL: Testing fvar[4] = var 32
DEBUG CAREFUL: Calling compare_branch_vars for var 32
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 32
DEBUG CAREFUL: New best var: 32
DEBUG CAREFUL: Testing fvar[5] = var 29
DEBUG CAREFUL: Calling compare_branch_vars for var 29
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 29
  % Initial guess is x32, Z0 = 28425090.3603967        , Z1 = 28436424.1343925        

DEBUG EVAL: Testing var 2 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=3, varin=41, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 0 gives z=28443318.590610
  % 	x2 = 0,	Z0 = 28443318.5906099        
DEBUG EVAL: First branch cutoff check: z=28443318.590610, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 1
ITER 1: row=3, varin=37, theta=1.000000, up=999999999999999983222784.000000
  % 	x2 = 1,	Z1 = 28479091.6475628        
DEBUG EVAL: Second branch cutoff check: z=28479091.647563, best_z=INF, threshold=INF
  %   New best:  x2, Z = 28443318.5906099        
DEBUG EVAL: Testing var 27 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=17, varin=41, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 27 = 0 gives z=28443318.590610
  % 	x27 = 0,	Z0 = 28443318.5906099        
DEBUG EVAL: First branch cutoff check: z=28443318.590610, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 27 = 1
ITER 1: row=17, varin=17, theta=1.000000, up=999999999999999983222784.000000
  % 	x27 = 1,	Z1 = 28816053.1869391        
DEBUG EVAL: Second branch cutoff check: z=28816053.186939, best_z=INF, threshold=INF
  %   New best:  x27, Z = 28443318.5906099        
DEBUG EVAL: Testing var 1 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=2, varin=72, theta=0.500000, up=1.000000
ITER 2: row=46, varin=104, theta=0.100000, up=1.000000
ITER 3: row=9, varin=80, theta=0.500000, up=1.000000
DEBUG EVAL: Branch var 1 = 0 gives z=28447337.546381
  % 	x1 = 0,	Z0 = 28447337.546381         
DEBUG EVAL: First branch cutoff check: z=28447337.546381, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 1 = 1
ITER 1: row=2, varin=43, theta=1.500000, up=999999999999999983222784.000000
ITER 2: row=43, varin=42, theta=1.500000, up=999999999999999983222784.000000
ITER 3: row=38, varin=104, theta=0.500000, up=1.000000
ITER 4: row=9, varin=41, theta=1.000000, up=999999999999999983222784.000000
  % 	x1 = 1,	Z1 = 28450213.0468272        
DEBUG EVAL: Second branch cutoff check: z=28450213.046827, best_z=INF, threshold=INF
  %   New best:  x1, Z = 28447337.546381         
DEBUG EVAL: Testing var 0 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=72, theta=0.500000, up=1.000000
ITER 2: row=46, varin=104, theta=0.100000, up=1.000000
ITER 3: row=9, varin=80, theta=0.500000, up=1.000000
DEBUG EVAL: Branch var 0 = 0 gives z=28447337.546381
  % 	x0 = 0,	Z0 = 28447337.546381         
DEBUG EVAL: First branch cutoff check: z=28447337.546381, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 0 = 1
ITER 1: row=1, varin=43, theta=1.500000, up=999999999999999983222784.000000
ITER 2: row=43, varin=42, theta=1.500000, up=999999999999999983222784.000000
ITER 3: row=38, varin=104, theta=0.500000, up=1.000000
ITER 4: row=9, varin=41, theta=1.000000, up=999999999999999983222784.000000
  % 	x0 = 1,	Z1 = 28450213.0468272        
DEBUG EVAL: Second branch cutoff check: z=28450213.046827, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 32 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=38, varin=43, theta=1.500000, up=999999999999999983222784.000000
ITER 2: row=43, varin=104, theta=1.500000, up=1.000000
ITER 3: row=43, varin=41, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=9, varin=104, theta=1.000000, up=1.000000
ITER 5: row=3, varin=37, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=17, varin=36, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=36, varin=38, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 32 = 1 gives z=28548304.946866
  % 	x32 = 1,	Z1 = 28548304.9468656        
DEBUG EVAL: First branch cutoff check: z=28548304.946866, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 32 = 0
ITER 1: row=38, varin=42, theta=0.500000, up=999999999999999983222784.000000
  % 	x32 = 0,	Z0 = 28428537.5885054        
DEBUG EVAL: Second branch cutoff check: z=28428537.588505, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 29 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=37, varin=72, theta=0.500000, up=1.000000
ITER 2: row=46, varin=104, theta=0.100000, up=1.000000
ITER 3: row=9, varin=80, theta=0.500000, up=1.000000
DEBUG EVAL: Branch var 29 = 0 gives z=28447337.546381
  % 	x29 = 0,	Z0 = 28447337.546381         
DEBUG EVAL: First branch cutoff check: z=28447337.546381, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 29 = 1
ITER 1: row=37, varin=43, theta=1.500000, up=999999999999999983222784.000000
ITER 2: row=43, varin=42, theta=1.500000, up=999999999999999983222784.000000
ITER 3: row=38, varin=104, theta=0.500000, up=1.000000
ITER 4: row=9, varin=41, theta=1.000000, up=999999999999999983222784.000000
  % 	x29 = 1,	Z1 = 28450213.0468272        
DEBUG EVAL: Second branch cutoff check: z=28450213.046827, best_z=INF, threshold=INF
  % Best branch is x1, Z0 = 28447337.546381         , Z1 = 28450213.0468272        

DEBUG CAREFUL: Final result - returning best.var = 1
DEBUG BB: Branching variable chosen: j=1
 % @NC  129  101	x1 = 0	28447337.546381
 % @NC  130  101	x1 = 1	28450213.046827
 %     101    61 28425090.3604               28425117.7203   x26 D    89    10
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cae7d0
% @LO 0.07  28.42509036039670533569 99.9000000000
% @LN 0.07  28.42511772025370930805 99.9000000000
% Resuming node 109 at  28.42511772025370930805
DEBUG CONSTRNT: LP rows=46, pool->nlprows=46, pool->npend=0
DEBUG CONSTRNT: Checking 46 LP rows (pool tracks 46, total LP rows 46)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 65
DEBUG CONSTRNT: Pool row 65 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 133
DEBUG CONSTRNT: Pool row 133 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 121
DEBUG CONSTRNT: Pool row 121 has lprow=45, expected 45
 % @PAP adding 31 rows, 144 nz to LP
DEBUG BB: Processing node 109, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=23, varin=28, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=25, varin=26, theta=2.000000, up=999999999999999983222784.000000
ITER 3: row=21, varin=24, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=1, varin=85, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=31)
DEBUG SOLUTION: LP solution array indices: FST[32-71], not_covered[72-91]
DEBUG SOLUTION: lp->best_solution[0] = 28425117.720254
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 31 rows, 60 cols, 204 nonzeros, 3 slack, 28 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 11 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=32, varin=22, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=1, varin=51, theta=0.333333, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=33)
DEBUG SOLUTION: LP solution array indices: FST[34-73], not_covered[74-93]
DEBUG SOLUTION: lp->best_solution[0] = 28483082.567426
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 33 rows, 60 cols, 215 nonzeros, 5 slack, 28 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % @PAP adding 7 rows, 67 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=35, varin=36, theta=2.461592, up=1.000000
ITER 2: row=35, varin=14, theta=0.470140, up=999999999999999983222784.000000
ITER 3: row=2, varin=36, theta=1.000000, up=1.000000
ITER 4: row=12, varin=38, theta=3.850091, up=1.000000
ITER 5: row=12, varin=62, theta=0.636474, up=1.000000
ITER 6: row=29, varin=38, theta=1.114614, up=1.000000
ITER 7: row=29, varin=90, theta=0.067218, up=1.000000
ITER 8: row=35, varin=77, theta=0.063402, up=1.000000
LP PHASE: Switching to primal (iter=8)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=35)
DEBUG SOLUTION: LP solution array indices: FST[36-75], not_covered[76-95]
DEBUG SOLUTION: lp->best_solution[0] = 28586936.947609
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.936598
DEBUG SOLUTION: lp->best_solution[4] = 0.936598
DEBUG SOLUTION: lp->best_solution[5] = 2.873197
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 35 rows, 60 cols, 263 nonzeros, 3 slack, 32 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 6 rows, 20 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=37, varin=63, theta=0.921190, up=1.000000
ITER 2: row=33, varin=75, theta=0.138935, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=38)
DEBUG SOLUTION: LP solution array indices: FST[39-78], not_covered[79-98]
DEBUG SOLUTION: lp->best_solution[0] = 28653629.796990
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 38 rows, 60 cols, 275 nonzeros, 0 slack, 38 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 6 rows, 19 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=39, varin=68, theta=0.803693, up=1.000000
ITER 2: row=42, varin=74, theta=1.000000, up=1.000000
ITER 3: row=36, varin=52, theta=0.250000, up=1.000000
ITER 4: row=44, varin=72, theta=0.967987, up=1.000000
ITER 5: row=41, varin=56, theta=0.016477, up=1.000000
ITER 6: row=29, varin=49, theta=0.015588, up=1.000000
ITER 7: row=27, varin=46, theta=0.011125, up=1.000000
ITER 8: row=39, varin=32, theta=7149.000000, up=999999999999999983222784.000000
ITER 9: row=32, varin=39, theta=0.010397, up=999999999999999983222784.000000
% Column 45 singular!
% SINGULAR BASIS!  Will attempt to recover.
LP PHASE: Starting dual phase (iter=9)
ITER 10: row=32, varin=89, theta=0.989603, up=1.000000
LP PHASE: Switching to primal (iter=10)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28797852.316583
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 44 rows, 60 cols, 294 nonzeros, 1 slack, 43 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=52, theta=6.500000, up=1.000000
ITER 2: row=1, varin=50, theta=5.500000, up=1.000000
ITER 3: row=1, varin=55, theta=4.500000, up=1.000000
ITER 4: row=1, varin=46, theta=3.500000, up=1.000000
ITER 5: row=1, varin=85, theta=5.000000, up=1.000000
ITER 6: row=1, varin=86, theta=4.000000, up=1.000000
ITER 7: row=1, varin=87, theta=3.000000, up=1.000000
ITER 8: row=1, varin=88, theta=2.000000, up=1.000000
ITER 9: row=1, varin=89, theta=1.000000, up=1.000000
ITER 10: row=8, varin=85, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=61)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28802389.081864
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 44 rows, 60 cols, 256 nonzeros, 3 slack, 41 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 5 rows, 49 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=46, varin=68, theta=0.804316, up=1.000000
ITER 2: row=24, varin=33, theta=0.285834, up=999999999999999983222784.000000
ITER 3: row=43, varin=105, theta=0.187386, up=1.000000
ITER 4: row=42, varin=43, theta=0.023337, up=999999999999999983222784.000000
ITER 5: row=5, varin=79, theta=0.276558, up=1.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=46)
DEBUG SOLUTION: LP solution array indices: FST[47-86], not_covered[87-106]
DEBUG SOLUTION: lp->best_solution[0] = 28865592.631391
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 46 rows, 60 cols, 294 nonzeros, 2 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 5 rows, 16 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=47, varin=5, theta=0.073442, up=999999999999999983222784.000000
ITER 2: row=46, varin=75, theta=0.779210, up=1.000000
ITER 3: row=45, varin=46, theta=0.009711, up=999999999999999983222784.000000
ITER 4: row=32, varin=31, theta=0.009436, up=999999999999999983222784.000000
ITER 5: row=47, varin=23, theta=0.371313, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=5)
ITER 6: row=1, varin=5, theta=0.000000, up=999999999999999983222784.000000
ITER 7: row=2, varin=33, theta=0.000000, up=999999999999999983222784.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 28888381.242304
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 49 rows, 60 cols, 306 nonzeros, 2 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=48, varin=44, theta=0.360833, up=999999999999999983222784.000000
ITER 2: row=44, varin=25, theta=0.051461, up=999999999999999983222784.000000
ITER 3: row=25, varin=27, theta=0.054827, up=999999999999999983222784.000000
ITER 4: row=27, varin=35, theta=0.102596, up=999999999999999983222784.000000
ITER 5: row=35, varin=55, theta=0.112551, up=1.000000
ITER 6: row=18, varin=51, theta=0.127157, up=1.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 28927580.042322
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 48 rows, 60 cols, 296 nonzeros, 0 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 109 LP 1 Solution, length = 28927580.042322, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.872843 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 1.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.500000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 1.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.500000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.500000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.127157 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.127157 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.500000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28927580.042322, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 109 at  28.92758004232246804577
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cb30f0
% @LO 0.07  28.42511772025370930805 99.9000000000
% @LN 0.07  28.42572938829063033950 99.9000000000
% Resuming node 123 at  28.42572938829063033950
DEBUG CONSTRNT: LP rows=48, pool->nlprows=48, pool->npend=0
DEBUG CONSTRNT: Checking 48 LP rows (pool tracks 48, total LP rows 48)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 45
DEBUG CONSTRNT: Pool row 45 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 62
DEBUG CONSTRNT: Pool row 62 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 79
DEBUG CONSTRNT: Pool row 79 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 141
DEBUG CONSTRNT: Pool row 141 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 145
DEBUG CONSTRNT: Pool row 145 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 159
DEBUG CONSTRNT: Pool row 159 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 133
DEBUG CONSTRNT: Pool row 133 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=47, expected 47
 % @PAP adding 36 rows, 145 nz to LP
DEBUG BB: Processing node 123, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 123 LP 2 Solution, length = 28425729.388291, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.500000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.500000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 1.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.500000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.500000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.500000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.500000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.500000 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=28425729.388291, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28425729.388291, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 123 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 123
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.500000
DEBUG CAREFUL: Adding var 9 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.500000
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=1.000000
DEBUG CAREFUL: Skipping var 15: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.500000
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.500000
DEBUG CAREFUL: Adding var 34 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 4 fractional variables

  %  Carefully choosing branching variable, nfrac = 4
DEBUG CAREFUL: Testing fvar[0] = var 34
DEBUG CAREFUL: Calling compare_branch_vars for var 34
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 34
DEBUG CAREFUL: New best var: 34
DEBUG CAREFUL: Testing fvar[1] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
DEBUG CAREFUL: Testing fvar[2] = var 9
DEBUG CAREFUL: Calling compare_branch_vars for var 9
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 9
DEBUG CAREFUL: Testing fvar[3] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
  % Initial guess is x34, Z0 = 28425729.3882906        , Z1 = 28432793.1100148        

DEBUG EVAL: Testing var 34 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=17, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=16, varin=34, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 34 = 1 gives z=28432793.110015
  % 	x34 = 1,	Z1 = 28432793.1100148        
DEBUG EVAL: First branch cutoff check: z=28432793.110015, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 34 = 0
ITER 1: row=1, varin=73, theta=0.500000, up=1.000000
  % 	x34 = 0,	Z0 = 28427257.2166129        
DEBUG EVAL: Second branch cutoff check: z=28427257.216613, best_z=INF, threshold=INF
  %   New best:  x34, Z = 28427257.2166129        
DEBUG EVAL: Testing var 26 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=33, varin=34, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 26 = 0 gives z=28432793.110015
  % 	x26 = 0,	Z0 = 28432793.1100148        
DEBUG EVAL: First branch cutoff check: z=28432793.110015, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 26 = 1
ITER 1: row=33, varin=12, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=36, varin=13, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=1, varin=73, theta=1.000000, up=1.000000
  % 	x26 = 1,	Z1 = 28787504.749393         
DEBUG EVAL: Second branch cutoff check: z=28787504.749393, best_z=INF, threshold=INF
  %   New best:  x26, Z = 28432793.1100148        
DEBUG EVAL: Testing var 9 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=26, varin=33, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 9 = 0 gives z=28437854.366554
  % 	x9 = 0,	Z0 = 28437854.3665538        
DEBUG EVAL: First branch cutoff check: z=28437854.366554, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 9 = 1
ITER 1: row=26, varin=34, theta=1.000000, up=999999999999999983222784.000000
  % 	x9 = 1,	Z1 = 28432793.1100148        
DEBUG EVAL: Second branch cutoff check: z=28432793.110015, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 10 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=12, varin=33, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 0 gives z=28437854.366554
  % 	x10 = 0,	Z0 = 28437854.3665538        
DEBUG EVAL: First branch cutoff check: z=28437854.366554, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 1
ITER 1: row=12, varin=34, theta=1.000000, up=999999999999999983222784.000000
  % 	x10 = 1,	Z1 = 28432793.1100148        
DEBUG EVAL: Second branch cutoff check: z=28432793.110015, best_z=INF, threshold=INF
  % Best branch is x26, Z0 = 28432793.1100148        , Z1 = 28787504.749393         

DEBUG CAREFUL: Final result - returning best.var = 26
DEBUG BB: Branching variable chosen: j=26
 % @NC  131  123	x26 = 0	28432793.110015
 % @NC  132  123	x26 = 1	28787504.749393
 %     123    62 28425729.3883               28427812.1257   x18 D    80    10
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7ce6f50
% @LO 0.07  28.42572938829063033950 99.9000000000
% @LN 0.07  28.42781212567938453617 99.9000000000
% Resuming node 110 at  28.42781212567938453617
DEBUG CONSTRNT: LP rows=36, pool->nlprows=36, pool->npend=0
DEBUG CONSTRNT: Checking 36 LP rows (pool tracks 36, total LP rows 36)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 158
DEBUG CONSTRNT: Pool row 158 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=35, expected 35
 % @PAP adding 31 rows, 144 nz to LP
DEBUG BB: Processing node 110, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=23, varin=41, theta=1.000000, up=1.000000
ITER 2: row=1, varin=17, theta=0.500000, up=999999999999999983222784.000000
ITER 3: row=17, varin=23, theta=0.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=31)
DEBUG SOLUTION: LP solution array indices: FST[32-71], not_covered[72-91]
DEBUG SOLUTION: lp->best_solution[0] = 28427812.125679
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 31 rows, 60 cols, 204 nonzeros, 3 slack, 28 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 8 rows, 77 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=39, varin=41, theta=0.470811, up=1.000000
ITER 2: row=38, varin=42, theta=1.796139, up=1.000000
ITER 3: row=38, varin=27, theta=0.074696, up=999999999999999983222784.000000
ITER 4: row=17, varin=42, theta=1.000000, up=1.000000
ITER 5: row=32, varin=17, theta=3.533043, up=999999999999999983222784.000000
ITER 6: row=17, varin=38, theta=2.487484, up=999999999999999983222784.000000
ITER 7: row=29, varin=42, theta=0.017777, up=1.000000
ITER 8: row=32, varin=39, theta=13840.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=8)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=39)
DEBUG SOLUTION: LP solution array indices: FST[40-79], not_covered[80-99]
DEBUG SOLUTION: lp->best_solution[0] = 28436660.132166
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 39 rows, 60 cols, 281 nonzeros, 7 slack, 32 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 7 slack rows
  % Node 110 LP 1 Solution, length = 28436660.132166, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.500000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.500000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.500000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 1.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.500000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.500000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.500000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 3 fractional variables
DEBUG CG: LP optimal, z=28436660.132166, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 110 at  28.43666013216620669368
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cc7030
% @LO 0.07  28.42781212567938453617 99.9000000000
% @LN 0.07  28.42793857114842381861 99.9000000000
% Resuming node 87 at  28.42793857114842381861
DEBUG CONSTRNT: LP rows=32, pool->nlprows=32, pool->npend=0
DEBUG CONSTRNT: Checking 32 LP rows (pool tracks 32, total LP rows 32)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 121
DEBUG CONSTRNT: Pool row 121 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 63
DEBUG CONSTRNT: Pool row 63 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=31, expected 31
 % @PAP adding 45 rows, 183 nz to LP
DEBUG BB: Processing node 87, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=19, varin=20, theta=0.333333, up=999999999999999983222784.000000
ITER 2: row=36, varin=70, theta=1.000000, up=1.000000
ITER 3: row=3, varin=21, theta=0.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 28427938.571148
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 45 rows, 60 cols, 243 nonzeros, 5 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 87 LP 1 Solution, length = 28427938.571148, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.500000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.500000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 1.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.500000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.500000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.500000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.500000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.500000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.500000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.500000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.500000 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=28427938.571148, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28427938.571148, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 87 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 87
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.500000
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.500000
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=1.000000
DEBUG CAREFUL: Skipping var 16: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.500000
DEBUG CAREFUL: Adding var 18 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.500000
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 4 fractional variables

  %  Carefully choosing branching variable, nfrac = 4
DEBUG CAREFUL: Testing fvar[0] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 2
DEBUG CAREFUL: New best var: 2
DEBUG CAREFUL: Testing fvar[1] = var 18
DEBUG CAREFUL: Calling compare_branch_vars for var 18
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 18
DEBUG CAREFUL: New best var: 18
DEBUG CAREFUL: Testing fvar[2] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[3] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
  % Initial guess is x18, Z0 = 28427938.5711484        , Z1 = 28562929.7261199        

DEBUG EVAL: Testing var 2 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=69, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 2 = 0 gives z=28431519.742213
  % 	x2 = 0,	Z0 = 28431519.7422133        
DEBUG EVAL: First branch cutoff check: z=28431519.742213, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 1
ITER 1: row=1, varin=34, theta=0.500000, up=999999999999999983222784.000000
  % 	x2 = 1,	Z1 = 28445825.0996249        
DEBUG EVAL: Second branch cutoff check: z=28445825.099625, best_z=INF, threshold=INF
  %   New best:  x2, Z = 28431519.7422133        
DEBUG EVAL: Testing var 18 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=15, varin=3, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=3, varin=43, theta=0.500000, up=999999999999999983222784.000000
ITER 3: row=43, varin=42, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=42, varin=39, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 18 = 1 gives z=28562929.726120
  % 	x18 = 1,	Z1 = 28562929.7261199        
DEBUG EVAL: First branch cutoff check: z=28562929.726120, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 18 = 0
ITER 1: row=15, varin=69, theta=1.000000, up=1.000000
  % 	x18 = 0,	Z0 = 28431519.7422133        
DEBUG EVAL: Second branch cutoff check: z=28431519.742213, best_z=INF, threshold=INF
  %   New best:  x18, Z = 28431519.7422133        
DEBUG EVAL: Testing var 10 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=12, varin=69, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 10 = 0 gives z=28431519.742213
  % 	x10 = 0,	Z0 = 28431519.7422133        
DEBUG EVAL: First branch cutoff check: z=28431519.742213, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 1
ITER 1: row=12, varin=3, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=3, varin=35, theta=0.500000, up=999999999999999983222784.000000
  % 	x10 = 1,	Z1 = 28491749.1998612        
DEBUG EVAL: Second branch cutoff check: z=28491749.199861, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 26 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=34, varin=69, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 26 = 0 gives z=28431519.742213
  % 	x26 = 0,	Z0 = 28431519.7422133        
DEBUG EVAL: First branch cutoff check: z=28431519.742213, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 26 = 1
ITER 1: row=34, varin=3, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=3, varin=35, theta=0.500000, up=999999999999999983222784.000000
  % 	x26 = 1,	Z1 = 28491749.1998612        
DEBUG EVAL: Second branch cutoff check: z=28491749.199861, best_z=INF, threshold=INF
  % Best branch is x18, Z0 = 28431519.7422133        , Z1 = 28562929.7261199        

DEBUG CAREFUL: Final result - returning best.var = 18
DEBUG BB: Branching variable chosen: j=18
 % @NC  133   87	x18 = 0	28431519.742213
 % @NC  134   87	x18 = 1	28562929.726120
 %      87    63 28427938.5711               28431519.7422   x17 D    52     8
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cb30f0
% @LO 0.07  28.42793857114842381861 99.9000000000
% @LN 0.07  28.43151974221333944115 99.9000000000
% Resuming node 133 at  28.43151974221333944115
DEBUG CONSTRNT: LP rows=45, pool->nlprows=45, pool->npend=0
DEBUG CONSTRNT: Checking 45 LP rows (pool tracks 45, total LP rows 45)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 49
DEBUG CONSTRNT: Pool row 49 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 68
DEBUG CONSTRNT: Pool row 68 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 82
DEBUG CONSTRNT: Pool row 82 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=44, expected 44
 % @PAP adding 45 rows, 183 nz to LP
DEBUG BB: Processing node 133, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=15, varin=69, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 28431519.742213
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 45 rows, 60 cols, 243 nonzeros, 0 slack, 45 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 5 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=46, varin=59, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 28439923.293518
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 47 rows, 60 cols, 248 nonzeros, 0 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 6 rows, 34 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=48, varin=58, theta=0.500000, up=1.000000
ITER 2: row=49, varin=34, theta=0.062500, up=999999999999999983222784.000000
ITER 3: row=53, varin=35, theta=0.071429, up=999999999999999983222784.000000
ITER 4: row=50, varin=48, theta=0.062500, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=53)
DEBUG SOLUTION: LP solution array indices: FST[54-93], not_covered[94-113]
DEBUG SOLUTION: lp->best_solution[0] = 28463638.254319
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 53 rows, 60 cols, 282 nonzeros, 8 slack, 45 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 8 slack rows
  % @PAP adding 4 rows, 13 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=46, varin=79, theta=1.000000, up=1.000000
ITER 2: row=32, varin=51, theta=0.250000, up=1.000000
ITER 3: row=41, varin=19, theta=0.333333, up=999999999999999983222784.000000
ITER 4: row=39, varin=40, theta=0.333333, up=999999999999999983222784.000000
ITER 5: row=40, varin=77, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 28501978.999403
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 49 rows, 60 cols, 279 nonzeros, 0 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=50, varin=3, theta=0.333333, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 28506515.764684
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.666667
DEBUG SOLUTION: lp->best_solution[4] = 0.666667
DEBUG SOLUTION: lp->best_solution[5] = 2.333333
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 51 rows, 60 cols, 285 nonzeros, 4 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % @PAP adding 4 rows, 9 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=48, varin=38, theta=8.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 28537752.056356
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 0.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 51 rows, 60 cols, 281 nonzeros, 4 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=48, varin=29, theta=0.125000, up=999999999999999983222784.000000
ITER 2: row=43, varin=81, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 28552533.058460
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 0.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 48 rows, 60 cols, 265 nonzeros, 0 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 7 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=49, varin=72, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28552927.854386
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 0.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 50 rows, 60 cols, 272 nonzeros, 0 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 16 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=51, varin=40, theta=0.625000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=54)
DEBUG SOLUTION: LP solution array indices: FST[55-94], not_covered[95-114]
DEBUG SOLUTION: lp->best_solution[0] = 28554948.861845
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 0.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 54 rows, 60 cols, 288 nonzeros, 6 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 6 slack rows
  % Node 133 LP 1 Solution, length = 28554948.861845, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.500000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.125000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.125000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.125000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.125000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 1.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.125000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.500000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.875000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.500000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.875000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.500000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.875000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.875000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.875000 (terminal 19)
 % 7 fractional variables
DEBUG CG: LP optimal, z=28554948.861845, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 133 at  28.55494886184494163217
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cb5c00
% @LO 0.07  28.43151974221333944115 99.9000000000
% @LN 0.07  28.43173768936295786602 99.9000000000
% Resuming node 121 at  28.43173768936295786602
DEBUG CONSTRNT: LP rows=48, pool->nlprows=48, pool->npend=0
DEBUG CONSTRNT: Checking 48 LP rows (pool tracks 48, total LP rows 48)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 49
DEBUG CONSTRNT: Pool row 49 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 68
DEBUG CONSTRNT: Pool row 68 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 82
DEBUG CONSTRNT: Pool row 82 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 133
DEBUG CONSTRNT: Pool row 133 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 121
DEBUG CONSTRNT: Pool row 121 has lprow=47, expected 47
 % @PAP adding 45 rows, 220 nz to LP
DEBUG BB: Processing node 121, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=23, varin=15, theta=0.312428, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 28431737.689363
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 45 rows, 60 cols, 280 nonzeros, 1 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 121 LP 1 Solution, length = 28431737.689363, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.687572 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.343786 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.343786 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 1.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.312428 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.312428 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.343786 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.656214 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.656214 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.312428 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.656214 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28431737.689363, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28431737.689363, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 121 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 121
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.687572
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.687572)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.343786
DEBUG CAREFUL: Adding var 9 to fractional list (xi=0.343786)
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.343786
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.343786)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=1.000000
DEBUG CAREFUL: Skipping var 17: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.312428
DEBUG CAREFUL: Adding var 27 to fractional list (xi=0.312428)
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.312428
DEBUG CAREFUL: Adding var 31 to fractional list (xi=0.312428)
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.343786
DEBUG CAREFUL: Adding var 34 to fractional list (xi=0.343786)
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 6 fractional variables

  %  Carefully choosing branching variable, nfrac = 6
DEBUG CAREFUL: Testing fvar[0] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 2
DEBUG CAREFUL: New best var: 2
DEBUG CAREFUL: Testing fvar[1] = var 9
DEBUG CAREFUL: Calling compare_branch_vars for var 9
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 9
DEBUG CAREFUL: Testing fvar[2] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[3] = var 34
DEBUG CAREFUL: Calling compare_branch_vars for var 34
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 34
DEBUG CAREFUL: Testing fvar[4] = var 27
DEBUG CAREFUL: Calling compare_branch_vars for var 27
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 27
DEBUG CAREFUL: Testing fvar[5] = var 31
DEBUG CAREFUL: Calling compare_branch_vars for var 31
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 31
DEBUG CAREFUL: New best var: 31
  % Initial guess is x31, Z0 = 28431737.6893629        , Z1 = 28665372.0746805        

DEBUG EVAL: Testing var 2 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=3, varin=21, theta=1.169416, up=999999999999999983222784.000000
ITER 2: row=34, varin=36, theta=0.165828, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 1 gives z=28477328.491537
  % 	x2 = 1,	Z1 = 28477328.4915366        
DEBUG EVAL: First branch cutoff check: z=28477328.491537, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 0
ITER 1: row=3, varin=42, theta=5.420409, up=999999999999999983222784.000000
ITER 2: row=34, varin=49, theta=0.475413, up=1.000000
ITER 3: row=28, varin=41, theta=0.948275, up=999999999999999983222784.000000
  % 	x2 = 0,	Z0 = 28511822.6542469        
DEBUG EVAL: Second branch cutoff check: z=28511822.654247, best_z=INF, threshold=INF
  %   New best:  x2, Z = 28477328.4915366        
DEBUG EVAL: Testing var 9 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=14, varin=42, theta=5.420409, up=999999999999999983222784.000000
ITER 2: row=34, varin=36, theta=0.247984, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 9 = 0 gives z=28498077.379697
  % 	x9 = 0,	Z0 = 28498077.3796972        
DEBUG EVAL: First branch cutoff check: z=28498077.379697, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 9 = 1
ITER 1: row=14, varin=21, theta=4.912404, up=999999999999999983222784.000000
ITER 2: row=22, varin=49, theta=0.707130, up=1.000000
ITER 3: row=28, varin=23, theta=1.950845, up=999999999999999983222784.000000
ITER 4: row=1, varin=41, theta=7.069158, up=999999999999999983222784.000000
ITER 5: row=26, varin=60, theta=2.943667, up=1.000000
ITER 6: row=26, varin=29, theta=1.258761, up=999999999999999983222784.000000
ITER 7: row=28, varin=76, theta=1.000000, up=1.000000
ITER 8: row=1, varin=60, theta=1.927773, up=1.000000
ITER 9: row=1, varin=3, theta=1.538185, up=999999999999999983222784.000000
ITER 10: row=2, varin=12, theta=2.539775, up=999999999999999983222784.000000
  % 	x9 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: Second branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=14, varin=42, theta=5.420409, up=999999999999999983222784.000000
ITER 2: row=34, varin=36, theta=0.247984, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 28498077.379697
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 45 rows, 60 cols, 280 nonzeros, 6 slack, 39 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 6 slack rows
   % @PAP adding 4 rows, 9 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=43, varin=77, theta=0.345211, up=1.000000
ITER 2: row=3, varin=21, theta=0.128434, up=999999999999999983222784.000000
ITER 3: row=40, varin=39, theta=0.256756, up=999999999999999983222784.000000
ITER 4: row=32, varin=31, theta=0.220840, up=999999999999999983222784.000000
ITER 5: row=38, varin=20, theta=0.233472, up=999999999999999983222784.000000
ITER 6: row=41, varin=36, theta=0.197474, up=999999999999999983222784.000000
ITER 7: row=36, varin=43, theta=0.927496, up=999999999999999983222784.000000
ITER 8: row=21, varin=27, theta=0.088770, up=999999999999999983222784.000000
ITER 9: row=27, varin=16, theta=0.077584, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=9)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 28557649.608823
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 43 rows, 60 cols, 276 nonzeros, 4 slack, 39 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 4 slack rows
   % @PAP adding 3 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=40, varin=73, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 28559810.175143
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 42 rows, 60 cols, 272 nonzeros, 1 slack, 41 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
   % @PAP adding 3 rows, 9 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=43, varin=20, theta=0.333333, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28568902.593073
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 44 rows, 60 cols, 277 nonzeros, 1 slack, 43 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 121 at  28.56890259307336421557
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cb6f50
% @LO 0.08  28.43173768936295786602 99.9000000000
% @LN 0.08  28.43189843928061577571 99.9000000000
% Resuming node 99 at  28.43189843928061577571
DEBUG CONSTRNT: LP rows=43, pool->nlprows=43, pool->npend=0
DEBUG CONSTRNT: Checking 43 LP rows (pool tracks 43, total LP rows 43)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 133
DEBUG CONSTRNT: Pool row 133 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 134
DEBUG CONSTRNT: Pool row 134 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=42, expected 42
 % @PAP adding 38 rows, 166 nz to LP
DEBUG BB: Processing node 99, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 99 LP 2 Solution, length = 28431898.439281, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.333333 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.333333 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.666667 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.333333 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.333333 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.666667 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.333333 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 3 fractional variables
DEBUG CG: LP optimal, z=28431898.439281, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28431898.439281, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 99 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 99
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=1.000000
DEBUG CAREFUL: Skipping var 5: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.333333
DEBUG CAREFUL: Adding var 6 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.333333
DEBUG CAREFUL: Adding var 12 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.666667
DEBUG CAREFUL: Adding var 14 to fractional list (xi=0.666667)
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 3 fractional variables

  %  Carefully choosing branching variable, nfrac = 3
DEBUG CAREFUL: Testing fvar[0] = var 6
DEBUG CAREFUL: Calling compare_branch_vars for var 6
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 6
DEBUG CAREFUL: New best var: 6
DEBUG CAREFUL: Testing fvar[1] = var 12
DEBUG CAREFUL: Calling compare_branch_vars for var 12
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 12
DEBUG CAREFUL: Testing fvar[2] = var 14
DEBUG CAREFUL: Calling compare_branch_vars for var 14
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 14
  % Initial guess is x6, Z0 = 28431898.4392806        , Z1 = 28718093.3959168        

DEBUG EVAL: Testing var 6 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=14, varin=36, theta=1.111111, up=999999999999999983222784.000000
ITER 2: row=30, varin=31, theta=0.400000, up=999999999999999983222784.000000
ITER 3: row=1, varin=30, theta=0.533333, up=999999999999999983222784.000000
ITER 4: row=17, varin=32, theta=0.695652, up=999999999999999983222784.000000
ITER 5: row=22, varin=26, theta=2.000000, up=999999999999999983222784.000000
ITER 6: row=2, varin=2, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=26, varin=35, theta=16.000000, up=999999999999999983222784.000000
ITER 8: row=8, varin=40, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 6 = 1 gives z=28737031.877411
  % 	x6 = 1,	Z1 = 28737031.8774114        
DEBUG EVAL: First branch cutoff check: z=28737031.877411, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 6 = 0
ITER 1: row=14, varin=32, theta=0.555556, up=999999999999999983222784.000000
ITER 2: row=18, varin=75, theta=1.000000, up=1.000000
ITER 3: row=9, varin=42, theta=0.500000, up=1.000000
  % 	x6 = 0,	Z0 = 28438506.4766915        
DEBUG EVAL: Second branch cutoff check: z=28438506.476691, best_z=INF, threshold=INF
  %   New best:  x6, Z = 28438506.4766915        
DEBUG EVAL: Testing var 12 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=7, varin=36, theta=1.111111, up=999999999999999983222784.000000
ITER 2: row=30, varin=31, theta=0.400000, up=999999999999999983222784.000000
ITER 3: row=1, varin=14, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 12 = 1 gives z=28460648.739165
  % 	x12 = 1,	Z1 = 28460648.7391649        
DEBUG EVAL: First branch cutoff check: z=28460648.739165, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 12 = 0
ITER 1: row=7, varin=32, theta=0.555556, up=999999999999999983222784.000000
ITER 2: row=18, varin=75, theta=1.000000, up=1.000000
ITER 3: row=9, varin=42, theta=0.500000, up=1.000000
  % 	x12 = 0,	Z0 = 28438506.4766915        
DEBUG EVAL: Second branch cutoff check: z=28438506.476691, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 14 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=15, varin=32, theta=0.555556, up=999999999999999983222784.000000
ITER 2: row=18, varin=75, theta=1.000000, up=1.000000
ITER 3: row=9, varin=42, theta=0.500000, up=1.000000
DEBUG EVAL: Branch var 14 = 1 gives z=28438506.476691
  % 	x14 = 1,	Z1 = 28438506.4766915        
DEBUG EVAL: First branch cutoff check: z=28438506.476691, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 14 = 0
ITER 1: row=15, varin=36, theta=1.111111, up=999999999999999983222784.000000
ITER 2: row=30, varin=31, theta=0.400000, up=999999999999999983222784.000000
ITER 3: row=1, varin=14, theta=1.000000, up=999999999999999983222784.000000
  % 	x14 = 0,	Z0 = 28460648.7391649        
DEBUG EVAL: Second branch cutoff check: z=28460648.739165, best_z=INF, threshold=INF
  % Best branch is x6, Z0 = 28438506.4766915        , Z1 = 28737031.8774114        

DEBUG CAREFUL: Final result - returning best.var = 6
DEBUG BB: Branching variable chosen: j=6
 % @NC  135   99	x6 = 0	28438506.476691
 % @NC  136   99	x6 = 1	28737031.877411
 %      99    64 28431898.4393               28432793.1100    x9 D    65     6
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cc9ac0
% @LO 0.08  28.43189843928061577571 99.9000000000
% @LN 0.08  28.43279311001484543908 99.9000000000
% Resuming node 131 at  28.43279311001484543908
DEBUG CONSTRNT: LP rows=38, pool->nlprows=38, pool->npend=0
DEBUG CONSTRNT: Checking 38 LP rows (pool tracks 38, total LP rows 38)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=37, expected 37
 % @PAP adding 36 rows, 145 nz to LP
DEBUG BB: Processing node 131, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=33, varin=34, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=36)
DEBUG SOLUTION: LP solution array indices: FST[37-76], not_covered[77-96]
DEBUG SOLUTION: lp->best_solution[0] = 28432793.110015
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 36 rows, 60 cols, 205 nonzeros, 3 slack, 33 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 18 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=37, varin=75, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=38)
DEBUG SOLUTION: LP solution array indices: FST[39-78], not_covered[79-98]
DEBUG SOLUTION: lp->best_solution[0] = 28435848.766659
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 38 rows, 60 cols, 223 nonzeros, 3 slack, 35 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 2 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=36, varin=33, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=37)
DEBUG SOLUTION: LP solution array indices: FST[38-77], not_covered[78-97]
DEBUG SOLUTION: lp->best_solution[0] = 28437854.366554
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 37 rows, 60 cols, 224 nonzeros, 1 slack, 36 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 2 rows, 11 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=37, varin=42, theta=0.250000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=38)
DEBUG SOLUTION: LP solution array indices: FST[39-78], not_covered[79-98]
DEBUG SOLUTION: lp->best_solution[0] = 28438013.270879
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 38 rows, 60 cols, 233 nonzeros, 1 slack, 37 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 6 rows, 31 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=38, varin=50, theta=0.166667, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 28440479.969804
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 43 rows, 60 cols, 255 nonzeros, 0 slack, 43 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=44, varin=31, theta=0.166667, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 28441579.407577
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 45 rows, 60 cols, 263 nonzeros, 5 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % Node 131 LP 1 Solution, length = 28441579.407577, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.166667 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.166667 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.500000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.500000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 1.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.166667 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.500000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.833333 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.833333 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.500000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.833333 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.500000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.833333 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.500000 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28441579.407577, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 131 at  28.44157940757697033973
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7ce3870
% @LO 0.08  28.43279311001484543908 99.9000000000
% @LN 0.08  28.43347719469601031506 99.9000000000
% Resuming node 100 at  28.43347719469601031506
DEBUG CONSTRNT: LP rows=40, pool->nlprows=40, pool->npend=0
DEBUG CONSTRNT: Checking 40 LP rows (pool tracks 40, total LP rows 40)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=39, expected 39
 % @PAP adding 33 rows, 161 nz to LP
DEBUG BB: Processing node 100, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=17, varin=24, theta=0.477273, up=999999999999999983222784.000000
ITER 2: row=26, varin=2, theta=0.500000, up=999999999999999983222784.000000
ITER 3: row=2, varin=25, theta=0.318584, up=999999999999999983222784.000000
ITER 4: row=21, varin=20, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=19, varin=32, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=12, varin=18, theta=0.428571, up=999999999999999983222784.000000
ITER 7: row=1, varin=35, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=7)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=33)
DEBUG SOLUTION: LP solution array indices: FST[34-73], not_covered[74-93]
DEBUG SOLUTION: lp->best_solution[0] = 28433477.194696
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 33 rows, 60 cols, 221 nonzeros, 0 slack, 33 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 6 rows, 67 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=39, varin=9, theta=0.176838, up=999999999999999983222784.000000
ITER 2: row=36, varin=30, theta=0.148029, up=999999999999999983222784.000000
ITER 3: row=37, varin=39, theta=334157.384615, up=999999999999999983222784.000000
ITER 4: row=34, varin=36, theta=10.493102, up=999999999999999983222784.000000
ITER 5: row=1, varin=42, theta=0.621730, up=1.000000
ITER 6: row=20, varin=92, theta=0.863197, up=1.000000
ITER 7: row=32, varin=21, theta=12.197680, up=999999999999999983222784.000000
ITER 8: row=37, varin=40, theta=0.191395, up=1.000000
ITER 9: row=18, varin=57, theta=0.835497, up=1.000000
ITER 10: row=24, varin=39, theta=114593.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=15)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=39)
DEBUG SOLUTION: LP solution array indices: FST[40-79], not_covered[80-99]
DEBUG SOLUTION: lp->best_solution[0] = 28584828.392753
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 39 rows, 60 cols, 288 nonzeros, 4 slack, 35 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % @PAP adding 5 rows, 17 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=36, varin=59, theta=0.337319, up=1.000000
ITER 2: row=20, varin=27, theta=0.542989, up=999999999999999983222784.000000
ITER 3: row=27, varin=23, theta=0.040296, up=999999999999999983222784.000000
ITER 4: row=25, varin=22, theta=0.234834, up=999999999999999983222784.000000
ITER 5: row=40, varin=95, theta=0.043816, up=1.000000
ITER 6: row=27, varin=20, theta=0.050194, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=40)
DEBUG SOLUTION: LP solution array indices: FST[41-80], not_covered[81-100]
DEBUG SOLUTION: lp->best_solution[0] = 28593392.516484
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.949806
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.949806
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.953677
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.949806
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 40 rows, 60 cols, 282 nonzeros, 7 slack, 33 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 7 slack rows
  % @PAP adding 3 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=36, varin=33, theta=1.148436, up=999999999999999983222784.000000
ITER 2: row=18, varin=28, theta=90450.947368, up=999999999999999983222784.000000
ITER 3: row=34, varin=63, theta=1.000000, up=1.000000
ITER 4: row=36, varin=16, theta=0.200000, up=999999999999999983222784.000000
ITER 5: row=35, varin=18, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=36)
DEBUG SOLUTION: LP solution array indices: FST[37-76], not_covered[77-96]
DEBUG SOLUTION: lp->best_solution[0] = 28611601.041036
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 36 rows, 60 cols, 261 nonzeros, 2 slack, 34 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % Node 100 LP 1 Solution, length = 28611601.041036, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.200000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 1.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.800000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.200000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.200000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.200000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.800000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.800000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.800000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.200000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.800000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.200000 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28611601.041036, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 100 at  28.61160104103571910628
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cd1940
% @LO 0.08  28.43347719469601031506 99.9000000000
% @LN 0.08  28.43348272956018973900 99.9000000000
% Resuming node 119 at  28.43348272956018973900
DEBUG CONSTRNT: LP rows=34, pool->nlprows=34, pool->npend=0
DEBUG CONSTRNT: Checking 34 LP rows (pool tracks 34, total LP rows 34)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 63
DEBUG CONSTRNT: Pool row 63 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 121
DEBUG CONSTRNT: Pool row 121 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 158
DEBUG CONSTRNT: Pool row 158 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=33, expected 33
 % @PAP adding 39 rows, 162 nz to LP
DEBUG BB: Processing node 119, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=16, varin=34, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=39)
DEBUG SOLUTION: LP solution array indices: FST[40-79], not_covered[80-99]
DEBUG SOLUTION: lp->best_solution[0] = 28433482.729560
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 39 rows, 60 cols, 222 nonzeros, 3 slack, 36 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 3 rows, 58 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=41, varin=67, theta=0.652061, up=1.000000
ITER 2: row=3, varin=37, theta=4.383329, up=999999999999999983222784.000000
ITER 3: row=40, varin=66, theta=0.622827, up=1.000000
ITER 4: row=32, varin=72, theta=0.653455, up=1.000000
ITER 5: row=27, varin=54, theta=0.436184, up=1.000000
ITER 6: row=39, varin=47, theta=0.062568, up=1.000000
LP PHASE: Switching to primal (iter=6)
ITER 7: row=15, varin=59, theta=0.000000, up=1.000000
ITER 8: row=16, varin=23, theta=0.045340, up=999999999999999983222784.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 28520959.209616
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 42 rows, 60 cols, 280 nonzeros, 6 slack, 36 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 6 slack rows
  % @PAP adding 3 rows, 7 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=56, theta=4.666667, up=1.000000
ITER 2: row=1, varin=55, theta=3.666667, up=1.000000
ITER 3: row=1, varin=54, theta=2.666667, up=1.000000
ITER 4: row=1, varin=48, theta=2.500000, up=1.000000
ITER 5: row=1, varin=50, theta=1.500000, up=1.000000
ITER 6: row=1, varin=41, theta=0.500000, up=1.000000
ITER 7: row=35, varin=80, theta=9.027882, up=1.000000
ITER 8: row=35, varin=81, theta=8.027882, up=1.000000
ITER 9: row=35, varin=82, theta=7.027882, up=1.000000
ITER 10: row=35, varin=83, theta=6.027882, up=1.000000
LP PHASE: Switching to primal (iter=71)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=39)
DEBUG SOLUTION: LP solution array indices: FST[40-79], not_covered[80-99]
DEBUG SOLUTION: lp->best_solution[0] = 28521278.594506
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 39 rows, 60 cols, 270 nonzeros, 0 slack, 39 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 5 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=40, varin=56, theta=0.492743, up=1.000000
ITER 2: row=15, varin=24, theta=0.069369, up=999999999999999983222784.000000
ITER 3: row=39, varin=38, theta=0.042887, up=999999999999999983222784.000000
ITER 4: row=38, varin=68, theta=0.196332, up=1.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=40)
DEBUG SOLUTION: LP solution array indices: FST[41-80], not_covered[81-100]
DEBUG SOLUTION: lp->best_solution[0] = 28524723.480207
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 40 rows, 60 cols, 275 nonzeros, 0 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 119 LP 1 Solution, length = 28524723.480207, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.696332 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.500000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.303668 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.696332 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 1.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.196332 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.500000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.303668 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.303668 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.500000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.303668 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.303668 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28524723.480207, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 119 at  28.52472348020684123071
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cb66c0
% @LO 0.08  28.43348272956018973900 99.9000000000
% @LN 0.08  28.43412417627868649106 99.9000000000
% Resuming node 127 at  28.43412417627868649106
DEBUG CONSTRNT: LP rows=40, pool->nlprows=40, pool->npend=0
DEBUG CONSTRNT: Checking 40 LP rows (pool tracks 40, total LP rows 40)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 158
DEBUG CONSTRNT: Pool row 158 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 145
DEBUG CONSTRNT: Pool row 145 has lprow=39, expected 39
 % @PAP adding 43 rows, 181 nz to LP
DEBUG BB: Processing node 127, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=29, varin=29, theta=0.333333, up=999999999999999983222784.000000
ITER 2: row=32, varin=34, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 28434124.176279
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 43 rows, 60 cols, 241 nonzeros, 4 slack, 39 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 9 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=44, varin=70, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 28446607.652310
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 45 rows, 60 cols, 250 nonzeros, 5 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % @PAP adding 4 rows, 11 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=41, varin=30, theta=0.166667, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28447889.391311
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 44 rows, 60 cols, 225 nonzeros, 4 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % Node 127 LP 1 Solution, length = 28447889.391311, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.166667 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.166667 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.166667 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.500000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.500000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.166667 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.166667 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.833333 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.833333 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.500000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.500000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.833333 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.833333 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.833333 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.833333 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.500000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.833333 (terminal 19)
 % 7 fractional variables
DEBUG CG: LP optimal, z=28447889.391311, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 127 at  28.44788939131094451795
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7ce6f50
% @LO 0.08  28.43412417627868649106 99.9000000000
% @LN 0.08  28.43666013216620669368 99.9000000000
% Resuming node 110 at  28.43666013216620669368
DEBUG CONSTRNT: LP rows=40, pool->nlprows=40, pool->npend=0
DEBUG CONSTRNT: Checking 40 LP rows (pool tracks 40, total LP rows 40)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=39, expected 39
 % @PAP adding 32 rows, 136 nz to LP
DEBUG BB: Processing node 110, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 110 LP 2 Solution, length = 28436660.132166, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.500000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.500000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.500000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 1.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.500000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.500000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.500000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 3 fractional variables
DEBUG CG: LP optimal, z=28436660.132166, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28436660.132166, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 110 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 110
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.500000
DEBUG CAREFUL: Adding var 5 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.500000
DEBUG CAREFUL: Adding var 7 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.500000
DEBUG CAREFUL: Adding var 9 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=1.000000
DEBUG CAREFUL: Skipping var 20: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 3 fractional variables

  %  Carefully choosing branching variable, nfrac = 3
DEBUG CAREFUL: Testing fvar[0] = var 9
DEBUG CAREFUL: Calling compare_branch_vars for var 9
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 9
DEBUG CAREFUL: New best var: 9
DEBUG CAREFUL: Testing fvar[1] = var 5
DEBUG CAREFUL: Calling compare_branch_vars for var 5
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 5
DEBUG CAREFUL: Testing fvar[2] = var 7
DEBUG CAREFUL: Calling compare_branch_vars for var 7
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 7
  % Initial guess is x9, Z0 = 28436660.1321662        , Z1 = 28441089.0263454        

DEBUG EVAL: Testing var 9 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=23, varin=21, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=30, varin=24, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=31, varin=22, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=1, varin=86, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 9 = 1 gives z=28501205.720132
  % 	x9 = 1,	Z1 = 28501205.7201318        
DEBUG EVAL: First branch cutoff check: z=28501205.720132, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 9 = 0
ITER 1: row=23, varin=26, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=1, varin=86, theta=1.000000, up=1.000000
  % 	x9 = 0,	Z0 = 28456922.9395496        
DEBUG EVAL: Second branch cutoff check: z=28456922.939550, best_z=INF, threshold=INF
  %   New best:  x9, Z = 28456922.9395496        
DEBUG EVAL: Testing var 5 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=7, varin=29, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=1, varin=86, theta=2.000000, up=1.000000
ITER 3: row=1, varin=25, theta=0.333333, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 5 = 0 gives z=28480184.672192
  % 	x5 = 0,	Z0 = 28480184.6721915        
DEBUG EVAL: First branch cutoff check: z=28480184.672192, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 5 = 1
ITER 1: row=7, varin=21, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=30, varin=26, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=1, varin=24, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=31, varin=22, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=23, varin=86, theta=1.000000, up=1.000000
  % 	x5 = 1,	Z1 = 28501205.7201318        
DEBUG EVAL: Second branch cutoff check: z=28501205.720132, best_z=INF, threshold=INF
  %   New best:  x5, Z = 28480184.6721915        
DEBUG EVAL: Testing var 7 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=21, varin=21, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=30, varin=26, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=1, varin=24, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=31, varin=22, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=23, varin=86, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 7 = 0 gives z=28501205.720132
  % 	x7 = 0,	Z0 = 28501205.7201318        
DEBUG EVAL: First branch cutoff check: z=28501205.720132, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 7 = 1
ITER 1: row=21, varin=29, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=1, varin=86, theta=2.000000, up=1.000000
ITER 3: row=1, varin=50, theta=0.333333, up=1.000000
  % 	x7 = 1,	Z1 = 28501625.5052784        
DEBUG EVAL: Second branch cutoff check: z=28501625.505278, best_z=INF, threshold=INF
  %   New best:  x7, Z = 28501205.7201318        
  % Best branch is x7, Z0 = 28501205.7201318        , Z1 = 28501625.5052784        

DEBUG CAREFUL: Final result - returning best.var = 7
DEBUG BB: Branching variable chosen: j=7
 % @NC  137  110	x7 = 0	28501205.720132
 % @NC  138  110	x7 = 1	28501625.505278
 %     110    65 28436660.1322               28437599.2721    x8 D    77     5
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7ccf030
% @LO 0.08  28.43666013216620669368 99.9000000000
% @LN 0.08  28.43759927213129401480 99.9000000000
% Resuming node 46 at  28.43759927213129401480
DEBUG CONSTRNT: LP rows=32, pool->nlprows=32, pool->npend=0
DEBUG CONSTRNT: Checking 32 LP rows (pool tracks 32, total LP rows 32)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 121
DEBUG CONSTRNT: Pool row 121 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 63
DEBUG CONSTRNT: Pool row 63 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=31, expected 31
 % @PAP adding 43 rows, 184 nz to LP
DEBUG BB: Processing node 46, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=27, varin=19, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 28437599.272131
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 43 rows, 60 cols, 244 nonzeros, 1 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=44, varin=22, theta=0.125000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28438843.420442
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 44 rows, 60 cols, 246 nonzeros, 5 slack, 39 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % @PAP adding 3 rows, 14 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=42, varin=16, theta=0.029412, up=999999999999999983222784.000000
ITER 2: row=40, varin=75, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 28452380.274236
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 42 rows, 60 cols, 239 nonzeros, 0 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 7 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=43, varin=66, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28452775.070162
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 44 rows, 60 cols, 246 nonzeros, 0 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=45, varin=3, theta=0.250000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 28455827.502344
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.750000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 45 rows, 60 cols, 250 nonzeros, 3 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % Node 46 LP 1 Solution, length = 28455827.502344, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.250000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.250000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.500000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.500000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.250000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.250000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 1.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.750000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.750000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.750000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.500000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.750000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.500000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28455827.502344, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 46 at  28.45582750234445157389
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7ccbbd0
% @LO 0.08  28.43759927213129401480 99.9000000000
% @LN 0.08  28.43806838992781038655 99.9000000000
% Resuming node 83 at  28.43806838992781038655
DEBUG CONSTRNT: LP rows=42, pool->nlprows=42, pool->npend=0
DEBUG CONSTRNT: Checking 42 LP rows (pool tracks 42, total LP rows 42)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 133
DEBUG CONSTRNT: Pool row 133 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=41, expected 41
 % @PAP adding 48 rows, 201 nz to LP
DEBUG BB: Processing node 83, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=32, varin=35, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 28438068.389928
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 48 rows, 60 cols, 261 nonzeros, 1 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 12 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=49, varin=38, theta=0.333333, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28451416.914029
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 50 rows, 60 cols, 273 nonzeros, 4 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % @PAP adding 4 rows, 10 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=47, varin=28, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=46, varin=32, theta=0.125000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28460088.097289
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 50 rows, 60 cols, 268 nonzeros, 8 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 8 slack rows
  % @PAP adding 3 rows, 46 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=45, varin=69, theta=0.087655, up=1.000000
ITER 2: row=43, varin=40, theta=3.637315, up=999999999999999983222784.000000
ITER 3: row=44, varin=45, theta=84019.500000, up=999999999999999983222784.000000
ITER 4: row=36, varin=36, theta=-0.154528, up=999999999999999983222784.000000
ITER 5: row=36, varin=41, theta=0.077104, up=999999999999999983222784.000000
ITER 6: row=32, varin=39, theta=0.140757, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=6)
ITER 7: row=39, varin=44, theta=0.000000, up=999999999999999983222784.000000
ITER 8: row=41, varin=79, theta=0.000000, up=1.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 28465982.389971
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 45 rows, 60 cols, 284 nonzeros, 2 slack, 43 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % Node 83 LP 1 Solution, length = 28465982.389971, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.500000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.500000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.500000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.500000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.500000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.500000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.500000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.500000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.500000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.500000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.500000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.500000 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28465982.389971, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 83 at  28.46598238997147234386
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cc2570
% @LO 0.08  28.43806838992781038655 99.9000000000
% @LN 0.08  28.43831566604955440880 99.9000000000
% Resuming node 113 at  28.43831566604955440880
DEBUG CONSTRNT: LP rows=43, pool->nlprows=43, pool->npend=0
DEBUG CONSTRNT: Checking 43 LP rows (pool tracks 43, total LP rows 43)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=42, expected 42
 % @PAP adding 40 rows, 162 nz to LP
DEBUG BB: Processing node 113, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=30, varin=30, theta=0.333333, up=999999999999999983222784.000000
ITER 2: row=33, varin=65, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=40)
DEBUG SOLUTION: LP solution array indices: FST[41-80], not_covered[81-100]
DEBUG SOLUTION: lp->best_solution[0] = 28438315.666050
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
  % @PL 40 rows, 60 cols, 222 nonzeros, 0 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 11 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=41, varin=31, theta=0.333333, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28440879.144051
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
  % @PL 44 rows, 60 cols, 233 nonzeros, 4 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % Node 113 LP 1 Solution, length = 28440879.144051, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.333333 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.333333 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.333333 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 1.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.333333 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.333333 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.666667 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.666667 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.666667 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.666667 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.666667 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.666667 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.666667 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28440879.144051, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 113 at  28.44087914405130490536
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cc5d40
% @LO 0.08  28.43831566604955440880 99.9000000000
% @LN 0.08  28.43839911325308023038 99.9000000000
% Resuming node 78 at  28.43839911325308023038
DEBUG CONSTRNT: LP rows=40, pool->nlprows=40, pool->npend=0
DEBUG CONSTRNT: Checking 40 LP rows (pool tracks 40, total LP rows 40)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=39, expected 39
 % @PAP adding 29 rows, 176 nz to LP
DEBUG BB: Processing node 78, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=21, varin=39, theta=2.001427, up=1.000000
ITER 2: row=21, varin=28, theta=0.720183, up=999999999999999983222784.000000
ITER 3: row=23, varin=7, theta=0.692712, up=999999999999999983222784.000000
ITER 4: row=7, varin=30, theta=1.577592, up=1.000000
ITER 5: row=7, varin=39, theta=0.938871, up=1.000000
ITER 6: row=2, varin=30, theta=1.000000, up=1.000000
ITER 7: row=1, varin=15, theta=1.636343, up=999999999999999983222784.000000
ITER 8: row=15, varin=47, theta=0.719733, up=1.000000
ITER 9: row=7, varin=32, theta=2.430034, up=1.000000
ITER 10: row=7, varin=56, theta=0.319351, up=1.000000
LP PHASE: Switching to primal (iter=10)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=29)
DEBUG SOLUTION: LP solution array indices: FST[30-69], not_covered[70-89]
DEBUG SOLUTION: lp->best_solution[0] = 28438399.113253
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 29 rows, 60 cols, 236 nonzeros, 1 slack, 28 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 8 rows, 32 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=31, varin=39, theta=1.373846, up=1.000000
ITER 2: row=31, varin=46, theta=0.155752, up=1.000000
ITER 3: row=29, varin=47, theta=1.188604, up=1.000000
ITER 4: row=29, varin=61, theta=0.106564, up=1.000000
ITER 5: row=15, varin=47, theta=1.000000, up=1.000000
ITER 6: row=3, varin=60, theta=0.633269, up=1.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=36)
DEBUG SOLUTION: LP solution array indices: FST[37-76], not_covered[77-96]
DEBUG SOLUTION: lp->best_solution[0] = 28521584.503891
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 36 rows, 60 cols, 256 nonzeros, 0 slack, 36 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 6 rows, 24 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=37, varin=23, theta=1.043712, up=999999999999999983222784.000000
ITER 2: row=40, varin=72, theta=0.780417, up=1.000000
ITER 3: row=39, varin=40, theta=0.200769, up=999999999999999983222784.000000
ITER 4: row=38, varin=37, theta=0.074701, up=999999999999999983222784.000000
ITER 5: row=20, varin=85, theta=0.015474, up=1.000000
ITER 6: row=37, varin=66, theta=0.122624, up=1.000000
ITER 7: row=41, varin=27, theta=0.036537, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=7)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 28608644.540035
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 42 rows, 60 cols, 280 nonzeros, 3 slack, 39 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 5 rows, 15 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=41, varin=72, theta=0.814308, up=1.000000
ITER 2: row=40, varin=66, theta=-1.126229, up=1.000000
ITER 3: row=40, varin=79, theta=0.371364, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28626708.653216
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 44 rows, 60 cols, 282 nonzeros, 0 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 3 rows, 13 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=47, varin=69, theta=0.472751, up=1.000000
ITER 2: row=45, varin=89, theta=0.261832, up=1.000000
ITER 3: row=39, varin=36, theta=0.186755, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 28631923.483949
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 47 rows, 60 cols, 295 nonzeros, 2 slack, 45 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 2 rows, 7 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=46, varin=84, theta=2.039786, up=1.000000
ITER 2: row=46, varin=50, theta=0.689534, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 28742768.824457
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 47 rows, 60 cols, 287 nonzeros, 0 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 6 rows, 25 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=51, varin=90, theta=0.555556, up=1.000000
ITER 2: row=53, varin=82, theta=0.285356, up=1.000000
ITER 3: row=52, varin=53, theta=0.500000, up=999999999999999983222784.000000
ITER 4: row=48, varin=51, theta=0.261428, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=53)
DEBUG SOLUTION: LP solution array indices: FST[54-93], not_covered[94-113]
DEBUG SOLUTION: lp->best_solution[0] = 28800537.939717
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 53 rows, 60 cols, 312 nonzeros, 3 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 1 rows, 5 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=51, varin=84, theta=0.711865, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 28817733.579497
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 51 rows, 60 cols, 298 nonzeros, 0 slack, 51 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 13 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=52, varin=86, theta=0.658618, up=1.000000
ITER 2: row=53, varin=87, theta=0.677397, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=55)
DEBUG SOLUTION: LP solution array indices: FST[56-95], not_covered[96-115]
DEBUG SOLUTION: lp->best_solution[0] = 28961574.450954
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 55 rows, 60 cols, 311 nonzeros, 2 slack, 53 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=54, varin=88, theta=0.276535, up=1.000000
ITER 2: row=4, varin=52, theta=2.305905, up=999999999999999983222784.000000
ITER 3: row=41, varin=99, theta=0.095773, up=1.000000
ITER 4: row=4, varin=66, theta=0.412945, up=1.000000
ITER 5: row=33, varin=8, theta=0.080601, up=999999999999999983222784.000000
ITER 6: row=42, varin=56, theta=0.106485, up=1.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=54)
DEBUG SOLUTION: LP solution array indices: FST[55-94], not_covered[95-114]
DEBUG SOLUTION: lp->best_solution[0] = 29087366.307914
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 0.964505
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 54 rows, 60 cols, 307 nonzeros, 1 slack, 53 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 2 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=55, varin=112, theta=0.119186, up=1.000000
ITER 2: row=38, varin=38, theta=0.032410, up=999999999999999983222784.000000
ITER 3: row=53, varin=32, theta=0.172267, up=999999999999999983222784.000000
ITER 4: row=32, varin=78, theta=0.172997, up=1.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=55)
DEBUG SOLUTION: LP solution array indices: FST[56-95], not_covered[96-115]
DEBUG SOLUTION: lp->best_solution[0] = 999999999999999983222784.000000
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 0.964505
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 55 rows, 60 cols, 309 nonzeros, 5 slack, 50 tight.
  % Node 78 LP 1 Solution, length = 999999999999999983222784.000000, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.106485 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.500000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.012344 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.012344 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.012344 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 1.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 1.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.500000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.106485 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.319454 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.500000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.141980 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.012344 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.012344 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.987656 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.858020 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.893515 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.893515 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.987656 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.500000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
DEBUG BB: compute_good_lower_bound returned status=1
DEBUG BB: Node 78 is INFEASIBLE
 %      78    64    infeasible               28438506.4767   x14 U    49     4
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cc7030
% @LO 0.08  28.43839911325308023038 99.9000000000
% @LN 0.08  28.43850647669147946317 99.9000000000
% Resuming node 135 at  28.43850647669147946317
DEBUG CONSTRNT: LP rows=55, pool->nlprows=55, pool->npend=0
DEBUG CONSTRNT: Checking 55 LP rows (pool tracks 55, total LP rows 55)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 141
DEBUG CONSTRNT: Pool row 141 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 145
DEBUG CONSTRNT: Pool row 145 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 159
DEBUG CONSTRNT: Pool row 159 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 133
DEBUG CONSTRNT: Pool row 133 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 134
DEBUG CONSTRNT: Pool row 134 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=54, expected 54
 % @PAP adding 38 rows, 166 nz to LP
DEBUG BB: Processing node 135, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=14, varin=32, theta=0.555556, up=999999999999999983222784.000000
ITER 2: row=18, varin=75, theta=1.000000, up=1.000000
ITER 3: row=9, varin=42, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=38)
DEBUG SOLUTION: LP solution array indices: FST[39-78], not_covered[79-98]
DEBUG SOLUTION: lp->best_solution[0] = 28438506.476691
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
  % @PL 38 rows, 60 cols, 226 nonzeros, 0 slack, 38 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 6 rows, 31 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=39, varin=35, theta=0.833333, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28441539.770782
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
  % @PL 44 rows, 60 cols, 257 nonzeros, 4 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % Node 135 LP 1 Solution, length = 28441539.770782, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.166667 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.166667 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.166667 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 1.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.166667 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.166667 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.166667 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.833333 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.833333 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.833333 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.833333 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.833333 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.833333 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.833333 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28441539.770782, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 135 at  28.44153977078224571073
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cc2570
% @LO 0.08  28.43850647669147946317 99.9000000000
% @LN 0.08  28.44087914405130490536 99.9000000000
% Resuming node 113 at  28.44087914405130490536
DEBUG CONSTRNT: LP rows=40, pool->nlprows=40, pool->npend=0
DEBUG CONSTRNT: Checking 40 LP rows (pool tracks 40, total LP rows 40)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=39, expected 39
 % @PAP adding 40 rows, 165 nz to LP
DEBUG BB: Processing node 113, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 113 LP 2 Solution, length = 28440879.144051, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.333333 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.333333 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.333333 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 1.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.333333 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.333333 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.666667 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.666667 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.666667 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.666667 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.666667 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.666667 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.666667 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28440879.144051, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28440879.144051, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 113 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 113
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.333333
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.333333
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=1.000000
DEBUG CAREFUL: Skipping var 5: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.333333
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=1.000000
DEBUG CAREFUL: Skipping var 15: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.333333
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.333333
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 17
DEBUG CAREFUL: New best var: 17
DEBUG CAREFUL: Testing fvar[1] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[2] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 3
DEBUG CAREFUL: New best var: 3
DEBUG CAREFUL: Testing fvar[3] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[4] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
  % Initial guess is x3, Z0 = 28440879.1440513        , Z1 = 28684156.6796653        

DEBUG EVAL: Testing var 17 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=17, varin=37, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=37, varin=34, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 17 = 1 gives z=28540224.529127
  % 	x17 = 1,	Z1 = 28540224.5291271        
DEBUG EVAL: First branch cutoff check: z=28540224.529127, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 17 = 0
ITER 1: row=17, varin=64, theta=1.000000, up=1.000000
ITER 2: row=40, varin=52, theta=0.500000, up=1.000000
  % 	x17 = 0,	Z0 = 28513614.5636781        
DEBUG EVAL: Second branch cutoff check: z=28513614.563678, best_z=INF, threshold=INF
  %   New best:  x17, Z = 28513614.5636781        
DEBUG EVAL: Testing var 2 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=64, theta=1.000000, up=1.000000
ITER 2: row=40, varin=52, theta=0.500000, up=1.000000
DEBUG EVAL: Branch var 2 = 0 gives z=28513614.563678
  % 	x2 = 0,	Z0 = 28513614.5636781        
DEBUG EVAL: First branch cutoff check: z=28513614.563678, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 1
ITER 1: row=1, varin=37, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=37, varin=18, theta=0.666667, up=999999999999999983222784.000000
  % 	x2 = 1,	Z1 = 28464727.8486866        
DEBUG EVAL: Second branch cutoff check: z=28464727.848687, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 3 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=15, varin=37, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=37, varin=9, theta=2.000000, up=999999999999999983222784.000000
ITER 3: row=9, varin=17, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=35, varin=31, theta=2.000000, up=999999999999999983222784.000000
ITER 5: row=31, varin=18, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=36, varin=26, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=38, varin=55, theta=0.500000, up=1.000000
ITER 8: row=7, varin=2, theta=0.400000, up=999999999999999983222784.000000
ITER 9: row=26, varin=19, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 3 = 1 gives z=28684156.679665
  % 	x3 = 1,	Z1 = 28684156.6796653        
DEBUG EVAL: First branch cutoff check: z=28684156.679665, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 3 = 0
ITER 1: row=15, varin=64, theta=1.000000, up=1.000000
ITER 2: row=40, varin=52, theta=0.500000, up=1.000000
  % 	x3 = 0,	Z0 = 28513614.5636781        
DEBUG EVAL: Second branch cutoff check: z=28513614.563678, best_z=INF, threshold=INF
  %   New best:  x3, Z = 28513614.5636781        
DEBUG EVAL: Testing var 10 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=8, varin=37, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=37, varin=30, theta=0.666667, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 1 gives z=28525959.982335
  % 	x10 = 1,	Z1 = 28525959.982335         
DEBUG EVAL: First branch cutoff check: z=28525959.982335, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 0
ITER 1: row=8, varin=11, theta=0.500000, up=999999999999999983222784.000000
  % 	x10 = 0,	Z0 = 28496040.2507476        
DEBUG EVAL: Second branch cutoff check: z=28496040.250748, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 26 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=31, varin=31, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 26 = 0 gives z=28477999.372909
  % 	x26 = 0,	Z0 = 28477999.3729086        
DEBUG EVAL: First branch cutoff check: z=28477999.372909, best_z=INF, threshold=INF
  % Best branch is x3, Z0 = 28513614.5636781        , Z1 = 28684156.6796653        

DEBUG CAREFUL: Final result - returning best.var = 3
DEBUG BB: Branching variable chosen: j=3
 % @NC  139  113	x3 = 0	28513614.563678
 % @NC  140  113	x3 = 1	28684156.679665
 %     113    65 28440879.1441               28441539.7708   x18 D    66     6
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cc7030
% @LO 0.08  28.44087914405130490536 99.9000000000
% @LN 0.08  28.44153977078224571073 99.9000000000
% Resuming node 135 at  28.44153977078224571073
DEBUG CONSTRNT: LP rows=40, pool->nlprows=40, pool->npend=0
DEBUG CONSTRNT: Checking 40 LP rows (pool tracks 40, total LP rows 40)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=39, expected 39
 % @PAP adding 40 rows, 162 nz to LP
DEBUG BB: Processing node 135, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 135 LP 2 Solution, length = 28441539.770782, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.166667 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.166667 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.166667 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 1.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.166667 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.166667 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.166667 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.833333 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.833333 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.833333 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.833333 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.833333 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.833333 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.833333 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28441539.770782, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28441539.770782, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 135 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 135
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.166667
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.166667
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=1.000000
DEBUG CAREFUL: Skipping var 5: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.166667
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=1.000000
DEBUG CAREFUL: Skipping var 14: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.166667
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.166667
DEBUG CAREFUL: Adding var 18 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.166667
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 6 fractional variables

  %  Carefully choosing branching variable, nfrac = 6
DEBUG CAREFUL: Testing fvar[0] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 17
DEBUG CAREFUL: New best var: 17
DEBUG CAREFUL: Testing fvar[1] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[2] = var 18
DEBUG CAREFUL: Calling compare_branch_vars for var 18
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 18
DEBUG CAREFUL: New best var: 18
DEBUG CAREFUL: Testing fvar[3] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[4] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 3
DEBUG CAREFUL: New best var: 3
DEBUG CAREFUL: Testing fvar[5] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
  % Initial guess is x3, Z0 = 28441539.7707822        , Z1 = 28576478.6008274        

DEBUG EVAL: Testing var 17 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=17, varin=75, theta=0.500000, up=1.000000
DEBUG EVAL: Branch var 17 = 0 gives z=28446888.075334
  % 	x17 = 0,	Z0 = 28446888.0753336        
DEBUG EVAL: First branch cutoff check: z=28446888.075334, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 17 = 1
ITER 1: row=17, varin=38, theta=2.500000, up=999999999999999983222784.000000
ITER 2: row=15, varin=30, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=33, varin=9, theta=3.000000, up=999999999999999983222784.000000
ITER 4: row=9, varin=35, theta=3.000000, up=999999999999999983222784.000000
ITER 5: row=35, varin=31, theta=0.666667, up=999999999999999983222784.000000
  % 	x17 = 1,	Z1 = 28568486.2151255        
DEBUG EVAL: Second branch cutoff check: z=28568486.215125, best_z=INF, threshold=INF
  %   New best:  x17, Z = 28446888.0753336        
DEBUG EVAL: Testing var 2 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=75, theta=0.500000, up=1.000000
DEBUG EVAL: Branch var 2 = 0 gives z=28446888.075334
  % 	x2 = 0,	Z0 = 28446888.0753336        
DEBUG EVAL: First branch cutoff check: z=28446888.075334, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 1
ITER 1: row=1, varin=38, theta=2.500000, up=999999999999999983222784.000000
ITER 2: row=15, varin=30, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=33, varin=9, theta=3.000000, up=999999999999999983222784.000000
ITER 4: row=9, varin=18, theta=0.750000, up=999999999999999983222784.000000
  % 	x2 = 1,	Z1 = 28469886.2105424        
DEBUG EVAL: Second branch cutoff check: z=28469886.210542, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 18 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=30, varin=38, theta=2.500000, up=999999999999999983222784.000000
ITER 2: row=15, varin=9, theta=3.000000, up=999999999999999983222784.000000
ITER 3: row=9, varin=18, theta=3.000000, up=999999999999999983222784.000000
ITER 4: row=32, varin=35, theta=3.000000, up=999999999999999983222784.000000
ITER 5: row=35, varin=26, theta=2.000000, up=999999999999999983222784.000000
ITER 6: row=2, varin=19, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 18 = 1 gives z=28683921.021458
  % 	x18 = 1,	Z1 = 28683921.0214578        
DEBUG EVAL: First branch cutoff check: z=28683921.021458, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 18 = 0
ITER 1: row=30, varin=30, theta=0.333333, up=999999999999999983222784.000000
ITER 2: row=33, varin=75, theta=0.500000, up=1.000000
  % 	x18 = 0,	Z0 = 28446888.0753336        
DEBUG EVAL: Second branch cutoff check: z=28446888.075334, best_z=INF, threshold=INF
  %   New best:  x18, Z = 28446888.0753336        
DEBUG EVAL: Testing var 10 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=8, varin=30, theta=0.333333, up=999999999999999983222784.000000
ITER 2: row=33, varin=75, theta=0.500000, up=1.000000
DEBUG EVAL: Branch var 10 = 0 gives z=28446888.075334
  % 	x10 = 0,	Z0 = 28446888.0753336        
DEBUG EVAL: First branch cutoff check: z=28446888.075334, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 1
ITER 1: row=8, varin=38, theta=2.500000, up=999999999999999983222784.000000
ITER 2: row=15, varin=9, theta=3.000000, up=999999999999999983222784.000000
ITER 3: row=9, varin=18, theta=3.000000, up=999999999999999983222784.000000
ITER 4: row=32, varin=35, theta=3.000000, up=999999999999999983222784.000000
ITER 5: row=35, varin=31, theta=0.500000, up=999999999999999983222784.000000
  % 	x10 = 1,	Z1 = 28535984.7528532        
DEBUG EVAL: Second branch cutoff check: z=28535984.752853, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 3 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=15, varin=30, theta=1.666667, up=999999999999999983222784.000000
ITER 2: row=33, varin=9, theta=5.000000, up=999999999999999983222784.000000
ITER 3: row=9, varin=35, theta=5.000000, up=999999999999999983222784.000000
ITER 4: row=35, varin=17, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=39, varin=31, theta=1.333333, up=999999999999999983222784.000000
ITER 6: row=30, varin=18, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=40, varin=26, theta=1.000000, up=999999999999999983222784.000000
ITER 8: row=2, varin=19, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 3 = 1 gives z=28731456.704843
  % 	x3 = 1,	Z1 = 28731456.7048434        
DEBUG EVAL: First branch cutoff check: z=28731456.704843, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 3 = 0
ITER 1: row=15, varin=38, theta=0.250000, up=999999999999999983222784.000000
  % 	x3 = 0,	Z0 = 28443056.4178276        
DEBUG EVAL: Second branch cutoff check: z=28443056.417828, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 26 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=35, varin=30, theta=0.333333, up=999999999999999983222784.000000
ITER 2: row=33, varin=75, theta=0.500000, up=1.000000
DEBUG EVAL: Branch var 26 = 0 gives z=28446888.075334
  % 	x26 = 0,	Z0 = 28446888.0753336        
DEBUG EVAL: First branch cutoff check: z=28446888.075334, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 26 = 1
ITER 1: row=35, varin=38, theta=2.500000, up=999999999999999983222784.000000
ITER 2: row=15, varin=9, theta=3.000000, up=999999999999999983222784.000000
ITER 3: row=9, varin=18, theta=3.000000, up=999999999999999983222784.000000
ITER 4: row=32, varin=31, theta=0.750000, up=999999999999999983222784.000000
  % 	x26 = 1,	Z1 = 28538772.3608968        
DEBUG EVAL: Second branch cutoff check: z=28538772.360897, best_z=INF, threshold=INF
  % Best branch is x18, Z0 = 28446888.0753336        , Z1 = 28683921.0214578        

DEBUG CAREFUL: Final result - returning best.var = 18
DEBUG BB: Branching variable chosen: j=18
 % @NC  141  135	x18 = 0	28446888.075334
 % @NC  142  135	x18 = 1	28683921.021458
 %     135    66 28441539.7708               28441579.4076    x6 D    99     7
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cc9ac0
% @LO 0.08  28.44153977078224571073 99.9000000000
% @LN 0.08  28.44157940757697033973 99.9000000000
% Resuming node 131 at  28.44157940757697033973
DEBUG CONSTRNT: LP rows=40, pool->nlprows=40, pool->npend=0
DEBUG CONSTRNT: Checking 40 LP rows (pool tracks 40, total LP rows 40)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=39, expected 39
 % @PAP adding 40 rows, 174 nz to LP
DEBUG BB: Processing node 131, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 131 LP 2 Solution, length = 28441579.407577, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.166667 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.166667 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.500000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.500000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 1.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.166667 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.500000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.833333 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.833333 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.500000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.833333 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.500000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.833333 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.500000 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28441579.407577, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28441579.407577, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 131 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 131
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.166667
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.166667
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.500000
DEBUG CAREFUL: Adding var 9 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.500000
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=1.000000
DEBUG CAREFUL: Skipping var 15: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.166667
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.500000
DEBUG CAREFUL: Adding var 34 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 6 fractional variables

  %  Carefully choosing branching variable, nfrac = 6
DEBUG CAREFUL: Testing fvar[0] = var 9
DEBUG CAREFUL: Calling compare_branch_vars for var 9
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 9
DEBUG CAREFUL: New best var: 9
DEBUG CAREFUL: Testing fvar[1] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[2] = var 34
DEBUG CAREFUL: Calling compare_branch_vars for var 34
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 34
DEBUG CAREFUL: Testing fvar[3] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[4] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 17
DEBUG CAREFUL: New best var: 17
DEBUG CAREFUL: Testing fvar[5] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 3
DEBUG CAREFUL: New best var: 3
  % Initial guess is x3, Z0 = 28441579.407577         , Z1 = 28597839.6428986        

DEBUG EVAL: Testing var 9 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=25, varin=31, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 9 = 0 gives z=28450365.705139
  % 	x9 = 0,	Z0 = 28450365.7051391        
DEBUG EVAL: First branch cutoff check: z=28450365.705139, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 9 = 1
ITER 1: row=25, varin=35, theta=1.000000, up=999999999999999983222784.000000
  % 	x9 = 1,	Z1 = 28445304.4486002        
DEBUG EVAL: Second branch cutoff check: z=28445304.448600, best_z=INF, threshold=INF
  %   New best:  x9, Z = 28445304.4486002        
DEBUG EVAL: Testing var 10 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=11, varin=31, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 0 gives z=28450365.705139
  % 	x10 = 0,	Z0 = 28450365.7051391        
DEBUG EVAL: First branch cutoff check: z=28450365.705139, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 1
ITER 1: row=11, varin=35, theta=1.000000, up=999999999999999983222784.000000
  % 	x10 = 1,	Z1 = 28445304.4486002        
DEBUG EVAL: Second branch cutoff check: z=28445304.448600, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 34 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=31, varin=35, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 34 = 0 gives z=28445304.448600
  % 	x34 = 0,	Z0 = 28445304.4486002        
DEBUG EVAL: First branch cutoff check: z=28445304.448600, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 34 = 1
ITER 1: row=31, varin=25, theta=1.000000, up=999999999999999983222784.000000
  % 	x34 = 1,	Z1 = 28633257.4182301        
DEBUG EVAL: Second branch cutoff check: z=28633257.418230, best_z=INF, threshold=INF
  %   New best:  x34, Z = 28445304.4486002        
DEBUG EVAL: Testing var 2 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=65, theta=0.500000, up=1.000000
ITER 2: row=3, varin=10, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 0 gives z=28466396.555007
  % 	x2 = 0,	Z0 = 28466396.5550074        
DEBUG EVAL: First branch cutoff check: z=28466396.555007, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 1
ITER 1: row=1, varin=39, theta=0.833333, up=999999999999999983222784.000000
ITER 2: row=10, varin=36, theta=1.250000, up=999999999999999983222784.000000
ITER 3: row=14, varin=35, theta=1.000000, up=999999999999999983222784.000000
  % 	x2 = 1,	Z1 = 28459568.9953923        
DEBUG EVAL: Second branch cutoff check: z=28459568.995392, best_z=INF, threshold=INF
  %   New best:  x2, Z = 28459568.9953923        
DEBUG EVAL: Testing var 17 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=16, varin=39, theta=0.833333, up=999999999999999983222784.000000
ITER 2: row=10, varin=36, theta=1.250000, up=999999999999999983222784.000000
ITER 3: row=14, varin=35, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 17 = 1 gives z=28459568.995392
  % 	x17 = 1,	Z1 = 28459568.9953923        
DEBUG EVAL: First branch cutoff check: z=28459568.995392, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 17 = 0
ITER 1: row=16, varin=65, theta=0.500000, up=1.000000
ITER 2: row=3, varin=10, theta=0.500000, up=999999999999999983222784.000000
  % 	x17 = 0,	Z0 = 28466396.5550074        
DEBUG EVAL: Second branch cutoff check: z=28466396.555007, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 3 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=14, varin=39, theta=0.833333, up=999999999999999983222784.000000
ITER 2: row=10, varin=35, theta=5.000000, up=999999999999999983222784.000000
ITER 3: row=11, varin=33, theta=2.000000, up=999999999999999983222784.000000
ITER 4: row=33, varin=31, theta=2.000000, up=999999999999999983222784.000000
ITER 5: row=31, varin=10, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=39, varin=27, theta=2.000000, up=999999999999999983222784.000000
ITER 7: row=5, varin=16, theta=1.000000, up=999999999999999983222784.000000
ITER 8: row=37, varin=17, theta=1.000000, up=999999999999999983222784.000000
ITER 9: row=38, varin=2, theta=0.800000, up=999999999999999983222784.000000
ITER 10: row=27, varin=18, theta=0.666667, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 3 = 1 gives z=28720180.857609
  % 	x3 = 1,	Z1 = 28720180.8576091        
DEBUG EVAL: First branch cutoff check: z=28720180.857609, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 3 = 0
ITER 1: row=14, varin=36, theta=0.500000, up=999999999999999983222784.000000
  % 	x3 = 0,	Z0 = 28448711.680973         
DEBUG EVAL: Second branch cutoff check: z=28448711.680973, best_z=INF, threshold=INF
  % Best branch is x2, Z0 = 28466396.5550074        , Z1 = 28459568.9953923        

DEBUG CAREFUL: Final result - returning best.var = 2
DEBUG BB: Branching variable chosen: j=2
 % @NC  143  131	x2 = 1	28459568.995392
 % @NC  144  131	x2 = 0	28466396.555007
 %     131    67 28441579.4076               28446888.0753   x26 D   123    11
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cc2570
% @LO 0.08  28.44157940757697033973 99.9000000000
% @LN 0.08  28.44688807533355046075 99.9000000000
% Resuming node 141 at  28.44688807533355046075
DEBUG CONSTRNT: LP rows=40, pool->nlprows=40, pool->npend=0
DEBUG CONSTRNT: Checking 40 LP rows (pool tracks 40, total LP rows 40)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=39, expected 39
 % @PAP adding 40 rows, 162 nz to LP
DEBUG BB: Processing node 141, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=30, varin=30, theta=0.333333, up=999999999999999983222784.000000
ITER 2: row=33, varin=75, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=40)
DEBUG SOLUTION: LP solution array indices: FST[41-80], not_covered[81-100]
DEBUG SOLUTION: lp->best_solution[0] = 28446888.075334
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
  % @PL 40 rows, 60 cols, 222 nonzeros, 0 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 141 LP 1 Solution, length = 28446888.075334, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.500000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.500000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.500000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.500000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.500000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.500000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 3 fractional variables
DEBUG CG: LP optimal, z=28446888.075334, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28446888.075334, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 141 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 141
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=1.000000
DEBUG CAREFUL: Skipping var 5: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.500000
DEBUG CAREFUL: Adding var 12 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.500000
DEBUG CAREFUL: Adding var 14 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.500000
DEBUG CAREFUL: Adding var 34 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 3 fractional variables

  %  Carefully choosing branching variable, nfrac = 3
DEBUG CAREFUL: Testing fvar[0] = var 34
DEBUG CAREFUL: Calling compare_branch_vars for var 34
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 34
DEBUG CAREFUL: New best var: 34
DEBUG CAREFUL: Testing fvar[1] = var 12
DEBUG CAREFUL: Calling compare_branch_vars for var 12
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 12
DEBUG CAREFUL: Testing fvar[2] = var 14
DEBUG CAREFUL: Calling compare_branch_vars for var 14
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 14
  % Initial guess is x34, Z0 = 28446888.0753336        , Z1 = 28588520.2150832        

DEBUG EVAL: Testing var 34 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=22, varin=33, theta=0.333333, up=999999999999999983222784.000000
ITER 2: row=16, varin=38, theta=0.500000, up=999999999999999983222784.000000
ITER 3: row=38, varin=9, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=9, varin=18, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=16, varin=35, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=35, varin=26, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=2, varin=17, theta=0.500000, up=999999999999999983222784.000000
ITER 8: row=19, varin=2, theta=0.500000, up=999999999999999983222784.000000
ITER 9: row=26, varin=19, theta=0.333333, up=999999999999999983222784.000000
ITER 10: row=33, varin=31, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 34 = 1 gives z=28607458.696578
  % 	x34 = 1,	Z1 = 28607458.6965778        
DEBUG EVAL: First branch cutoff check: z=28607458.696578, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 34 = 0
ITER 1: row=22, varin=14, theta=1.000000, up=999999999999999983222784.000000
  % 	x34 = 0,	Z0 = 28460648.7391649        
DEBUG EVAL: Second branch cutoff check: z=28460648.739165, best_z=INF, threshold=INF
  %   New best:  x34, Z = 28460648.7391649        
DEBUG EVAL: Testing var 12 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=33, theta=0.333333, up=999999999999999983222784.000000
ITER 2: row=16, varin=38, theta=0.500000, up=999999999999999983222784.000000
ITER 3: row=38, varin=9, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=9, varin=14, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 12 = 1 gives z=28460648.739165
  % 	x12 = 1,	Z1 = 28460648.7391649        
DEBUG EVAL: First branch cutoff check: z=28460648.739165, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 12 = 0
ITER 1: row=1, varin=65, theta=1.000000, up=1.000000
  % 	x12 = 0,	Z0 = 28485615.6912276        
DEBUG EVAL: Second branch cutoff check: z=28485615.691228, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 14 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=7, varin=65, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 14 = 1 gives z=28485615.691228
  % 	x14 = 1,	Z1 = 28485615.6912276        
DEBUG EVAL: First branch cutoff check: z=28485615.691228, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 14 = 0
ITER 1: row=7, varin=33, theta=0.333333, up=999999999999999983222784.000000
ITER 2: row=16, varin=38, theta=0.500000, up=999999999999999983222784.000000
ITER 3: row=38, varin=9, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=9, varin=14, theta=1.000000, up=999999999999999983222784.000000
  % 	x14 = 0,	Z0 = 28460648.7391649        
DEBUG EVAL: Second branch cutoff check: z=28460648.739165, best_z=INF, threshold=INF
  % Best branch is x34, Z0 = 28460648.7391649        , Z1 = 28607458.6965778        

DEBUG CAREFUL: Final result - returning best.var = 34
DEBUG BB: Branching variable chosen: j=34
 % @NC  145  141	x34 = 0	28460648.739165
 % @NC  146  141	x34 = 1	28607458.696578
 %     141    68 28446888.0753               28447337.5464   x18 D   135     8
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cdfb00
% @LO 0.08  28.44688807533355046075 99.9000000000
% @LN 0.08  28.44733754638100720058 99.9000000000
% Resuming node 129 at  28.44733754638100720058
DEBUG CONSTRNT: LP rows=40, pool->nlprows=40, pool->npend=0
DEBUG CONSTRNT: Checking 40 LP rows (pool tracks 40, total LP rows 40)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=39, expected 39
 % @PAP adding 46 rows, 189 nz to LP
DEBUG BB: Processing node 129, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=2, varin=72, theta=0.500000, up=1.000000
ITER 2: row=46, varin=104, theta=0.100000, up=1.000000
ITER 3: row=9, varin=80, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=46)
DEBUG SOLUTION: LP solution array indices: FST[47-86], not_covered[87-106]
DEBUG SOLUTION: lp->best_solution[0] = 28447337.546381
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 46 rows, 60 cols, 249 nonzeros, 0 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 14 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=47, varin=81, theta=0.500000, up=1.000000
ITER 2: row=50, varin=73, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28478939.395834
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 50 rows, 60 cols, 263 nonzeros, 0 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 19 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=51, varin=7, theta=0.100000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=54)
DEBUG SOLUTION: LP solution array indices: FST[55-94], not_covered[95-114]
DEBUG SOLUTION: lp->best_solution[0] = 28483225.810938
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 0.900000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 54 rows, 60 cols, 282 nonzeros, 2 slack, 52 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=53, varin=110, theta=0.500000, up=1.000000
ITER 2: row=46, varin=4, theta=0.125000, up=999999999999999983222784.000000
ITER 3: row=38, varin=45, theta=0.500000, up=999999999999999983222784.000000
ITER 4: row=45, varin=82, theta=0.500000, up=1.000000
ITER 5: row=9, varin=3, theta=0.250000, up=999999999999999983222784.000000
ITER 6: row=27, varin=37, theta=0.083333, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=53)
DEBUG SOLUTION: LP solution array indices: FST[54-93], not_covered[94-113]
DEBUG SOLUTION: lp->best_solution[0] = 28514413.037403
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.916667
DEBUG SOLUTION: lp->best_solution[4] = 0.916667
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 0.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.958333
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 53 rows, 60 cols, 280 nonzeros, 7 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 7 slack rows
  % @PAP adding 5 rows, 13 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=49, varin=85, theta=0.500000, up=1.000000
ITER 2: row=12, varin=30, theta=0.071429, up=999999999999999983222784.000000
ITER 3: row=29, varin=83, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 28537818.317185
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 0.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 51 rows, 60 cols, 279 nonzeros, 0 slack, 51 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 129 LP 1 Solution, length = 28537818.317185, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.500000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 1.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.500000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.500000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.500000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.500000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 3 fractional variables
DEBUG CG: LP optimal, z=28537818.317185, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 129 at  28.53781831718521999619
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cdc300
% @LO 0.08  28.44733754638100720058 99.9000000000
% @LN 0.08  28.44749491978758726418 99.9000000000
% Resuming node 88 at  28.44749491978758726418
DEBUG CONSTRNT: LP rows=51, pool->nlprows=51, pool->npend=0
DEBUG CONSTRNT: Checking 51 LP rows (pool tracks 51, total LP rows 51)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 65
DEBUG CONSTRNT: Pool row 65 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 133
DEBUG CONSTRNT: Pool row 133 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 121
DEBUG CONSTRNT: Pool row 121 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=50, expected 50
 % @PAP adding 45 rows, 183 nz to LP
DEBUG BB: Processing node 88, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=19, varin=43, theta=2.500000, up=999999999999999983222784.000000
ITER 2: row=15, varin=34, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=37, varin=42, theta=3.000000, up=999999999999999983222784.000000
ITER 4: row=42, varin=39, theta=3.000000, up=999999999999999983222784.000000
ITER 5: row=39, varin=35, theta=0.666667, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 28447494.919788
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 45 rows, 60 cols, 243 nonzeros, 10 slack, 35 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 5 rows, 59 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=50, varin=77, theta=2.277085, up=1.000000
ITER 2: row=50, varin=14, theta=0.773216, up=999999999999999983222784.000000
ITER 3: row=39, varin=77, theta=1.959762, up=1.000000
ITER 4: row=39, varin=30, theta=1.645481, up=999999999999999983222784.000000
ITER 5: row=5, varin=54, theta=0.586061, up=1.000000
ITER 6: row=46, varin=75, theta=0.695458, up=1.000000
ITER 7: row=3, varin=5, theta=0.609433, up=999999999999999983222784.000000
ITER 8: row=31, varin=87, theta=1.307726, up=1.000000
ITER 9: row=31, varin=74, theta=0.185505, up=1.000000
ITER 10: row=42, varin=87, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=11)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28595346.909274
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.262464
  % @PL 50 rows, 60 cols, 302 nonzeros, 10 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 10 slack rows
  % @PAP adding 2 rows, 5 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=41, varin=6, theta=0.220811, up=999999999999999983222784.000000
ITER 2: row=31, varin=72, theta=0.821238, up=1.000000
ITER 3: row=32, varin=70, theta=0.800605, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 28662772.109304
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 42 rows, 60 cols, 285 nonzeros, 0 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=43, varin=47, theta=3.073420, up=1.000000
ITER 2: row=43, varin=65, theta=0.479070, up=1.000000
ITER 3: row=37, varin=47, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 28687550.488693
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 43 rows, 60 cols, 287 nonzeros, 0 slack, 43 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 16 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=44, varin=49, theta=0.285094, up=1.000000
ITER 2: row=42, varin=66, theta=-3.073420, up=1.000000
ITER 3: row=42, varin=31, theta=0.278312, up=999999999999999983222784.000000
ITER 4: row=6, varin=66, theta=-3.073420, up=1.000000
ITER 5: row=1, varin=73, theta=0.611369, up=1.000000
ITER 6: row=47, varin=7, theta=0.171746, up=999999999999999983222784.000000
ITER 7: row=6, varin=58, theta=0.884747, up=1.000000
ITER 8: row=32, varin=70, theta=0.068985, up=1.000000
LP PHASE: Switching to primal (iter=8)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 28733735.628650
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 0.800000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 47 rows, 60 cols, 303 nonzeros, 2 slack, 45 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 4 rows, 11 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=47, varin=79, theta=1.000000, up=1.000000
ITER 2: row=49, varin=65, theta=0.152602, up=1.000000
ITER 3: row=27, varin=68, theta=0.940615, up=1.000000
ITER 4: row=35, varin=25, theta=0.158869, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 28810971.244075
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 49 rows, 60 cols, 310 nonzeros, 2 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=48, varin=53, theta=1.062686, up=1.000000
ITER 2: row=48, varin=77, theta=0.068284, up=1.000000
ITER 3: row=6, varin=53, theta=0.888577, up=1.000000
ITER 4: row=42, varin=81, theta=1.786552, up=1.000000
ITER 5: row=42, varin=14, theta=0.421128, up=999999999999999983222784.000000
ITER 6: row=44, varin=81, theta=1.000000, up=1.000000
ITER 7: row=35, varin=25, theta=0.250000, up=999999999999999983222784.000000
ITER 8: row=13, varin=45, theta=0.076907, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=8)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 28995466.427877
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 0.826907
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 48 rows, 60 cols, 308 nonzeros, 5 slack, 43 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % @PAP adding 3 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=46, varin=78, theta=1.031969, up=1.000000
ITER 2: row=46, varin=100, theta=0.020431, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=46)
DEBUG SOLUTION: LP solution array indices: FST[47-86], not_covered[87-106]
DEBUG SOLUTION: lp->best_solution[0] = 29016216.387095
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.979569
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 46 rows, 60 cols, 303 nonzeros, 1 slack, 45 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=46, varin=78, theta=0.597637, up=1.000000
ITER 2: row=43, varin=103, theta=0.205601, up=1.000000
ITER 3: row=44, varin=43, theta=0.082771, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
ITER 4: row=43, varin=57, theta=0.351594, up=1.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=46)
DEBUG SOLUTION: LP solution array indices: FST[47-86], not_covered[87-106]
DEBUG SOLUTION: lp->best_solution[0] = 29036975.235455
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
  % @PL 46 rows, 60 cols, 303 nonzeros, 0 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=47, varin=43, theta=0.084696, up=999999999999999983222784.000000
ITER 2: row=10, varin=81, theta=0.008812, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 29039258.180160
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.767624
DEBUG SOLUTION: lp->best_solution[5] = 2.767624
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
  % @PL 47 rows, 60 cols, 305 nonzeros, 3 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 2 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=45, varin=57, theta=0.111891, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=46)
DEBUG SOLUTION: LP solution array indices: FST[47-86], not_covered[87-106]
DEBUG SOLUTION: lp->best_solution[0] = 29040882.982390
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 46 rows, 60 cols, 301 nonzeros, 0 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 10 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=49, varin=81, theta=0.081343, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 29051143.634629
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 50 rows, 60 cols, 311 nonzeros, 0 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 88 LP 1 Solution, length = 29051143.634629, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.081343 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.081343 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.500000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.093286 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 1.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 1.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.081343 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.081343 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.093286 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.500000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.081343 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.081343 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.500000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.081343 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.081343 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.918657 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.918657 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.918657 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.918657 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.906714 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.500000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.906714 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 0.918657 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 13 fractional variables
DEBUG CG: LP optimal, z=29051143.634629, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 88 at  29.05114363462862669962
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cb66c0
% @LO 0.08  28.44749491978758726418 99.9000000000
% @LN 0.08  28.44788939131094451795 99.9000000000
% Resuming node 127 at  28.44788939131094451795
DEBUG CONSTRNT: LP rows=50, pool->nlprows=50, pool->npend=0
DEBUG CONSTRNT: Checking 50 LP rows (pool tracks 50, total LP rows 50)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 49
DEBUG CONSTRNT: Pool row 49 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 68
DEBUG CONSTRNT: Pool row 68 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 82
DEBUG CONSTRNT: Pool row 82 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 145
DEBUG CONSTRNT: Pool row 145 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 159
DEBUG CONSTRNT: Pool row 159 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 133
DEBUG CONSTRNT: Pool row 133 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 121
DEBUG CONSTRNT: Pool row 121 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 58
DEBUG CONSTRNT: Pool row 58 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 134
DEBUG CONSTRNT: Pool row 134 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=49, expected 49
 % @PAP adding 40 rows, 157 nz to LP
DEBUG BB: Processing node 127, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 127 LP 2 Solution, length = 28447889.391311, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.166667 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.166667 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.166667 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.500000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.500000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.166667 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.166667 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.833333 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.833333 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.500000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.500000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.833333 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.833333 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.833333 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.833333 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.500000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.833333 (terminal 19)
 % 7 fractional variables
DEBUG CG: LP optimal, z=28447889.391311, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28447889.391311, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 127 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 127
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.166667
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.166667
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=1.000000
DEBUG CAREFUL: Skipping var 7: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.166667
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.500000
DEBUG CAREFUL: Adding var 12 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.500000
DEBUG CAREFUL: Adding var 14 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.166667
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.166667
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 7 fractional variables

  %  Carefully choosing branching variable, nfrac = 7
DEBUG CAREFUL: Testing fvar[0] = var 12
DEBUG CAREFUL: Calling compare_branch_vars for var 12
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 12
DEBUG CAREFUL: New best var: 12
DEBUG CAREFUL: Testing fvar[1] = var 14
DEBUG CAREFUL: Calling compare_branch_vars for var 14
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 14
DEBUG CAREFUL: Testing fvar[2] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 17
DEBUG CAREFUL: New best var: 17
DEBUG CAREFUL: Testing fvar[3] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[4] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[5] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 3
DEBUG CAREFUL: New best var: 3
DEBUG CAREFUL: Testing fvar[6] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
  % Initial guess is x3, Z0 = 28447889.3913109        , Z1 = 28704932.1419572        

DEBUG EVAL: Testing var 12 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=7, varin=36, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 12 = 0 gives z=28461654.606343
  % 	x12 = 0,	Z0 = 28461654.6063432        
DEBUG EVAL: First branch cutoff check: z=28461654.606343, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 12 = 1
ITER 1: row=7, varin=23, theta=1.000000, up=999999999999999983222784.000000
  % 	x12 = 1,	Z1 = 28672067.6470968        
DEBUG EVAL: Second branch cutoff check: z=28672067.647097, best_z=INF, threshold=INF
  %   New best:  x12, Z = 28461654.6063432        
DEBUG EVAL: Testing var 14 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=21, varin=7, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 14 = 0 gives z=28659391.927702
  % 	x14 = 0,	Z0 = 28659391.9277023        
DEBUG EVAL: First branch cutoff check: z=28659391.927702, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 14 = 1
ITER 1: row=21, varin=36, theta=1.000000, up=999999999999999983222784.000000
  % 	x14 = 1,	Z1 = 28461654.6063432        
DEBUG EVAL: Second branch cutoff check: z=28461654.606343, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 17 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=16, varin=37, theta=2.500000, up=999999999999999983222784.000000
ITER 2: row=37, varin=36, theta=5.000000, up=999999999999999983222784.000000
ITER 3: row=7, varin=33, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 17 = 1 gives z=28560999.991419
  % 	x17 = 1,	Z1 = 28560999.991419         
DEBUG EVAL: First branch cutoff check: z=28560999.991419, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 17 = 0
ITER 1: row=16, varin=64, theta=0.500000, up=1.000000
ITER 2: row=40, varin=52, theta=0.250000, up=1.000000
  % 	x17 = 0,	Z0 = 28484257.1011243        
DEBUG EVAL: Second branch cutoff check: z=28484257.101124, best_z=INF, threshold=INF
  %   New best:  x17, Z = 28484257.1011243        
DEBUG EVAL: Testing var 2 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=64, theta=0.500000, up=1.000000
ITER 2: row=40, varin=52, theta=0.250000, up=1.000000
DEBUG EVAL: Branch var 2 = 0 gives z=28484257.101124
  % 	x2 = 0,	Z0 = 28484257.1011243        
DEBUG EVAL: First branch cutoff check: z=28484257.101124, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 1
ITER 1: row=1, varin=37, theta=2.500000, up=999999999999999983222784.000000
ITER 2: row=37, varin=17, theta=0.833333, up=999999999999999983222784.000000
  % 	x2 = 1,	Z1 = 28477700.2721051        
DEBUG EVAL: Second branch cutoff check: z=28477700.272105, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 10 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=10, varin=37, theta=2.500000, up=999999999999999983222784.000000
ITER 2: row=37, varin=36, theta=5.000000, up=999999999999999983222784.000000
ITER 3: row=7, varin=29, theta=0.666667, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 1 gives z=28546735.444627
  % 	x10 = 1,	Z1 = 28546735.4446269        
DEBUG EVAL: First branch cutoff check: z=28546735.444627, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 0
ITER 1: row=10, varin=13, theta=0.250000, up=999999999999999983222784.000000
  % 	x10 = 0,	Z0 = 28475469.9446591        
DEBUG EVAL: Second branch cutoff check: z=28475469.944659, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 3 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=14, varin=37, theta=2.500000, up=999999999999999983222784.000000
ITER 2: row=37, varin=36, theta=5.000000, up=999999999999999983222784.000000
ITER 3: row=7, varin=16, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=34, varin=30, theta=2.000000, up=999999999999999983222784.000000
ITER 5: row=30, varin=17, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=35, varin=25, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=38, varin=2, theta=0.400000, up=999999999999999983222784.000000
ITER 8: row=25, varin=18, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 3 = 1 gives z=28704932.141957
  % 	x3 = 1,	Z1 = 28704932.1419572        
DEBUG EVAL: First branch cutoff check: z=28704932.141957, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 3 = 0
ITER 1: row=14, varin=64, theta=0.500000, up=1.000000
ITER 2: row=40, varin=52, theta=0.250000, up=1.000000
  % 	x3 = 0,	Z0 = 28484257.1011243        
DEBUG EVAL: Second branch cutoff check: z=28484257.101124, best_z=INF, threshold=INF
  %   New best:  x3, Z = 28484257.1011243        
DEBUG EVAL: Testing var 26 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=30, varin=30, theta=0.250000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 26 = 0 gives z=28466449.505740
  % 	x26 = 0,	Z0 = 28466449.5057396        
DEBUG EVAL: First branch cutoff check: z=28466449.505740, best_z=INF, threshold=INF
  % Best branch is x3, Z0 = 28484257.1011243        , Z1 = 28704932.1419572        

DEBUG CAREFUL: Final result - returning best.var = 3
DEBUG BB: Branching variable chosen: j=3
 % @NC  147  127	x3 = 0	28484257.101124
 % @NC  148  127	x3 = 1	28704932.141957
 %     127    69 28447889.3913               28450213.0468   x18 D   117     6
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cebdd0
% @LO 0.09  28.44788939131094451795 99.9000000000
% @LN 0.09  28.45021304682720852952 99.9000000000
% Resuming node 130 at  28.45021304682720852952
DEBUG CONSTRNT: LP rows=40, pool->nlprows=40, pool->npend=0
DEBUG CONSTRNT: Checking 40 LP rows (pool tracks 40, total LP rows 40)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=39, expected 39
 % @PAP adding 46 rows, 189 nz to LP
DEBUG BB: Processing node 130, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=2, varin=43, theta=1.500000, up=999999999999999983222784.000000
ITER 2: row=43, varin=42, theta=1.500000, up=999999999999999983222784.000000
ITER 3: row=38, varin=104, theta=0.500000, up=1.000000
ITER 4: row=9, varin=41, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=46)
DEBUG SOLUTION: LP solution array indices: FST[47-86], not_covered[87-106]
DEBUG SOLUTION: lp->best_solution[0] = 28450213.046827
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 46 rows, 60 cols, 249 nonzeros, 2 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 5 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=47, varin=27, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=41, varin=64, theta=0.500000, up=1.000000
ITER 3: row=46, varin=81, theta=0.500000, up=1.000000
ITER 4: row=48, varin=38, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=42, varin=70, theta=0.600000, up=1.000000
ITER 6: row=43, varin=74, theta=0.500000, up=1.000000
ITER 7: row=10, varin=82, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=7)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 28863296.915942
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 48 rows, 60 cols, 254 nonzeros, 5 slack, 43 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % @PAP adding 4 rows, 12 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=44, varin=70, theta=0.500000, up=1.000000
ITER 2: row=46, varin=37, theta=0.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 28952195.028941
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 47 rows, 60 cols, 255 nonzeros, 1 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 4 rows, 19 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=47, varin=7, theta=0.200000, up=999999999999999983222784.000000
ITER 2: row=40, varin=107, theta=0.166667, up=1.000000
ITER 3: row=44, varin=82, theta=0.166667, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28978965.361231
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 0.833333
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 50 rows, 60 cols, 272 nonzeros, 2 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=49, varin=75, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 29069952.871644
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 0.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 49 rows, 60 cols, 270 nonzeros, 0 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=50, varin=26, theta=0.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 29079980.343211
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 0.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 51 rows, 60 cols, 274 nonzeros, 5 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % Node 130 LP 1 Solution, length = 29079980.343211, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 1.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.500000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.500000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 1.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.500000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.500000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.500000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.500000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.500000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.500000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.500000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.500000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.500000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.500000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.500000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.500000 (terminal 19)
 % 7 fractional variables
DEBUG CG: LP optimal, z=29079980.343211, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 130 at  29.07998034321082769793
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cac0a0
% @LO 0.09  28.45021304682720852952 99.9000000000
% @LN 0.09  28.45259901291278481494 99.9000000000
% Resuming node 111 at  28.45259901291278481494
DEBUG CONSTRNT: LP rows=46, pool->nlprows=46, pool->npend=0
DEBUG CONSTRNT: Checking 46 LP rows (pool tracks 46, total LP rows 46)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 65
DEBUG CONSTRNT: Pool row 65 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 133
DEBUG CONSTRNT: Pool row 133 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 121
DEBUG CONSTRNT: Pool row 121 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 142
DEBUG CONSTRNT: Pool row 142 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 143
DEBUG CONSTRNT: Pool row 143 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 134
DEBUG CONSTRNT: Pool row 134 has lprow=45, expected 45
 % @PAP adding 43 rows, 182 nz to LP
DEBUG BB: Processing node 111, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=14, varin=67, theta=1.000000, up=1.000000
ITER 2: row=43, varin=55, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 28452599.012913
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 43 rows, 60 cols, 242 nonzeros, 0 slack, 43 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 6 rows, 34 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=44, varin=37, theta=0.333333, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 28461469.001396
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 49 rows, 60 cols, 276 nonzeros, 6 slack, 43 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 6 slack rows
  % Node 111 LP 1 Solution, length = 28461469.001396, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.333333 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.333333 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.333333 (FST 11)
  % DEBUG LP_VARS: x[12] = 1.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 1.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.333333 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.333333 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.666667 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.666667 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.666667 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.666667 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.666667 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.666667 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.666667 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28461469.001396, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 111 at  28.46146900139580537825
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7ccf030
% @LO 0.09  28.45259901291278481494 99.9000000000
% @LN 0.09  28.45582750234445157389 99.9000000000
% Resuming node 46 at  28.45582750234445157389
DEBUG CONSTRNT: LP rows=43, pool->nlprows=43, pool->npend=0
DEBUG CONSTRNT: Checking 43 LP rows (pool tracks 43, total LP rows 43)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 49
DEBUG CONSTRNT: Pool row 49 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 82
DEBUG CONSTRNT: Pool row 82 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=42, expected 42
 % @PAP adding 42 rows, 177 nz to LP
DEBUG BB: Processing node 46, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 46 LP 2 Solution, length = 28455827.502344, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.250000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.250000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.500000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.500000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.250000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.250000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 1.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.750000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.750000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.750000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.500000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.750000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.500000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28455827.502344, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28455827.502344, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 46 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 46
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.250000
DEBUG CAREFUL: Adding var 0 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.250000
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.500000
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.500000
DEBUG CAREFUL: Adding var 27 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.250000
DEBUG CAREFUL: Adding var 29 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.250000
DEBUG CAREFUL: Adding var 32 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=1.000000
DEBUG CAREFUL: Skipping var 34: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 6 fractional variables

  %  Carefully choosing branching variable, nfrac = 6
DEBUG CAREFUL: Testing fvar[0] = var 27
DEBUG CAREFUL: Calling compare_branch_vars for var 27
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 27
DEBUG CAREFUL: New best var: 27
DEBUG CAREFUL: Testing fvar[1] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[2] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 1
DEBUG CAREFUL: Testing fvar[3] = var 0
DEBUG CAREFUL: Calling compare_branch_vars for var 0
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 0
DEBUG CAREFUL: Testing fvar[4] = var 29
DEBUG CAREFUL: Calling compare_branch_vars for var 29
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 29
DEBUG CAREFUL: Testing fvar[5] = var 32
DEBUG CAREFUL: Calling compare_branch_vars for var 32
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 32
DEBUG CAREFUL: New best var: 32
  % Initial guess is x32, Z0 = 28455827.5023445        , Z1 = 28467161.2763403        

DEBUG EVAL: Testing var 27 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=30, varin=37, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 27 = 0 gives z=28474055.732558
  % 	x27 = 0,	Z0 = 28474055.7325576        
DEBUG EVAL: First branch cutoff check: z=28474055.732558, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 27 = 1
ITER 1: row=30, varin=16, theta=1.000000, up=999999999999999983222784.000000
  % 	x27 = 1,	Z1 = 28846790.3288868        
DEBUG EVAL: Second branch cutoff check: z=28846790.328887, best_z=INF, threshold=INF
  %   New best:  x27, Z = 28474055.7325576        
DEBUG EVAL: Testing var 2 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=3, varin=37, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 0 gives z=28474055.732558
  % 	x2 = 0,	Z0 = 28474055.7325576        
DEBUG EVAL: First branch cutoff check: z=28474055.732558, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 1
ITER 1: row=3, varin=36, theta=1.000000, up=999999999999999983222784.000000
  % 	x2 = 1,	Z1 = 28509828.7895106        
DEBUG EVAL: Second branch cutoff check: z=28509828.789511, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 1 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=2, varin=18, theta=1.166667, up=999999999999999983222784.000000
ITER 2: row=15, varin=68, theta=0.500000, up=1.000000
DEBUG EVAL: Branch var 1 = 0 gives z=28467193.368320
  % 	x1 = 0,	Z0 = 28467193.3683196        
DEBUG EVAL: First branch cutoff check: z=28467193.368320, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 0 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=18, theta=1.166667, up=999999999999999983222784.000000
ITER 2: row=15, varin=68, theta=0.500000, up=1.000000
DEBUG EVAL: Branch var 0 = 0 gives z=28467193.368320
  % 	x0 = 0,	Z0 = 28467193.3683196        
DEBUG EVAL: First branch cutoff check: z=28467193.368320, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 29 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=31, varin=18, theta=1.166667, up=999999999999999983222784.000000
ITER 2: row=15, varin=68, theta=0.500000, up=1.000000
DEBUG EVAL: Branch var 29 = 0 gives z=28467193.368320
  % 	x29 = 0,	Z0 = 28467193.3683196        
DEBUG EVAL: First branch cutoff check: z=28467193.368320, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 32 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=36, varin=42, theta=1.500000, up=999999999999999983222784.000000
ITER 2: row=42, varin=38, theta=0.308824, up=999999999999999983222784.000000
ITER 3: row=16, varin=37, theta=3.000000, up=999999999999999983222784.000000
ITER 4: row=3, varin=36, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=30, varin=35, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=35, varin=30, theta=0.529412, up=999999999999999983222784.000000
ITER 7: row=27, varin=31, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 32 = 1 gives z=28579042.088813
  % 	x32 = 1,	Z1 = 28579042.0888133        
DEBUG EVAL: First branch cutoff check: z=28579042.088813, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 32 = 0
ITER 1: row=36, varin=41, theta=0.500000, up=999999999999999983222784.000000
  % 	x32 = 0,	Z0 = 28459274.7304531        
DEBUG EVAL: Second branch cutoff check: z=28459274.730453, best_z=INF, threshold=INF
  % Best branch is x27, Z0 = 28474055.7325576        , Z1 = 28846790.3288868        

DEBUG CAREFUL: Final result - returning best.var = 27
DEBUG BB: Branching variable chosen: j=27
 % @NC  149   46	x27 = 0	28474055.732558
 % @NC  150   46	x27 = 1	28846790.328887
 %      46    70 28455827.5023               28455994.3100   x34 U    30    10
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cd3de0
% @LO 0.09  28.45582750234445157389 99.9000000000
% @LN 0.09  28.45599431000439238915 99.9000000000
% Resuming node 115 at  28.45599431000439238915
DEBUG CONSTRNT: LP rows=42, pool->nlprows=42, pool->npend=0
DEBUG CONSTRNT: Checking 42 LP rows (pool tracks 42, total LP rows 42)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 133
DEBUG CONSTRNT: Pool row 133 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=41, expected 41
 % @PAP adding 42 rows, 174 nz to LP
DEBUG BB: Processing node 115, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=25, varin=36, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 28455994.310004
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 42 rows, 60 cols, 234 nonzeros, 1 slack, 41 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=43, varin=42, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28462888.766222
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 44 rows, 60 cols, 240 nonzeros, 2 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 2 rows, 5 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=43, varin=26, theta=0.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28473880.838481
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 44 rows, 60 cols, 241 nonzeros, 2 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % Node 115 LP 1 Solution, length = 28473880.838481, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.500000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.500000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.500000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 1.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 1.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.500000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.500000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.500000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.500000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.500000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.500000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.500000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.500000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28473880.838481, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 115 at  28.47388083848087703132
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cdaf50
% @LO 0.09  28.45599431000439238915 99.9000000000
% @LN 0.09  28.45938214129668253349 99.9000000000
% Resuming node 74 at  28.45938214129668253349
DEBUG CONSTRNT: LP rows=42, pool->nlprows=42, pool->npend=0
DEBUG CONSTRNT: Checking 42 LP rows (pool tracks 42, total LP rows 42)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 142
DEBUG CONSTRNT: Pool row 142 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 143
DEBUG CONSTRNT: Pool row 143 has lprow=41, expected 41
 % @PAP adding 30 rows, 132 nz to LP
DEBUG BB: Processing node 74, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 74 LP 2 Solution, length = 28459382.141297, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.250000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.750000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.750000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 1.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.250000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.250000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.750000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.750000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.250000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.250000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.750000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.250000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.750000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.250000 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28459382.141297, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28459382.141297, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 74 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 74
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.250000
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.750000
DEBUG CAREFUL: Adding var 9 to fractional list (xi=0.750000)
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.750000
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.750000)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=1.000000
DEBUG CAREFUL: Skipping var 14: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.250000
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.250000
DEBUG CAREFUL: Adding var 18 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 2
DEBUG CAREFUL: New best var: 2
DEBUG CAREFUL: Testing fvar[1] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[2] = var 18
DEBUG CAREFUL: Calling compare_branch_vars for var 18
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 18
DEBUG CAREFUL: New best var: 18
DEBUG CAREFUL: Testing fvar[3] = var 9
DEBUG CAREFUL: Calling compare_branch_vars for var 9
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 9
DEBUG CAREFUL: Testing fvar[4] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
  % Initial guess is x18, Z0 = 28459382.1412967        , Z1 = 28660496.7516634        

DEBUG EVAL: Testing var 2 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=57, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 2 = 0 gives z=28460904.435206
  % 	x2 = 0,	Z0 = 28460904.4352055        
DEBUG EVAL: First branch cutoff check: z=28460904.435206, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 1
ITER 1: row=1, varin=28, theta=0.750000, up=999999999999999983222784.000000
  % 	x2 = 1,	Z1 = 28486211.9340114        
DEBUG EVAL: Second branch cutoff check: z=28486211.934011, best_z=INF, threshold=INF
  %   New best:  x2, Z = 28460904.4352055        
DEBUG EVAL: Testing var 17 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=13, varin=57, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 17 = 0 gives z=28460904.435206
  % 	x17 = 0,	Z0 = 28460904.4352055        
DEBUG EVAL: First branch cutoff check: z=28460904.435206, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 17 = 1
ITER 1: row=13, varin=29, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=14, varin=28, theta=1.000000, up=999999999999999983222784.000000
  % 	x17 = 1,	Z1 = 28506869.0205703        
DEBUG EVAL: Second branch cutoff check: z=28506869.020570, best_z=INF, threshold=INF
  %   New best:  x17, Z = 28460904.4352055        
DEBUG EVAL: Testing var 18 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=19, varin=24, theta=3.000000, up=999999999999999983222784.000000
ITER 2: row=2, varin=15, theta=1.500000, up=999999999999999983222784.000000
ITER 3: row=13, varin=2, theta=0.500000, up=999999999999999983222784.000000
ITER 4: row=24, varin=12, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 18 = 1 gives z=28736256.700412
  % 	x18 = 1,	Z1 = 28736256.7004125        
DEBUG EVAL: First branch cutoff check: z=28736256.700412, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 18 = 0
ITER 1: row=19, varin=57, theta=1.000000, up=1.000000
  % 	x18 = 0,	Z0 = 28460904.4352055        
DEBUG EVAL: Second branch cutoff check: z=28460904.435206, best_z=INF, threshold=INF
  %   New best:  x18, Z = 28460904.4352055        
DEBUG EVAL: Testing var 9 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=11, varin=57, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 9 = 1 gives z=28460904.435206
  % 	x9 = 1,	Z1 = 28460904.4352055        
DEBUG EVAL: First branch cutoff check: z=28460904.435206, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 9 = 0
ITER 1: row=11, varin=30, theta=0.750000, up=999999999999999983222784.000000
  % 	x9 = 0,	Z0 = 28463178.0837009        
DEBUG EVAL: Second branch cutoff check: z=28463178.083701, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 10 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=8, varin=57, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 10 = 1 gives z=28460904.435206
  % 	x10 = 1,	Z1 = 28460904.4352055        
DEBUG EVAL: First branch cutoff check: z=28460904.435206, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 0
ITER 1: row=8, varin=30, theta=0.750000, up=999999999999999983222784.000000
  % 	x10 = 0,	Z0 = 28463178.0837009        
DEBUG EVAL: Second branch cutoff check: z=28463178.083701, best_z=INF, threshold=INF
  % Best branch is x18, Z0 = 28460904.4352055        , Z1 = 28736256.7004125        

DEBUG CAREFUL: Final result - returning best.var = 18
DEBUG BB: Branching variable chosen: j=18
 % @NC  151   74	x18 = 0	28460904.435206
 % @NC  152   74	x18 = 1	28736256.700412
 %      74    71 28459382.1413               28459568.9954   x14 U    51     8
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cc7030
% @LO 0.09  28.45938214129668253349 99.9000000000
% @LN 0.09  28.45956899539225659623 99.9000000000
% Resuming node 143 at  28.45956899539225659623
DEBUG CONSTRNT: LP rows=30, pool->nlprows=30, pool->npend=0
DEBUG CONSTRNT: Checking 30 LP rows (pool tracks 30, total LP rows 30)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=29, expected 29
 % @PAP adding 40 rows, 174 nz to LP
DEBUG BB: Processing node 143, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=39, theta=0.833333, up=999999999999999983222784.000000
ITER 2: row=10, varin=36, theta=1.250000, up=999999999999999983222784.000000
ITER 3: row=14, varin=35, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=40)
DEBUG SOLUTION: LP solution array indices: FST[41-80], not_covered[81-100]
DEBUG SOLUTION: lp->best_solution[0] = 28459568.995392
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 40 rows, 60 cols, 234 nonzeros, 4 slack, 36 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 40 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=41, varin=33, theta=0.464139, up=999999999999999983222784.000000
ITER 2: row=33, varin=31, theta=0.475229, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=41)
DEBUG SOLUTION: LP solution array indices: FST[42-81], not_covered[82-101]
DEBUG SOLUTION: lp->best_solution[0] = 28461974.253789
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 41 rows, 60 cols, 274 nonzeros, 6 slack, 35 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 6 slack rows
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=36, varin=17, theta=0.326861, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=36)
DEBUG SOLUTION: LP solution array indices: FST[37-76], not_covered[77-96]
DEBUG SOLUTION: lp->best_solution[0] = 28464164.150288
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 36 rows, 60 cols, 250 nonzeros, 1 slack, 35 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 143 LP 1 Solution, length = 28464164.150288, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.673139 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.673139 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 1.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.673139 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.326861 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.326861 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.326861 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.326861 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.326861 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.326861 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.326861 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=28464164.150288, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 143 at  28.46416415028842195056
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cc24b0
% @LO 0.09  28.45956899539225659623 99.9000000000
% @LN 0.09  28.46052377936813826409 99.9000000000
% Resuming node 105 at  28.46052377936813826409
DEBUG CONSTRNT: LP rows=35, pool->nlprows=35, pool->npend=0
DEBUG CONSTRNT: Checking 35 LP rows (pool tracks 35, total LP rows 35)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=34, expected 34
 % @PAP adding 42 rows, 203 nz to LP
DEBUG BB: Processing node 105, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 105 LP 2 Solution, length = 28460523.779368, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.333333 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.333333 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.849978 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.849978 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.333333 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.333333 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.666667 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.666667 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.150022 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.150022 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.666667 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.150022 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.666667 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.150022 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28460523.779368, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28460523.779368, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 105 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 105
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.333333
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.333333
DEBUG CAREFUL: Adding var 4 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.849978
DEBUG CAREFUL: Adding var 9 to fractional list (xi=0.849978)
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.849978
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.849978)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.333333
DEBUG CAREFUL: Adding var 11 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.333333
DEBUG CAREFUL: Adding var 22 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 6 fractional variables

  %  Carefully choosing branching variable, nfrac = 6
DEBUG CAREFUL: Testing fvar[0] = var 11
DEBUG CAREFUL: Calling compare_branch_vars for var 11
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 11
DEBUG CAREFUL: New best var: 11
DEBUG CAREFUL: Testing fvar[1] = var 4
DEBUG CAREFUL: Calling compare_branch_vars for var 4
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 4
DEBUG CAREFUL: New best var: 4
DEBUG CAREFUL: Testing fvar[2] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[3] = var 22
DEBUG CAREFUL: Calling compare_branch_vars for var 22
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 22
DEBUG CAREFUL: Testing fvar[4] = var 9
DEBUG CAREFUL: Calling compare_branch_vars for var 9
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 9
DEBUG CAREFUL: Testing fvar[5] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
  % Initial guess is x4, Z0 = 28460523.7793681        , Z1 = 28487223.1113873        

DEBUG EVAL: Testing var 11 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=24, varin=35, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 11 = 1 gives z=28500877.733245
  % 	x11 = 1,	Z1 = 28500877.733245         
DEBUG EVAL: First branch cutoff check: z=28500877.733245, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 11 = 0
ITER 1: row=24, varin=20, theta=0.333333, up=999999999999999983222784.000000
ITER 2: row=14, varin=34, theta=0.370122, up=999999999999999983222784.000000
ITER 3: row=40, varin=42, theta=155846.333333, up=999999999999999983222784.000000
  % 	x11 = 0,	Z0 = 28460523.7793681        
DEBUG EVAL: Second branch cutoff check: z=28460523.779368, best_z=INF, threshold=INF
  %   New best:  x11, Z = 28460523.7793681        
DEBUG EVAL: Testing var 4 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=16, varin=34, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=40, varin=39, theta=2.000000, up=999999999999999983222784.000000
ITER 3: row=39, varin=41, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 4 = 1 gives z=28525734.111655
  % 	x4 = 1,	Z1 = 28525734.1116545        
DEBUG EVAL: First branch cutoff check: z=28525734.111655, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 4 = 0
ITER 1: row=16, varin=20, theta=0.333333, up=999999999999999983222784.000000
ITER 2: row=13, varin=42, theta=155846.333333, up=999999999999999983222784.000000
  % 	x4 = 0,	Z0 = 28487489.7932958        
DEBUG EVAL: Second branch cutoff check: z=28487489.793296, best_z=INF, threshold=INF
  %   New best:  x4, Z = 28487489.7932958        
DEBUG EVAL: Testing var 2 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=20, theta=0.333333, up=999999999999999983222784.000000
ITER 2: row=14, varin=34, theta=0.370122, up=999999999999999983222784.000000
ITER 3: row=40, varin=42, theta=155846.333333, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 0 gives z=28433443.370107
  % 	x2 = 0,	Z0 = 28460523.7793681        
DEBUG EVAL: First branch cutoff check: z=28460523.779368, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 22 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=25, varin=20, theta=0.333333, up=999999999999999983222784.000000
ITER 2: row=13, varin=34, theta=0.370122, up=999999999999999983222784.000000
ITER 3: row=40, varin=42, theta=155846.333333, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 22 = 0 gives z=28433443.370107
  % 	x22 = 0,	Z0 = 28460523.7793681        
DEBUG EVAL: First branch cutoff check: z=28460523.779368, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 9 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=18, varin=20, theta=0.160521, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 9 = 1 gives z=28473115.993405
  % 	x9 = 1,	Z1 = 28473115.9934046        
DEBUG EVAL: First branch cutoff check: z=28473115.993405, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 10 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=13, varin=20, theta=0.160521, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 1 gives z=28473115.993405
  % 	x10 = 1,	Z1 = 28473115.9934046        
DEBUG EVAL: First branch cutoff check: z=28473115.993405, best_z=INF, threshold=INF
  % Best branch is x4, Z0 = 28487489.7932958        , Z1 = 28525734.1116545        

DEBUG CAREFUL: Final result - returning best.var = 4
DEBUG BB: Branching variable chosen: j=4
 % @NC  153  105	x4 = 0	28487489.793296
 % @NC  154  105	x4 = 1	28525734.111655
 %     105    72 28460523.7794               28460648.7392    x0 D    81    14
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cc9ac0
% @LO 0.09  28.46052377936813826409 99.9000000000
% @LN 0.09  28.46064873916487414363 99.9000000000
% Resuming node 145 at  28.46064873916487414363
DEBUG CONSTRNT: LP rows=42, pool->nlprows=42, pool->npend=0
DEBUG CONSTRNT: Checking 42 LP rows (pool tracks 42, total LP rows 42)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=41, expected 41
 % @PAP adding 40 rows, 162 nz to LP
DEBUG BB: Processing node 145, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=22, varin=14, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=40)
DEBUG SOLUTION: LP solution array indices: FST[41-80], not_covered[81-100]
DEBUG SOLUTION: lp->best_solution[0] = 28460648.739165
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 40 rows, 60 cols, 222 nonzeros, 1 slack, 39 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 25 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=41, varin=69, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28473132.215196
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.500000
  % @PL 44 rows, 60 cols, 247 nonzeros, 3 slack, 41 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 4 rows, 11 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=42, varin=30, theta=0.166667, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 28474413.954197
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 45 rows, 60 cols, 225 nonzeros, 4 slack, 41 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % Node 145 LP 1 Solution, length = 28474413.954197, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.166667 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.166667 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.166667 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.500000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.500000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.166667 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.166667 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.833333 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.833333 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.500000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.500000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.833333 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.833333 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.833333 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.833333 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.500000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.833333 (terminal 19)
 % 7 fractional variables
DEBUG CG: LP optimal, z=28474413.954197, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 145 at  28.47441395419713217052
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7ccf030
% @LO 0.09  28.46064873916487414363 99.9000000000
% @LN 0.09  28.46090443520554558177 99.9000000000
% Resuming node 151 at  28.46090443520554558177
DEBUG CONSTRNT: LP rows=41, pool->nlprows=41, pool->npend=0
DEBUG CONSTRNT: Checking 41 LP rows (pool tracks 41, total LP rows 41)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=40, expected 40
 % @PAP adding 30 rows, 132 nz to LP
DEBUG BB: Processing node 151, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=19, varin=57, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=30)
DEBUG SOLUTION: LP solution array indices: FST[31-70], not_covered[71-90]
DEBUG SOLUTION: lp->best_solution[0] = 28460904.435206
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 30 rows, 60 cols, 192 nonzeros, 0 slack, 30 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=31, varin=30, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=31)
DEBUG SOLUTION: LP solution array indices: FST[32-71], not_covered[72-91]
DEBUG SOLUTION: lp->best_solution[0] = 28465965.691744
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 31 rows, 60 cols, 194 nonzeros, 1 slack, 30 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 4 rows, 17 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=31, varin=29, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=14, varin=69, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=34)
DEBUG SOLUTION: LP solution array indices: FST[35-74], not_covered[75-94]
DEBUG SOLUTION: lp->best_solution[0] = 28473029.413469
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 34 rows, 60 cols, 207 nonzeros, 1 slack, 33 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 151 LP 1 Solution, length = 28473029.413469, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.500000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.500000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 1.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.500000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.500000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.500000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.500000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.500000 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=28473029.413469, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 151 at  28.47302941346871563155
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cac0a0
% @LO 0.09  28.46090443520554558177 99.9000000000
% @LN 0.09  28.46146900139580537825 99.9000000000
% Resuming node 111 at  28.46146900139580537825
DEBUG CONSTRNT: LP rows=33, pool->nlprows=33, pool->npend=0
DEBUG CONSTRNT: Checking 33 LP rows (pool tracks 33, total LP rows 33)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 158
DEBUG CONSTRNT: Pool row 158 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=32, expected 32
 % @PAP adding 43 rows, 182 nz to LP
DEBUG BB: Processing node 111, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 111 LP 2 Solution, length = 28461469.001396, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.333333 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.333333 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.333333 (FST 11)
  % DEBUG LP_VARS: x[12] = 1.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 1.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.333333 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.333333 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.666667 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.666667 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.666667 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.666667 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.666667 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.666667 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.666667 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28461469.001396, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28461469.001396, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 111 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 111
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.333333
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.333333
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.333333
DEBUG CAREFUL: Adding var 11 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=1.000000
DEBUG CAREFUL: Skipping var 12: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=1.000000
DEBUG CAREFUL: Skipping var 16: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.333333
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.333333
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 11
DEBUG CAREFUL: Calling compare_branch_vars for var 11
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 11
DEBUG CAREFUL: New best var: 11
DEBUG CAREFUL: Testing fvar[1] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[2] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[3] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[4] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
  % Initial guess is x11, Z0 = 28461469.0013958        , Z1 = 28659041.7202878        

DEBUG EVAL: Testing var 11 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=14, varin=40, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=40, varin=24, theta=2.000000, up=999999999999999983222784.000000
ITER 3: row=42, varin=37, theta=2.000000, up=999999999999999983222784.000000
ITER 4: row=37, varin=36, theta=2.000000, up=999999999999999983222784.000000
ITER 5: row=36, varin=32, theta=2.000000, up=999999999999999983222784.000000
ITER 6: row=32, varin=34, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=43, varin=28, theta=1.000000, up=999999999999999983222784.000000
ITER 8: row=38, varin=25, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 11 = 1 gives z=28849916.475390
  % 	x11 = 1,	Z1 = 28849916.4753903        
DEBUG EVAL: First branch cutoff check: z=28849916.475390, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 11 = 0
ITER 1: row=14, varin=48, theta=0.500000, up=1.000000
  % 	x11 = 0,	Z0 = 28464962.3535519        
DEBUG EVAL: Second branch cutoff check: z=28464962.353552, best_z=INF, threshold=INF
  %   New best:  x11, Z = 28464962.3535519        
DEBUG EVAL: Testing var 2 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=48, theta=0.500000, up=1.000000
DEBUG EVAL: Branch var 2 = 0 gives z=28464962.353552
  % 	x2 = 0,	Z0 = 28464962.3535519        
DEBUG EVAL: First branch cutoff check: z=28464962.353552, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 1
ITER 1: row=1, varin=41, theta=1.000000, up=999999999999999983222784.000000
  % 	x2 = 1,	Z1 = 28479208.9783618        
DEBUG EVAL: Second branch cutoff check: z=28479208.978362, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 17 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=23, varin=41, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 17 = 1 gives z=28479208.978362
  % 	x17 = 1,	Z1 = 28479208.9783618        
DEBUG EVAL: First branch cutoff check: z=28479208.978362, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 17 = 0
ITER 1: row=23, varin=48, theta=0.500000, up=1.000000
  % 	x17 = 0,	Z0 = 28464962.3535519        
DEBUG EVAL: Second branch cutoff check: z=28464962.353552, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 10 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=11, varin=48, theta=0.500000, up=1.000000
DEBUG EVAL: Branch var 10 = 0 gives z=28464962.353552
  % 	x10 = 0,	Z0 = 28464962.3535519        
DEBUG EVAL: First branch cutoff check: z=28464962.353552, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 1
ITER 1: row=11, varin=41, theta=1.000000, up=999999999999999983222784.000000
  % 	x10 = 1,	Z1 = 28479208.9783618        
DEBUG EVAL: Second branch cutoff check: z=28479208.978362, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 26 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=32, varin=48, theta=0.500000, up=1.000000
DEBUG EVAL: Branch var 26 = 0 gives z=28464962.353552
  % 	x26 = 0,	Z0 = 28464962.3535519        
DEBUG EVAL: First branch cutoff check: z=28464962.353552, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 26 = 1
ITER 1: row=32, varin=41, theta=1.000000, up=999999999999999983222784.000000
  % 	x26 = 1,	Z1 = 28479208.9783618        
DEBUG EVAL: Second branch cutoff check: z=28479208.978362, best_z=INF, threshold=INF
  % Best branch is x11, Z0 = 28464962.3535519        , Z1 = 28849916.4753903        

DEBUG CAREFUL: Final result - returning best.var = 11
DEBUG BB: Branching variable chosen: j=11
 % @NC  155  111	x11 = 0	28464962.353552
 % @NC  156  111	x11 = 1	28849916.475390
 %     111    73 28461469.0014               28464164.1503    x3 D    93     7
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cc7030
% @LO 0.09  28.46146900139580537825 99.9000000000
% @LN 0.09  28.46416415028842195056 99.9000000000
% Resuming node 143 at  28.46416415028842195056
DEBUG CONSTRNT: LP rows=43, pool->nlprows=43, pool->npend=0
DEBUG CONSTRNT: Checking 43 LP rows (pool tracks 43, total LP rows 43)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 49
DEBUG CONSTRNT: Pool row 49 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 82
DEBUG CONSTRNT: Pool row 82 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=42, expected 42
 % @PAP adding 35 rows, 188 nz to LP
DEBUG BB: Processing node 143, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 143 LP 2 Solution, length = 28464164.150288, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.673139 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.673139 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 1.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.673139 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.326861 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.326861 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.326861 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.326861 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.326861 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.326861 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.326861 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=28464164.150288, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28464164.150288, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 143 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 143
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=1.000000
DEBUG CAREFUL: Skipping var 2: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.673139
DEBUG CAREFUL: Adding var 9 to fractional list (xi=0.673139)
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.673139
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.673139)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=1.000000
DEBUG CAREFUL: Skipping var 15: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.673139
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.673139)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.326861
DEBUG CAREFUL: Adding var 34 to fractional list (xi=0.326861)
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 4 fractional variables

  %  Carefully choosing branching variable, nfrac = 4
DEBUG CAREFUL: Testing fvar[0] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 17
DEBUG CAREFUL: New best var: 17
DEBUG CAREFUL: Testing fvar[1] = var 34
DEBUG CAREFUL: Calling compare_branch_vars for var 34
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 34
DEBUG CAREFUL: New best var: 34
DEBUG CAREFUL: Testing fvar[2] = var 9
DEBUG CAREFUL: Calling compare_branch_vars for var 9
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 9
DEBUG CAREFUL: Testing fvar[3] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
  % Initial guess is x34, Z0 = 28464164.1502884        , Z1 = 28633257.4182301        

DEBUG EVAL: Testing var 17 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
DEBUG EVAL: Branch var 17 = 1 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x17 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=16, varin=35, theta=0.978689, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=35)
DEBUG SOLUTION: LP solution array indices: FST[36-75], not_covered[76-95]
DEBUG SOLUTION: lp->best_solution[0] = 28468674.028488
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 35 rows, 60 cols, 248 nonzeros, 1 slack, 34 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
   % @PAP adding 3 rows, 20 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=36, varin=74, theta=0.955850, up=1.000000
ITER 2: row=30, varin=34, theta=944374.000000, up=999999999999999983222784.000000
ITER 3: row=35, varin=41, theta=0.250000, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=37)
DEBUG SOLUTION: LP solution array indices: FST[38-77], not_covered[78-97]
DEBUG SOLUTION: lp->best_solution[0] = 28473786.327832
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 37 rows, 60 cols, 266 nonzeros, 1 slack, 36 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
   % @PAP adding 4 rows, 19 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=37, varin=56, theta=0.166667, up=1.000000
ITER 2: row=32, varin=65, theta=0.500000, up=1.000000
ITER 3: row=3, varin=10, theta=0.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=40)
DEBUG SOLUTION: LP solution array indices: FST[41-80], not_covered[81-100]
DEBUG SOLUTION: lp->best_solution[0] = 28502169.611960
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.500000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 40 rows, 60 cols, 245 nonzeros, 2 slack, 38 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 2 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 143 at  28.50216961196039733295
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7caffe0
% @LO 0.09  28.46416415028842195056 99.9000000000
% @LN 0.09  28.46459295281399803912 99.9000000000
% Resuming node 95 at  28.46459295281399803912
DEBUG CONSTRNT: LP rows=38, pool->nlprows=38, pool->npend=0
DEBUG CONSTRNT: Checking 38 LP rows (pool tracks 38, total LP rows 38)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=37, expected 37
 % @PAP adding 48 rows, 199 nz to LP
DEBUG BB: Processing node 95, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=32, varin=35, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 28464592.952814
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 48 rows, 60 cols, 259 nonzeros, 1 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 12 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=49, varin=38, theta=0.333333, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28477941.476916
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 50 rows, 60 cols, 271 nonzeros, 4 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % @PAP adding 4 rows, 10 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=47, varin=29, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=46, varin=32, theta=0.125000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28486612.660176
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 50 rows, 60 cols, 266 nonzeros, 8 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 8 slack rows
  % @PAP adding 3 rows, 46 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=45, varin=69, theta=0.101245, up=1.000000
ITER 2: row=43, varin=40, theta=3.436114, up=999999999999999983222784.000000
ITER 3: row=44, varin=45, theta=57494.500000, up=999999999999999983222784.000000
ITER 4: row=1, varin=36, theta=0.089446, up=999999999999999983222784.000000
ITER 5: row=45, varin=39, theta=0.096320, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=5)
ITER 6: row=36, varin=69, theta=0.000000, up=1.000000
ITER 7: row=39, varin=44, theta=0.000000, up=999999999999999983222784.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 28492506.952858
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 45 rows, 60 cols, 282 nonzeros, 2 slack, 43 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % Node 95 LP 1 Solution, length = 28492506.952858, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.500000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.500000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.500000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.500000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.500000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.500000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.500000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.500000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.500000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.500000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.500000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.500000 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28492506.952858, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 95 at  28.49250695285765999643
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cc24b0
% @LO 0.09  28.46459295281399803912 99.9000000000
% @LN 0.09  28.46496235355192894190 99.9000000000
% Resuming node 155 at  28.46496235355192894190
DEBUG CONSTRNT: LP rows=43, pool->nlprows=43, pool->npend=0
DEBUG CONSTRNT: Checking 43 LP rows (pool tracks 43, total LP rows 43)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=42, expected 42
 % @PAP adding 43 rows, 182 nz to LP
DEBUG BB: Processing node 155, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=14, varin=48, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 28464962.353552
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 43 rows, 60 cols, 242 nonzeros, 0 slack, 43 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 6 rows, 33 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=44, varin=41, theta=0.333333, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 28469711.228489
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 49 rows, 60 cols, 275 nonzeros, 6 slack, 43 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 6 slack rows
  % Node 155 LP 1 Solution, length = 28469711.228489, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.333333 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.333333 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.333333 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 1.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 1.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.333333 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.333333 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.666667 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.666667 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.666667 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.666667 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.666667 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.666667 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.666667 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28469711.228489, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 155 at  28.46971122848856694532
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7ccbbd0
% @LO 0.09  28.46496235355192894190 99.9000000000
% @LN 0.09  28.46598238997147234386 99.9000000000
% Resuming node 83 at  28.46598238997147234386
DEBUG CONSTRNT: LP rows=43, pool->nlprows=43, pool->npend=0
DEBUG CONSTRNT: Checking 43 LP rows (pool tracks 43, total LP rows 43)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 49
DEBUG CONSTRNT: Pool row 49 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 82
DEBUG CONSTRNT: Pool row 82 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=42, expected 42
 % @PAP adding 43 rows, 174 nz to LP
DEBUG BB: Processing node 83, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 83 LP 2 Solution, length = 28465982.389971, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.500000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.500000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.500000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.500000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.500000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.500000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.500000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.500000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.500000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.500000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.500000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.500000 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28465982.389971, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28465982.389971, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 83 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 83
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.500000
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=1.000000
DEBUG CAREFUL: Skipping var 7: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.500000
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.500000
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.500000
DEBUG CAREFUL: Adding var 22 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.500000
DEBUG CAREFUL: Adding var 31 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 2
DEBUG CAREFUL: New best var: 2
DEBUG CAREFUL: Testing fvar[1] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[2] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[3] = var 22
DEBUG CAREFUL: Calling compare_branch_vars for var 22
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 22
DEBUG CAREFUL: Testing fvar[4] = var 31
DEBUG CAREFUL: Calling compare_branch_vars for var 31
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 31
  % Initial guess is x2, Z0 = 28465982.3899715        , Z1 = 28473841.4468808        

DEBUG EVAL: Testing var 2 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=2, varin=42, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 1 gives z=28473841.446881
  % 	x2 = 1,	Z1 = 28473841.4468808        
DEBUG EVAL: First branch cutoff check: z=28473841.446881, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 0
ITER 1: row=2, varin=100, theta=0.333333, up=1.000000
  % 	x2 = 0,	Z0 = 28467482.5294558        
DEBUG EVAL: Second branch cutoff check: z=28467482.529456, best_z=INF, threshold=INF
  %   New best:  x2, Z = 28467482.5294558        
DEBUG EVAL: Testing var 17 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=19, varin=100, theta=0.333333, up=1.000000
DEBUG EVAL: Branch var 17 = 0 gives z=28467482.529456
  % 	x17 = 0,	Z0 = 28467482.5294558        
DEBUG EVAL: First branch cutoff check: z=28467482.529456, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 17 = 1
ITER 1: row=19, varin=40, theta=0.333333, up=999999999999999983222784.000000
ITER 2: row=43, varin=33, theta=1.000000, up=999999999999999983222784.000000
  % 	x17 = 1,	Z1 = 28611654.2327182        
DEBUG EVAL: Second branch cutoff check: z=28611654.232718, best_z=INF, threshold=INF
  %   New best:  x17, Z = 28467482.5294558        
DEBUG EVAL: Testing var 10 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=14, varin=100, theta=0.333333, up=1.000000
DEBUG EVAL: Branch var 10 = 0 gives z=28467482.529456
  % 	x10 = 0,	Z0 = 28467482.5294558        
DEBUG EVAL: First branch cutoff check: z=28467482.529456, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 1
ITER 1: row=14, varin=40, theta=0.333333, up=999999999999999983222784.000000
ITER 2: row=43, varin=33, theta=1.000000, up=999999999999999983222784.000000
  % 	x10 = 1,	Z1 = 28611654.2327182        
DEBUG EVAL: Second branch cutoff check: z=28611654.232718, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 22 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=21, varin=100, theta=0.333333, up=1.000000
DEBUG EVAL: Branch var 22 = 0 gives z=28467482.529456
  % 	x22 = 0,	Z0 = 28467482.5294558        
DEBUG EVAL: First branch cutoff check: z=28467482.529456, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 22 = 1
ITER 1: row=21, varin=40, theta=0.333333, up=999999999999999983222784.000000
ITER 2: row=43, varin=21, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=34, varin=22, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=21, varin=100, theta=0.666667, up=1.000000
  % 	x22 = 1,	Z1 = 29719978.8808518        
DEBUG EVAL: Second branch cutoff check: z=29719978.880852, best_z=INF, threshold=INF
  %   New best:  x22, Z = 28467482.5294558        
DEBUG EVAL: Testing var 31 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=37, varin=100, theta=0.333333, up=1.000000
DEBUG EVAL: Branch var 31 = 0 gives z=28467482.529456
  % 	x31 = 0,	Z0 = 28467482.5294558        
DEBUG EVAL: First branch cutoff check: z=28467482.529456, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 31 = 1
ITER 1: row=37, varin=42, theta=1.000000, up=999999999999999983222784.000000
  % 	x31 = 1,	Z1 = 28473841.4468808        
DEBUG EVAL: Second branch cutoff check: z=28473841.446881, best_z=INF, threshold=INF
  % Best branch is x22, Z0 = 28467482.5294558        , Z1 = 29719978.8808518        

DEBUG CAREFUL: Final result - returning best.var = 22
DEBUG BB: Branching variable chosen: j=22
 % @NC  157   83	x22 = 0	28467482.529456
 % @NC  158   83	x22 = 1	29719978.880852
 %      83    74 28465982.3900               28466396.5550   x27 D    55    10
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cf1f70
% @LO 0.09  28.46598238997147234386 99.9000000000
% @LN 0.09  28.46639655500742094318 99.9000000000
% Resuming node 144 at  28.46639655500742094318
DEBUG CONSTRNT: LP rows=43, pool->nlprows=43, pool->npend=0
DEBUG CONSTRNT: Checking 43 LP rows (pool tracks 43, total LP rows 43)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=42, expected 42
 % @PAP adding 40 rows, 174 nz to LP
DEBUG BB: Processing node 144, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=65, theta=0.500000, up=1.000000
ITER 2: row=3, varin=10, theta=0.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=40)
DEBUG SOLUTION: LP solution array indices: FST[41-80], not_covered[81-100]
DEBUG SOLUTION: lp->best_solution[0] = 28466396.555007
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.500000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 40 rows, 60 cols, 234 nonzeros, 2 slack, 38 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 144 LP 1 Solution, length = 28466396.555007, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.500000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.500000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.500000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.500000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.500000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.500000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.500000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.500000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.500000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.500000 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=28466396.555007, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28466396.555007, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 144 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 144
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.500000
DEBUG CAREFUL: Adding var 9 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.500000
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.500000
DEBUG CAREFUL: Adding var 15 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.500000
DEBUG CAREFUL: Adding var 34 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 4 fractional variables

  %  Carefully choosing branching variable, nfrac = 4
DEBUG CAREFUL: Testing fvar[0] = var 15
DEBUG CAREFUL: Calling compare_branch_vars for var 15
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 15
DEBUG CAREFUL: New best var: 15
DEBUG CAREFUL: Testing fvar[1] = var 9
DEBUG CAREFUL: Calling compare_branch_vars for var 9
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 9
DEBUG CAREFUL: Testing fvar[2] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[3] = var 34
DEBUG CAREFUL: Calling compare_branch_vars for var 34
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 34
DEBUG CAREFUL: New best var: 34
  % Initial guess is x34, Z0 = 28466396.5550074        , Z1 = 28633257.4182301        

DEBUG EVAL: Testing var 15 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=20, varin=3, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=3, varin=36, theta=0.250000, up=999999999999999983222784.000000
ITER 3: row=36, varin=35, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 15 = 0 gives z=28494938.743461
  % 	x15 = 0,	Z0 = 28494938.743461         
DEBUG EVAL: First branch cutoff check: z=28494938.743461, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 15 = 1
ITER 1: row=20, varin=15, theta=0.250000, up=999999999999999983222784.000000
  % 	x15 = 1,	Z1 = 28481486.9062578        
DEBUG EVAL: Second branch cutoff check: z=28481486.906258, best_z=INF, threshold=INF
  %   New best:  x15, Z = 28481486.9062578        
DEBUG EVAL: Testing var 9 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=31, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 9 = 0 gives z=28500000.000000
  % 	x9 = 0,	Z0 = 28500000                
DEBUG EVAL: First branch cutoff check: z=28500000.000000, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 9 = 1
ITER 1: row=1, varin=35, theta=1.000000, up=999999999999999983222784.000000
  % 	x9 = 1,	Z1 = 28494938.743461         
DEBUG EVAL: Second branch cutoff check: z=28494938.743461, best_z=INF, threshold=INF
  %   New best:  x9, Z = 28494938.743461         
DEBUG EVAL: Testing var 10 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=11, varin=11, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 0 gives z=28484437.432846
  % 	x10 = 0,	Z0 = 28484437.4328464        
DEBUG EVAL: First branch cutoff check: z=28484437.432846, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 34 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=25, varin=25, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 34 = 1 gives z=28682891.713091
  % 	x34 = 1,	Z1 = 28682891.713091         
DEBUG EVAL: First branch cutoff check: z=28682891.713091, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 34 = 0
ITER 1: row=25, varin=35, theta=1.000000, up=999999999999999983222784.000000
  % 	x34 = 0,	Z0 = 28494938.743461         
DEBUG EVAL: Second branch cutoff check: z=28494938.743461, best_z=INF, threshold=INF
  %   New best:  x34, Z = 28494938.743461         
  % Best branch is x34, Z0 = 28494938.743461         , Z1 = 28682891.713091         

DEBUG CAREFUL: Final result - returning best.var = 34
DEBUG BB: Branching variable chosen: j=34
 % @NC  159  144	x34 = 0	28494938.743461
 % @NC  160  144	x34 = 1	28682891.713091
 %     144    75 28466396.5550               28467482.5295    x2 D   131    12
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cac0a0
% @LO 0.09  28.46639655500742094318 99.9000000000
% @LN 0.09  28.46748252945578983031 99.9000000000
% Resuming node 157 at  28.46748252945578983031
DEBUG CONSTRNT: LP rows=40, pool->nlprows=40, pool->npend=0
DEBUG CONSTRNT: Checking 40 LP rows (pool tracks 40, total LP rows 40)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=39, expected 39
 % @PAP adding 43 rows, 174 nz to LP
DEBUG BB: Processing node 157, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=21, varin=100, theta=0.333333, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 28467482.529456
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 43 rows, 60 cols, 234 nonzeros, 1 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=44, varin=42, theta=0.250000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 28469072.258812
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 45 rows, 60 cols, 240 nonzeros, 3 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % Node 157 LP 1 Solution, length = 28469072.258812, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.250000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.250000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.250000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.250000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.250000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.250000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.250000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.250000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.750000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.750000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.750000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.750000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.750000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 0.750000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 8 fractional variables
DEBUG CG: LP optimal, z=28469072.258812, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
 % @LO 0.09  28.46748252945578983031 99.9000000000
 % @LN 0.09  28.46907225881203729045 99.9000000000
DEBUG CG: Second cutoff check: z=28469072.258812, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 157 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 157
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.250000
DEBUG CAREFUL: Adding var 0 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.250000
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=1.000000
DEBUG CAREFUL: Skipping var 7: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.250000
DEBUG CAREFUL: Adding var 23 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.250000
DEBUG CAREFUL: Adding var 24 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.250000
DEBUG CAREFUL: Adding var 30 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.250000
DEBUG CAREFUL: Adding var 31 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.250000
DEBUG CAREFUL: Adding var 32 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.250000
DEBUG CAREFUL: Adding var 33 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 8 fractional variables

  %  Carefully choosing branching variable, nfrac = 8
DEBUG CAREFUL: Testing fvar[0] = var 24
DEBUG CAREFUL: Calling compare_branch_vars for var 24
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 24
DEBUG CAREFUL: New best var: 24
DEBUG CAREFUL: Testing fvar[1] = var 23
DEBUG CAREFUL: Calling compare_branch_vars for var 23
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 23
DEBUG CAREFUL: New best var: 23
DEBUG CAREFUL: Testing fvar[2] = var 0
DEBUG CAREFUL: Calling compare_branch_vars for var 0
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 0
DEBUG CAREFUL: Testing fvar[3] = var 32
DEBUG CAREFUL: Calling compare_branch_vars for var 32
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 32
DEBUG CAREFUL: Testing fvar[4] = var 30
DEBUG CAREFUL: Calling compare_branch_vars for var 30
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 30
DEBUG CAREFUL: Testing fvar[5] = var 33
DEBUG CAREFUL: Calling compare_branch_vars for var 33
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 33
DEBUG CAREFUL: Testing fvar[6] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[7] = var 31
DEBUG CAREFUL: Calling compare_branch_vars for var 31
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 31
  % Initial guess is x23, Z0 = 28469072.258812         , Z1 = 28499613.7603086        

DEBUG EVAL: Testing var 24 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=32, varin=42, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 24 = 0 gives z=28473841.446881
  % 	x24 = 0,	Z0 = 28473841.4468808        
DEBUG EVAL: First branch cutoff check: z=28473841.446881, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 24 = 1
ITER 1: row=32, varin=40, theta=0.750000, up=999999999999999983222784.000000
ITER 2: row=36, varin=39, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=37, varin=2, theta=0.200000, up=999999999999999983222784.000000
  % 	x24 = 1,	Z1 = 28526936.0425507        
DEBUG EVAL: Second branch cutoff check: z=28526936.042551, best_z=INF, threshold=INF
  %   New best:  x24, Z = 28473841.4468808        
DEBUG EVAL: Testing var 23 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=19, varin=40, theta=0.750000, up=999999999999999983222784.000000
ITER 2: row=36, varin=39, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=37, varin=2, theta=0.200000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 23 = 1 gives z=28526936.042551
  % 	x23 = 1,	Z1 = 28526936.0425507        
DEBUG EVAL: First branch cutoff check: z=28526936.042551, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 23 = 0
ITER 1: row=19, varin=42, theta=1.000000, up=999999999999999983222784.000000
  % 	x23 = 0,	Z0 = 28473841.4468808        
DEBUG EVAL: Second branch cutoff check: z=28473841.446881, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 0 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=42, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 0 = 0 gives z=28473841.446881
  % 	x0 = 0,	Z0 = 28473841.4468808        
DEBUG EVAL: First branch cutoff check: z=28473841.446881, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 0 = 1
ITER 1: row=1, varin=39, theta=3.000000, up=999999999999999983222784.000000
ITER 2: row=37, varin=36, theta=2.000000, up=999999999999999983222784.000000
ITER 3: row=19, varin=35, theta=1.500000, up=999999999999999983222784.000000
ITER 4: row=35, varin=56, theta=1.500000, up=1.000000
ITER 5: row=35, varin=40, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=18, varin=56, theta=1.000000, up=1.000000
ITER 7: row=32, varin=37, theta=1.500000, up=999999999999999983222784.000000
ITER 8: row=28, varin=32, theta=0.500000, up=999999999999999983222784.000000
  % 	x0 = 1,	Z1 = 28855591.4131444        
DEBUG EVAL: Second branch cutoff check: z=28855591.413144, best_z=INF, threshold=INF
  %   New best:  x0, Z = 28473841.4468808        
DEBUG EVAL: Testing var 32 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=31, varin=42, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 32 = 0 gives z=28473841.446881
  % 	x32 = 0,	Z0 = 28473841.4468808        
DEBUG EVAL: First branch cutoff check: z=28473841.446881, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 32 = 1
ITER 1: row=31, varin=39, theta=3.000000, up=999999999999999983222784.000000
ITER 2: row=37, varin=36, theta=2.000000, up=999999999999999983222784.000000
ITER 3: row=19, varin=35, theta=1.500000, up=999999999999999983222784.000000
ITER 4: row=35, varin=26, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=38, varin=56, theta=1.500000, up=1.000000
ITER 6: row=38, varin=37, theta=0.200000, up=999999999999999983222784.000000
ITER 7: row=18, varin=56, theta=1.000000, up=1.000000
  % 	x32 = 1,	Z1 = 28785154.0786102        
DEBUG EVAL: Second branch cutoff check: z=28785154.078610, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 30 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=28, varin=42, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 30 = 0 gives z=28473841.446881
  % 	x30 = 0,	Z0 = 28473841.4468808        
DEBUG EVAL: First branch cutoff check: z=28473841.446881, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 30 = 1
ITER 1: row=28, varin=39, theta=3.000000, up=999999999999999983222784.000000
ITER 2: row=37, varin=36, theta=2.000000, up=999999999999999983222784.000000
ITER 3: row=19, varin=35, theta=1.500000, up=999999999999999983222784.000000
ITER 4: row=35, varin=26, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=38, varin=56, theta=1.500000, up=1.000000
ITER 6: row=38, varin=40, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=18, varin=56, theta=1.000000, up=1.000000
ITER 8: row=32, varin=32, theta=1.500000, up=999999999999999983222784.000000
ITER 9: row=36, varin=31, theta=0.500000, up=999999999999999983222784.000000
  % 	x30 = 1,	Z1 = 28874268.7379966        
DEBUG EVAL: Second branch cutoff check: z=28874268.737997, best_z=INF, threshold=INF
  %   New best:  x30, Z = 28473841.4468808        
DEBUG EVAL: Testing var 33 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=36, varin=42, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 33 = 0 gives z=28473841.446881
  % 	x33 = 0,	Z0 = 28473841.4468808        
DEBUG EVAL: First branch cutoff check: z=28473841.446881, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 33 = 1
ITER 1: row=36, varin=39, theta=3.000000, up=999999999999999983222784.000000
ITER 2: row=37, varin=36, theta=2.000000, up=999999999999999983222784.000000
ITER 3: row=19, varin=35, theta=1.500000, up=999999999999999983222784.000000
ITER 4: row=35, varin=2, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=32, varin=56, theta=1.500000, up=1.000000
ITER 6: row=32, varin=32, theta=0.250000, up=999999999999999983222784.000000
ITER 7: row=18, varin=56, theta=1.000000, up=1.000000
ITER 8: row=41, varin=37, theta=1.500000, up=999999999999999983222784.000000
ITER 9: row=28, varin=31, theta=0.500000, up=999999999999999983222784.000000
  % 	x33 = 1,	Z1 = 28863399.2987608        
DEBUG EVAL: Second branch cutoff check: z=28863399.298761, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 2 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=2, varin=42, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 1 gives z=28473841.446881
  % 	x2 = 1,	Z1 = 28473841.4468808        
DEBUG EVAL: First branch cutoff check: z=28473841.446881, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 0
ITER 1: row=2, varin=2, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=41, varin=40, theta=0.500000, up=999999999999999983222784.000000
ITER 3: row=42, varin=80, theta=0.333333, up=1.000000
  % 	x2 = 0,	Z0 = 28576324.7272012        
DEBUG EVAL: Second branch cutoff check: z=28576324.727201, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 31 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=37, varin=42, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 31 = 1 gives z=28473841.446881
  % 	x31 = 1,	Z1 = 28473841.4468808        
DEBUG EVAL: First branch cutoff check: z=28473841.446881, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 31 = 0
ITER 1: row=37, varin=39, theta=0.333333, up=999999999999999983222784.000000
  % 	x31 = 0,	Z0 = 28479406.8817734        
DEBUG EVAL: Second branch cutoff check: z=28479406.881773, best_z=INF, threshold=INF
  % Best branch is x30, Z0 = 28473841.4468808        , Z1 = 28874268.7379966        

DEBUG CAREFUL: Final result - returning best.var = 30
DEBUG BB: Branching variable chosen: j=30
 % @NC  161  157	x30 = 0	28473841.446881
 % @NC  162  157	x30 = 1	28874268.737997
 %     157    76 28469072.2588               28469711.2285   x22 D    83    11
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cc24b0
% @LO 0.09  28.46907225881203729045 99.9000000000
% @LN 0.09  28.46971122848856694532 99.9000000000
% Resuming node 155 at  28.46971122848856694532
DEBUG CONSTRNT: LP rows=42, pool->nlprows=42, pool->npend=0
DEBUG CONSTRNT: Checking 42 LP rows (pool tracks 42, total LP rows 42)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=41, expected 41
 % @PAP adding 43 rows, 182 nz to LP
DEBUG BB: Processing node 155, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 155 LP 2 Solution, length = 28469711.228489, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.333333 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.333333 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.333333 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 1.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 1.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.333333 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.333333 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.666667 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.666667 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.666667 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.666667 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.666667 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.666667 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.666667 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28469711.228489, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28469711.228489, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 155 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 155
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.333333
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.333333
DEBUG CAREFUL: Adding var 4 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.333333
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=1.000000
DEBUG CAREFUL: Skipping var 12: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=1.000000
DEBUG CAREFUL: Skipping var 16: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.333333
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.333333
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 4
DEBUG CAREFUL: Calling compare_branch_vars for var 4
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 4
DEBUG CAREFUL: New best var: 4
DEBUG CAREFUL: Testing fvar[1] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[2] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[3] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[4] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
  % Initial guess is x4, Z0 = 28469711.2284886        , Z1 = 28683768.4015661        

DEBUG EVAL: Testing var 4 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=14, varin=40, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=40, varin=37, theta=2.000000, up=999999999999999983222784.000000
ITER 3: row=37, varin=36, theta=2.000000, up=999999999999999983222784.000000
ITER 4: row=36, varin=23, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=42, varin=32, theta=2.000000, up=999999999999999983222784.000000
ITER 6: row=32, varin=24, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=43, varin=28, theta=1.000000, up=999999999999999983222784.000000
ITER 8: row=38, varin=25, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 4 = 1 gives z=28874643.156669
  % 	x4 = 1,	Z1 = 28874643.1566686        
DEBUG EVAL: First branch cutoff check: z=28874643.156669, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 4 = 0
ITER 1: row=14, varin=41, theta=1.000000, up=999999999999999983222784.000000
  % 	x4 = 0,	Z0 = 28479208.9783618        
DEBUG EVAL: Second branch cutoff check: z=28479208.978362, best_z=INF, threshold=INF
  %   New best:  x4, Z = 28479208.9783618        
DEBUG EVAL: Testing var 2 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=41, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 1 gives z=28479208.978362
  % 	x2 = 1,	Z1 = 28479208.9783618        
DEBUG EVAL: First branch cutoff check: z=28479208.978362, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 0
ITER 1: row=1, varin=73, theta=1.000000, up=1.000000
ITER 2: row=31, varin=88, theta=0.333333, up=1.000000
ITER 3: row=39, varin=71, theta=1.000000, up=1.000000
  % 	x2 = 0,	Z0 = 28514654.7187971        
DEBUG EVAL: Second branch cutoff check: z=28514654.718797, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 17 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=23, varin=41, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 17 = 1 gives z=28479208.978362
  % 	x17 = 1,	Z1 = 28479208.9783618        
DEBUG EVAL: First branch cutoff check: z=28479208.978362, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 17 = 0
ITER 1: row=23, varin=73, theta=1.000000, up=1.000000
ITER 2: row=31, varin=88, theta=0.333333, up=1.000000
ITER 3: row=39, varin=71, theta=1.000000, up=1.000000
  % 	x17 = 0,	Z0 = 28514654.7187971        
DEBUG EVAL: Second branch cutoff check: z=28514654.718797, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 10 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=11, varin=41, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 1 gives z=28479208.978362
  % 	x10 = 1,	Z1 = 28479208.9783618        
DEBUG EVAL: First branch cutoff check: z=28479208.978362, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 0
ITER 1: row=11, varin=73, theta=1.000000, up=1.000000
ITER 2: row=31, varin=88, theta=0.333333, up=1.000000
ITER 3: row=39, varin=71, theta=1.000000, up=1.000000
  % 	x10 = 0,	Z0 = 28514654.7187971        
DEBUG EVAL: Second branch cutoff check: z=28514654.718797, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 26 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=32, varin=41, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 26 = 1 gives z=28479208.978362
  % 	x26 = 1,	Z1 = 28479208.9783618        
DEBUG EVAL: First branch cutoff check: z=28479208.978362, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 26 = 0
ITER 1: row=32, varin=73, theta=1.000000, up=1.000000
ITER 2: row=31, varin=88, theta=0.333333, up=1.000000
ITER 3: row=39, varin=71, theta=1.000000, up=1.000000
  % 	x26 = 0,	Z0 = 28514654.7187971        
DEBUG EVAL: Second branch cutoff check: z=28514654.718797, best_z=INF, threshold=INF
  % Best branch is x4, Z0 = 28479208.9783618        , Z1 = 28874643.1566686        

DEBUG CAREFUL: Final result - returning best.var = 4
DEBUG BB: Branching variable chosen: j=4
 % @NC  163  155	x4 = 0	28479208.978362
 % @NC  164  155	x4 = 1	28874643.156669
 %     155    77 28469711.2285               28473029.4135   x11 D   111     8
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7ccf030
% @LO 0.09  28.46971122848856694532 99.9000000000
% @LN 0.09  28.47302941346871563155 99.9000000000
% Resuming node 151 at  28.47302941346871563155
DEBUG CONSTRNT: LP rows=43, pool->nlprows=43, pool->npend=0
DEBUG CONSTRNT: Checking 43 LP rows (pool tracks 43, total LP rows 43)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 49
DEBUG CONSTRNT: Pool row 49 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 82
DEBUG CONSTRNT: Pool row 82 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=42, expected 42
 % @PAP adding 33 rows, 137 nz to LP
DEBUG BB: Processing node 151, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 151 LP 2 Solution, length = 28473029.413469, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.500000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.500000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 1.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.500000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.500000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.500000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.500000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.500000 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=28473029.413469, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28473029.413469, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 151 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 151
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.500000
DEBUG CAREFUL: Adding var 9 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.500000
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=1.000000
DEBUG CAREFUL: Skipping var 14: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.500000
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.500000
DEBUG CAREFUL: Adding var 34 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 4 fractional variables

  %  Carefully choosing branching variable, nfrac = 4
DEBUG CAREFUL: Testing fvar[0] = var 34
DEBUG CAREFUL: Calling compare_branch_vars for var 34
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 34
DEBUG CAREFUL: New best var: 34
DEBUG CAREFUL: Testing fvar[1] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
DEBUG CAREFUL: Testing fvar[2] = var 9
DEBUG CAREFUL: Calling compare_branch_vars for var 9
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 9
DEBUG CAREFUL: Testing fvar[3] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
  % Initial guess is x34, Z0 = 28473029.4134687        , Z1 = 28480093.1351929        

DEBUG EVAL: Testing var 34 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=14, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=13, varin=31, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 34 = 1 gives z=28480093.135193
  % 	x34 = 1,	Z1 = 28480093.1351929        
DEBUG EVAL: First branch cutoff check: z=28480093.135193, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 34 = 0
ITER 1: row=1, varin=70, theta=0.500000, up=1.000000
  % 	x34 = 0,	Z0 = 28474557.241791         
DEBUG EVAL: Second branch cutoff check: z=28474557.241791, best_z=INF, threshold=INF
  %   New best:  x34, Z = 28474557.241791         
DEBUG EVAL: Testing var 26 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=30, varin=31, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 26 = 0 gives z=28480093.135193
  % 	x26 = 0,	Z0 = 28480093.1351929        
DEBUG EVAL: First branch cutoff check: z=28480093.135193, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 26 = 1
ITER 1: row=30, varin=9, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=33, varin=10, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=1, varin=70, theta=1.000000, up=1.000000
  % 	x26 = 1,	Z1 = 28834804.7745711        
DEBUG EVAL: Second branch cutoff check: z=28834804.774571, best_z=INF, threshold=INF
  %   New best:  x26, Z = 28480093.1351929        
DEBUG EVAL: Testing var 9 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=23, varin=30, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 9 = 0 gives z=28485154.391732
  % 	x9 = 0,	Z0 = 28485154.3917319        
DEBUG EVAL: First branch cutoff check: z=28485154.391732, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 9 = 1
ITER 1: row=23, varin=31, theta=1.000000, up=999999999999999983222784.000000
  % 	x9 = 1,	Z1 = 28480093.1351929        
DEBUG EVAL: Second branch cutoff check: z=28480093.135193, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 10 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=9, varin=30, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 0 gives z=28485154.391732
  % 	x10 = 0,	Z0 = 28485154.3917319        
DEBUG EVAL: First branch cutoff check: z=28485154.391732, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 1
ITER 1: row=9, varin=31, theta=1.000000, up=999999999999999983222784.000000
  % 	x10 = 1,	Z1 = 28480093.1351929        
DEBUG EVAL: Second branch cutoff check: z=28480093.135193, best_z=INF, threshold=INF
  % Best branch is x26, Z0 = 28480093.1351929        , Z1 = 28834804.7745711        

DEBUG CAREFUL: Final result - returning best.var = 26
DEBUG BB: Branching variable chosen: j=26
 % @NC  165  151	x26 = 0	28480093.135193
 % @NC  166  151	x26 = 1	28834804.774571
 %     151    78 28473029.4135               28473841.4469   x18 D    74     9
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cf1f70
% @LO 0.09  28.47302941346871563155 99.9000000000
% @LN 0.09  28.47384144688078677632 99.9000000000
% Resuming node 161 at  28.47384144688078677632
DEBUG CONSTRNT: LP rows=33, pool->nlprows=33, pool->npend=0
DEBUG CONSTRNT: Checking 33 LP rows (pool tracks 33, total LP rows 33)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 158
DEBUG CONSTRNT: Pool row 158 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=32, expected 32
 % @PAP adding 42 rows, 170 nz to LP
DEBUG BB: Processing node 161, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=28, varin=42, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 28473841.446881
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 42 rows, 60 cols, 230 nonzeros, 1 slack, 41 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=43, varin=2, theta=0.250000, up=999999999999999983222784.000000
ITER 2: row=41, varin=37, theta=0.250000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 28520538.548643
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 43 rows, 60 cols, 232 nonzeros, 3 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % Node 161 LP 1 Solution, length = 28520538.548643, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.250000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.500000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.250000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.250000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.500000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.250000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.250000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.750000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.750000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.750000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.500000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.500000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 0.750000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 7 fractional variables
DEBUG CG: LP optimal, z=28520538.548643, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 161 at  28.52053854864344017983
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cd3de0
% @LO 0.09  28.47384144688078677632 99.9000000000
% @LN 0.09  28.47388083848087703132 99.9000000000
% Resuming node 115 at  28.47388083848087703132
DEBUG CONSTRNT: LP rows=40, pool->nlprows=40, pool->npend=0
DEBUG CONSTRNT: Checking 40 LP rows (pool tracks 40, total LP rows 40)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 134
DEBUG CONSTRNT: Pool row 134 has lprow=39, expected 39
 % @PAP adding 42 rows, 175 nz to LP
DEBUG BB: Processing node 115, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 115 LP 2 Solution, length = 28473880.838481, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.500000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.500000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.500000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 1.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 1.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.500000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.500000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.500000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.500000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.500000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.500000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.500000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.500000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28473880.838481, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28473880.838481, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 115 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 115
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.500000
DEBUG CAREFUL: Adding var 0 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.500000
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.500000
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=1.000000
DEBUG CAREFUL: Skipping var 12: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=1.000000
DEBUG CAREFUL: Skipping var 13: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.500000
DEBUG CAREFUL: Adding var 29 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.500000
DEBUG CAREFUL: Adding var 32 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 2
DEBUG CAREFUL: New best var: 2
DEBUG CAREFUL: Testing fvar[1] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 1
DEBUG CAREFUL: Testing fvar[2] = var 0
DEBUG CAREFUL: Calling compare_branch_vars for var 0
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 0
DEBUG CAREFUL: Testing fvar[3] = var 29
DEBUG CAREFUL: Calling compare_branch_vars for var 29
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 29
DEBUG CAREFUL: Testing fvar[4] = var 32
DEBUG CAREFUL: Calling compare_branch_vars for var 32
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 32
DEBUG CAREFUL: New best var: 32
  % Initial guess is x32, Z0 = 28473880.8384809        , Z1 = 28560980.6662601        

DEBUG EVAL: Testing var 2 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=3, varin=76, theta=0.500000, up=1.000000
DEBUG EVAL: Branch var 2 = 0 gives z=28481688.724097
  % 	x2 = 0,	Z0 = 28481688.7240974        
DEBUG EVAL: First branch cutoff check: z=28481688.724097, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 1
ITER 1: row=3, varin=41, theta=1.000000, up=999999999999999983222784.000000
  % 	x2 = 1,	Z1 = 28484872.91074          
DEBUG EVAL: Second branch cutoff check: z=28484872.910740, best_z=INF, threshold=INF
  %   New best:  x2, Z = 28481688.7240974        
DEBUG EVAL: Testing var 1 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=2, varin=41, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 1 = 0 gives z=28484872.910740
  % 	x1 = 0,	Z0 = 28484872.91074          
DEBUG EVAL: First branch cutoff check: z=28484872.910740, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 1 = 1
ITER 1: row=2, varin=27, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=42, varin=35, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=3, varin=76, theta=1.000000, up=1.000000
  % 	x1 = 1,	Z1 = 28952221.1084872        
DEBUG EVAL: Second branch cutoff check: z=28952221.108487, best_z=INF, threshold=INF
  %   New best:  x1, Z = 28484872.91074          
DEBUG EVAL: Testing var 0 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=41, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 0 = 0 gives z=28484872.910740
  % 	x0 = 0,	Z0 = 28484872.91074          
DEBUG EVAL: First branch cutoff check: z=28484872.910740, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 0 = 1
ITER 1: row=1, varin=3, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=28, varin=4, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=36, varin=35, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=3, varin=76, theta=1.000000, up=1.000000
  % 	x0 = 1,	Z1 = 29108322.4968201        
DEBUG EVAL: Second branch cutoff check: z=29108322.496820, best_z=INF, threshold=INF
  %   New best:  x0, Z = 28484872.91074          
DEBUG EVAL: Testing var 29 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=14, varin=41, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 29 = 0 gives z=28484872.910740
  % 	x29 = 0,	Z0 = 28484872.91074          
DEBUG EVAL: First branch cutoff check: z=28484872.910740, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 29 = 1
ITER 1: row=14, varin=4, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=36, varin=27, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=42, varin=5, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=36, varin=41, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=3, varin=76, theta=1.000000, up=1.000000
  % 	x29 = 1,	Z1 = 29314309.1538699        
DEBUG EVAL: Second branch cutoff check: z=29314309.153870, best_z=INF, threshold=INF
  %   New best:  x29, Z = 28484872.91074          
DEBUG EVAL: Testing var 32 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=35, varin=41, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 32 = 1 gives z=28484872.910740
  % 	x32 = 1,	Z1 = 28560980.6662601        
DEBUG EVAL: First branch cutoff check: z=28560980.666260, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 32 = 0
ITER 1: row=35, varin=76, theta=0.500000, up=1.000000
  % 	x32 = 0,	Z0 = 28481688.7240974        
DEBUG EVAL: Second branch cutoff check: z=28481688.724097, best_z=INF, threshold=INF
  % Best branch is x29, Z0 = 28484872.91074          , Z1 = 29314309.1538699        

DEBUG CAREFUL: Final result - returning best.var = 29
DEBUG BB: Branching variable chosen: j=29
 % @NC  167  115	x29 = 0	28484872.910740
 % @NC  168  115	x29 = 1	29314309.153870
 %     115    79 28473880.8385               28474055.7326   x26 D   104    12
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cb66c0
% @LO 0.10  28.47388083848087703132 99.9000000000
% @LN 0.10  28.47405573255760913298 99.9000000000
% Resuming node 149 at  28.47405573255760913298
DEBUG CONSTRNT: LP rows=42, pool->nlprows=42, pool->npend=0
DEBUG CONSTRNT: Checking 42 LP rows (pool tracks 42, total LP rows 42)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 142
DEBUG CONSTRNT: Pool row 142 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 143
DEBUG CONSTRNT: Pool row 143 has lprow=41, expected 41
 % @PAP adding 42 rows, 177 nz to LP
DEBUG BB: Processing node 149, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=30, varin=37, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 28474055.732558
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 42 rows, 60 cols, 237 nonzeros, 1 slack, 41 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=43, varin=41, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28480950.188775
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 44 rows, 60 cols, 243 nonzeros, 2 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 2 rows, 5 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=43, varin=18, theta=1.166667, up=999999999999999983222784.000000
ITER 2: row=15, varin=70, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28488868.826641
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 44 rows, 60 cols, 244 nonzeros, 0 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 5 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=45, varin=36, theta=0.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 28491942.261034
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 45 rows, 60 cols, 249 nonzeros, 2 slack, 43 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % Node 149 LP 1 Solution, length = 28491942.261034, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.500000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.500000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.500000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.500000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.500000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 1.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.500000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.500000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.500000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.500000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.500000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.500000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28491942.261034, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 149 at  28.49194226103409377515
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cc9ac0
% @LO 0.10  28.47405573255760913298 99.9000000000
% @LN 0.10  28.47441395419713217052 99.9000000000
% Resuming node 145 at  28.47441395419713217052
DEBUG CONSTRNT: LP rows=43, pool->nlprows=43, pool->npend=0
DEBUG CONSTRNT: Checking 43 LP rows (pool tracks 43, total LP rows 43)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 142
DEBUG CONSTRNT: Pool row 142 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 143
DEBUG CONSTRNT: Pool row 143 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=42, expected 42
 % @PAP adding 41 rows, 157 nz to LP
DEBUG BB: Processing node 145, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 145 LP 2 Solution, length = 28474413.954197, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.166667 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.166667 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.166667 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.500000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.500000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.166667 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.166667 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.833333 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.833333 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.500000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.500000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.833333 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.833333 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.833333 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.833333 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.500000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.833333 (terminal 19)
 % 7 fractional variables
DEBUG CG: LP optimal, z=28474413.954197, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28474413.954197, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 145 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 145
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.166667
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.166667
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=1.000000
DEBUG CAREFUL: Skipping var 5: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.166667
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.500000
DEBUG CAREFUL: Adding var 12 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.500000
DEBUG CAREFUL: Adding var 14 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.166667
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.166667
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 7 fractional variables

  %  Carefully choosing branching variable, nfrac = 7
DEBUG CAREFUL: Testing fvar[0] = var 12
DEBUG CAREFUL: Calling compare_branch_vars for var 12
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 12
DEBUG CAREFUL: New best var: 12
DEBUG CAREFUL: Testing fvar[1] = var 14
DEBUG CAREFUL: Calling compare_branch_vars for var 14
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 14
DEBUG CAREFUL: Testing fvar[2] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 17
DEBUG CAREFUL: New best var: 17
DEBUG CAREFUL: Testing fvar[3] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[4] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[5] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 3
DEBUG CAREFUL: New best var: 3
DEBUG CAREFUL: Testing fvar[6] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
  % Initial guess is x3, Z0 = 28474413.9541971        , Z1 = 28731456.7048434        

DEBUG EVAL: Testing var 12 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=7, varin=22, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=37, varin=23, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 12 = 1 gives z=28936535.680801
  % 	x12 = 1,	Z1 = 28936535.6808012        
DEBUG EVAL: First branch cutoff check: z=28936535.680801, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 12 = 0
ITER 1: row=7, varin=36, theta=1.000000, up=999999999999999983222784.000000
  % 	x12 = 0,	Z0 = 28488179.1692294        
DEBUG EVAL: Second branch cutoff check: z=28488179.169229, best_z=INF, threshold=INF
  %   New best:  x12, Z = 28488179.1692294        
DEBUG EVAL: Testing var 14 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=21, varin=36, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 14 = 1 gives z=28488179.169229
  % 	x14 = 1,	Z1 = 28488179.1692294        
DEBUG EVAL: First branch cutoff check: z=28488179.169229, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 14 = 0
ITER 1: row=21, varin=7, theta=1.000000, up=999999999999999983222784.000000
  % 	x14 = 0,	Z0 = 28685916.4905885        
DEBUG EVAL: Second branch cutoff check: z=28685916.490588, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 17 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=16, varin=38, theta=2.500000, up=999999999999999983222784.000000
ITER 2: row=38, varin=36, theta=5.000000, up=999999999999999983222784.000000
ITER 3: row=7, varin=33, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 17 = 1 gives z=28587524.554305
  % 	x17 = 1,	Z1 = 28587524.5543052        
DEBUG EVAL: First branch cutoff check: z=28587524.554305, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 17 = 0
ITER 1: row=16, varin=65, theta=0.500000, up=1.000000
ITER 2: row=41, varin=53, theta=0.250000, up=1.000000
  % 	x17 = 0,	Z0 = 28510781.6640105        
DEBUG EVAL: Second branch cutoff check: z=28510781.664011, best_z=INF, threshold=INF
  %   New best:  x17, Z = 28510781.6640105        
DEBUG EVAL: Testing var 2 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=65, theta=0.500000, up=1.000000
ITER 2: row=41, varin=53, theta=0.250000, up=1.000000
DEBUG EVAL: Branch var 2 = 0 gives z=28510781.664011
  % 	x2 = 0,	Z0 = 28510781.6640105        
DEBUG EVAL: First branch cutoff check: z=28510781.664011, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 1
ITER 1: row=1, varin=38, theta=2.500000, up=999999999999999983222784.000000
ITER 2: row=38, varin=17, theta=0.833333, up=999999999999999983222784.000000
  % 	x2 = 1,	Z1 = 28504224.8349913        
DEBUG EVAL: Second branch cutoff check: z=28504224.834991, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 10 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=8, varin=38, theta=2.500000, up=999999999999999983222784.000000
ITER 2: row=38, varin=36, theta=5.000000, up=999999999999999983222784.000000
ITER 3: row=7, varin=29, theta=0.666667, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 1 gives z=28573260.007513
  % 	x10 = 1,	Z1 = 28573260.0075131        
DEBUG EVAL: First branch cutoff check: z=28573260.007513, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 0
ITER 1: row=8, varin=11, theta=0.250000, up=999999999999999983222784.000000
  % 	x10 = 0,	Z0 = 28501994.5075453        
DEBUG EVAL: Second branch cutoff check: z=28501994.507545, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 3 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=14, varin=38, theta=2.500000, up=999999999999999983222784.000000
ITER 2: row=38, varin=36, theta=5.000000, up=999999999999999983222784.000000
ITER 3: row=7, varin=9, theta=2.000000, up=999999999999999983222784.000000
ITER 4: row=9, varin=16, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=34, varin=30, theta=2.000000, up=999999999999999983222784.000000
ITER 6: row=30, varin=17, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=35, varin=25, theta=1.000000, up=999999999999999983222784.000000
ITER 8: row=39, varin=2, theta=0.400000, up=999999999999999983222784.000000
ITER 9: row=25, varin=18, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 3 = 1 gives z=28731456.704843
  % 	x3 = 1,	Z1 = 28731456.7048434        
DEBUG EVAL: First branch cutoff check: z=28731456.704843, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 3 = 0
ITER 1: row=14, varin=65, theta=0.500000, up=1.000000
ITER 2: row=41, varin=53, theta=0.250000, up=1.000000
  % 	x3 = 0,	Z0 = 28510781.6640105        
DEBUG EVAL: Second branch cutoff check: z=28510781.664011, best_z=INF, threshold=INF
  %   New best:  x3, Z = 28510781.6640105        
DEBUG EVAL: Testing var 26 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=30, varin=38, theta=2.500000, up=999999999999999983222784.000000
ITER 2: row=38, varin=36, theta=5.000000, up=999999999999999983222784.000000
ITER 3: row=7, varin=29, theta=0.666667, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 26 = 1 gives z=28573260.007513
  % 	x26 = 1,	Z1 = 28573260.0075131        
DEBUG EVAL: First branch cutoff check: z=28573260.007513, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 26 = 0
ITER 1: row=30, varin=30, theta=0.250000, up=999999999999999983222784.000000
  % 	x26 = 0,	Z0 = 28492974.0686258        
DEBUG EVAL: Second branch cutoff check: z=28492974.068626, best_z=INF, threshold=INF
  % Best branch is x3, Z0 = 28510781.6640105        , Z1 = 28731456.7048434        

DEBUG CAREFUL: Final result - returning best.var = 3
DEBUG BB: Branching variable chosen: j=3
 % @NC  169  145	x3 = 0	28510781.664011
 % @NC  170  145	x3 = 1	28731456.704843
 %     145    80 28474413.9542               28475644.7156   x34 D   141     9
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cb6780
% @LO 0.10  28.47441395419713217052 99.9000000000
% @LN 0.10  28.47564471556473364444 99.9000000000
% Resuming node 36 at  28.47564471556473364444
DEBUG CONSTRNT: LP rows=41, pool->nlprows=41, pool->npend=0
DEBUG CONSTRNT: Checking 41 LP rows (pool tracks 41, total LP rows 41)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=40, expected 40
 % @PAP adding 42 rows, 174 nz to LP
DEBUG BB: Processing node 36, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=21, varin=39, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=39, varin=24, theta=2.000000, up=999999999999999983222784.000000
ITER 3: row=41, varin=36, theta=2.000000, up=999999999999999983222784.000000
ITER 4: row=36, varin=17, theta=2.000000, up=999999999999999983222784.000000
ITER 5: row=17, varin=33, theta=2.000000, up=999999999999999983222784.000000
ITER 6: row=33, varin=25, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=42, varin=29, theta=1.000000, up=999999999999999983222784.000000
ITER 8: row=37, varin=26, theta=0.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=8)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 28475644.715565
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 42 rows, 60 cols, 234 nonzeros, 6 slack, 36 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 55 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=46, varin=19, theta=1.954862, up=999999999999999983222784.000000
ITER 2: row=16, varin=73, theta=1.419444, up=1.000000
ITER 3: row=16, varin=71, theta=0.466198, up=1.000000
ITER 4: row=33, varin=73, theta=1.000000, up=1.000000
ITER 5: row=38, varin=70, theta=1.324212, up=1.000000
ITER 6: row=38, varin=76, theta=0.380613, up=1.000000
ITER 7: row=39, varin=38, theta=1.000000, up=999999999999999983222784.000000
ITER 8: row=16, varin=70, theta=1.000000, up=1.000000
ITER 9: row=32, varin=74, theta=1.495496, up=1.000000
ITER 10: row=32, varin=68, theta=0.415429, up=1.000000
LP PHASE: Switching to primal (iter=20)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=46)
DEBUG SOLUTION: LP solution array indices: FST[47-86], not_covered[87-106]
DEBUG SOLUTION: lp->best_solution[0] = 29102694.926982
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 46 rows, 60 cols, 289 nonzeros, 6 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 6 slack rows
  % @PAP adding 5 rows, 17 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=41, varin=60, theta=0.741086, up=1.000000
ITER 2: row=19, varin=75, theta=1.176390, up=1.000000
ITER 3: row=19, varin=74, theta=0.112010, up=1.000000
ITER 4: row=43, varin=16, theta=0.543469, up=999999999999999983222784.000000
ITER 5: row=45, varin=73, theta=0.500000, up=1.000000
ITER 6: row=18, varin=21, theta=0.173725, up=999999999999999983222784.000000
ITER 7: row=21, varin=45, theta=0.843655, up=999999999999999983222784.000000
ITER 8: row=19, varin=102, theta=0.068707, up=1.000000
LP PHASE: Switching to primal (iter=8)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 29392790.555718
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.800000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 45 rows, 60 cols, 294 nonzeros, 5 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % @PAP adding 5 rows, 14 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=42, varin=75, theta=1.000000, up=1.000000
ITER 2: row=45, varin=74, theta=1.000000, up=1.000000
ITER 3: row=19, varin=18, theta=1.447498, up=999999999999999983222784.000000
ITER 4: row=11, varin=22, theta=0.902882, up=999999999999999983222784.000000
ITER 5: row=22, varin=17, theta=3.129106, up=999999999999999983222784.000000
ITER 6: row=17, varin=71, theta=1.490088, up=1.000000
ITER 7: row=17, varin=77, theta=6.475173, up=1.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 999999999999999983222784.000000
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.800000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 45 rows, 60 cols, 296 nonzeros, 4 slack, 41 tight.
  % Node 36 LP 1 Solution, length = 999999999999999983222784.000000, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.065646 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 1.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.137415 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.065646 (FST 27)
  % DEBUG LP_VARS: x[28] = 1.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 1.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.800000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.934354 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 0.931293 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
DEBUG BB: compute_good_lower_bound returned status=1
DEBUG BB: Node 36 is INFEASIBLE
 %      36    79    infeasible               28479208.9784   x11 U    23     6
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cac0a0
% @LO 0.10  28.47564471556473364444 99.9000000000
% @LN 0.10  28.47920897836184650487 99.9000000000
% Resuming node 163 at  28.47920897836184650487
DEBUG CONSTRNT: LP rows=45, pool->nlprows=45, pool->npend=0
DEBUG CONSTRNT: Checking 45 LP rows (pool tracks 45, total LP rows 45)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 145
DEBUG CONSTRNT: Pool row 145 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 159
DEBUG CONSTRNT: Pool row 159 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=44, expected 44
 % @PAP adding 43 rows, 182 nz to LP
DEBUG BB: Processing node 163, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=14, varin=41, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 28479208.978362
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 43 rows, 60 cols, 242 nonzeros, 3 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 42 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=45, varin=75, theta=0.322038, up=1.000000
ITER 2: row=44, varin=45, theta=229448.500000, up=999999999999999983222784.000000
ITER 3: row=31, varin=90, theta=0.129957, up=1.000000
ITER 4: row=39, varin=37, theta=0.129426, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
ITER 5: row=4, varin=73, theta=0.500000, up=1.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 28496931.848579
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 45 rows, 60 cols, 284 nonzeros, 4 slack, 41 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % Node 163 LP 1 Solution, length = 28496931.848579, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.500000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.500000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 1.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 1.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.500000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.500000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.500000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.500000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.500000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.500000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.500000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.500000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.500000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.500000 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28496931.848579, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 163 at  28.49693184857946803845
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cbfd10
% @LO 0.10  28.47920897836184650487 99.9000000000
% @LN 0.10  28.47957548333349819814 99.9000000000
% Resuming node 68 at  28.47957548333349819814
DEBUG CONSTRNT: LP rows=41, pool->nlprows=41, pool->npend=0
DEBUG CONSTRNT: Checking 41 LP rows (pool tracks 41, total LP rows 41)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 49
DEBUG CONSTRNT: Pool row 49 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 82
DEBUG CONSTRNT: Pool row 82 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 158
DEBUG CONSTRNT: Pool row 158 has lprow=40, expected 40
 % @PAP adding 44 rows, 185 nz to LP
DEBUG BB: Processing node 68, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=17, varin=41, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=41, varin=36, theta=2.000000, up=999999999999999983222784.000000
ITER 3: row=36, varin=25, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=39, varin=32, theta=2.000000, up=999999999999999983222784.000000
ITER 5: row=32, varin=26, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=40, varin=28, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=42, varin=2, theta=0.400000, up=999999999999999983222784.000000
ITER 8: row=28, varin=34, theta=0.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=8)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28479575.483333
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 44 rows, 60 cols, 245 nonzeros, 6 slack, 38 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 3 rows, 14 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=45, varin=48, theta=0.600000, up=1.000000
ITER 2: row=28, varin=74, theta=1.000000, up=1.000000
ITER 3: row=32, varin=49, theta=1.500000, up=1.000000
ITER 4: row=32, varin=84, theta=0.333333, up=1.000000
ITER 5: row=2, varin=49, theta=1.000000, up=1.000000
ITER 6: row=36, varin=72, theta=1.000000, up=1.000000
ITER 7: row=43, varin=71, theta=1.000000, up=1.000000
ITER 8: row=37, varin=59, theta=0.500000, up=1.000000
ITER 9: row=47, varin=52, theta=0.500000, up=1.000000
ITER 10: row=46, varin=77, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=12)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 28783403.686744
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 47 rows, 60 cols, 259 nonzeros, 3 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=45, varin=39, theta=0.666667, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 28787940.452025
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 45 rows, 60 cols, 255 nonzeros, 3 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 4 rows, 9 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=43, varin=62, theta=1.000000, up=1.000000
ITER 2: row=9, varin=79, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=46)
DEBUG SOLUTION: LP solution array indices: FST[47-86], not_covered[87-106]
DEBUG SOLUTION: lp->best_solution[0] = 28848738.747906
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 46 rows, 60 cols, 253 nonzeros, 1 slack, 45 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 2 rows, 7 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=46, varin=69, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 28849528.339758
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 47 rows, 60 cols, 258 nonzeros, 0 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 16 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=48, varin=28, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 28855633.204123
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 51 rows, 60 cols, 274 nonzeros, 2 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % Node 68 LP 1 Solution, length = 28855633.204123, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.500000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.500000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 1.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 1.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.500000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.500000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.500000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.500000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.500000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.500000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=28855633.204123, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 68 at  28.85563320412330767795
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cc24b0
% @LO 0.10  28.47957548333349819814 99.9000000000
% @LN 0.10  28.48009313519293073114 99.9000000000
% Resuming node 165 at  28.48009313519293073114
DEBUG CONSTRNT: LP rows=49, pool->nlprows=49, pool->npend=0
DEBUG CONSTRNT: Checking 49 LP rows (pool tracks 49, total LP rows 49)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 65
DEBUG CONSTRNT: Pool row 65 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 133
DEBUG CONSTRNT: Pool row 133 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 121
DEBUG CONSTRNT: Pool row 121 has lprow=48, expected 48
 % @PAP adding 33 rows, 137 nz to LP
DEBUG BB: Processing node 165, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=30, varin=31, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=33)
DEBUG SOLUTION: LP solution array indices: FST[34-73], not_covered[74-93]
DEBUG SOLUTION: lp->best_solution[0] = 28480093.135193
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 33 rows, 60 cols, 197 nonzeros, 3 slack, 30 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 18 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=34, varin=72, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=35)
DEBUG SOLUTION: LP solution array indices: FST[36-75], not_covered[76-95]
DEBUG SOLUTION: lp->best_solution[0] = 28483148.791838
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 35 rows, 60 cols, 215 nonzeros, 3 slack, 32 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 2 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=33, varin=30, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=34)
DEBUG SOLUTION: LP solution array indices: FST[35-74], not_covered[75-94]
DEBUG SOLUTION: lp->best_solution[0] = 28485154.391732
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 34 rows, 60 cols, 216 nonzeros, 1 slack, 33 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 2 rows, 11 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=34, varin=39, theta=0.250000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=35)
DEBUG SOLUTION: LP solution array indices: FST[36-75], not_covered[76-95]
DEBUG SOLUTION: lp->best_solution[0] = 28485313.296057
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 35 rows, 60 cols, 225 nonzeros, 1 slack, 34 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 6 rows, 31 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=35, varin=28, theta=0.166667, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=40)
DEBUG SOLUTION: LP solution array indices: FST[41-80], not_covered[81-100]
DEBUG SOLUTION: lp->best_solution[0] = 28488879.432755
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 40 rows, 60 cols, 247 nonzeros, 5 slack, 35 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % Node 165 LP 1 Solution, length = 28488879.432755, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.166667 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.166667 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.500000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.500000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 1.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.166667 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.500000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.833333 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.833333 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.500000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.833333 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.500000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.833333 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.500000 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28488879.432755, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 165 at  28.48887943275505563179
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cc2570
% @LO 0.10  28.48009313519293073114 99.9000000000
% @LN 0.10  28.48425710112432440724 99.9000000000
% Resuming node 147 at  28.48425710112432440724
DEBUG CONSTRNT: LP rows=35, pool->nlprows=35, pool->npend=0
DEBUG CONSTRNT: Checking 35 LP rows (pool tracks 35, total LP rows 35)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=34, expected 34
 % @PAP adding 40 rows, 157 nz to LP
DEBUG BB: Processing node 147, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=14, varin=64, theta=0.500000, up=1.000000
ITER 2: row=40, varin=52, theta=0.250000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=40)
DEBUG SOLUTION: LP solution array indices: FST[41-80], not_covered[81-100]
DEBUG SOLUTION: lp->best_solution[0] = 28484257.101124
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 40 rows, 60 cols, 217 nonzeros, 0 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 6 rows, 34 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=41, varin=33, theta=0.166667, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=46)
DEBUG SOLUTION: LP solution array indices: FST[47-86], not_covered[87-106]
DEBUG SOLUTION: lp->best_solution[0] = 28488692.095366
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 46 rows, 60 cols, 251 nonzeros, 6 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 6 slack rows
  % Node 147 LP 1 Solution, length = 28488692.095366, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.166667 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.166667 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.166667 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.500000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.500000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.166667 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.166667 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.833333 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.833333 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.500000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.500000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.833333 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.833333 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.833333 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.833333 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.500000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.833333 (terminal 19)
 % 7 fractional variables
DEBUG CG: LP optimal, z=28488692.095366, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 147 at  28.48869209536583468889
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7ccf030
% @LO 0.10  28.48425710112432440724 99.9000000000
% @LN 0.10  28.48487291074002669689 99.9000000000
% Resuming node 167 at  28.48487291074002669689
DEBUG CONSTRNT: LP rows=40, pool->nlprows=40, pool->npend=0
DEBUG CONSTRNT: Checking 40 LP rows (pool tracks 40, total LP rows 40)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=39, expected 39
 % @PAP adding 42 rows, 175 nz to LP
DEBUG BB: Processing node 167, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=14, varin=41, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 28484872.910740
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 42 rows, 60 cols, 235 nonzeros, 2 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 7 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=43, varin=78, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28500488.681973
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 44 rows, 60 cols, 242 nonzeros, 2 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 4 rows, 14 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=43, varin=77, theta=1.000000, up=1.000000
ITER 2: row=42, varin=3, theta=0.250000, up=999999999999999983222784.000000
ITER 3: row=46, varin=35, theta=0.250000, up=999999999999999983222784.000000
ITER 4: row=28, varin=46, theta=0.333333, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=46)
DEBUG SOLUTION: LP solution array indices: FST[47-86], not_covered[87-106]
DEBUG SOLUTION: lp->best_solution[0] = 28536200.175465
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 46 rows, 60 cols, 251 nonzeros, 5 slack, 41 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % Node 167 LP 1 Solution, length = 28536200.175465, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.333333 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.333333 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.333333 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 1.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 1.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.333333 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.333333 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.333333 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.666667 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.666667 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.666667 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.666667 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.666667 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.666667 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28536200.175465, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 167 at  28.53620017546495901684
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cdc750
% @LO 0.10  28.48487291074002669689 99.9000000000
% @LN 0.10  28.48709000079187347865 99.9000000000
% Resuming node 125 at  28.48709000079187347865
DEBUG CONSTRNT: LP rows=41, pool->nlprows=41, pool->npend=0
DEBUG CONSTRNT: Checking 41 LP rows (pool tracks 41, total LP rows 41)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=40, expected 40
 % @PAP adding 40 rows, 167 nz to LP
DEBUG BB: Processing node 125, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=15, varin=47, theta=0.500000, up=1.000000
ITER 2: row=25, varin=64, theta=1.000000, up=1.000000
ITER 3: row=40, varin=52, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=40)
DEBUG SOLUTION: LP solution array indices: FST[41-80], not_covered[81-100]
DEBUG SOLUTION: lp->best_solution[0] = 28487090.000792
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
  % @PL 40 rows, 60 cols, 227 nonzeros, 0 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 6 rows, 34 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=41, varin=34, theta=0.333333, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=46)
DEBUG SOLUTION: LP solution array indices: FST[47-86], not_covered[87-106]
DEBUG SOLUTION: lp->best_solution[0] = 28495959.989275
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
  % @PL 46 rows, 60 cols, 261 nonzeros, 6 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 6 slack rows
  % Node 125 LP 1 Solution, length = 28495959.989275, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.333333 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.333333 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.333333 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 1.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.333333 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.333333 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.666667 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.666667 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.666667 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.666667 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.666667 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.666667 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.666667 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28495959.989275, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 125 at  28.49595998927489759467
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cdaf50
% @LO 0.10  28.48709000079187347865 99.9000000000
% @LN 0.10  28.48748979329577224462 99.9000000000
% Resuming node 153 at  28.48748979329577224462
DEBUG CONSTRNT: LP rows=40, pool->nlprows=40, pool->npend=0
DEBUG CONSTRNT: Checking 40 LP rows (pool tracks 40, total LP rows 40)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=39, expected 39
 % @PAP adding 42 rows, 203 nz to LP
DEBUG BB: Processing node 153, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=16, varin=20, theta=0.333333, up=999999999999999983222784.000000
ITER 2: row=13, varin=42, theta=155846.333333, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 28487489.793296
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.666667
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 42 rows, 60 cols, 263 nonzeros, 3 slack, 39 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 5 rows, 16 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=44, varin=35, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=42, varin=58, theta=0.515336, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 28500877.733245
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 47 rows, 60 cols, 279 nonzeros, 4 slack, 43 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=44, varin=76, theta=0.297293, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28503724.951225
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 44 rows, 60 cols, 271 nonzeros, 0 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 153 LP 1 Solution, length = 28503724.951225, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.702707 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.702707 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.702707 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.702707 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.297293 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.297293 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.297293 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.297293 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.297293 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.297293 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.297293 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.297293 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28503724.951225, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 153 at  28.50372495122535454470
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cc2570
% @LO 0.10  28.48748979329577224462 99.9000000000
% @LN 0.10  28.48869209536583468889 99.9000000000
% Resuming node 147 at  28.48869209536583468889
DEBUG CONSTRNT: LP rows=44, pool->nlprows=44, pool->npend=0
DEBUG CONSTRNT: Checking 44 LP rows (pool tracks 44, total LP rows 44)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=43, expected 43
 % @PAP adding 40 rows, 157 nz to LP
DEBUG BB: Processing node 147, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 147 LP 2 Solution, length = 28488692.095366, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.166667 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.166667 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.166667 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.500000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.500000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.166667 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.166667 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.833333 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.833333 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.500000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.500000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.833333 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.833333 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.833333 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.833333 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.500000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.833333 (terminal 19)
 % 7 fractional variables
DEBUG CG: LP optimal, z=28488692.095366, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28488692.095366, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 147 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 147
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.166667
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=1.000000
DEBUG CAREFUL: Skipping var 7: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.166667
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.166667
DEBUG CAREFUL: Adding var 11 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.500000
DEBUG CAREFUL: Adding var 12 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.500000
DEBUG CAREFUL: Adding var 14 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.166667
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.166667
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 7 fractional variables

  %  Carefully choosing branching variable, nfrac = 7
DEBUG CAREFUL: Testing fvar[0] = var 12
DEBUG CAREFUL: Calling compare_branch_vars for var 12
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 12
DEBUG CAREFUL: New best var: 12
DEBUG CAREFUL: Testing fvar[1] = var 14
DEBUG CAREFUL: Calling compare_branch_vars for var 14
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 14
DEBUG CAREFUL: Testing fvar[2] = var 11
DEBUG CAREFUL: Calling compare_branch_vars for var 11
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 11
DEBUG CAREFUL: New best var: 11
DEBUG CAREFUL: Testing fvar[3] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[4] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[5] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[6] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
  % Initial guess is x11, Z0 = 28488692.0953658        , Z1 = 28750720.2116157        

DEBUG EVAL: Testing var 12 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=7, varin=23, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 12 = 1 gives z=28753673.055207
  % 	x12 = 1,	Z1 = 28753673.0552066        
DEBUG EVAL: First branch cutoff check: z=28753673.055207, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 12 = 0
ITER 1: row=7, varin=33, theta=1.000000, up=999999999999999983222784.000000
  % 	x12 = 0,	Z0 = 28543260.014453         
DEBUG EVAL: Second branch cutoff check: z=28543260.014453, best_z=INF, threshold=INF
  %   New best:  x12, Z = 28543260.014453         
DEBUG EVAL: Testing var 14 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=21, varin=33, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 14 = 1 gives z=28543260.014453
  % 	x14 = 1,	Z1 = 28543260.014453         
DEBUG EVAL: First branch cutoff check: z=28543260.014453, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 14 = 0
ITER 1: row=21, varin=7, theta=1.000000, up=999999999999999983222784.000000
  % 	x14 = 0,	Z0 = 28740997.3358121        
DEBUG EVAL: Second branch cutoff check: z=28740997.335812, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 11 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=14, varin=37, theta=2.500000, up=999999999999999983222784.000000
ITER 2: row=37, varin=17, theta=2.500000, up=999999999999999983222784.000000
ITER 3: row=39, varin=34, theta=2.500000, up=999999999999999983222784.000000
ITER 4: row=34, varin=33, theta=5.000000, up=999999999999999983222784.000000
ITER 5: row=7, varin=30, theta=2.000000, up=999999999999999983222784.000000
ITER 6: row=30, varin=18, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=40, varin=25, theta=1.000000, up=999999999999999983222784.000000
ITER 8: row=35, varin=29, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 11 = 1 gives z=28931707.488448
  % 	x11 = 1,	Z1 = 28931707.4884475        
DEBUG EVAL: First branch cutoff check: z=28931707.488448, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 11 = 0
ITER 1: row=14, varin=45, theta=0.250000, up=1.000000
  % 	x11 = 0,	Z0 = 28490438.7714439        
DEBUG EVAL: Second branch cutoff check: z=28490438.771444, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 17 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=16, varin=38, theta=1.250000, up=999999999999999983222784.000000
ITER 2: row=14, varin=37, theta=0.500000, up=999999999999999983222784.000000
ITER 3: row=37, varin=34, theta=0.500000, up=999999999999999983222784.000000
ITER 4: row=34, varin=33, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 17 = 1 gives z=28560999.991419
  % 	x17 = 1,	Z1 = 28560999.991419         
DEBUG EVAL: First branch cutoff check: z=28560999.991419, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 17 = 0
ITER 1: row=16, varin=45, theta=0.250000, up=1.000000
  % 	x17 = 0,	Z0 = 28490438.7714439        
DEBUG EVAL: Second branch cutoff check: z=28490438.771444, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 2 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=45, theta=0.250000, up=1.000000
DEBUG EVAL: Branch var 2 = 0 gives z=28490438.771444
  % 	x2 = 0,	Z0 = 28490438.7714439        
DEBUG EVAL: First branch cutoff check: z=28490438.771444, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 10 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=10, varin=38, theta=1.250000, up=999999999999999983222784.000000
ITER 2: row=14, varin=37, theta=0.500000, up=999999999999999983222784.000000
ITER 3: row=37, varin=34, theta=0.500000, up=999999999999999983222784.000000
ITER 4: row=34, varin=33, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 1 gives z=28560999.991419
  % 	x10 = 1,	Z1 = 28560999.991419         
DEBUG EVAL: First branch cutoff check: z=28560999.991419, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 0
ITER 1: row=10, varin=45, theta=0.250000, up=1.000000
  % 	x10 = 0,	Z0 = 28490438.7714439        
DEBUG EVAL: Second branch cutoff check: z=28490438.771444, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 26 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=30, varin=45, theta=0.250000, up=1.000000
DEBUG EVAL: Branch var 26 = 0 gives z=28490438.771444
  % 	x26 = 0,	Z0 = 28490438.7714439        
DEBUG EVAL: First branch cutoff check: z=28490438.771444, best_z=INF, threshold=INF
  % Best branch is x12, Z0 = 28543260.014453         , Z1 = 28753673.0552066        

DEBUG CAREFUL: Final result - returning best.var = 12
DEBUG BB: Branching variable chosen: j=12
 % @NC  171  147	x12 = 0	28543260.014453
 % @NC  172  147	x12 = 1	28753673.055207
 %     147    80 28488692.0954               28488879.4328    x3 D   127     7
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cc24b0
% @LO 0.10  28.48869209536583468889 99.9000000000
% @LN 0.10  28.48887943275505563179 99.9000000000
% Resuming node 165 at  28.48887943275505563179
DEBUG CONSTRNT: LP rows=40, pool->nlprows=40, pool->npend=0
DEBUG CONSTRNT: Checking 40 LP rows (pool tracks 40, total LP rows 40)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=39, expected 39
 % @PAP adding 35 rows, 158 nz to LP
DEBUG BB: Processing node 165, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 165 LP 2 Solution, length = 28488879.432755, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.166667 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.166667 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.500000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.500000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 1.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.166667 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.500000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.833333 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.833333 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.500000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.833333 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.500000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.833333 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.500000 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28488879.432755, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28488879.432755, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 165 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 165
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.166667
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.166667
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.500000
DEBUG CAREFUL: Adding var 9 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.500000
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=1.000000
DEBUG CAREFUL: Skipping var 14: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.166667
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.500000
DEBUG CAREFUL: Adding var 34 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 6 fractional variables

  %  Carefully choosing branching variable, nfrac = 6
DEBUG CAREFUL: Testing fvar[0] = var 9
DEBUG CAREFUL: Calling compare_branch_vars for var 9
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 9
DEBUG CAREFUL: New best var: 9
DEBUG CAREFUL: Testing fvar[1] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[2] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 17
DEBUG CAREFUL: New best var: 17
DEBUG CAREFUL: Testing fvar[3] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[4] = var 34
DEBUG CAREFUL: Calling compare_branch_vars for var 34
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 34
DEBUG CAREFUL: Testing fvar[5] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 3
DEBUG CAREFUL: New best var: 3
  % Initial guess is x3, Z0 = 28488879.4327551        , Z1 = 28645139.6680767        

DEBUG EVAL: Testing var 9 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=19, varin=28, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 9 = 0 gives z=28497665.730317
  % 	x9 = 0,	Z0 = 28497665.7303172        
DEBUG EVAL: First branch cutoff check: z=28497665.730317, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 9 = 1
ITER 1: row=19, varin=32, theta=1.000000, up=999999999999999983222784.000000
  % 	x9 = 1,	Z1 = 28492604.4737782        
DEBUG EVAL: Second branch cutoff check: z=28492604.473778, best_z=INF, threshold=INF
  %   New best:  x9, Z = 28492604.4737782        
DEBUG EVAL: Testing var 2 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=60, theta=0.500000, up=1.000000
DEBUG EVAL: Branch var 2 = 0 gives z=28508867.903325
  % 	x2 = 0,	Z0 = 28508867.9033251        
DEBUG EVAL: First branch cutoff check: z=28508867.903325, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 1
ITER 1: row=1, varin=33, theta=1.250000, up=999999999999999983222784.000000
ITER 2: row=11, varin=32, theta=1.000000, up=999999999999999983222784.000000
  % 	x2 = 1,	Z1 = 28506869.0205703        
DEBUG EVAL: Second branch cutoff check: z=28506869.020570, best_z=INF, threshold=INF
  %   New best:  x2, Z = 28506869.0205703        
DEBUG EVAL: Testing var 17 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=13, varin=33, theta=1.250000, up=999999999999999983222784.000000
ITER 2: row=11, varin=32, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 17 = 1 gives z=28506869.020570
  % 	x17 = 1,	Z1 = 28506869.0205703        
DEBUG EVAL: First branch cutoff check: z=28506869.020570, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 17 = 0
ITER 1: row=13, varin=60, theta=0.500000, up=1.000000
  % 	x17 = 0,	Z0 = 28508867.9033251        
DEBUG EVAL: Second branch cutoff check: z=28508867.903325, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 10 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=8, varin=28, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 0 gives z=28497665.730317
  % 	x10 = 0,	Z0 = 28497665.7303172        
DEBUG EVAL: First branch cutoff check: z=28497665.730317, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 34 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=28, varin=32, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 34 = 0 gives z=28492604.473778
  % 	x34 = 0,	Z0 = 28492604.4737782        
DEBUG EVAL: First branch cutoff check: z=28492604.473778, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 3 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=11, varin=32, theta=5.000000, up=999999999999999983222784.000000
ITER 2: row=8, varin=30, theta=2.000000, up=999999999999999983222784.000000
ITER 3: row=30, varin=28, theta=2.000000, up=999999999999999983222784.000000
ITER 4: row=28, varin=24, theta=2.000000, up=999999999999999983222784.000000
ITER 5: row=2, varin=13, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=34, varin=14, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=35, varin=2, theta=1.000000, up=999999999999999983222784.000000
ITER 8: row=24, varin=15, theta=0.666667, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 3 = 1 gives z=28767480.882787
  % 	x3 = 1,	Z1 = 28767480.8827872        
DEBUG EVAL: First branch cutoff check: z=28767480.882787, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 3 = 0
ITER 1: row=11, varin=33, theta=0.500000, up=999999999999999983222784.000000
  % 	x3 = 0,	Z0 = 28496011.7061511        
DEBUG EVAL: Second branch cutoff check: z=28496011.706151, best_z=INF, threshold=INF
  % Best branch is x2, Z0 = 28508867.9033251        , Z1 = 28506869.0205703        

DEBUG CAREFUL: Final result - returning best.var = 2
DEBUG BB: Branching variable chosen: j=2
 % @NC  173  165	x2 = 1	28506869.020570
 % @NC  174  165	x2 = 0	28508867.903325
 %     165    81 28488879.4328               28491942.2610   x26 D   151    10
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cb66c0
% @LO 0.10  28.48887943275505563179 99.9000000000
% @LN 0.10  28.49194226103409377515 99.9000000000
% Resuming node 149 at  28.49194226103409377515
DEBUG CONSTRNT: LP rows=35, pool->nlprows=35, pool->npend=0
DEBUG CONSTRNT: Checking 35 LP rows (pool tracks 35, total LP rows 35)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=34, expected 34
 % @PAP adding 43 rows, 183 nz to LP
DEBUG BB: Processing node 149, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 149 LP 2 Solution, length = 28491942.261034, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.500000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.500000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.500000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.500000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.500000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 1.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.500000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.500000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.500000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.500000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.500000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.500000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28491942.261034, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28491942.261034, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 149 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 149
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.500000
DEBUG CAREFUL: Adding var 0 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.500000
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.500000
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.500000
DEBUG CAREFUL: Adding var 29 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.500000
DEBUG CAREFUL: Adding var 32 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=1.000000
DEBUG CAREFUL: Skipping var 34: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 1
DEBUG CAREFUL: New best var: 1
DEBUG CAREFUL: Testing fvar[1] = var 0
DEBUG CAREFUL: Calling compare_branch_vars for var 0
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 0
DEBUG CAREFUL: Testing fvar[2] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 2
DEBUG CAREFUL: New best var: 2
DEBUG CAREFUL: Testing fvar[3] = var 29
DEBUG CAREFUL: Calling compare_branch_vars for var 29
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 29
DEBUG CAREFUL: Testing fvar[4] = var 32
DEBUG CAREFUL: Calling compare_branch_vars for var 32
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 32
DEBUG CAREFUL: New best var: 32
  % Initial guess is x32, Z0 = 28491942.2610341        , Z1 = 28579042.0888133        

DEBUG EVAL: Testing var 1 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=2, varin=41, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 1 = 0 gives z=28502934.333293
  % 	x1 = 0,	Z0 = 28502934.3332932        
DEBUG EVAL: First branch cutoff check: z=28502934.333293, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 1 = 1
ITER 1: row=2, varin=20, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=42, varin=31, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=3, varin=58, theta=1.000000, up=1.000000
ITER 4: row=12, varin=77, theta=1.000000, up=1.000000
  % 	x1 = 1,	Z1 = 28970282.5310404        
DEBUG EVAL: Second branch cutoff check: z=28970282.531040, best_z=INF, threshold=INF
  %   New best:  x1, Z = 28502934.3332932        
DEBUG EVAL: Testing var 0 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=41, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 0 = 0 gives z=28502934.333293
  % 	x0 = 0,	Z0 = 28502934.3332932        
DEBUG EVAL: First branch cutoff check: z=28502934.333293, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 0 = 1
ITER 1: row=1, varin=3, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=21, varin=4, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=32, varin=31, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=3, varin=58, theta=1.000000, up=1.000000
ITER 5: row=12, varin=77, theta=1.000000, up=1.000000
  % 	x0 = 1,	Z1 = 29126383.9193733        
DEBUG EVAL: Second branch cutoff check: z=29126383.919373, best_z=INF, threshold=INF
  %   New best:  x0, Z = 28502934.3332932        
DEBUG EVAL: Testing var 2 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=3, varin=43, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=43, varin=15, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=14, varin=41, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 1 gives z=28502934.333293
  % 	x2 = 1,	Z1 = 28509828.7895106        
DEBUG EVAL: First branch cutoff check: z=28509828.789511, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 0
ITER 1: row=3, varin=58, theta=0.500000, up=1.000000
ITER 2: row=12, varin=77, theta=0.500000, up=1.000000
  % 	x2 = 0,	Z0 = 28499750.1466506        
DEBUG EVAL: Second branch cutoff check: z=28499750.146651, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 29 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=30, varin=41, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 29 = 0 gives z=28502934.333293
  % 	x29 = 0,	Z0 = 28502934.3332932        
DEBUG EVAL: First branch cutoff check: z=28502934.333293, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 29 = 1
ITER 1: row=30, varin=4, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=32, varin=20, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=42, varin=8, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=32, varin=41, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=3, varin=58, theta=1.000000, up=1.000000
ITER 6: row=12, varin=77, theta=1.000000, up=1.000000
  % 	x29 = 1,	Z1 = 29332370.5764231        
DEBUG EVAL: Second branch cutoff check: z=29332370.576423, best_z=INF, threshold=INF
  %   New best:  x29, Z = 28502934.3332932        
DEBUG EVAL: Testing var 32 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=31, varin=43, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=43, varin=15, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=14, varin=41, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 32 = 1 gives z=28502934.333293
  % 	x32 = 1,	Z1 = 28579042.0888133        
DEBUG EVAL: First branch cutoff check: z=28579042.088813, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 32 = 0
ITER 1: row=31, varin=58, theta=0.500000, up=1.000000
ITER 2: row=12, varin=77, theta=0.500000, up=1.000000
  % 	x32 = 0,	Z0 = 28499750.1466506        
DEBUG EVAL: Second branch cutoff check: z=28499750.146651, best_z=INF, threshold=INF
  % Best branch is x29, Z0 = 28502934.3332932        , Z1 = 29332370.5764231        

DEBUG CAREFUL: Final result - returning best.var = 29
DEBUG BB: Branching variable chosen: j=29
 % @NC  175  149	x29 = 0	28502934.333293
 % @NC  176  149	x29 = 1	29332370.576423
 %     149    82 28491942.2610               28492251.2027   x27 D    46    11
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cd9650
% @LO 0.10  28.49194226103409377515 99.9000000000
% @LN 0.10  28.49225120272802769250 99.9000000000
% Resuming node 70 at  28.49225120272802769250
DEBUG CONSTRNT: LP rows=43, pool->nlprows=43, pool->npend=0
DEBUG CONSTRNT: Checking 43 LP rows (pool tracks 43, total LP rows 43)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 142
DEBUG CONSTRNT: Pool row 142 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 143
DEBUG CONSTRNT: Pool row 143 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=42, expected 42
 % @PAP adding 44 rows, 185 nz to LP
DEBUG BB: Processing node 70, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=17, varin=3, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=3, varin=53, theta=1.000000, up=1.000000
ITER 3: row=10, varin=40, theta=2.000000, up=999999999999999983222784.000000
ITER 4: row=40, varin=28, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=43, varin=36, theta=2.000000, up=999999999999999983222784.000000
ITER 6: row=36, varin=29, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=44, varin=31, theta=1.000000, up=999999999999999983222784.000000
ITER 8: row=5, varin=2, theta=0.400000, up=999999999999999983222784.000000
ITER 9: row=31, varin=38, theta=0.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=9)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28492251.202728
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 44 rows, 60 cols, 245 nonzeros, 7 slack, 37 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 54 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=48, varin=49, theta=0.068224, up=1.000000
ITER 2: row=45, varin=48, theta=255262.400000, up=999999999999999983222784.000000
ITER 3: row=31, varin=75, theta=1.000000, up=1.000000
ITER 4: row=36, varin=93, theta=1.500000, up=1.000000
ITER 5: row=36, varin=85, theta=0.333333, up=1.000000
ITER 6: row=45, varin=93, theta=0.516243, up=1.000000
ITER 7: row=40, varin=55, theta=0.326420, up=1.000000
ITER 8: row=2, varin=48, theta=263312.000000, up=999999999999999983222784.000000
ITER 9: row=10, varin=72, theta=0.533843, up=1.000000
ITER 10: row=41, varin=6, theta=1.897983, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=14)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 28763322.567262
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 48 rows, 60 cols, 299 nonzeros, 5 slack, 43 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % @PAP adding 3 rows, 7 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=32, varin=5, theta=0.250000, up=999999999999999983222784.000000
ITER 2: row=44, varin=32, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=46)
DEBUG SOLUTION: LP solution array indices: FST[47-86], not_covered[87-106]
DEBUG SOLUTION: lp->best_solution[0] = 28766964.091180
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.500000
DEBUG SOLUTION: lp->best_solution[5] = 2.500000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 46 rows, 60 cols, 258 nonzeros, 4 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % @PAP adding 2 rows, 5 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=43, varin=25, theta=0.250000, up=999999999999999983222784.000000
ITER 2: row=44, varin=72, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28796079.406139
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 0.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 44 rows, 60 cols, 246 nonzeros, 0 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=45, varin=78, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 28861414.467300
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 0.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 45 rows, 60 cols, 248 nonzeros, 0 slack, 45 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 7 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=46, varin=69, theta=1.000000, up=1.000000
ITER 2: row=11, varin=3, theta=0.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 28868308.923518
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.500000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 0.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 47 rows, 60 cols, 255 nonzeros, 2 slack, 45 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % Node 70 LP 1 Solution, length = 28868308.923518, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.500000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.500000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 1.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 1.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 1.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.500000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.500000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.500000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.500000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.500000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.500000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=28868308.923518, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 70 at  28.86830892351783361960
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7caffe0
% @LO 0.10  28.49225120272802769250 99.9000000000
% @LN 0.10  28.49250695285765999643 99.9000000000
% Resuming node 95 at  28.49250695285765999643
DEBUG CONSTRNT: LP rows=45, pool->nlprows=45, pool->npend=0
DEBUG CONSTRNT: Checking 45 LP rows (pool tracks 45, total LP rows 45)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 133
DEBUG CONSTRNT: Pool row 133 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=44, expected 44
 % @PAP adding 43 rows, 172 nz to LP
DEBUG BB: Processing node 95, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 95 LP 2 Solution, length = 28492506.952858, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.500000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.500000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.500000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.500000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.500000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.500000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.500000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.500000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.500000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.500000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.500000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.500000 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28492506.952858, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28492506.952858, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 95 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 95
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.500000
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=1.000000
DEBUG CAREFUL: Skipping var 5: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.500000
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.500000
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.500000
DEBUG CAREFUL: Adding var 22 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.500000
DEBUG CAREFUL: Adding var 31 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 2
DEBUG CAREFUL: New best var: 2
DEBUG CAREFUL: Testing fvar[1] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[2] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[3] = var 22
DEBUG CAREFUL: Calling compare_branch_vars for var 22
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 22
DEBUG CAREFUL: Testing fvar[4] = var 31
DEBUG CAREFUL: Calling compare_branch_vars for var 31
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 31
  % Initial guess is x2, Z0 = 28492506.9528577        , Z1 = 28500366.009767         

DEBUG EVAL: Testing var 2 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=42, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 1 gives z=28500366.009767
  % 	x2 = 1,	Z1 = 28500366.009767         
DEBUG EVAL: First branch cutoff check: z=28500366.009767, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 0
ITER 1: row=1, varin=44, theta=0.333333, up=1.000000
  % 	x2 = 0,	Z0 = 28494007.092342         
DEBUG EVAL: Second branch cutoff check: z=28494007.092342, best_z=INF, threshold=INF
  %   New best:  x2, Z = 28494007.092342         
DEBUG EVAL: Testing var 10 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=12, varin=44, theta=0.333333, up=1.000000
DEBUG EVAL: Branch var 10 = 0 gives z=28494007.092342
  % 	x10 = 0,	Z0 = 28494007.092342         
DEBUG EVAL: First branch cutoff check: z=28494007.092342, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 1
ITER 1: row=12, varin=39, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=43, varin=33, theta=1.000000, up=999999999999999983222784.000000
  % 	x10 = 1,	Z1 = 28638178.7956044        
DEBUG EVAL: Second branch cutoff check: z=28638178.795604, best_z=INF, threshold=INF
  %   New best:  x10, Z = 28494007.092342         
DEBUG EVAL: Testing var 17 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=19, varin=44, theta=0.333333, up=1.000000
DEBUG EVAL: Branch var 17 = 0 gives z=28494007.092342
  % 	x17 = 0,	Z0 = 28494007.092342         
DEBUG EVAL: First branch cutoff check: z=28494007.092342, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 17 = 1
ITER 1: row=19, varin=39, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=43, varin=33, theta=1.000000, up=999999999999999983222784.000000
  % 	x17 = 1,	Z1 = 28638178.7956044        
DEBUG EVAL: Second branch cutoff check: z=28638178.795604, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 22 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=21, varin=44, theta=0.333333, up=1.000000
DEBUG EVAL: Branch var 22 = 0 gives z=28494007.092342
  % 	x22 = 0,	Z0 = 28494007.092342         
DEBUG EVAL: First branch cutoff check: z=28494007.092342, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 22 = 1
ITER 1: row=21, varin=39, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=43, varin=21, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=34, varin=22, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=21, varin=44, theta=0.666667, up=1.000000
  % 	x22 = 1,	Z1 = 29746503.443738         
DEBUG EVAL: Second branch cutoff check: z=29746503.443738, best_z=INF, threshold=INF
  %   New best:  x22, Z = 28494007.092342         
DEBUG EVAL: Testing var 31 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=33, varin=44, theta=0.333333, up=1.000000
DEBUG EVAL: Branch var 31 = 0 gives z=28494007.092342
  % 	x31 = 0,	Z0 = 28494007.092342         
DEBUG EVAL: First branch cutoff check: z=28494007.092342, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 31 = 1
ITER 1: row=33, varin=42, theta=1.000000, up=999999999999999983222784.000000
  % 	x31 = 1,	Z1 = 28500366.009767         
DEBUG EVAL: Second branch cutoff check: z=28500366.009767, best_z=INF, threshold=INF
  % Best branch is x22, Z0 = 28494007.092342         , Z1 = 29746503.443738         

DEBUG CAREFUL: Final result - returning best.var = 22
DEBUG BB: Branching variable chosen: j=22
 % @NC  177   95	x22 = 0	28494007.092342
 % @NC  178   95	x22 = 1	29746503.443738
 %      95    83 28492506.9529               28494007.0923   x27 D    63    11
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cb66c0
% @LO 0.10  28.49250695285765999643 99.9000000000
% @LN 0.10  28.49400709234197393016 99.9000000000
% Resuming node 177 at  28.49400709234197393016
DEBUG CONSTRNT: LP rows=43, pool->nlprows=43, pool->npend=0
DEBUG CONSTRNT: Checking 43 LP rows (pool tracks 43, total LP rows 43)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=42, expected 42
 % @PAP adding 43 rows, 172 nz to LP
DEBUG BB: Processing node 177, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=21, varin=44, theta=0.333333, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 28494007.092342
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 43 rows, 60 cols, 232 nonzeros, 1 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=44, varin=42, theta=0.250000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 28495596.821698
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 45 rows, 60 cols, 238 nonzeros, 3 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % Node 177 LP 1 Solution, length = 28495596.821698, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.250000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.250000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.250000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.250000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.250000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.250000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.250000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.250000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.750000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.750000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.750000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.750000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.750000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 0.750000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 8 fractional variables
DEBUG CG: LP optimal, z=28495596.821698, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 177 at  28.49559682169822139031
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7ccbbd0
% @LO 0.10  28.49400709234197393016 99.9000000000
% @LN 0.10  28.49493874346104504980 99.9000000000
% Resuming node 159 at  28.49493874346104504980
DEBUG CONSTRNT: LP rows=42, pool->nlprows=42, pool->npend=0
DEBUG CONSTRNT: Checking 42 LP rows (pool tracks 42, total LP rows 42)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=41, expected 41
 % @PAP adding 40 rows, 174 nz to LP
DEBUG BB: Processing node 159, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=25, varin=35, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=40)
DEBUG SOLUTION: LP solution array indices: FST[41-80], not_covered[81-100]
DEBUG SOLUTION: lp->best_solution[0] = 28494938.743461
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 40 rows, 60 cols, 234 nonzeros, 3 slack, 37 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 16 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=42, varin=15, theta=0.041667, up=999999999999999983222784.000000
ITER 2: row=41, varin=31, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 28500000.000000
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 42 rows, 60 cols, 250 nonzeros, 3 slack, 39 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 1 rows, 40 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=40, varin=39, theta=2.750000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=40)
DEBUG SOLUTION: LP solution array indices: FST[41-80], not_covered[81-100]
DEBUG SOLUTION: lp->best_solution[0] = 28506279.861490
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.875000
  % @PL 40 rows, 60 cols, 264 nonzeros, 3 slack, 37 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % Node 159 LP 1 Solution, length = 28506279.861490, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.125000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.250000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.250000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.250000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.125000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.875000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.875000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.750000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.750000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.750000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.750000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.750000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.875000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.750000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.750000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.750000 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28506279.861490, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 159 at  28.50627986149045156594
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cb66c0
% @LO 0.10  28.49493874346104504980 99.9000000000
% @LN 0.10  28.49559682169822139031 99.9000000000
% Resuming node 177 at  28.49559682169822139031
DEBUG CONSTRNT: LP rows=37, pool->nlprows=37, pool->npend=0
DEBUG CONSTRNT: Checking 37 LP rows (pool tracks 37, total LP rows 37)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 63
DEBUG CONSTRNT: Pool row 63 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 162
DEBUG CONSTRNT: Pool row 162 has lprow=36, expected 36
 % @PAP adding 42 rows, 168 nz to LP
DEBUG BB: Processing node 177, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 177 LP 2 Solution, length = 28495596.821698, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.250000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.250000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.250000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.250000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.250000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.250000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.250000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.250000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.750000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.750000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.750000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.750000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.750000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 0.750000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 8 fractional variables
DEBUG CG: LP optimal, z=28495596.821698, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28495596.821698, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 177 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 177
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.250000
DEBUG CAREFUL: Adding var 0 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.250000
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=1.000000
DEBUG CAREFUL: Skipping var 5: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.250000
DEBUG CAREFUL: Adding var 23 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.250000
DEBUG CAREFUL: Adding var 24 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.250000
DEBUG CAREFUL: Adding var 30 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.250000
DEBUG CAREFUL: Adding var 31 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.250000
DEBUG CAREFUL: Adding var 32 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.250000
DEBUG CAREFUL: Adding var 33 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 8 fractional variables

  %  Carefully choosing branching variable, nfrac = 8
DEBUG CAREFUL: Testing fvar[0] = var 24
DEBUG CAREFUL: Calling compare_branch_vars for var 24
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 24
DEBUG CAREFUL: New best var: 24
DEBUG CAREFUL: Testing fvar[1] = var 23
DEBUG CAREFUL: Calling compare_branch_vars for var 23
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 23
DEBUG CAREFUL: New best var: 23
DEBUG CAREFUL: Testing fvar[2] = var 0
DEBUG CAREFUL: Calling compare_branch_vars for var 0
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 0
DEBUG CAREFUL: Testing fvar[3] = var 32
DEBUG CAREFUL: Calling compare_branch_vars for var 32
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 32
DEBUG CAREFUL: Testing fvar[4] = var 30
DEBUG CAREFUL: Calling compare_branch_vars for var 30
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 30
DEBUG CAREFUL: Testing fvar[5] = var 33
DEBUG CAREFUL: Calling compare_branch_vars for var 33
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 33
DEBUG CAREFUL: Testing fvar[6] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[7] = var 31
DEBUG CAREFUL: Calling compare_branch_vars for var 31
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 31
  % Initial guess is x23, Z0 = 28495596.8216982        , Z1 = 28526138.3231948        

DEBUG EVAL: Testing var 24 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=32, varin=42, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 24 = 0 gives z=28500366.009767
  % 	x24 = 0,	Z0 = 28500366.009767         
DEBUG EVAL: First branch cutoff check: z=28500366.009767, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 24 = 1
ITER 1: row=32, varin=40, theta=0.750000, up=999999999999999983222784.000000
ITER 2: row=36, varin=39, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=37, varin=2, theta=0.200000, up=999999999999999983222784.000000
  % 	x24 = 1,	Z1 = 28553460.6054369        
DEBUG EVAL: Second branch cutoff check: z=28553460.605437, best_z=INF, threshold=INF
  %   New best:  x24, Z = 28500366.009767         
DEBUG EVAL: Testing var 23 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=19, varin=40, theta=0.750000, up=999999999999999983222784.000000
ITER 2: row=36, varin=39, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=37, varin=2, theta=0.200000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 23 = 1 gives z=28553460.605437
  % 	x23 = 1,	Z1 = 28553460.6054369        
DEBUG EVAL: First branch cutoff check: z=28553460.605437, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 23 = 0
ITER 1: row=19, varin=42, theta=1.000000, up=999999999999999983222784.000000
  % 	x23 = 0,	Z0 = 28500366.009767         
DEBUG EVAL: Second branch cutoff check: z=28500366.009767, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 0 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=39, theta=3.000000, up=999999999999999983222784.000000
ITER 2: row=37, varin=36, theta=2.000000, up=999999999999999983222784.000000
ITER 3: row=19, varin=35, theta=1.500000, up=999999999999999983222784.000000
ITER 4: row=35, varin=56, theta=1.500000, up=1.000000
ITER 5: row=35, varin=40, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=18, varin=56, theta=1.000000, up=1.000000
ITER 7: row=32, varin=37, theta=1.500000, up=999999999999999983222784.000000
ITER 8: row=28, varin=32, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 0 = 1 gives z=28882115.976031
  % 	x0 = 1,	Z1 = 28882115.9760305        
DEBUG EVAL: First branch cutoff check: z=28882115.976031, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 0 = 0
ITER 1: row=1, varin=42, theta=1.000000, up=999999999999999983222784.000000
  % 	x0 = 0,	Z0 = 28500366.009767         
DEBUG EVAL: Second branch cutoff check: z=28500366.009767, best_z=INF, threshold=INF
  %   New best:  x0, Z = 28500366.009767         
DEBUG EVAL: Testing var 32 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=31, varin=42, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 32 = 0 gives z=28500366.009767
  % 	x32 = 0,	Z0 = 28500366.009767         
DEBUG EVAL: First branch cutoff check: z=28500366.009767, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 32 = 1
ITER 1: row=31, varin=39, theta=3.000000, up=999999999999999983222784.000000
ITER 2: row=37, varin=36, theta=2.000000, up=999999999999999983222784.000000
ITER 3: row=19, varin=35, theta=1.500000, up=999999999999999983222784.000000
ITER 4: row=35, varin=26, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=38, varin=56, theta=1.500000, up=1.000000
ITER 6: row=38, varin=37, theta=0.200000, up=999999999999999983222784.000000
ITER 7: row=18, varin=56, theta=1.000000, up=1.000000
  % 	x32 = 1,	Z1 = 28811678.6414964        
DEBUG EVAL: Second branch cutoff check: z=28811678.641496, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 30 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=28, varin=42, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 30 = 0 gives z=28500366.009767
  % 	x30 = 0,	Z0 = 28500366.009767         
DEBUG EVAL: First branch cutoff check: z=28500366.009767, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 30 = 1
ITER 1: row=28, varin=39, theta=3.000000, up=999999999999999983222784.000000
ITER 2: row=37, varin=36, theta=2.000000, up=999999999999999983222784.000000
ITER 3: row=19, varin=35, theta=1.500000, up=999999999999999983222784.000000
ITER 4: row=35, varin=26, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=38, varin=56, theta=1.500000, up=1.000000
ITER 6: row=38, varin=40, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=18, varin=56, theta=1.000000, up=1.000000
ITER 8: row=32, varin=32, theta=1.500000, up=999999999999999983222784.000000
ITER 9: row=36, varin=31, theta=0.500000, up=999999999999999983222784.000000
  % 	x30 = 1,	Z1 = 28900793.3008828        
DEBUG EVAL: Second branch cutoff check: z=28900793.300883, best_z=INF, threshold=INF
  %   New best:  x30, Z = 28500366.009767         
DEBUG EVAL: Testing var 33 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=36, varin=42, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 33 = 0 gives z=28500366.009767
  % 	x33 = 0,	Z0 = 28500366.009767         
DEBUG EVAL: First branch cutoff check: z=28500366.009767, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 33 = 1
ITER 1: row=36, varin=39, theta=3.000000, up=999999999999999983222784.000000
ITER 2: row=37, varin=36, theta=2.000000, up=999999999999999983222784.000000
ITER 3: row=19, varin=35, theta=1.500000, up=999999999999999983222784.000000
ITER 4: row=35, varin=2, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=32, varin=56, theta=1.500000, up=1.000000
ITER 6: row=32, varin=32, theta=0.250000, up=999999999999999983222784.000000
ITER 7: row=18, varin=56, theta=1.000000, up=1.000000
ITER 8: row=41, varin=37, theta=1.500000, up=999999999999999983222784.000000
ITER 9: row=28, varin=31, theta=0.500000, up=999999999999999983222784.000000
  % 	x33 = 1,	Z1 = 28889923.861647         
DEBUG EVAL: Second branch cutoff check: z=28889923.861647, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 2 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=2, varin=42, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 1 gives z=28500366.009767
  % 	x2 = 1,	Z1 = 28500366.009767         
DEBUG EVAL: First branch cutoff check: z=28500366.009767, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 0
ITER 1: row=2, varin=2, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=41, varin=40, theta=0.500000, up=999999999999999983222784.000000
ITER 3: row=42, varin=80, theta=0.333333, up=1.000000
  % 	x2 = 0,	Z0 = 28602849.2900874        
DEBUG EVAL: Second branch cutoff check: z=28602849.290087, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 31 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=37, varin=42, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 31 = 1 gives z=28500366.009767
  % 	x31 = 1,	Z1 = 28500366.009767         
DEBUG EVAL: First branch cutoff check: z=28500366.009767, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 31 = 0
ITER 1: row=37, varin=39, theta=0.333333, up=999999999999999983222784.000000
  % 	x31 = 0,	Z0 = 28505931.4446596        
DEBUG EVAL: Second branch cutoff check: z=28505931.444660, best_z=INF, threshold=INF
  % Best branch is x30, Z0 = 28500366.009767         , Z1 = 28900793.3008828        

DEBUG CAREFUL: Final result - returning best.var = 30
DEBUG BB: Branching variable chosen: j=30
 % @NC  179  177	x30 = 0	28500366.009767
 % @NC  180  177	x30 = 1	28900793.300883
 %     177    84 28495596.8217               28495959.9893   x22 D    95    12
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cdc750
% @LO 0.11  28.49559682169822139031 99.9000000000
% @LN 0.11  28.49595998927489759467 99.9000000000
% Resuming node 125 at  28.49595998927489759467
DEBUG CONSTRNT: LP rows=42, pool->nlprows=42, pool->npend=0
DEBUG CONSTRNT: Checking 42 LP rows (pool tracks 42, total LP rows 42)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=41, expected 41
 % @PAP adding 40 rows, 167 nz to LP
DEBUG BB: Processing node 125, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 125 LP 2 Solution, length = 28495959.989275, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.333333 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.333333 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.333333 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 1.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.333333 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.333333 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.666667 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.666667 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.666667 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.666667 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.666667 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.666667 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.666667 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28495959.989275, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28495959.989275, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 125 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 125
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.333333
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=1.000000
DEBUG CAREFUL: Skipping var 7: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.333333
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.333333
DEBUG CAREFUL: Adding var 11 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=1.000000
DEBUG CAREFUL: Skipping var 15: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.333333
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.333333
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 11
DEBUG CAREFUL: Calling compare_branch_vars for var 11
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 11
DEBUG CAREFUL: New best var: 11
DEBUG CAREFUL: Testing fvar[1] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[2] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[3] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[4] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
  % Initial guess is x11, Z0 = 28495959.9892749        , Z1 = 28750720.2116157        

DEBUG EVAL: Testing var 11 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=15, varin=37, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=37, varin=18, theta=2.000000, up=999999999999999983222784.000000
ITER 3: row=39, varin=89, theta=1.000000, up=1.000000
ITER 4: row=7, varin=34, theta=2.000000, up=999999999999999983222784.000000
ITER 5: row=34, varin=14, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=14, varin=31, theta=2.000000, up=999999999999999983222784.000000
ITER 7: row=31, varin=19, theta=1.000000, up=999999999999999983222784.000000
ITER 8: row=40, varin=26, theta=1.000000, up=999999999999999983222784.000000
ITER 9: row=35, varin=30, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 11 = 1 gives z=28884407.463269
  % 	x11 = 1,	Z1 = 28884407.4632694        
DEBUG EVAL: First branch cutoff check: z=28884407.463269, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 11 = 0
ITER 1: row=15, varin=45, theta=0.500000, up=1.000000
  % 	x11 = 0,	Z0 = 28499453.341431         
DEBUG EVAL: Second branch cutoff check: z=28499453.341431, best_z=INF, threshold=INF
  %   New best:  x11, Z = 28499453.341431         
DEBUG EVAL: Testing var 17 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=17, varin=38, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 17 = 1 gives z=28513699.966241
  % 	x17 = 1,	Z1 = 28513699.9662409        
DEBUG EVAL: First branch cutoff check: z=28513699.966241, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 17 = 0
ITER 1: row=17, varin=45, theta=0.500000, up=1.000000
  % 	x17 = 0,	Z0 = 28499453.341431         
DEBUG EVAL: Second branch cutoff check: z=28499453.341431, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 2 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=45, theta=0.500000, up=1.000000
DEBUG EVAL: Branch var 2 = 0 gives z=28499453.341431
  % 	x2 = 0,	Z0 = 28499453.341431         
DEBUG EVAL: First branch cutoff check: z=28499453.341431, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 1
ITER 1: row=1, varin=38, theta=1.000000, up=999999999999999983222784.000000
  % 	x2 = 1,	Z1 = 28513699.9662409        
DEBUG EVAL: Second branch cutoff check: z=28513699.966241, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 10 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=10, varin=38, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 1 gives z=28513699.966241
  % 	x10 = 1,	Z1 = 28513699.9662409        
DEBUG EVAL: First branch cutoff check: z=28513699.966241, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 0
ITER 1: row=10, varin=45, theta=0.500000, up=1.000000
  % 	x10 = 0,	Z0 = 28499453.341431         
DEBUG EVAL: Second branch cutoff check: z=28499453.341431, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 26 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=31, varin=45, theta=0.500000, up=1.000000
DEBUG EVAL: Branch var 26 = 0 gives z=28499453.341431
  % 	x26 = 0,	Z0 = 28499453.341431         
DEBUG EVAL: First branch cutoff check: z=28499453.341431, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 26 = 1
ITER 1: row=31, varin=38, theta=1.000000, up=999999999999999983222784.000000
  % 	x26 = 1,	Z1 = 28513699.9662409        
DEBUG EVAL: Second branch cutoff check: z=28513699.966241, best_z=INF, threshold=INF
  % Best branch is x11, Z0 = 28499453.341431         , Z1 = 28884407.4632694        

DEBUG CAREFUL: Final result - returning best.var = 11
DEBUG BB: Branching variable chosen: j=11
 % @NC  181  125	x11 = 0	28499453.341431
 % @NC  182  125	x11 = 1	28884407.463269
 %     125    85 28495959.9893               28496931.8486    x3 D   107     6
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cac0a0
% @LO 0.11  28.49595998927489759467 99.9000000000
% @LN 0.11  28.49693184857946803845 99.9000000000
% Resuming node 163 at  28.49693184857946803845
DEBUG CONSTRNT: LP rows=40, pool->nlprows=40, pool->npend=0
DEBUG CONSTRNT: Checking 40 LP rows (pool tracks 40, total LP rows 40)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=39, expected 39
 % @PAP adding 41 rows, 178 nz to LP
DEBUG BB: Processing node 163, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 163 LP 2 Solution, length = 28496931.848579, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.500000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.500000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 1.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 1.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.500000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.500000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.500000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.500000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.500000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.500000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.500000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.500000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.500000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.500000 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28496931.848579, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28496931.848579, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 163 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 163
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.500000
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.500000
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=1.000000
DEBUG CAREFUL: Skipping var 12: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=1.000000
DEBUG CAREFUL: Skipping var 16: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.500000
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.500000
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.500000
DEBUG CAREFUL: Adding var 27 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 27
DEBUG CAREFUL: Calling compare_branch_vars for var 27
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 27
DEBUG CAREFUL: New best var: 27
DEBUG CAREFUL: Testing fvar[1] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[2] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[3] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[4] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
  % Initial guess is x27, Z0 = 28496931.8485795        , Z1 = 28514654.7187971        

DEBUG EVAL: Testing var 27 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=31, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=31, varin=41, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 27 = 1 gives z=28514654.718797
  % 	x27 = 1,	Z1 = 28514654.7187971        
DEBUG EVAL: First branch cutoff check: z=28514654.718797, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 27 = 0
ITER 1: row=1, varin=86, theta=0.166667, up=1.000000
  % 	x27 = 0,	Z0 = 28499200.2312201        
DEBUG EVAL: Second branch cutoff check: z=28499200.231220, best_z=INF, threshold=INF
  %   New best:  x27, Z = 28499200.2312201        
DEBUG EVAL: Testing var 2 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=15, varin=24, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 1 gives z=28514818.377056
  % 	x2 = 1,	Z1 = 28514818.377056         
DEBUG EVAL: First branch cutoff check: z=28514818.377056, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 0
ITER 1: row=15, varin=41, theta=1.000000, up=999999999999999983222784.000000
  % 	x2 = 0,	Z0 = 28514654.7187971        
DEBUG EVAL: Second branch cutoff check: z=28514654.718797, best_z=INF, threshold=INF
  %   New best:  x2, Z = 28514654.7187971        
DEBUG EVAL: Testing var 17 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=25, varin=13, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 17 = 1 gives z=28601765.647814
  % 	x17 = 1,	Z1 = 28601765.6478137        
DEBUG EVAL: First branch cutoff check: z=28601765.647814, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 17 = 0
ITER 1: row=25, varin=41, theta=1.000000, up=999999999999999983222784.000000
  % 	x17 = 0,	Z0 = 28514654.7187971        
DEBUG EVAL: Second branch cutoff check: z=28514654.718797, best_z=INF, threshold=INF
  %   New best:  x17, Z = 28514654.7187971        
DEBUG EVAL: Testing var 10 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=12, varin=32, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 1 gives z=28688240.561587
  % 	x10 = 1,	Z1 = 28688240.5615875        
DEBUG EVAL: First branch cutoff check: z=28688240.561587, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 0
ITER 1: row=12, varin=41, theta=1.000000, up=999999999999999983222784.000000
  % 	x10 = 0,	Z0 = 28514654.7187971        
DEBUG EVAL: Second branch cutoff check: z=28514654.718797, best_z=INF, threshold=INF
  %   New best:  x10, Z = 28514654.7187971        
DEBUG EVAL: Testing var 26 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=32, varin=12, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=35, varin=13, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 26 = 1 gives z=28888025.330369
  % 	x26 = 1,	Z1 = 28888025.3303691        
DEBUG EVAL: First branch cutoff check: z=28888025.330369, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 26 = 0
ITER 1: row=32, varin=41, theta=1.000000, up=999999999999999983222784.000000
  % 	x26 = 0,	Z0 = 28514654.7187971        
DEBUG EVAL: Second branch cutoff check: z=28514654.718797, best_z=INF, threshold=INF
  %   New best:  x26, Z = 28514654.7187971        
  % Best branch is x26, Z0 = 28514654.7187971        , Z1 = 28888025.3303691        

DEBUG CAREFUL: Final result - returning best.var = 26
DEBUG BB: Branching variable chosen: j=26
 % @NC  183  163	x26 = 0	28514654.718797
 % @NC  184  163	x26 = 1	28888025.330369
 %     163    86 28496931.8486               28499453.3414    x4 D   155     9
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cb66c0
% @LO 0.11  28.49693184857946803845 99.9000000000
% @LN 0.11  28.49945334143101760560 99.9000000000
% Resuming node 181 at  28.49945334143101760560
DEBUG CONSTRNT: LP rows=41, pool->nlprows=41, pool->npend=0
DEBUG CONSTRNT: Checking 41 LP rows (pool tracks 41, total LP rows 41)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 49
DEBUG CONSTRNT: Pool row 49 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 82
DEBUG CONSTRNT: Pool row 82 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 158
DEBUG CONSTRNT: Pool row 158 has lprow=40, expected 40
 % @PAP adding 40 rows, 167 nz to LP
DEBUG BB: Processing node 181, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=15, varin=45, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=40)
DEBUG SOLUTION: LP solution array indices: FST[41-80], not_covered[81-100]
DEBUG SOLUTION: lp->best_solution[0] = 28499453.341431
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
  % @PL 40 rows, 60 cols, 227 nonzeros, 0 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 6 rows, 33 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=41, varin=38, theta=0.333333, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=46)
DEBUG SOLUTION: LP solution array indices: FST[47-86], not_covered[87-106]
DEBUG SOLUTION: lp->best_solution[0] = 28504202.216368
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
  % @PL 46 rows, 60 cols, 260 nonzeros, 6 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 6 slack rows
  % Node 181 LP 1 Solution, length = 28504202.216368, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.333333 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.333333 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.333333 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 1.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.333333 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.333333 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.666667 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.666667 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.666667 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.666667 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.666667 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.666667 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.666667 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28504202.216368, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 181 at  28.50420221636765916173
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7caffe0
% @LO 0.11  28.49945334143101760560 99.9000000000
% @LN 0.11  28.50036600976697442889 99.9000000000
% Resuming node 179 at  28.50036600976697442889
DEBUG CONSTRNT: LP rows=40, pool->nlprows=40, pool->npend=0
DEBUG CONSTRNT: Checking 40 LP rows (pool tracks 40, total LP rows 40)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=39, expected 39
 % @PAP adding 42 rows, 168 nz to LP
DEBUG BB: Processing node 179, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=28, varin=42, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 28500366.009767
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 42 rows, 60 cols, 228 nonzeros, 1 slack, 41 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=43, varin=2, theta=0.250000, up=999999999999999983222784.000000
ITER 2: row=41, varin=37, theta=0.250000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 28547063.111530
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 43 rows, 60 cols, 230 nonzeros, 3 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % Node 179 LP 1 Solution, length = 28547063.111530, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.250000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.500000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.250000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.250000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.500000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.250000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.250000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.750000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.750000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.750000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.500000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.500000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 0.750000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 7 fractional variables
DEBUG CG: LP optimal, z=28547063.111530, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 179 at  28.54706311152963138511
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cceac0
% @LO 0.11  28.50036600976697442889 99.9000000000
% @LN 0.11  28.50037139684302189835 99.9000000000
% Resuming node 38 at  28.50037139684302189835
DEBUG CONSTRNT: LP rows=40, pool->nlprows=40, pool->npend=0
DEBUG CONSTRNT: Checking 40 LP rows (pool tracks 40, total LP rows 40)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 134
DEBUG CONSTRNT: Pool row 134 has lprow=39, expected 39
 % @PAP adding 42 rows, 174 nz to LP
DEBUG BB: Processing node 38, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=21, varin=39, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=39, varin=36, theta=2.000000, up=999999999999999983222784.000000
ITER 3: row=36, varin=17, theta=2.000000, up=999999999999999983222784.000000
ITER 4: row=17, varin=23, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=41, varin=33, theta=2.000000, up=999999999999999983222784.000000
ITER 6: row=33, varin=24, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=42, varin=29, theta=1.000000, up=999999999999999983222784.000000
ITER 8: row=37, varin=26, theta=0.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=8)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 28500371.396843
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 42 rows, 60 cols, 234 nonzeros, 6 slack, 36 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 53 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=46, varin=19, theta=2.019776, up=999999999999999983222784.000000
ITER 2: row=16, varin=73, theta=1.515942, up=1.000000
ITER 3: row=16, varin=71, theta=0.573452, up=1.000000
ITER 4: row=33, varin=73, theta=1.000000, up=1.000000
ITER 5: row=38, varin=70, theta=1.414236, up=1.000000
ITER 6: row=38, varin=76, theta=0.486297, up=1.000000
ITER 7: row=39, varin=38, theta=1.000000, up=999999999999999983222784.000000
ITER 8: row=16, varin=70, theta=1.000000, up=1.000000
ITER 9: row=32, varin=74, theta=1.597164, up=1.000000
ITER 10: row=32, varin=68, theta=0.500669, up=1.000000
LP PHASE: Switching to primal (iter=20)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=46)
DEBUG SOLUTION: LP solution array indices: FST[47-86], not_covered[87-106]
DEBUG SOLUTION: lp->best_solution[0] = 29190040.073012
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 46 rows, 60 cols, 287 nonzeros, 6 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 6 slack rows
  % @PAP adding 5 rows, 18 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=41, varin=16, theta=0.407632, up=999999999999999983222784.000000
ITER 2: row=45, varin=73, theta=0.500000, up=1.000000
ITER 3: row=43, varin=60, theta=1.469395, up=1.000000
ITER 4: row=43, varin=75, theta=0.785385, up=1.000000
ITER 5: row=19, varin=60, theta=1.000000, up=1.000000
ITER 6: row=43, varin=74, theta=0.880060, up=1.000000
ITER 7: row=18, varin=21, theta=0.237530, up=999999999999999983222784.000000
ITER 8: row=21, varin=45, theta=1.153511, up=999999999999999983222784.000000
ITER 9: row=43, varin=102, theta=0.556386, up=1.000000
ITER 10: row=45, varin=18, theta=0.137083, up=999999999999999983222784.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 999999999999999983222784.000000
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 45 rows, 60 cols, 293 nonzeros, 6 slack, 39 tight.
  % Node 38 LP 1 Solution, length = 999999999999999983222784.000000, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.288436 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 1.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.711564 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 1.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.711564 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
DEBUG BB: compute_good_lower_bound returned status=1
DEBUG BB: Node 38 is INFEASIBLE
 %      38    85    infeasible               28501205.7201    x4 U    35     7
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cb6f50
% @LO 0.11  28.50037139684302189835 99.9000000000
% @LN 0.11  28.50120572013181430293 99.9000000000
% Resuming node 137 at  28.50120572013181430293
DEBUG CONSTRNT: LP rows=45, pool->nlprows=45, pool->npend=0
DEBUG CONSTRNT: Checking 45 LP rows (pool tracks 45, total LP rows 45)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 141
DEBUG CONSTRNT: Pool row 141 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 145
DEBUG CONSTRNT: Pool row 145 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 133
DEBUG CONSTRNT: Pool row 133 has lprow=44, expected 44
 % @PAP adding 32 rows, 136 nz to LP
DEBUG BB: Processing node 137, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=21, varin=21, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=30, varin=26, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=1, varin=24, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=31, varin=22, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=23, varin=86, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=32)
DEBUG SOLUTION: LP solution array indices: FST[33-72], not_covered[73-92]
DEBUG SOLUTION: lp->best_solution[0] = 28501205.720132
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 32 rows, 60 cols, 196 nonzeros, 3 slack, 29 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 40 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=33, varin=43, theta=1.675203, up=1.000000
ITER 2: row=33, varin=25, theta=0.284100, up=999999999999999983222784.000000
ITER 3: row=1, varin=43, theta=0.503884, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=33)
DEBUG SOLUTION: LP solution array indices: FST[34-73], not_covered[74-93]
DEBUG SOLUTION: lp->best_solution[0] = 28511627.377071
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 33 rows, 60 cols, 236 nonzeros, 5 slack, 28 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % Node 137 LP 1 Solution, length = 28511627.377071, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.503884 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.503884 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 1.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.496116 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.496116 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.496116 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.496116 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 2 fractional variables
DEBUG CG: LP optimal, z=28511627.377071, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 137 at  28.51162737707105776508
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cf15d0
% @LO 0.11  28.50120572013181430293 99.9000000000
% @LN 0.11  28.50162550527835136904 99.9000000000
% Resuming node 138 at  28.50162550527835136904
DEBUG CONSTRNT: LP rows=28, pool->nlprows=28, pool->npend=0
DEBUG CONSTRNT: Checking 28 LP rows (pool tracks 28, total LP rows 28)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 121
DEBUG CONSTRNT: Pool row 121 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 63
DEBUG CONSTRNT: Pool row 63 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=27, expected 27
 % @PAP adding 32 rows, 136 nz to LP
DEBUG BB: Processing node 138, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=21, varin=29, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=1, varin=86, theta=2.000000, up=1.000000
ITER 3: row=1, varin=50, theta=0.333333, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=32)
DEBUG SOLUTION: LP solution array indices: FST[33-72], not_covered[73-92]
DEBUG SOLUTION: lp->best_solution[0] = 28501625.505278
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 32 rows, 60 cols, 196 nonzeros, 4 slack, 28 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 7 rows, 67 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=39, varin=40, theta=3.228286, up=1.000000
ITER 2: row=39, varin=25, theta=0.378008, up=999999999999999983222784.000000
ITER 3: row=2, varin=40, theta=1.000000, up=1.000000
ITER 4: row=23, varin=14, theta=1.038421, up=999999999999999983222784.000000
ITER 5: row=12, varin=26, theta=1.204323, up=999999999999999983222784.000000
ITER 6: row=26, varin=93, theta=5.049251, up=1.000000
ITER 7: row=26, varin=66, theta=0.904267, up=1.000000
ITER 8: row=33, varin=93, theta=0.895706, up=1.000000
ITER 9: row=26, varin=64, theta=0.101233, up=1.000000
ITER 10: row=3, varin=63, theta=0.094412, up=1.000000
LP PHASE: Switching to primal (iter=10)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=39)
DEBUG SOLUTION: LP solution array indices: FST[40-79], not_covered[80-99]
DEBUG SOLUTION: lp->best_solution[0] = 28632524.759796
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 39 rows, 60 cols, 263 nonzeros, 4 slack, 35 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % @PAP adding 4 rows, 10 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=36, varin=94, theta=1.000000, up=1.000000
ITER 2: row=14, varin=66, theta=1.000000, up=1.000000
ITER 3: row=38, varin=46, theta=1.086394, up=1.000000
ITER 4: row=38, varin=61, theta=0.073659, up=1.000000
ITER 5: row=1, varin=14, theta=0.042027, up=999999999999999983222784.000000
ITER 6: row=28, varin=69, theta=0.120954, up=1.000000
ITER 7: row=12, varin=29, theta=0.042366, up=999999999999999983222784.000000
ITER 8: row=29, varin=23, theta=0.049083, up=999999999999999983222784.000000
ITER 9: row=23, varin=46, theta=0.120214, up=1.000000
LP PHASE: Switching to primal (iter=9)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=39)
DEBUG SOLUTION: LP solution array indices: FST[40-79], not_covered[80-99]
DEBUG SOLUTION: lp->best_solution[0] = 28783982.213814
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 39 rows, 60 cols, 265 nonzeros, 0 slack, 39 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 8 rows, 34 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=42, varin=53, theta=0.359213, up=1.000000
ITER 2: row=40, varin=65, theta=1.876624, up=1.000000
ITER 3: row=40, varin=75, theta=0.565476, up=1.000000
ITER 4: row=29, varin=65, theta=1.000000, up=1.000000
ITER 5: row=23, varin=58, theta=0.480188, up=1.000000
ITER 6: row=14, varin=50, theta=0.807445, up=1.000000
ITER 7: row=40, varin=20, theta=0.033797, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=7)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 28884939.472194
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 47 rows, 60 cols, 299 nonzeros, 1 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 5 rows, 13 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=51, varin=79, theta=0.946921, up=1.000000
ITER 2: row=48, varin=61, theta=0.500000, up=1.000000
ITER 3: row=47, varin=77, theta=0.598748, up=1.000000
ITER 4: row=25, varin=47, theta=0.610856, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 28973687.558782
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 51 rows, 60 cols, 310 nonzeros, 2 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=50, varin=92, theta=0.500000, up=1.000000
ITER 2: row=38, varin=98, theta=0.333333, up=1.000000
ITER 3: row=1, varin=27, theta=0.548429, up=999999999999999983222784.000000
ITER 4: row=24, varin=53, theta=0.636440, up=1.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 29025781.887628
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 50 rows, 60 cols, 305 nonzeros, 1 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 138 LP 1 Solution, length = 29025781.887628, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.636440 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.500000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 1.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.500000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.500000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.363560 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.363560 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.500000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=29025781.887628, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 138 at  29.02578188762798916400
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cc6e20
% @LO 0.11  28.50162550527835136904 99.9000000000
% @LN 0.11  28.50216927845092129701 99.9000000000
% Resuming node 40 at  28.50216927845092129701
DEBUG CONSTRNT: LP rows=49, pool->nlprows=49, pool->npend=0
DEBUG CONSTRNT: Checking 49 LP rows (pool tracks 49, total LP rows 49)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 141
DEBUG CONSTRNT: Pool row 141 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 145
DEBUG CONSTRNT: Pool row 145 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 159
DEBUG CONSTRNT: Pool row 159 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 133
DEBUG CONSTRNT: Pool row 133 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=48, expected 48
 % @PAP adding 42 rows, 172 nz to LP
DEBUG BB: Processing node 40, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=21, varin=39, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=39, varin=24, theta=2.000000, up=999999999999999983222784.000000
ITER 3: row=41, varin=58, theta=2.000000, up=1.000000
ITER 4: row=41, varin=57, theta=1.000000, up=1.000000
ITER 5: row=11, varin=36, theta=2.000000, up=999999999999999983222784.000000
ITER 6: row=36, varin=15, theta=2.000000, up=999999999999999983222784.000000
ITER 7: row=15, varin=33, theta=2.000000, up=999999999999999983222784.000000
ITER 8: row=12, varin=58, theta=1.000000, up=1.000000
ITER 9: row=33, varin=25, theta=1.000000, up=999999999999999983222784.000000
ITER 10: row=42, varin=29, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=11)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 28502169.278451
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 42 rows, 60 cols, 232 nonzeros, 6 slack, 36 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 55 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=46, varin=17, theta=2.024496, up=999999999999999983222784.000000
ITER 2: row=14, varin=73, theta=1.522959, up=1.000000
ITER 3: row=14, varin=71, theta=0.581251, up=1.000000
ITER 4: row=33, varin=73, theta=1.000000, up=1.000000
ITER 5: row=38, varin=70, theta=1.420782, up=1.000000
ITER 6: row=38, varin=76, theta=0.493982, up=1.000000
ITER 7: row=39, varin=38, theta=1.000000, up=999999999999999983222784.000000
ITER 8: row=14, varin=70, theta=1.000000, up=1.000000
ITER 9: row=32, varin=74, theta=1.604556, up=1.000000
ITER 10: row=32, varin=68, theta=0.506867, up=1.000000
LP PHASE: Switching to primal (iter=20)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=46)
DEBUG SOLUTION: LP solution array indices: FST[47-86], not_covered[87-106]
DEBUG SOLUTION: lp->best_solution[0] = 29196391.196001
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 46 rows, 60 cols, 287 nonzeros, 6 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 6 slack rows
  % @PAP adding 5 rows, 17 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=41, varin=12, theta=0.904203, up=999999999999999983222784.000000
ITER 2: row=12, varin=75, theta=1.435318, up=1.000000
ITER 3: row=12, varin=74, theta=0.276434, up=1.000000
ITER 4: row=44, varin=14, theta=0.343499, up=999999999999999983222784.000000
ITER 5: row=43, varin=44, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=45, varin=73, theta=0.500000, up=1.000000
ITER 7: row=14, varin=45, theta=1.176042, up=999999999999999983222784.000000
ITER 8: row=12, varin=102, theta=0.591847, up=1.000000
ITER 9: row=45, varin=19, theta=0.232442, up=999999999999999983222784.000000
ITER 10: row=33, varin=23, theta=0.142383, up=999999999999999983222784.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 999999999999999983222784.000000
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 45 rows, 60 cols, 292 nonzeros, 6 slack, 39 tight.
  % Node 40 LP 1 Solution, length = 999999999999999983222784.000000, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.279627 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 1.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.720373 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 1.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.720373 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
DEBUG BB: compute_good_lower_bound returned status=1
DEBUG BB: Node 40 is INFEASIBLE
 %      40    84    infeasible               28502169.6120   x11 U    27     7
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cc7030
% @LO 0.11  28.50216927845092129701 99.9000000000
% @LN 0.11  28.50216961196039733295 99.9000000000
% Resuming node 143 at  28.50216961196039733295
DEBUG CONSTRNT: LP rows=45, pool->nlprows=45, pool->npend=0
DEBUG CONSTRNT: Checking 45 LP rows (pool tracks 45, total LP rows 45)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 145
DEBUG CONSTRNT: Pool row 145 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 159
DEBUG CONSTRNT: Pool row 159 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 133
DEBUG CONSTRNT: Pool row 133 has lprow=44, expected 44
 % @PAP adding 38 rows, 165 nz to LP
DEBUG BB: Processing node 143, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 143 LP 3 Solution, length = 28502169.611960, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.500000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.500000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.500000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.500000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.500000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.500000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.500000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.500000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.500000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.500000 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=28502169.611960, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28502169.611960, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 143 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 143
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=1.000000
DEBUG CAREFUL: Skipping var 2: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.500000
DEBUG CAREFUL: Adding var 9 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.500000
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.500000
DEBUG CAREFUL: Adding var 15 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.500000
DEBUG CAREFUL: Adding var 34 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 4 fractional variables

  %  Carefully choosing branching variable, nfrac = 4
DEBUG CAREFUL: Testing fvar[0] = var 15
DEBUG CAREFUL: Calling compare_branch_vars for var 15
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 15
DEBUG CAREFUL: New best var: 15
DEBUG CAREFUL: Testing fvar[1] = var 9
DEBUG CAREFUL: Calling compare_branch_vars for var 9
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 9
DEBUG CAREFUL: Testing fvar[2] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[3] = var 34
DEBUG CAREFUL: Calling compare_branch_vars for var 34
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 34
DEBUG CAREFUL: New best var: 34
  % Initial guess is x34, Z0 = 28502169.6119604        , Z1 = 28633257.4182301        

DEBUG EVAL: Testing var 15 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=18, varin=3, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=3, varin=35, theta=0.250000, up=999999999999999983222784.000000
ITER 3: row=35, varin=33, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 15 = 0 gives z=28530711.800414
  % 	x15 = 0,	Z0 = 28530711.800414         
DEBUG EVAL: First branch cutoff check: z=28530711.800414, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 15 = 1
ITER 1: row=18, varin=62, theta=0.500000, up=1.000000
ITER 2: row=30, varin=50, theta=0.250000, up=1.000000
ITER 3: row=38, varin=43, theta=0.250000, up=1.000000
ITER 4: row=36, varin=15, theta=0.055556, up=999999999999999983222784.000000
ITER 5: row=30, varin=16, theta=0.006579, up=999999999999999983222784.000000
ITER 6: row=37, varin=50, theta=0.136364, up=1.000000
  % 	x15 = 1,	Z1 = 28546357.9967086        
DEBUG EVAL: Second branch cutoff check: z=28546357.996709, best_z=INF, threshold=INF
  %   New best:  x15, Z = 28530711.800414         
DEBUG EVAL: Testing var 9 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=34, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 9 = 0 gives z=28535773.056953
  % 	x9 = 0,	Z0 = 28535773.056953         
DEBUG EVAL: First branch cutoff check: z=28535773.056953, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 9 = 1
ITER 1: row=1, varin=33, theta=1.000000, up=999999999999999983222784.000000
  % 	x9 = 1,	Z1 = 28530711.800414         
DEBUG EVAL: Second branch cutoff check: z=28530711.800414, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 10 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=10, varin=10, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 0 gives z=28520210.489799
  % 	x10 = 0,	Z0 = 28520210.4897994        
DEBUG EVAL: First branch cutoff check: z=28520210.489799, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 34 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=23, varin=23, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 34 = 1 gives z=28718664.770044
  % 	x34 = 1,	Z1 = 28718664.770044         
DEBUG EVAL: First branch cutoff check: z=28718664.770044, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 34 = 0
ITER 1: row=23, varin=33, theta=1.000000, up=999999999999999983222784.000000
  % 	x34 = 0,	Z0 = 28530711.800414         
DEBUG EVAL: Second branch cutoff check: z=28530711.800414, best_z=INF, threshold=INF
  %   New best:  x34, Z = 28530711.800414         
  % Best branch is x34, Z0 = 28530711.800414         , Z1 = 28718664.770044         

DEBUG CAREFUL: Final result - returning best.var = 34
DEBUG BB: Branching variable chosen: j=34
 % @NC  185  143	x34 = 0	28530711.800414
 % @NC  186  143	x34 = 1	28718664.770044
 %     143    85 28502169.6120               28502934.3333    x2 U   131    12
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cc24b0
% @LO 0.11  28.50216961196039733295 99.9000000000
% @LN 0.11  28.50293433329323988801 99.9000000000
% Resuming node 175 at  28.50293433329323988801
DEBUG CONSTRNT: LP rows=38, pool->nlprows=38, pool->npend=0
DEBUG CONSTRNT: Checking 38 LP rows (pool tracks 38, total LP rows 38)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=37, expected 37
 % @PAP adding 43 rows, 183 nz to LP
DEBUG BB: Processing node 175, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=30, varin=41, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 28502934.333293
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 43 rows, 60 cols, 243 nonzeros, 2 slack, 41 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 7 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=44, varin=60, theta=1.000000, up=1.000000
ITER 2: row=12, varin=79, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 28518550.104526
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 45 rows, 60 cols, 250 nonzeros, 2 slack, 43 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 4 rows, 14 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=44, varin=78, theta=1.000000, up=1.000000
ITER 2: row=43, varin=30, theta=0.400000, up=999999999999999983222784.000000
ITER 3: row=37, varin=3, theta=0.250000, up=999999999999999983222784.000000
ITER 4: row=47, varin=31, theta=0.250000, up=999999999999999983222784.000000
ITER 5: row=21, varin=47, theta=0.333333, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 28554261.598018
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 47 rows, 60 cols, 259 nonzeros, 5 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % Node 175 LP 1 Solution, length = 28554261.598018, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.333333 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.333333 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.333333 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.333333 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.333333 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.333333 (FST 33)
  % DEBUG LP_VARS: x[34] = 1.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.666667 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.666667 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.666667 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.666667 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.666667 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.666667 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28554261.598018, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 175 at  28.55426159801817220796
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cdaf50
% @LO 0.11  28.50293433329323988801 99.9000000000
% @LN 0.11  28.50372495122535454470 99.9000000000
% Resuming node 153 at  28.50372495122535454470
DEBUG CONSTRNT: LP rows=42, pool->nlprows=42, pool->npend=0
DEBUG CONSTRNT: Checking 42 LP rows (pool tracks 42, total LP rows 42)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=41, expected 41
 % @PAP adding 44 rows, 211 nz to LP
DEBUG BB: Processing node 153, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 153 LP 2 Solution, length = 28503724.951225, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.702707 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.702707 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.702707 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.702707 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.297293 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.297293 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.297293 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.297293 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.297293 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.297293 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.297293 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.297293 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28503724.951225, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28503724.951225, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 153 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 153
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.702707
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.702707)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.702707
DEBUG CAREFUL: Adding var 9 to fractional list (xi=0.702707)
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.702707
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.702707)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.702707
DEBUG CAREFUL: Adding var 11 to fractional list (xi=0.702707)
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.297293
DEBUG CAREFUL: Adding var 31 to fractional list (xi=0.297293)
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 31
DEBUG CAREFUL: Calling compare_branch_vars for var 31
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 31
DEBUG CAREFUL: New best var: 31
DEBUG CAREFUL: Testing fvar[1] = var 9
DEBUG CAREFUL: Calling compare_branch_vars for var 9
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 9
DEBUG CAREFUL: Testing fvar[2] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[3] = var 11
DEBUG CAREFUL: Calling compare_branch_vars for var 11
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 11
DEBUG CAREFUL: Testing fvar[4] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
  % Initial guess is x31, Z0 = 28503724.9512254        , Z1 = 28516030.3086238        

DEBUG EVAL: Testing var 31 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=24, varin=44, theta=1.218090, up=999999999999999983222784.000000
ITER 2: row=13, varin=40, theta=210443.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 31 = 1 gives z=28511558.676505
  % 	x31 = 1,	Z1 = 28516030.3086238        
DEBUG EVAL: First branch cutoff check: z=28516030.308624, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 31 = 0
ITER 1: row=24, varin=26, theta=0.312935, up=999999999999999983222784.000000
ITER 2: row=37, varin=21, theta=0.383258, up=999999999999999983222784.000000
ITER 3: row=3, varin=82, theta=0.325010, up=1.000000
  % 	x31 = 0,	Z0 = 28550593.9977474        
DEBUG EVAL: Second branch cutoff check: z=28550593.997747, best_z=INF, threshold=INF
  %   New best:  x31, Z = 28516030.3086238        
DEBUG EVAL: Testing var 9 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=16, varin=44, theta=0.702642, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 9 = 1 gives z=28507607.034033
  % 	x9 = 1,	Z1 = 28507607.0340326        
DEBUG EVAL: First branch cutoff check: z=28507607.034033, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 10 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=13, varin=44, theta=0.702642, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 1 gives z=28507607.034033
  % 	x10 = 1,	Z1 = 28507607.0340326        
DEBUG EVAL: First branch cutoff check: z=28507607.034033, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 11 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
DEBUG EVAL: Branch var 11 = 1 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x11 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=18, varin=44, theta=1.218090, up=999999999999999983222784.000000
ITER 2: row=13, varin=40, theta=210443.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28511558.676505
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 44 rows, 60 cols, 271 nonzeros, 2 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 2 slack rows
   % @PAP adding 2 rows, 12 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=43, varin=26, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=37, varin=39, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28547331.733458
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 44 rows, 60 cols, 241 nonzeros, 2 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 2 slack rows
   % @PAP adding 2 rows, 42 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=44, varin=55, theta=0.048013, up=1.000000
ITER 2: row=43, varin=21, theta=0.500000, up=999999999999999983222784.000000
ITER 3: row=3, varin=82, theta=0.500000, up=1.000000
ITER 4: row=19, varin=44, theta=10735.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28600766.740242
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 44 rows, 60 cols, 271 nonzeros, 1 slack, 43 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
   % @PAP adding 1 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=44, varin=83, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28601344.949866
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 44 rows, 60 cols, 235 nonzeros, 0 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @PAP adding 2 rows, 10 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=45, varin=56, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=46)
DEBUG SOLUTION: LP solution array indices: FST[47-86], not_covered[87-106]
DEBUG SOLUTION: lp->best_solution[0] = 28603297.368512
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 46 rows, 60 cols, 245 nonzeros, 0 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 153 at  28.60329736851178594748
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cb66c0
% @LO 0.11  28.50372495122535454470 99.9000000000
% @LN 0.11  28.50420221636765916173 99.9000000000
% Resuming node 181 at  28.50420221636765916173
DEBUG CONSTRNT: LP rows=46, pool->nlprows=46, pool->npend=0
DEBUG CONSTRNT: Checking 46 LP rows (pool tracks 46, total LP rows 46)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 134
DEBUG CONSTRNT: Pool row 134 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 105
DEBUG CONSTRNT: Pool row 105 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=45, expected 45
 % @PAP adding 40 rows, 167 nz to LP
DEBUG BB: Processing node 181, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 181 LP 2 Solution, length = 28504202.216368, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.333333 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.333333 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.333333 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 1.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.333333 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.333333 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.666667 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.666667 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.666667 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.666667 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.666667 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.666667 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.666667 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28504202.216368, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28504202.216368, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 181 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 181
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.333333
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.333333
DEBUG CAREFUL: Adding var 4 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=1.000000
DEBUG CAREFUL: Skipping var 7: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.333333
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=1.000000
DEBUG CAREFUL: Skipping var 15: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.333333
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.333333
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 4
DEBUG CAREFUL: Calling compare_branch_vars for var 4
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 4
DEBUG CAREFUL: New best var: 4
DEBUG CAREFUL: Testing fvar[1] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[2] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[3] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[4] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
  % Initial guess is x4, Z0 = 28504202.2163677        , Z1 = 28781460.5188403        

DEBUG EVAL: Testing var 4 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=15, varin=37, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=37, varin=89, theta=1.000000, up=1.000000
ITER 3: row=7, varin=34, theta=2.000000, up=999999999999999983222784.000000
ITER 4: row=34, varin=17, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=39, varin=14, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=14, varin=31, theta=2.000000, up=999999999999999983222784.000000
ITER 7: row=31, varin=18, theta=1.000000, up=999999999999999983222784.000000
ITER 8: row=40, varin=26, theta=1.000000, up=999999999999999983222784.000000
ITER 9: row=35, varin=30, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 4 = 1 gives z=28909134.144548
  % 	x4 = 1,	Z1 = 28909134.1445477        
DEBUG EVAL: First branch cutoff check: z=28909134.144548, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 4 = 0
ITER 1: row=15, varin=38, theta=1.000000, up=999999999999999983222784.000000
  % 	x4 = 0,	Z0 = 28513699.9662409        
DEBUG EVAL: Second branch cutoff check: z=28513699.966241, best_z=INF, threshold=INF
  %   New best:  x4, Z = 28513699.9662409        
DEBUG EVAL: Testing var 17 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=17, varin=38, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 17 = 1 gives z=28513699.966241
  % 	x17 = 1,	Z1 = 28513699.9662409        
DEBUG EVAL: First branch cutoff check: z=28513699.966241, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 17 = 0
ITER 1: row=17, varin=70, theta=1.000000, up=1.000000
ITER 2: row=29, varin=42, theta=0.333333, up=1.000000
ITER 3: row=36, varin=68, theta=1.000000, up=1.000000
  % 	x17 = 0,	Z0 = 28549145.7066762        
DEBUG EVAL: Second branch cutoff check: z=28549145.706676, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 2 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=38, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 1 gives z=28513699.966241
  % 	x2 = 1,	Z1 = 28513699.9662409        
DEBUG EVAL: First branch cutoff check: z=28513699.966241, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 0
ITER 1: row=1, varin=70, theta=1.000000, up=1.000000
ITER 2: row=29, varin=42, theta=0.333333, up=1.000000
ITER 3: row=36, varin=68, theta=1.000000, up=1.000000
  % 	x2 = 0,	Z0 = 28549145.7066762        
DEBUG EVAL: Second branch cutoff check: z=28549145.706676, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 10 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=10, varin=38, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 1 gives z=28513699.966241
  % 	x10 = 1,	Z1 = 28513699.9662409        
DEBUG EVAL: First branch cutoff check: z=28513699.966241, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 0
ITER 1: row=10, varin=70, theta=1.000000, up=1.000000
ITER 2: row=29, varin=42, theta=0.333333, up=1.000000
ITER 3: row=36, varin=68, theta=1.000000, up=1.000000
  % 	x10 = 0,	Z0 = 28549145.7066762        
DEBUG EVAL: Second branch cutoff check: z=28549145.706676, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 26 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=31, varin=38, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 26 = 1 gives z=28513699.966241
  % 	x26 = 1,	Z1 = 28513699.9662409        
DEBUG EVAL: First branch cutoff check: z=28513699.966241, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 26 = 0
ITER 1: row=31, varin=70, theta=1.000000, up=1.000000
ITER 2: row=29, varin=42, theta=0.333333, up=1.000000
ITER 3: row=36, varin=68, theta=1.000000, up=1.000000
  % 	x26 = 0,	Z0 = 28549145.7066762        
DEBUG EVAL: Second branch cutoff check: z=28549145.706676, best_z=INF, threshold=INF
  % Best branch is x4, Z0 = 28513699.9662409        , Z1 = 28909134.1445477        

DEBUG CAREFUL: Final result - returning best.var = 4
DEBUG BB: Branching variable chosen: j=4
 % @NC  187  181	x4 = 0	28513699.966241
 % @NC  188  181	x4 = 1	28909134.144548
 %     181    86 28504202.2164               28506279.8615   x11 D   125     7
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7ccbbd0
% @LO 0.11  28.50420221636765916173 99.9000000000
% @LN 0.11  28.50627986149045156594 99.9000000000
% Resuming node 159 at  28.50627986149045156594
DEBUG CONSTRNT: LP rows=40, pool->nlprows=40, pool->npend=0
DEBUG CONSTRNT: Checking 40 LP rows (pool tracks 40, total LP rows 40)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=39, expected 39
 % @PAP adding 37 rows, 186 nz to LP
DEBUG BB: Processing node 159, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 159 LP 2 Solution, length = 28506279.861490, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.125000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.250000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.250000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.250000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.125000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.875000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.875000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.750000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.750000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.750000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.750000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.750000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.875000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.750000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.750000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.750000 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28506279.861490, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28506279.861490, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 159 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 159
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.125000
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.125000)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.250000
DEBUG CAREFUL: Adding var 9 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.250000
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.250000
DEBUG CAREFUL: Adding var 15 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.125000
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.125000)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 17
DEBUG CAREFUL: New best var: 17
DEBUG CAREFUL: Testing fvar[1] = var 15
DEBUG CAREFUL: Calling compare_branch_vars for var 15
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 15
DEBUG CAREFUL: Testing fvar[2] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 3
DEBUG CAREFUL: New best var: 3
DEBUG CAREFUL: Testing fvar[3] = var 9
DEBUG CAREFUL: Calling compare_branch_vars for var 9
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 9
DEBUG CAREFUL: Testing fvar[4] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
  % Initial guess is x3, Z0 = 28506279.8614905        , Z1 = 28720180.8576091        

DEBUG EVAL: Testing var 17 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=14, varin=61, theta=0.250000, up=1.000000
ITER 2: row=30, varin=39, theta=0.166667, up=1.000000
DEBUG EVAL: Branch var 17 = 0 gives z=28516193.700369
  % 	x17 = 0,	Z0 = 28516193.7003689        
DEBUG EVAL: First branch cutoff check: z=28516193.700369, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 17 = 1
ITER 1: row=14, varin=37, theta=7.000000, up=999999999999999983222784.000000
ITER 2: row=10, varin=36, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=18, varin=3, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=3, varin=31, theta=0.500000, up=999999999999999983222784.000000
  % 	x17 = 1,	Z1 = 28612066.7167195        
DEBUG EVAL: Second branch cutoff check: z=28612066.716720, best_z=INF, threshold=INF
  %   New best:  x17, Z = 28516193.7003689        
DEBUG EVAL: Testing var 15 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=18, varin=39, theta=0.500000, up=1.000000
ITER 2: row=1, varin=3, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 15 = 0 gives z=28555940.406237
  % 	x15 = 0,	Z0 = 28555940.4062365        
DEBUG EVAL: First branch cutoff check: z=28555940.406237, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 15 = 1
ITER 1: row=18, varin=37, theta=3.000000, up=999999999999999983222784.000000
  % 	x15 = 1,	Z1 = 28525119.4459618        
DEBUG EVAL: Second branch cutoff check: z=28525119.445962, best_z=INF, threshold=INF
  %   New best:  x15, Z = 28525119.4459618        
DEBUG EVAL: Testing var 3 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=37, theta=7.000000, up=999999999999999983222784.000000
ITER 2: row=10, varin=36, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=18, varin=3, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=3, varin=29, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=29, varin=14, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=32, varin=34, theta=0.500000, up=999999999999999983222784.000000
ITER 7: row=34, varin=25, theta=1.000000, up=999999999999999983222784.000000
ITER 8: row=5, varin=15, theta=0.500000, up=999999999999999983222784.000000
ITER 9: row=33, varin=2, theta=0.400000, up=999999999999999983222784.000000
ITER 10: row=25, varin=16, theta=0.333333, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 3 = 1 gives z=28742372.647828
  % 	x3 = 1,	Z1 = 28742372.6478279        
DEBUG EVAL: First branch cutoff check: z=28742372.647828, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 3 = 0
ITER 1: row=1, varin=61, theta=0.250000, up=1.000000
ITER 2: row=30, varin=39, theta=0.166667, up=1.000000
  % 	x3 = 0,	Z0 = 28516193.7003689        
DEBUG EVAL: Second branch cutoff check: z=28516193.700369, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 9 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=23, varin=36, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 9 = 0 gives z=28515090.351250
  % 	x9 = 0,	Z0 = 28515090.3512504        
DEBUG EVAL: First branch cutoff check: z=28515090.351250, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 10 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=10, varin=36, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 0 gives z=28515090.351250
  % 	x10 = 0,	Z0 = 28515090.3512504        
DEBUG EVAL: First branch cutoff check: z=28515090.351250, best_z=INF, threshold=INF
  % Best branch is x15, Z0 = 28555940.4062365        , Z1 = 28525119.4459618        

DEBUG CAREFUL: Final result - returning best.var = 15
DEBUG BB: Branching variable chosen: j=15
 % @NC  189  159	x15 = 1	28525119.445962
 % @NC  190  159	x15 = 0	28555940.406237
 %     159    87 28506279.8615               28506869.0206   x34 D   144    13
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cc2570
% @LO 0.11  28.50627986149045156594 99.9000000000
% @LN 0.11  28.50686902057034188829 99.9000000000
% Resuming node 173 at  28.50686902057034188829
DEBUG CONSTRNT: LP rows=37, pool->nlprows=37, pool->npend=0
DEBUG CONSTRNT: Checking 37 LP rows (pool tracks 37, total LP rows 37)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 63
DEBUG CONSTRNT: Pool row 63 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 162
DEBUG CONSTRNT: Pool row 162 has lprow=36, expected 36
 % @PAP adding 35 rows, 158 nz to LP
DEBUG BB: Processing node 173, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=33, theta=1.250000, up=999999999999999983222784.000000
ITER 2: row=11, varin=32, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=35)
DEBUG SOLUTION: LP solution array indices: FST[36-75], not_covered[76-95]
DEBUG SOLUTION: lp->best_solution[0] = 28506869.020570
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 35 rows, 60 cols, 218 nonzeros, 4 slack, 31 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 40 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=36, varin=30, theta=0.512014, up=999999999999999983222784.000000
ITER 2: row=30, varin=28, theta=0.524248, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=36)
DEBUG SOLUTION: LP solution array indices: FST[37-76], not_covered[77-96]
DEBUG SOLUTION: lp->best_solution[0] = 28509522.375150
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 36 rows, 60 cols, 258 nonzeros, 6 slack, 30 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 6 slack rows
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=31, varin=14, theta=0.360576, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=31)
DEBUG SOLUTION: LP solution array indices: FST[32-71], not_covered[72-91]
DEBUG SOLUTION: lp->best_solution[0] = 28511938.153809
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.639424
  % @PL 31 rows, 60 cols, 234 nonzeros, 1 slack, 30 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 173 LP 1 Solution, length = 28511938.153809, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.639424 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.639424 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 1.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.639424 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.360576 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.360576 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.360576 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.360576 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.360576 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.360576 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.360576 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=28511938.153809, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 173 at  28.51193815380902663037
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cfa210
% @LO 0.11  28.50686902057034188829 99.9000000000
% @LN 0.11  28.50886790332511111501 99.9000000000
% Resuming node 174 at  28.50886790332511111501
DEBUG CONSTRNT: LP rows=30, pool->nlprows=30, pool->npend=0
DEBUG CONSTRNT: Checking 30 LP rows (pool tracks 30, total LP rows 30)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=29, expected 29
 % @PAP adding 35 rows, 158 nz to LP
DEBUG BB: Processing node 174, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=60, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=35)
DEBUG SOLUTION: LP solution array indices: FST[36-75], not_covered[76-95]
DEBUG SOLUTION: lp->best_solution[0] = 28508867.903325
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 35 rows, 60 cols, 218 nonzeros, 0 slack, 35 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 11 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=36, varin=12, theta=0.250000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=39)
DEBUG SOLUTION: LP solution array indices: FST[40-79], not_covered[80-99]
DEBUG SOLUTION: lp->best_solution[0] = 28528786.931436
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.750000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 39 rows, 60 cols, 229 nonzeros, 1 slack, 38 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 174 LP 1 Solution, length = 28528786.931436, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.250000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.500000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.500000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 1.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.250000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.500000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.750000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.750000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.500000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.500000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.750000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.500000 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28528786.931436, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 174 at  28.52878693143588506587
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cd3de0
% @LO 0.11  28.50886790332511111501 99.9000000000
% @LN 0.11  28.51078166401050850709 99.9000000000
% Resuming node 169 at  28.51078166401050850709
DEBUG CONSTRNT: LP rows=38, pool->nlprows=38, pool->npend=0
DEBUG CONSTRNT: Checking 38 LP rows (pool tracks 38, total LP rows 38)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=37, expected 37
 % @PAP adding 41 rows, 157 nz to LP
DEBUG BB: Processing node 169, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=14, varin=65, theta=0.500000, up=1.000000
ITER 2: row=41, varin=53, theta=0.250000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=41)
DEBUG SOLUTION: LP solution array indices: FST[42-81], not_covered[82-101]
DEBUG SOLUTION: lp->best_solution[0] = 28510781.664011
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 41 rows, 60 cols, 217 nonzeros, 0 slack, 41 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 6 rows, 34 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=42, varin=33, theta=0.166667, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 28515216.658252
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 47 rows, 60 cols, 251 nonzeros, 6 slack, 41 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 6 slack rows
  % Node 169 LP 1 Solution, length = 28515216.658252, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.166667 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.166667 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.166667 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.500000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.500000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.166667 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.166667 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.833333 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.833333 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.500000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.500000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.833333 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.833333 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.833333 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.833333 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.500000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.833333 (terminal 19)
 % 7 fractional variables
DEBUG CG: LP optimal, z=28515216.658252, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 169 at  28.51521665825201878874
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cb6f50
% @LO 0.11  28.51078166401050850709 99.9000000000
% @LN 0.11  28.51162737707105776508 99.9000000000
% Resuming node 137 at  28.51162737707105776508
DEBUG CONSTRNT: LP rows=41, pool->nlprows=41, pool->npend=0
DEBUG CONSTRNT: Checking 41 LP rows (pool tracks 41, total LP rows 41)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=40, expected 40
 % @PAP adding 28 rows, 160 nz to LP
DEBUG BB: Processing node 137, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 137 LP 2 Solution, length = 28511627.377071, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.503884 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.503884 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 1.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.496116 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.496116 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.496116 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.496116 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 2 fractional variables
DEBUG CG: LP optimal, z=28511627.377071, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28511627.377071, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 137 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 137
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=1.000000
DEBUG CAREFUL: Skipping var 2: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.503884
DEBUG CAREFUL: Adding var 5 to fractional list (xi=0.503884)
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.503884
DEBUG CAREFUL: Adding var 9 to fractional list (xi=0.503884)
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=1.000000
DEBUG CAREFUL: Skipping var 20: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 2 fractional variables

  %  Carefully choosing branching variable, nfrac = 2
DEBUG CAREFUL: Testing fvar[0] = var 9
DEBUG CAREFUL: Calling compare_branch_vars for var 9
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 9
DEBUG CAREFUL: New best var: 9
DEBUG CAREFUL: Testing fvar[1] = var 5
DEBUG CAREFUL: Calling compare_branch_vars for var 5
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 5
  % Initial guess is x9, Z0 = 28511627.3770711        , Z1 = 28511627.3770711        

DEBUG EVAL: Testing var 9 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=21, varin=31, theta=0.704864, up=1.000000
ITER 2: row=27, varin=26, theta=1.052271, up=999999999999999983222784.000000
ITER 3: row=1, varin=29, theta=0.237720, up=1.000000
ITER 4: row=2, varin=14, theta=0.219356, up=999999999999999983222784.000000
ITER 5: row=12, varin=46, theta=0.282416, up=1.000000
DEBUG EVAL: Branch var 9 = 1 gives z=28572034.675925
  % 	x9 = 1,	Z1 = 28572034.675925         
DEBUG EVAL: First branch cutoff check: z=28572034.675925, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 9 = 0
ITER 1: row=21, varin=46, theta=0.248920, up=1.000000
  % 	x9 = 0,	Z0 = 28526646.3667861        
DEBUG EVAL: Second branch cutoff check: z=28526646.366786, best_z=INF, threshold=INF
  %   New best:  x9, Z = 28526646.3667861        
DEBUG EVAL: Testing var 5 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
DEBUG EVAL: Branch var 5 = 1 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x5 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=26, theta=0.953371, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
ITER 2: row=27, varin=30, theta=0.000000, up=1.000000
ITER 3: row=1, varin=28, theta=556788.000000, up=999999999999999983222784.000000
ITER 4: row=7, varin=31, theta=0.000000, up=1.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=28)
DEBUG SOLUTION: LP solution array indices: FST[29-68], not_covered[69-88]
DEBUG SOLUTION: lp->best_solution[0] = 28522212.201222
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 28 rows, 60 cols, 220 nonzeros, 1 slack, 27 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=38, theta=7.500000, up=1.000000
ITER 2: row=1, varin=29, theta=6.500000, up=1.000000
ITER 3: row=1, varin=68, theta=11.000000, up=1.000000
ITER 4: row=1, varin=69, theta=10.000000, up=1.000000
ITER 5: row=1, varin=70, theta=9.000000, up=1.000000
ITER 6: row=1, varin=71, theta=8.000000, up=1.000000
ITER 7: row=1, varin=72, theta=7.000000, up=1.000000
ITER 8: row=1, varin=73, theta=6.000000, up=1.000000
ITER 9: row=1, varin=74, theta=5.000000, up=1.000000
ITER 10: row=1, varin=75, theta=4.000000, up=1.000000
LP PHASE: Switching to primal (iter=37)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=27)
DEBUG SOLUTION: LP solution array indices: FST[28-67], not_covered[68-87]
DEBUG SOLUTION: lp->best_solution[0] = 28522212.201222
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 27 rows, 60 cols, 180 nonzeros, 0 slack, 27 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 137 at  28.52221220122238776185
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cc2570
% @LO 0.11  28.51162737707105776508 99.9000000000
% @LN 0.11  28.51193815380902663037 99.9000000000
% Resuming node 173 at  28.51193815380902663037
DEBUG CONSTRNT: LP rows=27, pool->nlprows=27, pool->npend=0
DEBUG CONSTRNT: Checking 27 LP rows (pool tracks 27, total LP rows 27)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 121
DEBUG CONSTRNT: Pool row 121 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 63
DEBUG CONSTRNT: Pool row 63 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=26, expected 26
 % @PAP adding 30 rows, 172 nz to LP
DEBUG BB: Processing node 173, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 173 LP 2 Solution, length = 28511938.153809, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.639424 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.639424 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 1.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.639424 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.360576 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.360576 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.360576 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.360576 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.360576 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.360576 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.360576 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=28511938.153809, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28511938.153809, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 173 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 173
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=1.000000
DEBUG CAREFUL: Skipping var 2: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.639424
DEBUG CAREFUL: Adding var 9 to fractional list (xi=0.639424)
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.639424
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.639424)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=1.000000
DEBUG CAREFUL: Skipping var 14: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.639424
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.639424)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.360576
DEBUG CAREFUL: Adding var 34 to fractional list (xi=0.360576)
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 4 fractional variables

  %  Carefully choosing branching variable, nfrac = 4
DEBUG CAREFUL: Testing fvar[0] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 17
DEBUG CAREFUL: New best var: 17
DEBUG CAREFUL: Testing fvar[1] = var 9
DEBUG CAREFUL: Calling compare_branch_vars for var 9
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 9
DEBUG CAREFUL: Testing fvar[2] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[3] = var 34
DEBUG CAREFUL: Calling compare_branch_vars for var 34
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 34
  % Initial guess is x17, Z0 = 28511938.153809         , Z1 = 28511938.153809         

DEBUG EVAL: Testing var 17 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
DEBUG EVAL: Branch var 17 = 1 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x17 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=13, varin=30, theta=0.929670, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=30)
DEBUG SOLUTION: LP solution array indices: FST[31-70], not_covered[71-90]
DEBUG SOLUTION: lp->best_solution[0] = 28516222.149849
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 30 rows, 60 cols, 232 nonzeros, 1 slack, 29 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
   % @PAP adding 3 rows, 20 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=31, varin=69, theta=0.907975, up=1.000000
ITER 2: row=27, varin=29, theta=897074.000000, up=999999999999999983222784.000000
ITER 3: row=30, varin=36, theta=0.250000, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=32)
DEBUG SOLUTION: LP solution array indices: FST[33-72], not_covered[73-92]
DEBUG SOLUTION: lp->best_solution[0] = 28521086.353010
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 32 rows, 60 cols, 250 nonzeros, 1 slack, 31 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
   % @PAP adding 4 rows, 19 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=32, varin=60, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=35)
DEBUG SOLUTION: LP solution array indices: FST[36-75], not_covered[76-95]
DEBUG SOLUTION: lp->best_solution[0] = 28544640.960278
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 35 rows, 60 cols, 229 nonzeros, 0 slack, 35 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @PAP adding 4 rows, 11 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=36, varin=63, theta=0.500000, up=1.000000
ITER 2: row=28, varin=51, theta=0.250000, up=1.000000
ITER 3: row=35, varin=44, theta=0.250000, up=1.000000
ITER 4: row=33, varin=13, theta=0.055556, up=999999999999999983222784.000000
ITER 5: row=28, varin=14, theta=0.006579, up=999999999999999983222784.000000
ITER 6: row=34, varin=51, theta=0.136364, up=1.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=39)
DEBUG SOLUTION: LP solution array indices: FST[40-79], not_covered[80-99]
DEBUG SOLUTION: lp->best_solution[0] = 28593658.021887
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.977273
DEBUG SOLUTION: lp->best_solution[14] = 0.977273
   % @PL 39 rows, 60 cols, 240 nonzeros, 2 slack, 37 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 2 slack rows
   % @PAP adding 2 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=39, varin=69, theta=0.500000, up=1.000000
ITER 2: row=24, varin=41, theta=0.125000, up=1.000000
ITER 3: row=36, varin=13, theta=0.125000, up=999999999999999983222784.000000
ITER 4: row=37, varin=33, theta=0.208333, up=999999999999999983222784.000000
ITER 5: row=38, varin=67, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=39)
DEBUG SOLUTION: LP solution array indices: FST[40-79], not_covered[80-99]
DEBUG SOLUTION: lp->best_solution[0] = 28613318.262034
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 39 rows, 60 cols, 240 nonzeros, 0 slack, 39 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=40, varin=34, theta=0.166667, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=40)
DEBUG SOLUTION: LP solution array indices: FST[41-80], not_covered[81-100]
DEBUG SOLUTION: lp->best_solution[0] = 28615586.644675
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 40 rows, 60 cols, 242 nonzeros, 3 slack, 37 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 3 slack rows
   % @PAP adding 3 rows, 7 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=38, varin=30, theta=0.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=40)
DEBUG SOLUTION: LP solution array indices: FST[41-80], not_covered[81-100]
DEBUG SOLUTION: lp->best_solution[0] = 28632448.938822
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 40 rows, 60 cols, 238 nonzeros, 2 slack, 38 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 2 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 173 at  28.63244893882218278236
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cc5d40
% @LO 0.11  28.51193815380902663037 99.9000000000
% @LN 0.11  28.51361456367806113121 99.9000000000
% Resuming node 139 at  28.51361456367806113121
DEBUG CONSTRNT: LP rows=38, pool->nlprows=38, pool->npend=0
DEBUG CONSTRNT: Checking 38 LP rows (pool tracks 38, total LP rows 38)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 133
DEBUG CONSTRNT: Pool row 133 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=37, expected 37
 % @PAP adding 40 rows, 165 nz to LP
DEBUG BB: Processing node 139, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=15, varin=64, theta=1.000000, up=1.000000
ITER 2: row=40, varin=52, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=40)
DEBUG SOLUTION: LP solution array indices: FST[41-80], not_covered[81-100]
DEBUG SOLUTION: lp->best_solution[0] = 28513614.563678
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
  % @PL 40 rows, 60 cols, 225 nonzeros, 0 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 6 rows, 34 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=41, varin=34, theta=0.333333, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=46)
DEBUG SOLUTION: LP solution array indices: FST[47-86], not_covered[87-106]
DEBUG SOLUTION: lp->best_solution[0] = 28522484.552161
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
  % @PL 46 rows, 60 cols, 259 nonzeros, 6 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 6 slack rows
  % Node 139 LP 1 Solution, length = 28522484.552161, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.333333 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.333333 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.333333 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 1.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.333333 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.333333 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.666667 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.666667 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.666667 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.666667 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.666667 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.666667 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.666667 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28522484.552161, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 139 at  28.52248455216108169452
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cc7030
% @LO 0.11  28.51361456367806113121 99.9000000000
% @LN 0.11  28.51369996624093516857 99.9000000000
% Resuming node 187 at  28.51369996624093516857
DEBUG CONSTRNT: LP rows=40, pool->nlprows=40, pool->npend=0
DEBUG CONSTRNT: Checking 40 LP rows (pool tracks 40, total LP rows 40)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=39, expected 39
 % @PAP adding 40 rows, 167 nz to LP
DEBUG BB: Processing node 187, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=15, varin=38, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=40)
DEBUG SOLUTION: LP solution array indices: FST[41-80], not_covered[81-100]
DEBUG SOLUTION: lp->best_solution[0] = 28513699.966241
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
  % @PL 40 rows, 60 cols, 227 nonzeros, 3 slack, 37 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 42 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=42, varin=72, theta=0.348789, up=1.000000
ITER 2: row=29, varin=44, theta=0.140753, up=1.000000
ITER 3: row=41, varin=42, theta=82793.500000, up=999999999999999983222784.000000
ITER 4: row=36, varin=34, theta=0.140178, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
ITER 5: row=4, varin=70, theta=0.500000, up=1.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 28531422.836459
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
  % @PL 42 rows, 60 cols, 269 nonzeros, 4 slack, 38 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % Node 187 LP 1 Solution, length = 28531422.836459, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.500000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.500000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 1.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.500000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.500000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.500000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.500000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.500000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.500000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.500000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.500000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.500000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.500000 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28531422.836459, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 187 at  28.53142283645855670215
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cceb80
% @LO 0.12  28.51369996624093516857 99.9000000000
% @LN 0.12  28.51375357054348924635 99.9000000000
% Resuming node 44 at  28.51375357054348924635
DEBUG CONSTRNT: LP rows=38, pool->nlprows=38, pool->npend=0
DEBUG CONSTRNT: Checking 38 LP rows (pool tracks 38, total LP rows 38)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 158
DEBUG CONSTRNT: Pool row 158 has lprow=37, expected 37
 % @PAP adding 40 rows, 170 nz to LP
DEBUG BB: Processing node 44, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=33, varin=18, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=35, varin=19, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=40)
DEBUG SOLUTION: LP solution array indices: FST[41-80], not_covered[81-100]
DEBUG SOLUTION: lp->best_solution[0] = 28513753.570543
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 40 rows, 60 cols, 230 nonzeros, 3 slack, 37 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 42 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=42, varin=38, theta=0.710969, up=999999999999999983222784.000000
ITER 2: row=41, varin=26, theta=0.587490, up=999999999999999983222784.000000
ITER 3: row=39, varin=37, theta=0.666667, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 28612388.500056
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 42 rows, 60 cols, 272 nonzeros, 7 slack, 35 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 7 slack rows
  % @PAP adding 5 rows, 11 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=36, varin=62, theta=1.000000, up=1.000000
ITER 2: row=13, varin=73, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=40)
DEBUG SOLUTION: LP solution array indices: FST[41-80], not_covered[81-100]
DEBUG SOLUTION: lp->best_solution[0] = 28645155.731505
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 40 rows, 60 cols, 263 nonzeros, 2 slack, 38 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 4 rows, 13 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=40, varin=99, theta=1.000000, up=1.000000
ITER 2: row=32, varin=28, theta=0.333333, up=999999999999999983222784.000000
ITER 3: row=31, varin=67, theta=1.000000, up=1.000000
ITER 4: row=42, varin=76, theta=0.497281, up=1.000000
ITER 5: row=39, varin=42, theta=0.585998, up=999999999999999983222784.000000
ITER 6: row=32, varin=73, theta=0.250000, up=1.000000
ITER 7: row=39, varin=65, theta=0.020521, up=1.000000
LP PHASE: Switching to primal (iter=7)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 28708046.674363
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 42 rows, 60 cols, 272 nonzeros, 1 slack, 41 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=42, varin=41, theta=0.318058, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 28715003.952249
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 42 rows, 60 cols, 272 nonzeros, 1 slack, 41 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 44 LP 1 Solution, length = 28715003.952249, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.181942 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.181942 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.500000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.500000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.272233 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 1.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.500000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.181942 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.181942 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.181942 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.181942 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.818058 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.500000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.818058 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.818058 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.500000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.818058 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.500000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.500000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 10 fractional variables
DEBUG CG: LP optimal, z=28715003.952249, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 44 at  28.71500395224905233249
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cdc750
% @LO 0.12  28.51375357054348924635 99.9000000000
% @LN 0.12  28.51465471879709667746 99.9000000000
% Resuming node 183 at  28.51465471879709667746
DEBUG CONSTRNT: LP rows=41, pool->nlprows=41, pool->npend=0
DEBUG CONSTRNT: Checking 41 LP rows (pool tracks 41, total LP rows 41)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 158
DEBUG CONSTRNT: Pool row 158 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 133
DEBUG CONSTRNT: Pool row 133 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=40, expected 40
 % @PAP adding 41 rows, 178 nz to LP
DEBUG BB: Processing node 183, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=32, varin=41, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=41)
DEBUG SOLUTION: LP solution array indices: FST[42-81], not_covered[82-101]
DEBUG SOLUTION: lp->best_solution[0] = 28514654.718797
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 41 rows, 60 cols, 238 nonzeros, 1 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=42, varin=88, theta=0.333333, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 28519191.484078
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 43 rows, 60 cols, 244 nonzeros, 4 slack, 39 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % @PAP adding 4 rows, 9 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=40, varin=24, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 28550427.775750
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 43 rows, 60 cols, 240 nonzeros, 3 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=41, varin=48, theta=0.250000, up=1.000000
ITER 2: row=7, varin=74, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=41)
DEBUG SOLUTION: LP solution array indices: FST[42-81], not_covered[82-101]
DEBUG SOLUTION: lp->best_solution[0] = 28565208.777855
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 41 rows, 60 cols, 234 nonzeros, 0 slack, 41 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 7 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=42, varin=65, theta=0.500000, up=1.000000
ITER 2: row=10, varin=29, theta=0.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 28568656.005963
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 43 rows, 60 cols, 241 nonzeros, 2 slack, 41 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % Node 183 LP 1 Solution, length = 28568656.005963, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.250000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.250000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.500000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 1.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 1.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.500000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.250000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.250000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.750000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.750000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.750000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.500000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.750000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.500000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28568656.005963, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 183 at  28.56865600596322707361
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cd3de0
% @LO 0.12  28.51465471879709667746 99.9000000000
% @LN 0.12  28.51521665825201878874 99.9000000000
% Resuming node 169 at  28.51521665825201878874
DEBUG CONSTRNT: LP rows=41, pool->nlprows=41, pool->npend=0
DEBUG CONSTRNT: Checking 41 LP rows (pool tracks 41, total LP rows 41)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 49
DEBUG CONSTRNT: Pool row 49 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 82
DEBUG CONSTRNT: Pool row 82 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 133
DEBUG CONSTRNT: Pool row 133 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=40, expected 40
 % @PAP adding 41 rows, 157 nz to LP
DEBUG BB: Processing node 169, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 169 LP 2 Solution, length = 28515216.658252, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.166667 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.166667 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.166667 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.500000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.500000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.166667 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.166667 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.833333 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.833333 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.500000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.500000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.833333 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.833333 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.833333 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.833333 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.500000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.833333 (terminal 19)
 % 7 fractional variables
DEBUG CG: LP optimal, z=28515216.658252, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28515216.658252, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 169 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 169
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.166667
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=1.000000
DEBUG CAREFUL: Skipping var 5: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.166667
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.166667
DEBUG CAREFUL: Adding var 11 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.500000
DEBUG CAREFUL: Adding var 12 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.500000
DEBUG CAREFUL: Adding var 14 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.166667
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.166667
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 7 fractional variables

  %  Carefully choosing branching variable, nfrac = 7
DEBUG CAREFUL: Testing fvar[0] = var 12
DEBUG CAREFUL: Calling compare_branch_vars for var 12
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 12
DEBUG CAREFUL: New best var: 12
DEBUG CAREFUL: Testing fvar[1] = var 14
DEBUG CAREFUL: Calling compare_branch_vars for var 14
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 14
DEBUG CAREFUL: Testing fvar[2] = var 11
DEBUG CAREFUL: Calling compare_branch_vars for var 11
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 11
DEBUG CAREFUL: Testing fvar[3] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[4] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[5] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[6] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
  % Initial guess is x12, Z0 = 28515216.658252         , Z1 = 28936535.6808012        

DEBUG EVAL: Testing var 12 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=7, varin=22, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=34, varin=23, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 12 = 1 gives z=29099746.497021
  % 	x12 = 1,	Z1 = 29099746.4970207        
DEBUG EVAL: First branch cutoff check: z=29099746.497021, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 12 = 0
ITER 1: row=7, varin=33, theta=1.000000, up=999999999999999983222784.000000
  % 	x12 = 0,	Z0 = 28569784.5773392        
DEBUG EVAL: Second branch cutoff check: z=28569784.577339, best_z=INF, threshold=INF
  %   New best:  x12, Z = 28569784.5773392        
DEBUG EVAL: Testing var 14 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=21, varin=33, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 14 = 1 gives z=28569784.577339
  % 	x14 = 1,	Z1 = 28569784.5773392        
DEBUG EVAL: First branch cutoff check: z=28569784.577339, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 14 = 0
ITER 1: row=21, varin=7, theta=1.000000, up=999999999999999983222784.000000
  % 	x14 = 0,	Z0 = 28767521.8986983        
DEBUG EVAL: Second branch cutoff check: z=28767521.898698, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 11 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=14, varin=38, theta=2.500000, up=999999999999999983222784.000000
ITER 2: row=38, varin=17, theta=2.500000, up=999999999999999983222784.000000
ITER 3: row=40, varin=35, theta=2.500000, up=999999999999999983222784.000000
ITER 4: row=35, varin=33, theta=5.000000, up=999999999999999983222784.000000
ITER 5: row=7, varin=9, theta=2.000000, up=999999999999999983222784.000000
ITER 6: row=9, varin=30, theta=2.000000, up=999999999999999983222784.000000
ITER 7: row=30, varin=18, theta=1.000000, up=999999999999999983222784.000000
ITER 8: row=41, varin=25, theta=1.000000, up=999999999999999983222784.000000
ITER 9: row=36, varin=29, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 11 = 1 gives z=28958232.051334
  % 	x11 = 1,	Z1 = 28958232.0513337        
DEBUG EVAL: First branch cutoff check: z=28958232.051334, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 11 = 0
ITER 1: row=14, varin=46, theta=0.250000, up=1.000000
  % 	x11 = 0,	Z0 = 28516963.3343301        
DEBUG EVAL: Second branch cutoff check: z=28516963.334330, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 17 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=16, varin=39, theta=1.250000, up=999999999999999983222784.000000
ITER 2: row=14, varin=38, theta=0.500000, up=999999999999999983222784.000000
ITER 3: row=38, varin=35, theta=0.500000, up=999999999999999983222784.000000
ITER 4: row=35, varin=33, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 17 = 1 gives z=28587524.554305
  % 	x17 = 1,	Z1 = 28587524.5543052        
DEBUG EVAL: First branch cutoff check: z=28587524.554305, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 17 = 0
ITER 1: row=16, varin=46, theta=0.250000, up=1.000000
  % 	x17 = 0,	Z0 = 28516963.3343301        
DEBUG EVAL: Second branch cutoff check: z=28516963.334330, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 2 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=46, theta=0.250000, up=1.000000
DEBUG EVAL: Branch var 2 = 0 gives z=28516963.334330
  % 	x2 = 0,	Z0 = 28516963.3343301        
DEBUG EVAL: First branch cutoff check: z=28516963.334330, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 10 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=8, varin=39, theta=1.250000, up=999999999999999983222784.000000
ITER 2: row=14, varin=38, theta=0.500000, up=999999999999999983222784.000000
ITER 3: row=38, varin=35, theta=0.500000, up=999999999999999983222784.000000
ITER 4: row=35, varin=33, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 1 gives z=28587524.554305
  % 	x10 = 1,	Z1 = 28587524.5543052        
DEBUG EVAL: First branch cutoff check: z=28587524.554305, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 0
ITER 1: row=8, varin=46, theta=0.250000, up=1.000000
  % 	x10 = 0,	Z0 = 28516963.3343301        
DEBUG EVAL: Second branch cutoff check: z=28516963.334330, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 26 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=30, varin=39, theta=1.250000, up=999999999999999983222784.000000
ITER 2: row=14, varin=38, theta=0.500000, up=999999999999999983222784.000000
ITER 3: row=38, varin=35, theta=0.500000, up=999999999999999983222784.000000
ITER 4: row=35, varin=33, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 26 = 1 gives z=28587524.554305
  % 	x26 = 1,	Z1 = 28587524.5543052        
DEBUG EVAL: First branch cutoff check: z=28587524.554305, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 26 = 0
ITER 1: row=30, varin=46, theta=0.250000, up=1.000000
  % 	x26 = 0,	Z0 = 28516963.3343301        
DEBUG EVAL: Second branch cutoff check: z=28516963.334330, best_z=INF, threshold=INF
  % Best branch is x12, Z0 = 28569784.5773392        , Z1 = 29099746.4970207        

DEBUG CAREFUL: Final result - returning best.var = 12
DEBUG BB: Branching variable chosen: j=12
 % @NC  191  169	x12 = 0	28569784.577339
 % @NC  192  169	x12 = 1	29099746.497021
 %     169    88 28515216.6583               28520538.5486    x3 D   145    10
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cf1f70
% @LO 0.12  28.51521665825201878874 99.9000000000
% @LN 0.12  28.52053854864344017983 99.9000000000
% Resuming node 161 at  28.52053854864344017983
DEBUG CONSTRNT: LP rows=41, pool->nlprows=41, pool->npend=0
DEBUG CONSTRNT: Checking 41 LP rows (pool tracks 41, total LP rows 41)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=40, expected 40
 % @PAP adding 40 rows, 166 nz to LP
DEBUG BB: Processing node 161, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 161 LP 2 Solution, length = 28520538.548643, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.250000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.500000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.250000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.250000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.500000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.250000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.250000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.750000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.750000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.750000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.500000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.500000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 0.750000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 7 fractional variables
DEBUG CG: LP optimal, z=28520538.548643, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28520538.548643, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 161 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 161
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.250000
DEBUG CAREFUL: Adding var 0 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.500000
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=1.000000
DEBUG CAREFUL: Skipping var 7: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.250000
DEBUG CAREFUL: Adding var 23 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.250000
DEBUG CAREFUL: Adding var 24 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.500000
DEBUG CAREFUL: Adding var 31 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.250000
DEBUG CAREFUL: Adding var 32 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.250000
DEBUG CAREFUL: Adding var 33 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 7 fractional variables

  %  Carefully choosing branching variable, nfrac = 7
DEBUG CAREFUL: Testing fvar[0] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 2
DEBUG CAREFUL: New best var: 2
DEBUG CAREFUL: Testing fvar[1] = var 31
DEBUG CAREFUL: Calling compare_branch_vars for var 31
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 31
DEBUG CAREFUL: Testing fvar[2] = var 24
DEBUG CAREFUL: Calling compare_branch_vars for var 24
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 24
DEBUG CAREFUL: Testing fvar[3] = var 23
DEBUG CAREFUL: Calling compare_branch_vars for var 23
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 23
DEBUG CAREFUL: Testing fvar[4] = var 0
DEBUG CAREFUL: Calling compare_branch_vars for var 0
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 0
DEBUG CAREFUL: New best var: 0
DEBUG CAREFUL: Testing fvar[5] = var 32
DEBUG CAREFUL: Calling compare_branch_vars for var 32
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 32
DEBUG CAREFUL: Testing fvar[6] = var 33
DEBUG CAREFUL: Calling compare_branch_vars for var 33
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 33
DEBUG CAREFUL: New best var: 33
  % Initial guess is x33, Z0 = 28520538.5486434        , Z1 = 28863399.2987608        

DEBUG EVAL: Testing var 2 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=19, varin=37, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 1 gives z=28603008.707359
  % 	x2 = 1,	Z1 = 28603008.7073591        
DEBUG EVAL: First branch cutoff check: z=28603008.707359, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 0
ITER 1: row=19, varin=40, theta=1.000000, up=999999999999999983222784.000000
  % 	x2 = 0,	Z0 = 28576324.7272012        
DEBUG EVAL: Second branch cutoff check: z=28576324.727201, best_z=INF, threshold=INF
  %   New best:  x2, Z = 28576324.7272012        
DEBUG EVAL: Testing var 31 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=28, varin=40, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 31 = 0 gives z=28567235.650406
  % 	x31 = 0,	Z0 = 28567235.6504061        
DEBUG EVAL: First branch cutoff check: z=28567235.650406, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 24 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=32, varin=38, theta=0.375000, up=999999999999999983222784.000000
ITER 2: row=1, varin=39, theta=0.250000, up=999999999999999983222784.000000
ITER 3: row=36, varin=40, theta=0.333333, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 24 = 1 gives z=28540701.389345
  % 	x24 = 1,	Z1 = 28540701.3893448        
DEBUG EVAL: First branch cutoff check: z=28540701.389345, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 23 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=26, varin=38, theta=0.375000, up=999999999999999983222784.000000
ITER 2: row=1, varin=39, theta=0.250000, up=999999999999999983222784.000000
ITER 3: row=36, varin=40, theta=0.333333, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 23 = 1 gives z=28540701.389345
  % 	x23 = 1,	Z1 = 28540701.3893448        
DEBUG EVAL: First branch cutoff check: z=28540701.389345, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 0 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=39, theta=0.750000, up=999999999999999983222784.000000
ITER 2: row=2, varin=40, theta=3.000000, up=999999999999999983222784.000000
ITER 3: row=19, varin=37, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=28, varin=36, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=26, varin=35, theta=0.500000, up=999999999999999983222784.000000
ITER 6: row=35, varin=54, theta=0.500000, up=1.000000
ITER 7: row=18, varin=38, theta=1.000000, up=999999999999999983222784.000000
ITER 8: row=32, varin=32, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 0 = 1 gives z=28819818.356191
  % 	x0 = 1,	Z1 = 28855591.4131444        
DEBUG EVAL: First branch cutoff check: z=28855591.413144, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 0 = 0
ITER 1: row=1, varin=38, theta=0.250000, up=999999999999999983222784.000000
  % 	x0 = 0,	Z0 = 28523986.4037288        
DEBUG EVAL: Second branch cutoff check: z=28523986.403729, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 32 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=31, varin=39, theta=0.750000, up=999999999999999983222784.000000
ITER 2: row=2, varin=40, theta=3.000000, up=999999999999999983222784.000000
ITER 3: row=19, varin=37, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=28, varin=36, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=26, varin=35, theta=0.500000, up=999999999999999983222784.000000
ITER 6: row=35, varin=26, theta=0.333333, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 32 = 1 gives z=28778271.072731
  % 	x32 = 1,	Z1 = 28785154.0786102        
DEBUG EVAL: First branch cutoff check: z=28785154.078610, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 32 = 0
ITER 1: row=31, varin=38, theta=0.250000, up=999999999999999983222784.000000
  % 	x32 = 0,	Z0 = 28523986.4037288        
DEBUG EVAL: Second branch cutoff check: z=28523986.403729, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 33 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=36, varin=40, theta=3.000000, up=999999999999999983222784.000000
ITER 2: row=19, varin=37, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=28, varin=36, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=26, varin=35, theta=0.500000, up=999999999999999983222784.000000
ITER 5: row=35, varin=54, theta=0.500000, up=1.000000
ITER 6: row=18, varin=32, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 33 = 1 gives z=28829167.606214
  % 	x33 = 1,	Z1 = 28863399.2987608        
DEBUG EVAL: First branch cutoff check: z=28863399.298761, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 33 = 0
ITER 1: row=36, varin=38, theta=0.250000, up=999999999999999983222784.000000
  % 	x33 = 0,	Z0 = 28523986.4037288        
DEBUG EVAL: Second branch cutoff check: z=28523986.403729, best_z=INF, threshold=INF
  % Best branch is x2, Z0 = 28576324.7272012        , Z1 = 28603008.7073591        

DEBUG CAREFUL: Final result - returning best.var = 2
DEBUG BB: Branching variable chosen: j=2
 % @NC  193  161	x2 = 0	28576324.727201
 % @NC  194  161	x2 = 1	28603008.707359
 %     161    89 28520538.5486               28522212.2012   x30 D   157    12
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ffe7cb6f50
% @LO 0.12  28.52053854864344017983 99.9000000000
% @LN 0.12  28.52221220122238776185 99.9000000000
% Resuming node 137 at  28.52221220122238776185
DEBUG CONSTRNT: LP rows=40, pool->nlprows=40, pool->npend=0
DEBUG CONSTRNT: Checking 40 LP rows (pool tracks 40, total LP rows 40)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 134
DEBUG CONSTRNT: Pool row 134 has lprow=39, expected 39
 % @PAP adding 27 rows, 120 nz to LP
DEBUG BB: Processing node 137, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 137 LP 3 Solution, length = 28522212.201222, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 1.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 1.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 0 fractional variables
DEBUG CG: LP optimal, z=28522212.201222, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG IFS: Budget mode - accepting integer solution with 2 edges covering 7 vertices
DEBUG CG: integer_feasible_solution returned: TRUE
DEBUG CG: Solution is integer feasible, returning LB_INTEGRAL
DEBUG BB: compute_good_lower_bound returned status=3
DEBUG BB: Node 137 is INTEGRAL (integer solution found)
 %  	=== 88 nodes cut off ===
 % @UO 0.12   9.02221220122238598549 -216.1332449857
 % @UN 0.12   9.02221220122238598549 -216.1332449857
DEBUG BB: Calling heuristic UB for integer solution, current best_z=9022212.201222
DEBUG BB: Heuristic did not improve integer solution
 % *   137     0  9022212.2012  9022212.2012                  x7 D   110     6
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=(nil)
DEBUG BB: No more nodes to process, exiting

 % Certificate of solution:
 % @C	.4767008182741058	.2081993675729823
 % @C	.9346545514704401	.5030260596239182
 % @C	.8743159763680044	.2782542139644725
 % @C	.9603074535474138	.1921833678795793
%%Page: 1 1
BeginPlot
	Plot_Terminals
 % fs2: 13 0 6
	13 T	.4767008182741058	.2081993675729823	S
	.4767008182741058	.2081993675729823	0 T	S
	.4767008182741058	.2081993675729823	6 T	S
 % fs20: 19 15 3 6 12
	19 T	.9346545514704401	.5030260596239182	S
	.9346545514704401	.5030260596239182	.8743159763680044	.2782542139644725	S
	.8743159763680044	.2782542139644725	.9603074535474138	.1921833678795793	S
	.9603074535474138	.1921833678795793	15 T	S
	.9603074535474138	.1921833678795793	3 T	S
	.8743159763680044	.2782542139644725	6 T	S
	.9346545514704401	.5030260596239182	12 T	S
  (Euclidean SMT:  20 points,  length = 9.022212201222386,  0.12 seconds)
EndPlot

% @0 Euclidean SMT
% N M Nodes LPs P1CPU P2CPU TotCPU
% @1 20 40 136 226 0.00 0.12 0.12
% Z RootZ %Gap RootLPs RootCPU RedMST
% @2 9.022212201222386 27756089.338381 -207.64173 2 0.00 -188.5468
% InitPRows InitPNZ InitLPRows InitLPNZ
% @3 163 594 135 555
% RootPRows RootPNZ RootLPRows RootLPNZ
% @4 164 606 39 231
% FinalPRows FinalPNZ FinalLPRows FinalLPNZ
% @5 164 606 27 180
% SMTFSTs SMTAvgFSTSz SMTMaxFSTSz #2FSTs #3FSTs ... #10FSTS #>10FSTs
% @6 2 4.000000 5 0 1 0 1 0 0 0 0 0 0
