 % ./bb
 % Args:
DEBUG P1READ: Terminal 0 battery=100.00
DEBUG P1READ: Terminal 1 battery=94.00
DEBUG P1READ: Terminal 2 battery=94.00
DEBUG P1READ: Terminal 3 battery=87.50
DEBUG P1READ: Terminal 4 battery=98.00
DEBUG P1READ: Terminal 5 battery=79.50
DEBUG P1READ: Terminal 6 battery=94.60
DEBUG P1READ: Terminal 7 battery=100.00
DEBUG P1READ: Terminal 8 battery=100.00
DEBUG P1READ: Terminal 9 battery=98.10
DEBUG P1READ: Terminal 10 battery=82.20
DEBUG P1READ: Terminal 11 battery=38.70
DEBUG P1READ: Terminal 12 battery=95.00
DEBUG P1READ: Terminal 13 battery=61.90
DEBUG P1READ: Terminal 14 battery=62.30
DEBUG P1READ: Terminal 15 battery=88.60
DEBUG P1READ: Terminal 16 battery=80.00
DEBUG P1READ: Terminal 17 battery=98.60
DEBUG P1READ: Terminal 18 battery=73.20
DEBUG P1READ: Terminal 19 battery=99.60
DEBUG HG: num_verts=20, num_edges=40
 % Phase 1: 0.00 seconds

%%BeginSetup

0 1 0 1 SetAxes

20 DefineTerminals
	.4588350000000000	.2373240000000000	DT
	.1270640000000000	.3509960000000000	DT
	.1544540000000000	.4808220000000000	DT
	.9474030000000000	.1441120000000000	DT
	.2867390000000000	.0565890000000000	DT
	.1326890000000000	.1166050000000000	DT
	.6273950000000000	.2122140000000000	DT
	.0794880000000000	.7970990000000000	DT
	.0327480000000000	.8803250000000000	DT
	.3110550000000000	.8689670000000000	DT
	.0916180000000000	.0221720000000000	DT
	.3600710000000000	.6382240000000000	DT
	.7197120000000000	.7181670000000000	DT
	.4424420000000000	.1450340000000000	DT
	.9983770000000000	.5729870000000000	DT
	.9654920000000000	.1935700000000000	DT
	.1600100000000000	.4187950000000000	DT
	.2909450000000000	.9620800000000000	DT
	.3330000000000000	.9414120000000000	DT
	.9512590000000000	.5074670000000000	DT

%%EndSetup

DEBUG ALGO: num_verts=20 <= 8? NO, num_edges=40 <= 12? NO
DEBUG ALGO: Forcing BRANCH-AND-CUT for multi-objective optimization (vertices=20 > 1)
DEBUG SPANNING: Adding modified spanning constraint for budget mode
DEBUG SPANNING: Added modified spanning constraint: Σ(|FST|-1)*x + Σnot_covered = 19
DEBUG CONSTRAINT: Adding soft cutset constraints with not_covered variables
DEBUG CONSTRAINT: Added constraint x[2] + not_covered[0] ≤ 1 for terminal 0
DEBUG CONSTRAINT: Added constraint x[27] + not_covered[0] ≤ 1 for terminal 0
DEBUG CONSTRAINT: Added constraint x[31] + not_covered[0] ≤ 1 for terminal 0
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 3·not_covered[0] ≤ 3 for terminal 0
DEBUG CONSTRAINT: Added constraint x[0] + not_covered[1] ≤ 1 for terminal 1
DEBUG CONSTRAINT: Added constraint x[24] + not_covered[1] ≤ 1 for terminal 1
DEBUG CONSTRAINT: Added constraint x[33] + not_covered[1] ≤ 1 for terminal 1
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 3·not_covered[1] ≤ 3 for terminal 1
DEBUG CONSTRAINT: Added constraint x[5] + not_covered[2] ≤ 1 for terminal 2
DEBUG CONSTRAINT: Added constraint x[7] + not_covered[2] ≤ 1 for terminal 2
DEBUG CONSTRAINT: Added constraint x[16] + not_covered[2] ≤ 1 for terminal 2
DEBUG CONSTRAINT: Added constraint x[23] + not_covered[2] ≤ 1 for terminal 2
DEBUG CONSTRAINT: Added constraint x[36] + not_covered[2] ≤ 1 for terminal 2
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 5·not_covered[2] ≤ 5 for terminal 2
DEBUG CONSTRAINT: Added constraint x[3] + not_covered[3] ≤ 1 for terminal 3
DEBUG CONSTRAINT: Added constraint x[4] + not_covered[3] ≤ 1 for terminal 3
DEBUG CONSTRAINT: Added constraint x[17] + not_covered[3] ≤ 1 for terminal 3
DEBUG CONSTRAINT: Added constraint x[20] + not_covered[3] ≤ 1 for terminal 3
DEBUG CONSTRAINT: Added constraint x[22] + not_covered[3] ≤ 1 for terminal 3
DEBUG CONSTRAINT: Added constraint x[39] + not_covered[3] ≤ 1 for terminal 3
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 6·not_covered[3] ≤ 6 for terminal 3
DEBUG CONSTRAINT: Added constraint x[0] + not_covered[4] ≤ 1 for terminal 4
DEBUG CONSTRAINT: Added constraint x[1] + not_covered[4] ≤ 1 for terminal 4
DEBUG CONSTRAINT: Added constraint x[30] + not_covered[4] ≤ 1 for terminal 4
DEBUG CONSTRAINT: Added constraint x[32] + not_covered[4] ≤ 1 for terminal 4
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 4·not_covered[4] ≤ 4 for terminal 4
DEBUG CONSTRAINT: Added constraint x[0] + not_covered[5] ≤ 1 for terminal 5
DEBUG CONSTRAINT: Added constraint x[1] + not_covered[5] ≤ 1 for terminal 5
DEBUG CONSTRAINT: Added constraint x[29] + not_covered[5] ≤ 1 for terminal 5
DEBUG CONSTRAINT: Added constraint x[30] + not_covered[5] ≤ 1 for terminal 5
DEBUG CONSTRAINT: Added constraint x[33] + not_covered[5] ≤ 1 for terminal 5
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 5·not_covered[5] ≤ 5 for terminal 5
DEBUG CONSTRAINT: Added constraint x[2] + not_covered[6] ≤ 1 for terminal 6
DEBUG CONSTRAINT: Added constraint x[3] + not_covered[6] ≤ 1 for terminal 6
DEBUG CONSTRAINT: Added constraint x[4] + not_covered[6] ≤ 1 for terminal 6
DEBUG CONSTRAINT: Added constraint x[11] + not_covered[6] ≤ 1 for terminal 6
DEBUG CONSTRAINT: Added constraint x[17] + not_covered[6] ≤ 1 for terminal 6
DEBUG CONSTRAINT: Added constraint x[18] + not_covered[6] ≤ 1 for terminal 6
DEBUG CONSTRAINT: Added constraint x[20] + not_covered[6] ≤ 1 for terminal 6
DEBUG CONSTRAINT: Added constraint x[31] + not_covered[6] ≤ 1 for terminal 6
DEBUG CONSTRAINT: Added constraint x[39] + not_covered[6] ≤ 1 for terminal 6
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 9·not_covered[6] ≤ 9 for terminal 6
DEBUG CONSTRAINT: Added constraint x[5] + not_covered[7] ≤ 1 for terminal 7
DEBUG CONSTRAINT: Added constraint x[6] + not_covered[7] ≤ 1 for terminal 7
DEBUG CONSTRAINT: Added constraint x[8] + not_covered[7] ≤ 1 for terminal 7
DEBUG CONSTRAINT: Added constraint x[13] + not_covered[7] ≤ 1 for terminal 7
DEBUG CONSTRAINT: Added constraint x[14] + not_covered[7] ≤ 1 for terminal 7
DEBUG CONSTRAINT: Added constraint x[15] + not_covered[7] ≤ 1 for terminal 7
DEBUG CONSTRAINT: Added constraint x[16] + not_covered[7] ≤ 1 for terminal 7
DEBUG CONSTRAINT: Added constraint x[19] + not_covered[7] ≤ 1 for terminal 7
DEBUG CONSTRAINT: Added constraint x[28] + not_covered[7] ≤ 1 for terminal 7
DEBUG CONSTRAINT: Added constraint x[35] + not_covered[7] ≤ 1 for terminal 7
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 10·not_covered[7] ≤ 10 for terminal 7
DEBUG CONSTRAINT: Added constraint x[6] + not_covered[8] ≤ 1 for terminal 8
DEBUG CONSTRAINT: Added constraint x[13] + not_covered[8] ≤ 1 for terminal 8
DEBUG CONSTRAINT: Added constraint x[14] + not_covered[8] ≤ 1 for terminal 8
DEBUG CONSTRAINT: Added constraint x[19] + not_covered[8] ≤ 1 for terminal 8
DEBUG CONSTRAINT: Added constraint x[28] + not_covered[8] ≤ 1 for terminal 8
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 5·not_covered[8] ≤ 5 for terminal 8
DEBUG CONSTRAINT: Added constraint x[6] + not_covered[9] ≤ 1 for terminal 9
DEBUG CONSTRAINT: Added constraint x[7] + not_covered[9] ≤ 1 for terminal 9
DEBUG CONSTRAINT: Added constraint x[8] + not_covered[9] ≤ 1 for terminal 9
DEBUG CONSTRAINT: Added constraint x[9] + not_covered[9] ≤ 1 for terminal 9
DEBUG CONSTRAINT: Added constraint x[12] + not_covered[9] ≤ 1 for terminal 9
DEBUG CONSTRAINT: Added constraint x[13] + not_covered[9] ≤ 1 for terminal 9
DEBUG CONSTRAINT: Added constraint x[14] + not_covered[9] ≤ 1 for terminal 9
DEBUG CONSTRAINT: Added constraint x[15] + not_covered[9] ≤ 1 for terminal 9
DEBUG CONSTRAINT: Added constraint x[16] + not_covered[9] ≤ 1 for terminal 9
DEBUG CONSTRAINT: Added constraint x[19] + not_covered[9] ≤ 1 for terminal 9
DEBUG CONSTRAINT: Added constraint x[25] + not_covered[9] ≤ 1 for terminal 9
DEBUG CONSTRAINT: Added constraint x[34] + not_covered[9] ≤ 1 for terminal 9
DEBUG CONSTRAINT: Added constraint x[35] + not_covered[9] ≤ 1 for terminal 9
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 13·not_covered[9] ≤ 13 for terminal 9
DEBUG CONSTRAINT: Added constraint x[1] + not_covered[10] ≤ 1 for terminal 10
DEBUG CONSTRAINT: Added constraint x[29] + not_covered[10] ≤ 1 for terminal 10
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 2·not_covered[10] ≤ 2 for terminal 10
DEBUG CONSTRAINT: Added constraint x[5] + not_covered[11] ≤ 1 for terminal 11
DEBUG CONSTRAINT: Added constraint x[7] + not_covered[11] ≤ 1 for terminal 11
DEBUG CONSTRAINT: Added constraint x[8] + not_covered[11] ≤ 1 for terminal 11
DEBUG CONSTRAINT: Added constraint x[9] + not_covered[11] ≤ 1 for terminal 11
DEBUG CONSTRAINT: Added constraint x[13] + not_covered[11] ≤ 1 for terminal 11
DEBUG CONSTRAINT: Added constraint x[16] + not_covered[11] ≤ 1 for terminal 11
DEBUG CONSTRAINT: Added constraint x[34] + not_covered[11] ≤ 1 for terminal 11
DEBUG CONSTRAINT: Added constraint x[36] + not_covered[11] ≤ 1 for terminal 11
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 8·not_covered[11] ≤ 8 for terminal 11
DEBUG CONSTRAINT: Added constraint x[9] + not_covered[12] ≤ 1 for terminal 12
DEBUG CONSTRAINT: Added constraint x[10] + not_covered[12] ≤ 1 for terminal 12
DEBUG CONSTRAINT: Added constraint x[18] + not_covered[12] ≤ 1 for terminal 12
DEBUG CONSTRAINT: Added constraint x[20] + not_covered[12] ≤ 1 for terminal 12
DEBUG CONSTRAINT: Added constraint x[37] + not_covered[12] ≤ 1 for terminal 12
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 5·not_covered[12] ≤ 5 for terminal 12
DEBUG CONSTRAINT: Added constraint x[2] + not_covered[13] ≤ 1 for terminal 13
DEBUG CONSTRAINT: Added constraint x[27] + not_covered[13] ≤ 1 for terminal 13
DEBUG CONSTRAINT: Added constraint x[32] + not_covered[13] ≤ 1 for terminal 13
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 3·not_covered[13] ≤ 3 for terminal 13
DEBUG CONSTRAINT: Added constraint x[10] + not_covered[14] ≤ 1 for terminal 14
DEBUG CONSTRAINT: Added constraint x[26] + not_covered[14] ≤ 1 for terminal 14
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 2·not_covered[14] ≤ 2 for terminal 14
DEBUG CONSTRAINT: Added constraint x[3] + not_covered[15] ≤ 1 for terminal 15
DEBUG CONSTRAINT: Added constraint x[11] + not_covered[15] ≤ 1 for terminal 15
DEBUG CONSTRAINT: Added constraint x[17] + not_covered[15] ≤ 1 for terminal 15
DEBUG CONSTRAINT: Added constraint x[18] + not_covered[15] ≤ 1 for terminal 15
DEBUG CONSTRAINT: Added constraint x[20] + not_covered[15] ≤ 1 for terminal 15
DEBUG CONSTRAINT: Added constraint x[22] + not_covered[15] ≤ 1 for terminal 15
DEBUG CONSTRAINT: Added constraint x[38] + not_covered[15] ≤ 1 for terminal 15
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 7·not_covered[15] ≤ 7 for terminal 15
DEBUG CONSTRAINT: Added constraint x[23] + not_covered[16] ≤ 1 for terminal 16
DEBUG CONSTRAINT: Added constraint x[24] + not_covered[16] ≤ 1 for terminal 16
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 2·not_covered[16] ≤ 2 for terminal 16
DEBUG CONSTRAINT: Added constraint x[12] + not_covered[17] ≤ 1 for terminal 17
DEBUG CONSTRAINT: Added constraint x[15] + not_covered[17] ≤ 1 for terminal 17
DEBUG CONSTRAINT: Added constraint x[19] + not_covered[17] ≤ 1 for terminal 17
DEBUG CONSTRAINT: Added constraint x[21] + not_covered[17] ≤ 1 for terminal 17
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 4·not_covered[17] ≤ 4 for terminal 17
DEBUG CONSTRAINT: Added constraint x[12] + not_covered[18] ≤ 1 for terminal 18
DEBUG CONSTRAINT: Added constraint x[14] + not_covered[18] ≤ 1 for terminal 18
DEBUG CONSTRAINT: Added constraint x[15] + not_covered[18] ≤ 1 for terminal 18
DEBUG CONSTRAINT: Added constraint x[19] + not_covered[18] ≤ 1 for terminal 18
DEBUG CONSTRAINT: Added constraint x[21] + not_covered[18] ≤ 1 for terminal 18
DEBUG CONSTRAINT: Added constraint x[25] + not_covered[18] ≤ 1 for terminal 18
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 6·not_covered[18] ≤ 6 for terminal 18
DEBUG CONSTRAINT: Added constraint x[4] + not_covered[19] ≤ 1 for terminal 19
DEBUG CONSTRAINT: Added constraint x[10] + not_covered[19] ≤ 1 for terminal 19
DEBUG CONSTRAINT: Added constraint x[11] + not_covered[19] ≤ 1 for terminal 19
DEBUG CONSTRAINT: Added constraint x[17] + not_covered[19] ≤ 1 for terminal 19
DEBUG CONSTRAINT: Added constraint x[18] + not_covered[19] ≤ 1 for terminal 19
DEBUG CONSTRAINT: Added constraint x[20] + not_covered[19] ≤ 1 for terminal 19
DEBUG CONSTRAINT: Added constraint x[26] + not_covered[19] ≤ 1 for terminal 19
DEBUG CONSTRAINT: Added constraint x[37] + not_covered[19] ≤ 1 for terminal 19
DEBUG CONSTRAINT: Added constraint x[38] + not_covered[19] ≤ 1 for terminal 19
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 9·not_covered[19] ≤ 9 for terminal 19
DEBUG CONSTRAINT: Added source terminal constraint: not_covered[0] = 0
DEBUG BUDGET: Adding budget constraint ≤ 1800000.000 to constraint pool
DEBUG BUDGET: Using raw tree costs directly
DEBUG BUDGET: Budget limit: 1800000.000
DEBUG BUDGET: Building raw cost constraint coefficients:
DEBUG BUDGET:   x[0] coefficient = 398991 (raw=398991.100)
DEBUG BUDGET:   x[1] coefficient = 260889 (raw=260889.712)
DEBUG BUDGET:   x[2] coefficient = 256773 (raw=256773.057)
DEBUG BUDGET:   x[3] coefficient = 376541 (raw=376541.557)
DEBUG BUDGET:   x[4] coefficient = 646084 (raw=646084.462)
DEBUG BUDGET:   x[5] coefficient = 520973 (raw=520973.020)
DEBUG BUDGET:   x[6] coefficient = 334575 (raw=334575.182)
DEBUG BUDGET:   x[7] coefficient = 494448 (raw=494448.457)
DEBUG BUDGET:   x[8] coefficient = 455905 (raw=455905.519)
DEBUG BUDGET:   x[9] coefficient = 584020 (raw=584020.499)
DEBUG BUDGET:   x[10] coefficient = 380918 (raw=380918.244)
DEBUG BUDGET:   x[11] coefficient = 621357 (raw=621357.781)
DEBUG BUDGET:   x[12] coefficient = 120675 (raw=120675.719)
DEBUG BUDGET:   x[13] coefficient = 551354 (raw=551354.477)
DEBUG BUDGET:   x[14] coefficient = 410262 (raw=410262.679)
DEBUG BUDGET:   x[15] coefficient = 362962 (raw=362962.653)
DEBUG BUDGET:   x[16] coefficient = 702244 (raw=702244.403)
DEBUG BUDGET:   x[17] coefficient = 673894 (raw=673894.542)
DEBUG BUDGET:   x[18] coefficient = 933994 (raw=933994.022)
DEBUG BUDGET:   x[19] coefficient = 454199 (raw=454199.906)
DEBUG BUDGET:   x[20] coefficient = 986439 (raw=986439.144)
DEBUG BUDGET:   x[21] coefficient = 46859 (raw=46859.249)
DEBUG BUDGET:   x[22] coefficient = 52662 (raw=52662.185)
DEBUG BUDGET:   x[23] coefficient = 62275 (raw=62275.339)
DEBUG BUDGET:   x[24] coefficient = 75379 (raw=75379.993)
DEBUG BUDGET:   x[25] coefficient = 75695 (raw=75695.846)
DEBUG BUDGET:   x[26] coefficient = 80703 (raw=80703.013)
DEBUG BUDGET:   x[27] coefficient = 93734 (raw=93734.596)
DEBUG BUDGET:   x[28] coefficient = 95452 (raw=95452.578)
DEBUG BUDGET:   x[29] coefficient = 102977 (raw=102977.757)
DEBUG BUDGET:   x[30] coefficient = 165327 (raw=165327.925)
DEBUG BUDGET:   x[31] coefficient = 170420 (raw=170420.027)
DEBUG BUDGET:   x[32] coefficient = 179069 (raw=179069.657)
DEBUG BUDGET:   x[33] coefficient = 234458 (raw=234458.486)
DEBUG BUDGET:   x[34] coefficient = 235891 (raw=235891.713)
DEBUG BUDGET:   x[35] coefficient = 242462 (raw=242462.956)
DEBUG BUDGET:   x[36] coefficient = 258947 (raw=258947.370)
DEBUG BUDGET:   x[37] coefficient = 313063 (raw=313063.098)
DEBUG BUDGET:   x[38] coefficient = 314219 (raw=314219.517)
DEBUG BUDGET:   x[39] coefficient = 327174 (raw=327174.269)
DEBUG BUDGET: Constraint: Σ tree_cost[i] * x[i] ≤ 1800000
DEBUG BUDGET: Budget constraint added to pool with 40 FSTs
DEBUG CONSTRAINT: Adding 'at least one FST' constraint: Σ x[i] ≥ 1
DEBUG CONSTRAINT: Added 'at least one FST' constraint: Σ x[i] ≥ 1
 % _gst_initialize_constraint_pool: 0.00 seconds.
 % Constraint pool initialized with:
 % 	1	Total degree rows	40	coeffs.
 % 	20	Cutset rows		111	coeffs.
 % 	0	Incompatibility rows	0	coeffs.
 % 	29	2-terminal SEC rows	102	coeffs.
 % 	1	At least one FST rows	40	coeffs.
 % 	163	Total rows in pool	135	in LP
 % @PMEM 163 rows, 1 blocks, 415 nzfree, 0 nzwasted, 1172 nztotal
DEBUG SOFT: Found 20 terminals, 40 FSTs
DEBUG SOFT: Adding space for 20 not_covered variables in soft constraints, total ncoeff=514
DEBUG LP_SETUP: Created LP with 0 rows, 60 columns (nedges=40 + nterms=20)
DEBUG SOFT: Set bounds for 40 FST vars [1-40] and 20 coverage vars [41-60]
DEBUG OBJ: Using raw costs - alpha=10000.0 (battery weight), beta=1500000 (coverage penalty)
DEBUG OBJ: Allocated rowvec[0-60] for ncols=60 LP variables
DEBUG OBJ: Full_trees battery_score=0.000 for FST 0
DEBUG OBJ: Recalculating for FST 0 with 3 terminals
DEBUG OBJ: Terminal 0 (idx 5): battery=79.50, running_total=79.50
DEBUG OBJ: Terminal 1 (idx 1): battery=94.00, running_total=173.50
DEBUG OBJ: Terminal 2 (idx 4): battery=98.00, running_total=271.50
DEBUG OBJ: Recalculated battery_score=271.500 for FST 0
DEBUG OBJ: FST 0: tree_cost=398991.100, battery_cost=271.500 (weighted=2715000.0), combined=3113991.1
DEBUG OBJ: Full_trees battery_score=0.000 for FST 1
DEBUG OBJ: Recalculating for FST 1 with 3 terminals
DEBUG OBJ: Terminal 0 (idx 10): battery=82.20, running_total=82.20
DEBUG OBJ: Terminal 1 (idx 5): battery=79.50, running_total=161.70
DEBUG OBJ: Terminal 2 (idx 4): battery=98.00, running_total=259.70
DEBUG OBJ: Recalculated battery_score=259.700 for FST 1
DEBUG OBJ: FST 1: tree_cost=260889.712, battery_cost=259.700 (weighted=2597000.0), combined=2857889.7
DEBUG OBJ: Full_trees battery_score=0.000 for FST 2
DEBUG OBJ: Recalculating for FST 2 with 3 terminals
DEBUG OBJ: Terminal 0 (idx 13): battery=61.90, running_total=61.90
DEBUG OBJ: Terminal 1 (idx 0): battery=100.00, running_total=161.90
DEBUG OBJ: Terminal 2 (idx 6): battery=94.60, running_total=256.50
DEBUG OBJ: Recalculated battery_score=256.500 for FST 2
DEBUG OBJ: FST 2: tree_cost=256773.057, battery_cost=256.500 (weighted=2565000.0), combined=2821773.1
DEBUG OBJ: Full_trees battery_score=0.000 for FST 3
DEBUG OBJ: Recalculating for FST 3 with 3 terminals
DEBUG OBJ: Terminal 0 (idx 15): battery=88.60, running_total=88.60
DEBUG OBJ: Terminal 1 (idx 3): battery=87.50, running_total=176.10
DEBUG OBJ: Terminal 2 (idx 6): battery=94.60, running_total=270.70
DEBUG OBJ: Recalculated battery_score=270.700 for FST 3
DEBUG OBJ: FST 3: tree_cost=376541.557, battery_cost=270.700 (weighted=2707000.0), combined=3083541.6
DEBUG OBJ: Full_trees battery_score=0.000 for FST 4
DEBUG OBJ: Recalculating for FST 4 with 3 terminals
DEBUG OBJ: Terminal 0 (idx 19): battery=99.60, running_total=99.60
DEBUG OBJ: Terminal 1 (idx 3): battery=87.50, running_total=187.10
DEBUG OBJ: Terminal 2 (idx 6): battery=94.60, running_total=281.70
DEBUG OBJ: Recalculated battery_score=281.700 for FST 4
DEBUG OBJ: FST 4: tree_cost=646084.462, battery_cost=281.700 (weighted=2817000.0), combined=3463084.5
DEBUG OBJ: Full_trees battery_score=0.000 for FST 5
DEBUG OBJ: Recalculating for FST 5 with 3 terminals
DEBUG OBJ: Terminal 0 (idx 11): battery=38.70, running_total=38.70
DEBUG OBJ: Terminal 1 (idx 2): battery=94.00, running_total=132.70
DEBUG OBJ: Terminal 2 (idx 7): battery=100.00, running_total=232.70
DEBUG OBJ: Recalculated battery_score=232.700 for FST 5
DEBUG OBJ: FST 5: tree_cost=520973.020, battery_cost=232.700 (weighted=2327000.0), combined=2847973.0
DEBUG OBJ: Full_trees battery_score=0.000 for FST 6
DEBUG OBJ: Recalculating for FST 6 with 3 terminals
DEBUG OBJ: Terminal 0 (idx 9): battery=98.10, running_total=98.10
DEBUG OBJ: Terminal 1 (idx 7): battery=100.00, running_total=198.10
DEBUG OBJ: Terminal 2 (idx 8): battery=100.00, running_total=298.10
DEBUG OBJ: Recalculated battery_score=298.100 for FST 6
DEBUG OBJ: FST 6: tree_cost=334575.182, battery_cost=298.100 (weighted=2981000.0), combined=3315575.2
DEBUG OBJ: Full_trees battery_score=0.000 for FST 7
DEBUG OBJ: Recalculating for FST 7 with 3 terminals
DEBUG OBJ: Terminal 0 (idx 11): battery=38.70, running_total=38.70
DEBUG OBJ: Terminal 1 (idx 2): battery=94.00, running_total=132.70
DEBUG OBJ: Terminal 2 (idx 9): battery=98.10, running_total=230.80
DEBUG OBJ: Recalculated battery_score=230.800 for FST 7
DEBUG OBJ: FST 7: tree_cost=494448.457, battery_cost=230.800 (weighted=2308000.0), combined=2802448.5
DEBUG OBJ: Full_trees battery_score=0.000 for FST 8
DEBUG OBJ: Recalculating for FST 8 with 3 terminals
DEBUG OBJ: Terminal 0 (idx 11): battery=38.70, running_total=38.70
DEBUG OBJ: Terminal 1 (idx 7): battery=100.00, running_total=138.70
DEBUG OBJ: Terminal 2 (idx 9): battery=98.10, running_total=236.80
DEBUG OBJ: Recalculated battery_score=236.800 for FST 8
DEBUG OBJ: FST 8: tree_cost=455905.519, battery_cost=236.800 (weighted=2368000.0), combined=2823905.5
DEBUG OBJ: Full_trees battery_score=0.000 for FST 9
DEBUG OBJ: Recalculating for FST 9 with 3 terminals
DEBUG OBJ: Terminal 0 (idx 12): battery=95.00, running_total=95.00
DEBUG OBJ: Terminal 1 (idx 11): battery=38.70, running_total=133.70
DEBUG OBJ: Terminal 2 (idx 9): battery=98.10, running_total=231.80
DEBUG OBJ: Recalculated battery_score=231.800 for FST 9
DEBUG OBJ: FST 9: tree_cost=584020.499, battery_cost=231.800 (weighted=2318000.0), combined=2902020.5
DEBUG OBJ: Full_trees battery_score=0.000 for FST 10
DEBUG OBJ: Recalculating for FST 10 with 3 terminals
DEBUG OBJ: Terminal 0 (idx 19): battery=99.60, running_total=99.60
DEBUG OBJ: Terminal 1 (idx 12): battery=95.00, running_total=194.60
DEBUG OBJ: Terminal 2 (idx 14): battery=62.30, running_total=256.90
DEBUG OBJ: Recalculated battery_score=256.900 for FST 10
DEBUG OBJ: FST 10: tree_cost=380918.244, battery_cost=256.900 (weighted=2569000.0), combined=2949918.2
DEBUG OBJ: Full_trees battery_score=0.000 for FST 11
DEBUG OBJ: Recalculating for FST 11 with 3 terminals
DEBUG OBJ: Terminal 0 (idx 19): battery=99.60, running_total=99.60
DEBUG OBJ: Terminal 1 (idx 15): battery=88.60, running_total=188.20
DEBUG OBJ: Terminal 2 (idx 6): battery=94.60, running_total=282.80
DEBUG OBJ: Recalculated battery_score=282.800 for FST 11
DEBUG OBJ: FST 11: tree_cost=621357.781, battery_cost=282.800 (weighted=2828000.0), combined=3449357.8
DEBUG OBJ: Full_trees battery_score=0.000 for FST 12
DEBUG OBJ: Recalculating for FST 12 with 3 terminals
DEBUG OBJ: Terminal 0 (idx 18): battery=73.20, running_total=73.20
DEBUG OBJ: Terminal 1 (idx 9): battery=98.10, running_total=171.30
DEBUG OBJ: Terminal 2 (idx 17): battery=98.60, running_total=269.90
DEBUG OBJ: Recalculated battery_score=269.900 for FST 12
DEBUG OBJ: FST 12: tree_cost=120675.719, battery_cost=269.900 (weighted=2699000.0), combined=2819675.7
DEBUG OBJ: Full_trees battery_score=0.000 for FST 13
DEBUG OBJ: Recalculating for FST 13 with 4 terminals
DEBUG OBJ: Terminal 0 (idx 11): battery=38.70, running_total=38.70
DEBUG OBJ: Terminal 1 (idx 7): battery=100.00, running_total=138.70
DEBUG OBJ: Terminal 2 (idx 8): battery=100.00, running_total=238.70
DEBUG OBJ: Terminal 3 (idx 9): battery=98.10, running_total=336.80
DEBUG OBJ: Recalculated battery_score=336.800 for FST 13
DEBUG OBJ: FST 13: tree_cost=551354.477, battery_cost=336.800 (weighted=3368000.0), combined=3919354.5
DEBUG OBJ: Full_trees battery_score=0.000 for FST 14
DEBUG OBJ: Recalculating for FST 14 with 4 terminals
DEBUG OBJ: Terminal 0 (idx 18): battery=73.20, running_total=73.20
DEBUG OBJ: Terminal 1 (idx 9): battery=98.10, running_total=171.30
DEBUG OBJ: Terminal 2 (idx 7): battery=100.00, running_total=271.30
DEBUG OBJ: Terminal 3 (idx 8): battery=100.00, running_total=371.30
DEBUG OBJ: Recalculated battery_score=371.300 for FST 14
DEBUG OBJ: FST 14: tree_cost=410262.679, battery_cost=371.300 (weighted=3713000.0), combined=4123262.7
DEBUG OBJ: Full_trees battery_score=0.000 for FST 15
DEBUG OBJ: Recalculating for FST 15 with 4 terminals
DEBUG OBJ: Terminal 0 (idx 18): battery=73.20, running_total=73.20
DEBUG OBJ: Terminal 1 (idx 9): battery=98.10, running_total=171.30
DEBUG OBJ: Terminal 2 (idx 7): battery=100.00, running_total=271.30
DEBUG OBJ: Terminal 3 (idx 17): battery=98.60, running_total=369.90
DEBUG OBJ: Recalculated battery_score=369.900 for FST 15
DEBUG OBJ: FST 15: tree_cost=362962.653, battery_cost=369.900 (weighted=3699000.0), combined=4061962.7
DEBUG OBJ: Full_trees battery_score=0.000 for FST 16
DEBUG OBJ: Recalculating for FST 16 with 4 terminals
DEBUG OBJ: Terminal 0 (idx 11): battery=38.70, running_total=38.70
DEBUG OBJ: Terminal 1 (idx 2): battery=94.00, running_total=132.70
DEBUG OBJ: Terminal 2 (idx 7): battery=100.00, running_total=232.70
DEBUG OBJ: Terminal 3 (idx 9): battery=98.10, running_total=330.80
DEBUG OBJ: Recalculated battery_score=330.800 for FST 16
DEBUG OBJ: FST 16: tree_cost=702244.403, battery_cost=330.800 (weighted=3308000.0), combined=4010244.4
DEBUG OBJ: Full_trees battery_score=0.000 for FST 17
DEBUG OBJ: Recalculating for FST 17 with 4 terminals
DEBUG OBJ: Terminal 0 (idx 19): battery=99.60, running_total=99.60
DEBUG OBJ: Terminal 1 (idx 15): battery=88.60, running_total=188.20
DEBUG OBJ: Terminal 2 (idx 3): battery=87.50, running_total=275.70
DEBUG OBJ: Terminal 3 (idx 6): battery=94.60, running_total=370.30
DEBUG OBJ: Recalculated battery_score=370.300 for FST 17
DEBUG OBJ: FST 17: tree_cost=673894.542, battery_cost=370.300 (weighted=3703000.0), combined=4376894.5
DEBUG OBJ: Full_trees battery_score=0.000 for FST 18
DEBUG OBJ: Recalculating for FST 18 with 4 terminals
DEBUG OBJ: Terminal 0 (idx 19): battery=99.60, running_total=99.60
DEBUG OBJ: Terminal 1 (idx 15): battery=88.60, running_total=188.20
DEBUG OBJ: Terminal 2 (idx 6): battery=94.60, running_total=282.80
DEBUG OBJ: Terminal 3 (idx 12): battery=95.00, running_total=377.80
DEBUG OBJ: Recalculated battery_score=377.800 for FST 18
DEBUG OBJ: FST 18: tree_cost=933994.022, battery_cost=377.800 (weighted=3778000.0), combined=4711994.0
DEBUG OBJ: Full_trees battery_score=0.000 for FST 19
DEBUG OBJ: Recalculating for FST 19 with 5 terminals
DEBUG OBJ: Terminal 0 (idx 18): battery=73.20, running_total=73.20
DEBUG OBJ: Terminal 1 (idx 9): battery=98.10, running_total=171.30
DEBUG OBJ: Terminal 2 (idx 7): battery=100.00, running_total=271.30
DEBUG OBJ: Terminal 3 (idx 8): battery=100.00, running_total=371.30
DEBUG OBJ: Terminal 4 (idx 17): battery=98.60, running_total=469.90
DEBUG OBJ: Recalculated battery_score=469.900 for FST 19
DEBUG OBJ: FST 19: tree_cost=454199.906, battery_cost=469.900 (weighted=4699000.0), combined=5153199.9
DEBUG OBJ: Full_trees battery_score=0.000 for FST 20
DEBUG OBJ: Recalculating for FST 20 with 5 terminals
DEBUG OBJ: Terminal 0 (idx 19): battery=99.60, running_total=99.60
DEBUG OBJ: Terminal 1 (idx 15): battery=88.60, running_total=188.20
DEBUG OBJ: Terminal 2 (idx 3): battery=87.50, running_total=275.70
DEBUG OBJ: Terminal 3 (idx 6): battery=94.60, running_total=370.30
DEBUG OBJ: Terminal 4 (idx 12): battery=95.00, running_total=465.30
DEBUG OBJ: Recalculated battery_score=465.300 for FST 20
DEBUG OBJ: FST 20: tree_cost=986439.144, battery_cost=465.300 (weighted=4653000.0), combined=5639439.1
DEBUG OBJ: Full_trees battery_score=0.000 for FST 21
DEBUG OBJ: Recalculating for FST 21 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 18): battery=73.20, running_total=73.20
DEBUG OBJ: Terminal 1 (idx 17): battery=98.60, running_total=171.80
DEBUG OBJ: Recalculated battery_score=171.800 for FST 21
DEBUG OBJ: FST 21: tree_cost=46859.249, battery_cost=171.800 (weighted=1718000.0), combined=1764859.2
DEBUG OBJ: Full_trees battery_score=0.000 for FST 22
DEBUG OBJ: Recalculating for FST 22 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 15): battery=88.60, running_total=88.60
DEBUG OBJ: Terminal 1 (idx 3): battery=87.50, running_total=176.10
DEBUG OBJ: Recalculated battery_score=176.100 for FST 22
DEBUG OBJ: FST 22: tree_cost=52662.185, battery_cost=176.100 (weighted=1761000.0), combined=1813662.2
DEBUG OBJ: Full_trees battery_score=0.000 for FST 23
DEBUG OBJ: Recalculating for FST 23 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 16): battery=80.00, running_total=80.00
DEBUG OBJ: Terminal 1 (idx 2): battery=94.00, running_total=174.00
DEBUG OBJ: Recalculated battery_score=174.000 for FST 23
DEBUG OBJ: FST 23: tree_cost=62275.339, battery_cost=174.000 (weighted=1740000.0), combined=1802275.3
DEBUG OBJ: Full_trees battery_score=0.000 for FST 24
DEBUG OBJ: Recalculating for FST 24 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 16): battery=80.00, running_total=80.00
DEBUG OBJ: Terminal 1 (idx 1): battery=94.00, running_total=174.00
DEBUG OBJ: Recalculated battery_score=174.000 for FST 24
DEBUG OBJ: FST 24: tree_cost=75379.993, battery_cost=174.000 (weighted=1740000.0), combined=1815380.0
DEBUG OBJ: Full_trees battery_score=0.000 for FST 25
DEBUG OBJ: Recalculating for FST 25 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 18): battery=73.20, running_total=73.20
DEBUG OBJ: Terminal 1 (idx 9): battery=98.10, running_total=171.30
DEBUG OBJ: Recalculated battery_score=171.300 for FST 25
DEBUG OBJ: FST 25: tree_cost=75695.846, battery_cost=171.300 (weighted=1713000.0), combined=1788695.8
DEBUG OBJ: Full_trees battery_score=0.000 for FST 26
DEBUG OBJ: Recalculating for FST 26 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 14): battery=62.30, running_total=62.30
DEBUG OBJ: Terminal 1 (idx 19): battery=99.60, running_total=161.90
DEBUG OBJ: Recalculated battery_score=161.900 for FST 26
DEBUG OBJ: FST 26: tree_cost=80703.013, battery_cost=161.900 (weighted=1619000.0), combined=1699703.0
DEBUG OBJ: Full_trees battery_score=0.000 for FST 27
DEBUG OBJ: Recalculating for FST 27 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 0): battery=100.00, running_total=100.00
DEBUG OBJ: Terminal 1 (idx 13): battery=61.90, running_total=161.90
DEBUG OBJ: Recalculated battery_score=161.900 for FST 27
DEBUG OBJ: FST 27: tree_cost=93734.596, battery_cost=161.900 (weighted=1619000.0), combined=1712734.6
DEBUG OBJ: Full_trees battery_score=0.000 for FST 28
DEBUG OBJ: Recalculating for FST 28 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 8): battery=100.00, running_total=100.00
DEBUG OBJ: Terminal 1 (idx 7): battery=100.00, running_total=200.00
DEBUG OBJ: Recalculated battery_score=200.000 for FST 28
DEBUG OBJ: FST 28: tree_cost=95452.578, battery_cost=200.000 (weighted=2000000.0), combined=2095452.6
DEBUG OBJ: Full_trees battery_score=0.000 for FST 29
DEBUG OBJ: Recalculating for FST 29 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 5): battery=79.50, running_total=79.50
DEBUG OBJ: Terminal 1 (idx 10): battery=82.20, running_total=161.70
DEBUG OBJ: Recalculated battery_score=161.700 for FST 29
DEBUG OBJ: FST 29: tree_cost=102977.757, battery_cost=161.700 (weighted=1617000.0), combined=1719977.8
DEBUG OBJ: Full_trees battery_score=0.000 for FST 30
DEBUG OBJ: Recalculating for FST 30 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 4): battery=98.00, running_total=98.00
DEBUG OBJ: Terminal 1 (idx 5): battery=79.50, running_total=177.50
DEBUG OBJ: Recalculated battery_score=177.500 for FST 30
DEBUG OBJ: FST 30: tree_cost=165327.925, battery_cost=177.500 (weighted=1775000.0), combined=1940327.9
DEBUG OBJ: Full_trees battery_score=0.000 for FST 31
DEBUG OBJ: Recalculating for FST 31 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 6): battery=94.60, running_total=94.60
DEBUG OBJ: Terminal 1 (idx 0): battery=100.00, running_total=194.60
DEBUG OBJ: Recalculated battery_score=194.600 for FST 31
DEBUG OBJ: FST 31: tree_cost=170420.027, battery_cost=194.600 (weighted=1946000.0), combined=2116420.0
DEBUG OBJ: Full_trees battery_score=0.000 for FST 32
DEBUG OBJ: Recalculating for FST 32 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 13): battery=61.90, running_total=61.90
DEBUG OBJ: Terminal 1 (idx 4): battery=98.00, running_total=159.90
DEBUG OBJ: Recalculated battery_score=159.900 for FST 32
DEBUG OBJ: FST 32: tree_cost=179069.657, battery_cost=159.900 (weighted=1599000.0), combined=1778069.7
DEBUG OBJ: Full_trees battery_score=0.000 for FST 33
DEBUG OBJ: Recalculating for FST 33 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 5): battery=79.50, running_total=79.50
DEBUG OBJ: Terminal 1 (idx 1): battery=94.00, running_total=173.50
DEBUG OBJ: Recalculated battery_score=173.500 for FST 33
DEBUG OBJ: FST 33: tree_cost=234458.486, battery_cost=173.500 (weighted=1735000.0), combined=1969458.5
DEBUG OBJ: Full_trees battery_score=0.000 for FST 34
DEBUG OBJ: Recalculating for FST 34 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 11): battery=38.70, running_total=38.70
DEBUG OBJ: Terminal 1 (idx 9): battery=98.10, running_total=136.80
DEBUG OBJ: Recalculated battery_score=136.800 for FST 34
DEBUG OBJ: FST 34: tree_cost=235891.713, battery_cost=136.800 (weighted=1368000.0), combined=1603891.7
DEBUG OBJ: Full_trees battery_score=0.000 for FST 35
DEBUG OBJ: Recalculating for FST 35 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 9): battery=98.10, running_total=98.10
DEBUG OBJ: Terminal 1 (idx 7): battery=100.00, running_total=198.10
DEBUG OBJ: Recalculated battery_score=198.100 for FST 35
DEBUG OBJ: FST 35: tree_cost=242462.956, battery_cost=198.100 (weighted=1981000.0), combined=2223463.0
DEBUG OBJ: Full_trees battery_score=0.000 for FST 36
DEBUG OBJ: Recalculating for FST 36 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 2): battery=94.00, running_total=94.00
DEBUG OBJ: Terminal 1 (idx 11): battery=38.70, running_total=132.70
DEBUG OBJ: Recalculated battery_score=132.700 for FST 36
DEBUG OBJ: FST 36: tree_cost=258947.370, battery_cost=132.700 (weighted=1327000.0), combined=1585947.4
DEBUG OBJ: Full_trees battery_score=0.000 for FST 37
DEBUG OBJ: Recalculating for FST 37 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 19): battery=99.60, running_total=99.60
DEBUG OBJ: Terminal 1 (idx 12): battery=95.00, running_total=194.60
DEBUG OBJ: Recalculated battery_score=194.600 for FST 37
DEBUG OBJ: FST 37: tree_cost=313063.098, battery_cost=194.600 (weighted=1946000.0), combined=2259063.1
DEBUG OBJ: Full_trees battery_score=0.000 for FST 38
DEBUG OBJ: Recalculating for FST 38 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 15): battery=88.60, running_total=88.60
DEBUG OBJ: Terminal 1 (idx 19): battery=99.60, running_total=188.20
DEBUG OBJ: Recalculated battery_score=188.200 for FST 38
DEBUG OBJ: FST 38: tree_cost=314219.517, battery_cost=188.200 (weighted=1882000.0), combined=2196219.5
DEBUG OBJ: Full_trees battery_score=0.000 for FST 39
DEBUG OBJ: Recalculating for FST 39 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 3): battery=87.50, running_total=87.50
DEBUG OBJ: Terminal 1 (idx 6): battery=94.60, running_total=182.10
DEBUG OBJ: Recalculated battery_score=182.100 for FST 39
DEBUG OBJ: FST 39: tree_cost=327174.269, battery_cost=182.100 (weighted=1821000.0), combined=2148174.3
DEBUG OBJ: Added penalty terms beta=1500000 for 20 not_covered variables [41-60]
DEBUG LP_MATRIX: LP has 0 rows, 60 columns after setup
DEBUG EXTRA_COEFF: Calculated extra_coeff=1 for 135 rows
DEBUG SOFT: Added not_covered_0 (RC_var 43 -> matrix_idx 40) to soft constraint 134
DEBUG MATRIX_CHECK: nzi=495, ncoeff=514, extra_coeff=1, expected=515
ERROR: Matrix coefficient count mismatch! nzi=495 != ncoeff=514 + extra_coeff=1
WARNING: Allowing discrepancy in budget mode (nzi=495 vs expected=515)
DEBUG MATRIX: Total matrix has 495 entries (nzi=495)
DEBUG MATRIX: matbeg[135] = 495 (should equal nzi)
DEBUG LP: Calling add_rows with 135 rows
DEBUG LP: Before add_rows: LP has 0 rows, 60 cols, 60 nonzeros
DEBUG LP: After add_rows: LP has 135 rows, 60 cols, 555 nonzeros
DEBUG NLPROWS: nrows=135, extra_rows=0, setting nlprows=135
 % _gst_build_initial_formulation: 0.00 seconds.
DEBUG BB: Expected nlprows=135, total rows=163
DEBUG BB: Row 0 (uid=0) has lprow=0 (included, j=0)
DEBUG BB: Row 1 (uid=1) has lprow=1 (included, j=1)
DEBUG BB: Row 2 (uid=2) has lprow=2 (included, j=2)
DEBUG BB: Row 3 (uid=3) has lprow=3 (included, j=3)
DEBUG BB: Row 4 (uid=4) has lprow=4 (included, j=4)
DEBUG BB: Row 5 (uid=5) has lprow=5 (included, j=5)
DEBUG BB: Row 6 (uid=6) has lprow=6 (included, j=6)
DEBUG BB: Row 7 (uid=7) has lprow=7 (included, j=7)
DEBUG BB: Row 8 (uid=8) has lprow=8 (included, j=8)
DEBUG BB: Row 9 (uid=9) has lprow=9 (included, j=9)
DEBUG BB: Row 10 (uid=10) has lprow=10 (included, j=10)
DEBUG BB: Row 11 (uid=11) has lprow=11 (included, j=11)
DEBUG BB: Row 12 (uid=12) has lprow=12 (included, j=12)
DEBUG BB: Row 13 (uid=13) has lprow=13 (included, j=13)
DEBUG BB: Row 14 (uid=14) has lprow=14 (included, j=14)
DEBUG BB: Row 15 (uid=15) has lprow=15 (included, j=15)
DEBUG BB: Row 16 (uid=16) has lprow=16 (included, j=16)
DEBUG BB: Row 17 (uid=17) has lprow=17 (included, j=17)
DEBUG BB: Row 18 (uid=18) has lprow=18 (included, j=18)
DEBUG BB: Row 19 (uid=19) has lprow=19 (included, j=19)
DEBUG BB: Row 20 (uid=20) has lprow=20 (included, j=20)
DEBUG BB: Row 21 (uid=21) has lprow=21 (included, j=21)
DEBUG BB: Row 22 (uid=22) has lprow=22 (included, j=22)
DEBUG BB: Row 23 (uid=23) has lprow=23 (included, j=23)
DEBUG BB: Row 24 (uid=24) has lprow=24 (included, j=24)
DEBUG BB: Row 25 (uid=25) has lprow=25 (included, j=25)
DEBUG BB: Row 26 (uid=26) has lprow=26 (included, j=26)
DEBUG BB: Row 27 (uid=27) has lprow=27 (included, j=27)
DEBUG BB: Row 28 (uid=28) has lprow=28 (included, j=28)
DEBUG BB: Row 29 (uid=29) has lprow=29 (included, j=29)
DEBUG BB: Row 30 (uid=30) has lprow=30 (included, j=30)
DEBUG BB: Row 31 (uid=31) has lprow=31 (included, j=31)
DEBUG BB: Row 32 (uid=32) has lprow=32 (included, j=32)
DEBUG BB: Row 33 (uid=33) has lprow=33 (included, j=33)
DEBUG BB: Row 34 (uid=34) has lprow=34 (included, j=34)
DEBUG BB: Row 35 (uid=35) has lprow=35 (included, j=35)
DEBUG BB: Row 36 (uid=36) has lprow=36 (included, j=36)
DEBUG BB: Row 37 (uid=37) has lprow=37 (included, j=37)
DEBUG BB: Row 38 (uid=38) has lprow=38 (included, j=38)
DEBUG BB: Row 39 (uid=39) has lprow=39 (included, j=39)
DEBUG BB: Row 40 (uid=40) has lprow=40 (included, j=40)
DEBUG BB: Row 41 (uid=41) has lprow=41 (included, j=41)
DEBUG BB: Row 42 (uid=42) has lprow=42 (included, j=42)
DEBUG BB: Row 43 (uid=43) has lprow=43 (included, j=43)
DEBUG BB: Row 44 (uid=44) has lprow=44 (included, j=44)
DEBUG BB: Row 45 (uid=45) has lprow=45 (included, j=45)
DEBUG BB: Row 46 (uid=46) has lprow=46 (included, j=46)
DEBUG BB: Row 47 (uid=47) has lprow=47 (included, j=47)
DEBUG BB: Row 48 (uid=48) has lprow=48 (included, j=48)
DEBUG BB: Row 49 (uid=49) has lprow=49 (included, j=49)
DEBUG BB: Row 50 (uid=50) has lprow=50 (included, j=50)
DEBUG BB: Row 51 (uid=51) has lprow=51 (included, j=51)
DEBUG BB: Row 52 (uid=52) has lprow=52 (included, j=52)
DEBUG BB: Row 53 (uid=53) has lprow=53 (included, j=53)
DEBUG BB: Row 54 (uid=54) has lprow=54 (included, j=54)
DEBUG BB: Row 55 (uid=55) has lprow=55 (included, j=55)
DEBUG BB: Row 56 (uid=56) has lprow=56 (included, j=56)
DEBUG BB: Row 57 (uid=57) has lprow=57 (included, j=57)
DEBUG BB: Row 58 (uid=58) has lprow=58 (included, j=58)
DEBUG BB: Row 59 (uid=59) has lprow=59 (included, j=59)
DEBUG BB: Row 60 (uid=60) has lprow=60 (included, j=60)
DEBUG BB: Row 61 (uid=61) has lprow=61 (included, j=61)
DEBUG BB: Row 62 (uid=62) has lprow=62 (included, j=62)
DEBUG BB: Row 63 (uid=63) has lprow=63 (included, j=63)
DEBUG BB: Row 64 (uid=64) has lprow=64 (included, j=64)
DEBUG BB: Row 65 (uid=65) has lprow=65 (included, j=65)
DEBUG BB: Row 66 (uid=66) has lprow=66 (included, j=66)
DEBUG BB: Row 67 (uid=67) has lprow=67 (included, j=67)
DEBUG BB: Row 68 (uid=68) has lprow=68 (included, j=68)
DEBUG BB: Row 69 (uid=69) has lprow=69 (included, j=69)
DEBUG BB: Row 70 (uid=70) has lprow=70 (included, j=70)
DEBUG BB: Row 71 (uid=71) has lprow=71 (included, j=71)
DEBUG BB: Row 72 (uid=72) has lprow=72 (included, j=72)
DEBUG BB: Row 73 (uid=73) has lprow=73 (included, j=73)
DEBUG BB: Row 74 (uid=74) has lprow=74 (included, j=74)
DEBUG BB: Row 75 (uid=75) has lprow=75 (included, j=75)
DEBUG BB: Row 76 (uid=76) has lprow=76 (included, j=76)
DEBUG BB: Row 77 (uid=77) has lprow=77 (included, j=77)
DEBUG BB: Row 78 (uid=78) has lprow=78 (included, j=78)
DEBUG BB: Row 79 (uid=79) has lprow=79 (included, j=79)
DEBUG BB: Row 80 (uid=80) has lprow=80 (included, j=80)
DEBUG BB: Row 81 (uid=81) has lprow=81 (included, j=81)
DEBUG BB: Row 82 (uid=82) has lprow=82 (included, j=82)
DEBUG BB: Row 83 (uid=83) has lprow=83 (included, j=83)
DEBUG BB: Row 84 (uid=84) has lprow=84 (included, j=84)
DEBUG BB: Row 85 (uid=85) has lprow=85 (included, j=85)
DEBUG BB: Row 86 (uid=86) has lprow=86 (included, j=86)
DEBUG BB: Row 87 (uid=87) has lprow=87 (included, j=87)
DEBUG BB: Row 88 (uid=88) has lprow=88 (included, j=88)
DEBUG BB: Row 89 (uid=89) has lprow=89 (included, j=89)
DEBUG BB: Row 90 (uid=90) has lprow=90 (included, j=90)
DEBUG BB: Row 91 (uid=91) has lprow=91 (included, j=91)
DEBUG BB: Row 92 (uid=92) has lprow=92 (included, j=92)
DEBUG BB: Row 93 (uid=93) has lprow=93 (included, j=93)
DEBUG BB: Row 94 (uid=94) has lprow=94 (included, j=94)
DEBUG BB: Row 95 (uid=95) has lprow=95 (included, j=95)
DEBUG BB: Row 96 (uid=96) has lprow=96 (included, j=96)
DEBUG BB: Row 97 (uid=97) has lprow=97 (included, j=97)
DEBUG BB: Row 98 (uid=98) has lprow=98 (included, j=98)
DEBUG BB: Row 99 (uid=99) has lprow=99 (included, j=99)
DEBUG BB: Row 100 (uid=100) has lprow=100 (included, j=100)
DEBUG BB: Row 101 (uid=101) has lprow=101 (included, j=101)
DEBUG BB: Row 102 (uid=102) has lprow=102 (included, j=102)
DEBUG BB: Row 103 (uid=103) has lprow=103 (included, j=103)
DEBUG BB: Row 104 (uid=104) has lprow=104 (included, j=104)
DEBUG BB: Row 105 (uid=105) has lprow=105 (included, j=105)
DEBUG BB: Row 106 (uid=106) has lprow=106 (included, j=106)
DEBUG BB: Row 107 (uid=107) has lprow=107 (included, j=107)
DEBUG BB: Row 108 (uid=108) has lprow=108 (included, j=108)
DEBUG BB: Row 109 (uid=109) has lprow=109 (included, j=109)
DEBUG BB: Row 110 (uid=110) has lprow=110 (included, j=110)
DEBUG BB: Row 111 (uid=111) has lprow=111 (included, j=111)
DEBUG BB: Row 112 (uid=112) has lprow=112 (included, j=112)
DEBUG BB: Row 113 (uid=113) has lprow=113 (included, j=113)
DEBUG BB: Row 114 (uid=114) has lprow=114 (included, j=114)
DEBUG BB: Row 115 (uid=115) has lprow=115 (included, j=115)
DEBUG BB: Row 116 (uid=116) has lprow=116 (included, j=116)
DEBUG BB: Row 117 (uid=117) has lprow=117 (included, j=117)
DEBUG BB: Row 118 (uid=118) has lprow=118 (included, j=118)
DEBUG BB: Row 119 (uid=119) has lprow=119 (included, j=119)
DEBUG BB: Row 120 (uid=120) has lprow=120 (included, j=120)
DEBUG BB: Row 121 (uid=121) has lprow=121 (included, j=121)
DEBUG BB: Row 122 (uid=122) has lprow=122 (included, j=122)
DEBUG BB: Row 123 (uid=123) has lprow=123 (included, j=123)
DEBUG BB: Row 124 (uid=124) has lprow=124 (included, j=124)
DEBUG BB: Row 125 (uid=125) has lprow=125 (included, j=125)
DEBUG BB: Row 126 (uid=126) has lprow=126 (included, j=126)
DEBUG BB: Row 127 (uid=127) has lprow=127 (included, j=127)
DEBUG BB: Row 128 (uid=128) has lprow=128 (included, j=128)
DEBUG BB: Row 129 (uid=129) has lprow=129 (included, j=129)
DEBUG BB: Row 130 (uid=130) has lprow=130 (included, j=130)
DEBUG BB: Row 131 (uid=131) has lprow=131 (included, j=131)
DEBUG BB: Row 132 (uid=132) has lprow=132 (included, j=132)
DEBUG BB: Row 133 (uid=133) has lprow=-1 (skipped)
DEBUG BB: Row 134 (uid=134) has lprow=-1 (skipped)
DEBUG BB: Row 135 (uid=135) has lprow=-1 (skipped)
DEBUG BB: Row 136 (uid=136) has lprow=-1 (skipped)
DEBUG BB: Row 137 (uid=137) has lprow=-1 (skipped)
DEBUG BB: Row 138 (uid=138) has lprow=-1 (skipped)
DEBUG BB: Row 139 (uid=139) has lprow=-1 (skipped)
DEBUG BB: Row 140 (uid=140) has lprow=-1 (skipped)
DEBUG BB: Row 141 (uid=141) has lprow=-1 (skipped)
DEBUG BB: Row 142 (uid=142) has lprow=-1 (skipped)
DEBUG BB: Row 143 (uid=143) has lprow=-1 (skipped)
DEBUG BB: Row 144 (uid=144) has lprow=-1 (skipped)
DEBUG BB: Row 145 (uid=145) has lprow=-1 (skipped)
DEBUG BB: Row 146 (uid=146) has lprow=-1 (skipped)
DEBUG BB: Row 147 (uid=147) has lprow=-1 (skipped)
DEBUG BB: Row 148 (uid=148) has lprow=-1 (skipped)
DEBUG BB: Row 149 (uid=149) has lprow=-1 (skipped)
DEBUG BB: Row 150 (uid=150) has lprow=-1 (skipped)
DEBUG BB: Row 151 (uid=151) has lprow=-1 (skipped)
DEBUG BB: Row 152 (uid=152) has lprow=-1 (skipped)
DEBUG BB: Row 153 (uid=153) has lprow=-1 (skipped)
DEBUG BB: Row 154 (uid=154) has lprow=-1 (skipped)
DEBUG BB: Row 155 (uid=155) has lprow=-1 (skipped)
DEBUG BB: Row 156 (uid=156) has lprow=-1 (skipped)
DEBUG BB: Row 157 (uid=157) has lprow=-1 (skipped)
DEBUG BB: Row 158 (uid=158) has lprow=-1 (skipped)
DEBUG BB: Row 159 (uid=159) has lprow=-1 (skipped)
DEBUG BB: Row 160 (uid=160) has lprow=-1 (skipped)
DEBUG BB: Row 161 (uid=161) has lprow=133 (included, j=133)
DEBUG BB: Row 162 (uid=162) has lprow=134 (included, j=134)
DEBUG BB: Found 135 actual LP rows, expected 135
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ad4c48c600
% Resuming node 0
DEBUG CONSTRNT: LP rows=135, pool->nlprows=135, pool->npend=0
DEBUG CONSTRNT: Checking 135 LP rows (pool tracks 135, total LP rows 135)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 1
DEBUG CONSTRNT: Pool row 1 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 2
DEBUG CONSTRNT: Pool row 2 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 3
DEBUG CONSTRNT: Pool row 3 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 4
DEBUG CONSTRNT: Pool row 4 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 20
DEBUG CONSTRNT: Pool row 20 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 41
DEBUG CONSTRNT: Pool row 41 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 45
DEBUG CONSTRNT: Pool row 45 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 49
DEBUG CONSTRNT: Pool row 49 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 51
DEBUG CONSTRNT: Pool row 51 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 52
DEBUG CONSTRNT: Pool row 52 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=54, expected 54
DEBUG CONSTRNT: Checking LP row 55 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=55, expected 55
DEBUG CONSTRNT: Checking LP row 56 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=56, expected 56
DEBUG CONSTRNT: Checking LP row 57 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=57, expected 57
DEBUG CONSTRNT: Checking LP row 58 -> pool row 58
DEBUG CONSTRNT: Pool row 58 has lprow=58, expected 58
DEBUG CONSTRNT: Checking LP row 59 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=59, expected 59
DEBUG CONSTRNT: Checking LP row 60 -> pool row 60
DEBUG CONSTRNT: Pool row 60 has lprow=60, expected 60
DEBUG CONSTRNT: Checking LP row 61 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=61, expected 61
DEBUG CONSTRNT: Checking LP row 62 -> pool row 62
DEBUG CONSTRNT: Pool row 62 has lprow=62, expected 62
DEBUG CONSTRNT: Checking LP row 63 -> pool row 63
DEBUG CONSTRNT: Pool row 63 has lprow=63, expected 63
DEBUG CONSTRNT: Checking LP row 64 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=64, expected 64
DEBUG CONSTRNT: Checking LP row 65 -> pool row 65
DEBUG CONSTRNT: Pool row 65 has lprow=65, expected 65
DEBUG CONSTRNT: Checking LP row 66 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=66, expected 66
DEBUG CONSTRNT: Checking LP row 67 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=67, expected 67
DEBUG CONSTRNT: Checking LP row 68 -> pool row 68
DEBUG CONSTRNT: Pool row 68 has lprow=68, expected 68
DEBUG CONSTRNT: Checking LP row 69 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=69, expected 69
DEBUG CONSTRNT: Checking LP row 70 -> pool row 70
DEBUG CONSTRNT: Pool row 70 has lprow=70, expected 70
DEBUG CONSTRNT: Checking LP row 71 -> pool row 71
DEBUG CONSTRNT: Pool row 71 has lprow=71, expected 71
DEBUG CONSTRNT: Checking LP row 72 -> pool row 72
DEBUG CONSTRNT: Pool row 72 has lprow=72, expected 72
DEBUG CONSTRNT: Checking LP row 73 -> pool row 73
DEBUG CONSTRNT: Pool row 73 has lprow=73, expected 73
DEBUG CONSTRNT: Checking LP row 74 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=74, expected 74
DEBUG CONSTRNT: Checking LP row 75 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=75, expected 75
DEBUG CONSTRNT: Checking LP row 76 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=76, expected 76
DEBUG CONSTRNT: Checking LP row 77 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=77, expected 77
DEBUG CONSTRNT: Checking LP row 78 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=78, expected 78
DEBUG CONSTRNT: Checking LP row 79 -> pool row 79
DEBUG CONSTRNT: Pool row 79 has lprow=79, expected 79
DEBUG CONSTRNT: Checking LP row 80 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=80, expected 80
DEBUG CONSTRNT: Checking LP row 81 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=81, expected 81
DEBUG CONSTRNT: Checking LP row 82 -> pool row 82
DEBUG CONSTRNT: Pool row 82 has lprow=82, expected 82
DEBUG CONSTRNT: Checking LP row 83 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=83, expected 83
DEBUG CONSTRNT: Checking LP row 84 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=84, expected 84
DEBUG CONSTRNT: Checking LP row 85 -> pool row 85
DEBUG CONSTRNT: Pool row 85 has lprow=85, expected 85
DEBUG CONSTRNT: Checking LP row 86 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=86, expected 86
DEBUG CONSTRNT: Checking LP row 87 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=87, expected 87
DEBUG CONSTRNT: Checking LP row 88 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=88, expected 88
DEBUG CONSTRNT: Checking LP row 89 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=89, expected 89
DEBUG CONSTRNT: Checking LP row 90 -> pool row 90
DEBUG CONSTRNT: Pool row 90 has lprow=90, expected 90
DEBUG CONSTRNT: Checking LP row 91 -> pool row 91
DEBUG CONSTRNT: Pool row 91 has lprow=91, expected 91
DEBUG CONSTRNT: Checking LP row 92 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=92, expected 92
DEBUG CONSTRNT: Checking LP row 93 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=93, expected 93
DEBUG CONSTRNT: Checking LP row 94 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=94, expected 94
DEBUG CONSTRNT: Checking LP row 95 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=95, expected 95
DEBUG CONSTRNT: Checking LP row 96 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=96, expected 96
DEBUG CONSTRNT: Checking LP row 97 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=97, expected 97
DEBUG CONSTRNT: Checking LP row 98 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=98, expected 98
DEBUG CONSTRNT: Checking LP row 99 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=99, expected 99
DEBUG CONSTRNT: Checking LP row 100 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=100, expected 100
DEBUG CONSTRNT: Checking LP row 101 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=101, expected 101
DEBUG CONSTRNT: Checking LP row 102 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=102, expected 102
DEBUG CONSTRNT: Checking LP row 103 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=103, expected 103
DEBUG CONSTRNT: Checking LP row 104 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=104, expected 104
DEBUG CONSTRNT: Checking LP row 105 -> pool row 105
DEBUG CONSTRNT: Pool row 105 has lprow=105, expected 105
DEBUG CONSTRNT: Checking LP row 106 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=106, expected 106
DEBUG CONSTRNT: Checking LP row 107 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=107, expected 107
DEBUG CONSTRNT: Checking LP row 108 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=108, expected 108
DEBUG CONSTRNT: Checking LP row 109 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=109, expected 109
DEBUG CONSTRNT: Checking LP row 110 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=110, expected 110
DEBUG CONSTRNT: Checking LP row 111 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=111, expected 111
DEBUG CONSTRNT: Checking LP row 112 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=112, expected 112
DEBUG CONSTRNT: Checking LP row 113 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=113, expected 113
DEBUG CONSTRNT: Checking LP row 114 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=114, expected 114
DEBUG CONSTRNT: Checking LP row 115 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=115, expected 115
DEBUG CONSTRNT: Checking LP row 116 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=116, expected 116
DEBUG CONSTRNT: Checking LP row 117 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=117, expected 117
DEBUG CONSTRNT: Checking LP row 118 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=118, expected 118
DEBUG CONSTRNT: Checking LP row 119 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=119, expected 119
DEBUG CONSTRNT: Checking LP row 120 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=120, expected 120
DEBUG CONSTRNT: Checking LP row 121 -> pool row 121
DEBUG CONSTRNT: Pool row 121 has lprow=121, expected 121
DEBUG CONSTRNT: Checking LP row 122 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=122, expected 122
DEBUG CONSTRNT: Checking LP row 123 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=123, expected 123
DEBUG CONSTRNT: Checking LP row 124 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=124, expected 124
DEBUG CONSTRNT: Checking LP row 125 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=125, expected 125
DEBUG CONSTRNT: Checking LP row 126 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=126, expected 126
DEBUG CONSTRNT: Checking LP row 127 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=127, expected 127
DEBUG CONSTRNT: Checking LP row 128 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=128, expected 128
DEBUG CONSTRNT: Checking LP row 129 -> pool row 129
DEBUG CONSTRNT: Pool row 129 has lprow=129, expected 129
DEBUG CONSTRNT: Checking LP row 130 -> pool row 130
DEBUG CONSTRNT: Pool row 130 has lprow=130, expected 130
DEBUG CONSTRNT: Checking LP row 131 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=131, expected 131
DEBUG CONSTRNT: Checking LP row 132 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=132, expected 132
DEBUG CONSTRNT: Checking LP row 133 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=133, expected 133
DEBUG CONSTRNT: Checking LP row 134 -> pool row 162
DEBUG CONSTRNT: Pool row 162 has lprow=134, expected 134
 % @PAP adding 135 rows, 494 nz to LP
DEBUG BB: Processing node 0, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=155, theta=4.750000, up=1.000000
ITER 2: row=1, varin=149, theta=5.000000, up=1.000000
ITER 3: row=1, varin=152, theta=4.000000, up=1.000000
ITER 4: row=1, varin=151, theta=3.000000, up=1.000000
ITER 5: row=1, varin=150, theta=2.000000, up=1.000000
ITER 6: row=1, varin=143, theta=1.500000, up=1.000000
ITER 7: row=1, varin=148, theta=0.500000, up=1.000000
ITER 8: row=134, varin=143, theta=3.306302, up=1.000000
ITER 9: row=134, varin=152, theta=1.653840, up=1.000000
ITER 10: row=134, varin=150, theta=1.486599, up=1.000000
LP PHASE: Switching to primal (iter=21)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=135)
DEBUG SOLUTION: LP solution array indices: FST[136-175], not_covered[176-195]
DEBUG SOLUTION: lp->best_solution[0] = 26168780.685055
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 0.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 0.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.727233
DEBUG SOLUTION: lp->best_solution[7] = 0.727233
DEBUG SOLUTION: lp->best_solution[8] = 0.727233
DEBUG SOLUTION: lp->best_solution[9] = 2.181699
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 135 rows, 60 cols, 554 nonzeros, 92 slack, 43 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 92 slack rows
  % @PAP adding 9 rows, 36 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=44, varin=55, theta=4.405969, up=1.000000
ITER 2: row=44, varin=54, theta=3.352234, up=1.000000
ITER 3: row=44, varin=60, theta=1.241125, up=1.000000
ITER 4: row=44, varin=69, theta=0.408327, up=1.000000
ITER 5: row=43, varin=73, theta=0.712855, up=1.000000
ITER 6: row=51, varin=68, theta=2.000000, up=1.000000
ITER 7: row=51, varin=65, theta=1.000000, up=1.000000
ITER 8: row=1, varin=99, theta=2.235029, up=1.000000
ITER 9: row=1, varin=101, theta=1.235029, up=1.000000
ITER 10: row=1, varin=102, theta=0.235029, up=1.000000
LP PHASE: Switching to primal (iter=29)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 27013341.184705
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 0.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 0.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.661722
DEBUG SOLUTION: lp->best_solution[9] = 0.661722
DEBUG SOLUTION: lp->best_solution[10] = 0.661722
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.661722
DEBUG SOLUTION: lp->best_solution[13] = 0.661722
DEBUG SOLUTION: lp->best_solution[14] = 4.308608
  % @PL 52 rows, 60 cols, 293 nonzeros, 30 slack, 22 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 30 slack rows
  % @PAP adding 11 rows, 44 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=25, varin=80, theta=0.148698, up=1.000000
ITER 2: row=26, varin=84, theta=1.000000, up=1.000000
ITER 3: row=1, varin=89, theta=1.133862, up=1.000000
ITER 4: row=1, varin=90, theta=0.133862, up=1.000000
ITER 5: row=28, varin=9, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=32, varin=87, theta=1.000000, up=1.000000
ITER 7: row=1, varin=91, theta=1.133862, up=1.000000
ITER 8: row=1, varin=92, theta=0.133862, up=1.000000
ITER 9: row=10, varin=91, theta=1.000000, up=1.000000
ITER 10: row=11, varin=93, theta=1.133862, up=1.000000
LP PHASE: Switching to primal (iter=15)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=33)
DEBUG SOLUTION: LP solution array indices: FST[34-73], not_covered[74-93]
DEBUG SOLUTION: lp->best_solution[0] = 27039977.028003
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 33 rows, 60 cols, 261 nonzeros, 5 slack, 28 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % @PAP adding 4 rows, 22 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=29, varin=26, theta=3.556138, up=999999999999999983222784.000000
ITER 2: row=5, varin=38, theta=2.083298, up=1.000000
ITER 3: row=5, varin=9, theta=0.621230, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=32)
DEBUG SOLUTION: LP solution array indices: FST[33-72], not_covered[73-92]
DEBUG SOLUTION: lp->best_solution[0] = 27058110.721869
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.378770
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 32 rows, 60 cols, 258 nonzeros, 2 slack, 30 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 3 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=33, varin=89, theta=0.323287, up=1.000000
ITER 2: row=31, varin=39, theta=0.500000, up=1.000000
ITER 3: row=29, varin=31, theta=12.330411, up=999999999999999983222784.000000
ITER 4: row=31, varin=93, theta=0.264670, up=1.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=33)
DEBUG SOLUTION: LP solution array indices: FST[34-73], not_covered[74-93]
DEBUG SOLUTION: lp->best_solution[0] = 27068491.517424
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 33 rows, 60 cols, 255 nonzeros, 7 slack, 26 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 7 slack rows
  % @PAP adding 2 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=27, varin=34, theta=0.250000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=28)
DEBUG SOLUTION: LP solution array indices: FST[29-68], not_covered[69-88]
DEBUG SOLUTION: lp->best_solution[0] = 27068508.913819
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 28 rows, 60 cols, 234 nonzeros, 0 slack, 28 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 0 LP 1 Solution, length = 27068508.913819, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 1.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.250000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.750000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.250000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.250000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.750000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.276350 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.250000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.723650 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.250000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.250000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.250000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.250000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.723650 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.723650 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.250000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.250000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.723650 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=27068508.913819, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
 % @LO 0.00  27.06850891381922252776 99.9000000000
 % @LN 0.00  27.06850891381922252776 99.9000000000
DEBUG CG: Second cutoff check: z=27068508.913819, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 3 connected components.
 % initially 3 congested vertices:
 % _gst_find_congested_components found 1 components:
 % 	component 0:	3 verts,	4 edges
 % @PAP adding 1 rows, 12 nz to LP
 % @PMEM 164 rows, 1 blocks, 402 nzfree, 0 nzwasted, 1172 nztotal
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=29, varin=27, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=29)
DEBUG SOLUTION: LP solution array indices: FST[30-69], not_covered[70-89]
DEBUG SOLUTION: lp->best_solution[0] = 27068561.103004
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 29 rows, 60 cols, 246 nonzeros, 2 slack, 27 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 4 rows, 19 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=28, varin=26, theta=0.200000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=31)
DEBUG SOLUTION: LP solution array indices: FST[32-71], not_covered[72-91]
DEBUG SOLUTION: lp->best_solution[0] = 27071883.767022
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 31 rows, 60 cols, 257 nonzeros, 3 slack, 28 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % Node 0 LP 2 Solution, length = 27071883.767022, 0.00/0.00/0.00/0.00/0.00/0.00/0.00 1
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 1.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.400000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.400000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.200000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.200000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.800000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.383607 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.600000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.616393 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.200000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.200000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.200000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.600000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.616393 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.616393 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.200000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.200000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.616393 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=27071883.767022, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
 % @LO 0.00  27.06850891381922252776 99.9000000000
 % @LN 0.00  27.07188376702206511482 99.9000000000
DEBUG CG: Second cutoff check: z=27071883.767022, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 3 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 0 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 0
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=1.000000
DEBUG CAREFUL: Skipping var 1: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=1.000000
DEBUG CAREFUL: Skipping var 2: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.400000
DEBUG CAREFUL: Adding var 5 to fractional list (xi=0.400000)
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.400000
DEBUG CAREFUL: Adding var 7 to fractional list (xi=0.400000)
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.200000
DEBUG CAREFUL: Adding var 12 to fractional list (xi=0.200000)
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.200000
DEBUG CAREFUL: Adding var 13 to fractional list (xi=0.200000)
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.800000
DEBUG CAREFUL: Adding var 19 to fractional list (xi=0.800000)
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.383607
DEBUG CAREFUL: Adding var 20 to fractional list (xi=0.383607)
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 6 fractional variables

  %  Carefully choosing branching variable, nfrac = 6
DEBUG CAREFUL: Testing fvar[0] = var 12
DEBUG CAREFUL: Calling compare_branch_vars for var 12
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 12
DEBUG CAREFUL: New best var: 12
DEBUG CAREFUL: Testing fvar[1] = var 19
DEBUG CAREFUL: Calling compare_branch_vars for var 19
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 19
DEBUG CAREFUL: New best var: 19
DEBUG CAREFUL: Testing fvar[2] = var 13
DEBUG CAREFUL: Calling compare_branch_vars for var 13
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 13
DEBUG CAREFUL: Testing fvar[3] = var 7
DEBUG CAREFUL: Calling compare_branch_vars for var 7
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 7
DEBUG CAREFUL: Testing fvar[4] = var 5
DEBUG CAREFUL: Calling compare_branch_vars for var 5
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 5
DEBUG CAREFUL: Testing fvar[5] = var 20
DEBUG CAREFUL: Calling compare_branch_vars for var 20
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 20
  % Initial guess is x19, Z0 = 27178792.1828626        , Z1 = 27071883.7670221        

DEBUG EVAL: Testing var 12 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=12, varin=46, theta=0.333333, up=1.000000
DEBUG EVAL: Branch var 12 = 0 gives z=27082022.705958
  % 	x12 = 0,	Z0 = 27082022.7059582        
DEBUG EVAL: First branch cutoff check: z=27082022.705958, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 12 = 1
ITER 1: row=12, varin=27, theta=4.000000, up=999999999999999983222784.000000
ITER 2: row=1, varin=6, theta=4.000000, up=999999999999999983222784.000000
ITER 3: row=7, varin=21, theta=3.000000, up=999999999999999983222784.000000
ITER 4: row=22, varin=25, theta=2.000000, up=999999999999999983222784.000000
ITER 5: row=27, varin=24, theta=1.618699, up=999999999999999983222784.000000
ITER 6: row=25, varin=22, theta=1.237398, up=999999999999999983222784.000000
ITER 7: row=24, varin=8, theta=0.856098, up=999999999999999983222784.000000
  % 	x12 = 1,	Z1 = 27195614.2596919        
DEBUG EVAL: Second branch cutoff check: z=27195614.259692, best_z=INF, threshold=INF
  %   New best:  x12, Z = 27082022.7059582        
DEBUG EVAL: Testing var 19 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=6, varin=46, theta=0.333333, up=1.000000
DEBUG EVAL: Branch var 19 = 1 gives z=27082022.705958
  % 	x19 = 1,	Z1 = 27082022.7059582        
DEBUG EVAL: First branch cutoff check: z=27082022.705958, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 19 = 0
ITER 1: row=6, varin=27, theta=4.000000, up=999999999999999983222784.000000
ITER 2: row=1, varin=8, theta=4.000000, up=999999999999999983222784.000000
ITER 3: row=9, varin=9, theta=3.000000, up=999999999999999983222784.000000
ITER 4: row=10, varin=25, theta=2.000000, up=999999999999999983222784.000000
ITER 5: row=27, varin=24, theta=1.618699, up=999999999999999983222784.000000
ITER 6: row=25, varin=22, theta=1.237398, up=999999999999999983222784.000000
ITER 7: row=24, varin=6, theta=0.856098, up=999999999999999983222784.000000
  % 	x19 = 0,	Z0 = 27195614.2596919        
DEBUG EVAL: Second branch cutoff check: z=27195614.259692, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 13 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=13, varin=46, theta=0.333333, up=1.000000
DEBUG EVAL: Branch var 13 = 0 gives z=27082022.705958
  % 	x13 = 0,	Z0 = 27082022.7059582        
DEBUG EVAL: First branch cutoff check: z=27082022.705958, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 13 = 1
ITER 1: row=13, varin=27, theta=4.000000, up=999999999999999983222784.000000
ITER 2: row=1, varin=6, theta=4.000000, up=999999999999999983222784.000000
ITER 3: row=7, varin=21, theta=3.000000, up=999999999999999983222784.000000
ITER 4: row=22, varin=25, theta=2.000000, up=999999999999999983222784.000000
ITER 5: row=27, varin=24, theta=1.618699, up=999999999999999983222784.000000
ITER 6: row=25, varin=22, theta=1.237398, up=999999999999999983222784.000000
ITER 7: row=24, varin=8, theta=0.856098, up=999999999999999983222784.000000
  % 	x13 = 1,	Z1 = 27195614.2596919        
DEBUG EVAL: Second branch cutoff check: z=27195614.259692, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 7 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=2, varin=26, theta=0.666667, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 7 = 0 gives z=27085313.594253
  % 	x7 = 0,	Z0 = 27085313.5942535        
DEBUG EVAL: First branch cutoff check: z=27085313.594253, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 7 = 1
ITER 1: row=2, varin=27, theta=1.500000, up=999999999999999983222784.000000
ITER 2: row=1, varin=46, theta=0.666667, up=1.000000
ITER 3: row=3, varin=73, theta=0.238037, up=1.000000
  % 	x7 = 1,	Z1 = 27096836.1656428        
DEBUG EVAL: Second branch cutoff check: z=27096836.165643, best_z=INF, threshold=INF
  %   New best:  x7, Z = 27085313.5942535        
DEBUG EVAL: Testing var 5 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=27, theta=0.666667, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 5 = 0 gives z=27074098.876367
  % 	x5 = 0,	Z0 = 27074098.8763673        
DEBUG EVAL: First branch cutoff check: z=27074098.876367, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 20 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=3, varin=46, theta=0.446325, up=1.000000
ITER 2: row=6, varin=27, theta=0.453223, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 20 = 0 gives z=27088123.810844
  % 	x20 = 0,	Z0 = 27088123.8108441        
DEBUG EVAL: First branch cutoff check: z=27088123.810844, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 20 = 1
ITER 1: row=3, varin=26, theta=1.074861, up=999999999999999983222784.000000
ITER 2: row=22, varin=27, theta=0.515007, up=999999999999999983222784.000000
ITER 3: row=1, varin=73, theta=0.776967, up=1.000000
  % 	x20 = 1,	Z1 = 27100212.3992661        
DEBUG EVAL: Second branch cutoff check: z=27100212.399266, best_z=INF, threshold=INF
  %   New best:  x20, Z = 27088123.8108441        
  % Best branch is x20, Z0 = 27088123.8108441        , Z1 = 27100212.3992661        

DEBUG CAREFUL: Final result - returning best.var = 20
DEBUG BB: Branching variable chosen: j=20
 % @NC    1    0	x20 = 0	27088123.810844
 % @NC    2    0	x20 = 1	27100212.399266
 %       0     2 27071883.7670               27088123.8108
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ad4c49c0e0
% @LO 0.00  27.07188376702206511482 99.9000000000
% @LN 0.00  27.08812381084410958465 99.9000000000
% Resuming node 1 at  27.08812381084410958465
DEBUG CONSTRNT: LP rows=28, pool->nlprows=28, pool->npend=0
DEBUG CONSTRNT: Checking 28 LP rows (pool tracks 28, total LP rows 28)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=27, expected 27
 % @PAP adding 28 rows, 178 nz to LP
DEBUG BB: Processing node 1, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=3, varin=46, theta=0.446325, up=1.000000
ITER 2: row=6, varin=27, theta=0.453223, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=28)
DEBUG SOLUTION: LP solution array indices: FST[29-68], not_covered[69-88]
DEBUG SOLUTION: lp->best_solution[0] = 27088123.810844
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 28 rows, 60 cols, 238 nonzeros, 2 slack, 26 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 6 rows, 31 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=29, varin=45, theta=0.866738, up=1.000000
ITER 2: row=34, varin=25, theta=0.095905, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=34)
DEBUG SOLUTION: LP solution array indices: FST[35-74], not_covered[75-94]
DEBUG SOLUTION: lp->best_solution[0] = 27100496.199341
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 34 rows, 60 cols, 269 nonzeros, 4 slack, 30 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % @PAP adding 5 rows, 15 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=31, varin=3, theta=0.473406, up=999999999999999983222784.000000
ITER 2: row=28, varin=24, theta=0.463923, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=35)
DEBUG SOLUTION: LP solution array indices: FST[36-75], not_covered[76-95]
DEBUG SOLUTION: lp->best_solution[0] = 27114337.576783
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.536077
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 35 rows, 60 cols, 276 nonzeros, 5 slack, 30 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % @PAP adding 3 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=31, varin=53, theta=0.107266, up=1.000000
ITER 2: row=33, varin=21, theta=0.723346, up=999999999999999983222784.000000
ITER 3: row=29, varin=26, theta=4.492156, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=33)
DEBUG SOLUTION: LP solution array indices: FST[34-73], not_covered[74-93]
DEBUG SOLUTION: lp->best_solution[0] = 27141071.212062
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 33 rows, 60 cols, 261 nonzeros, 1 slack, 32 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 1 LP 1 Solution, length = 27141071.212062, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 1.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.400000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.400000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.200000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.200000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.561519 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.800000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.600000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.438481 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.200000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.200000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.200000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.600000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.438481 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.200000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.200000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.438481 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=27141071.212062, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 1 at  27.14107121206168216077
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ad4c49c780
% @LO 0.00  27.08812381084410958465 99.9000000000
% @LN 0.00  27.10021239926613745297 99.9000000000
% Resuming node 2 at  27.10021239926613745297
DEBUG CONSTRNT: LP rows=32, pool->nlprows=32, pool->npend=0
DEBUG CONSTRNT: Checking 32 LP rows (pool tracks 32, total LP rows 32)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 91
DEBUG CONSTRNT: Pool row 91 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=31, expected 31
 % @PAP adding 28 rows, 178 nz to LP
DEBUG BB: Processing node 2, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=3, varin=26, theta=1.074861, up=999999999999999983222784.000000
ITER 2: row=22, varin=27, theta=0.515007, up=999999999999999983222784.000000
ITER 3: row=1, varin=73, theta=0.776967, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=28)
DEBUG SOLUTION: LP solution array indices: FST[29-68], not_covered[69-88]
DEBUG SOLUTION: lp->best_solution[0] = 27100212.399266
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 28 rows, 60 cols, 238 nonzeros, 1 slack, 27 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 11 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=29, varin=82, theta=0.159587, up=1.000000
ITER 2: row=5, varin=21, theta=0.042913, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=30)
DEBUG SOLUTION: LP solution array indices: FST[31-70], not_covered[71-90]
DEBUG SOLUTION: lp->best_solution[0] = 27103470.418545
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 30 rows, 60 cols, 249 nonzeros, 5 slack, 25 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % Node 2 LP 1 Solution, length = 27103470.418545, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.130906 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.173819 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.173819 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.826181 (FST 19)
  % DEBUG LP_VARS: x[20] = 1.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.869094 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.173819 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.173819 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.173819 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.826181 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.173819 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.173819 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=27103470.418545, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
 % @LO 0.00  27.10021239926613745297 99.9000000000
 % @LN 0.00  27.10347041854459249066 99.9000000000
DEBUG CG: Second cutoff check: z=27103470.418545, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 2 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 2
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=1.000000
DEBUG CAREFUL: Skipping var 2: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.130906
DEBUG CAREFUL: Adding var 7 to fractional list (xi=0.130906)
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.173819
DEBUG CAREFUL: Adding var 12 to fractional list (xi=0.173819)
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.173819
DEBUG CAREFUL: Adding var 13 to fractional list (xi=0.173819)
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.826181
DEBUG CAREFUL: Adding var 19 to fractional list (xi=0.826181)
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=1.000000
DEBUG CAREFUL: Skipping var 20: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 4 fractional variables

  %  Carefully choosing branching variable, nfrac = 4
DEBUG CAREFUL: Testing fvar[0] = var 19
DEBUG CAREFUL: Calling compare_branch_vars for var 19
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 19
DEBUG CAREFUL: New best var: 19
DEBUG CAREFUL: Testing fvar[1] = var 7
DEBUG CAREFUL: Calling compare_branch_vars for var 7
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 7
DEBUG CAREFUL: Testing fvar[2] = var 13
DEBUG CAREFUL: Calling compare_branch_vars for var 13
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 13
DEBUG CAREFUL: New best var: 13
DEBUG CAREFUL: Testing fvar[3] = var 12
DEBUG CAREFUL: Calling compare_branch_vars for var 12
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 12
  % Initial guess is x13, Z0 = 27103470.4185446        , Z1 = 27195614.2596919        

DEBUG EVAL: Testing var 19 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=6, varin=31, theta=0.837443, up=1.000000
ITER 2: row=1, varin=4, theta=0.605229, up=999999999999999983222784.000000
ITER 3: row=4, varin=28, theta=0.614930, up=1.000000
DEBUG EVAL: Branch var 19 = 1 gives z=27147995.765864
  % 	x19 = 1,	Z1 = 27147995.7658641        
DEBUG EVAL: First branch cutoff check: z=27147995.765864, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 19 = 0
ITER 1: row=6, varin=2, theta=3.766930, up=999999999999999983222784.000000
ITER 2: row=14, varin=70, theta=1.232858, up=1.000000
ITER 3: row=14, varin=6, theta=0.478586, up=999999999999999983222784.000000
ITER 4: row=1, varin=41, theta=0.817750, up=1.000000
ITER 5: row=13, varin=4, theta=1.441724, up=999999999999999983222784.000000
ITER 6: row=7, varin=8, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=4, varin=28, theta=0.448805, up=1.000000
  % 	x19 = 0,	Z0 = 27280231.5363439        
DEBUG EVAL: Second branch cutoff check: z=27280231.536344, best_z=INF, threshold=INF
  %   New best:  x19, Z = 27147995.7658641        
DEBUG EVAL: Testing var 7 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=31, theta=0.136048, up=1.000000
DEBUG EVAL: Branch var 7 = 0 gives z=27106224.468804
  % 	x7 = 0,	Z0 = 27106224.4688043        
DEBUG EVAL: First branch cutoff check: z=27106224.468804, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 13 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=12, varin=2, theta=3.766930, up=999999999999999983222784.000000
ITER 2: row=14, varin=70, theta=1.232858, up=1.000000
ITER 3: row=14, varin=7, theta=0.478586, up=999999999999999983222784.000000
ITER 4: row=1, varin=41, theta=0.817750, up=1.000000
ITER 5: row=13, varin=4, theta=1.441724, up=999999999999999983222784.000000
ITER 6: row=8, varin=8, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=4, varin=28, theta=0.448805, up=1.000000
DEBUG EVAL: Branch var 13 = 1 gives z=27280231.536344
  % 	x13 = 1,	Z1 = 27280231.5363439        
DEBUG EVAL: First branch cutoff check: z=27280231.536344, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 13 = 0
ITER 1: row=12, varin=31, theta=0.837443, up=1.000000
ITER 2: row=14, varin=40, theta=0.106244, up=1.000000
ITER 3: row=16, varin=68, theta=-0.674887, up=1.000000
ITER 4: row=1, varin=14, theta=0.132220, up=999999999999999983222784.000000
  % 	x13 = 0,	Z0 = 27122067.8552006        
DEBUG EVAL: Second branch cutoff check: z=27122067.855201, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 12 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=2, varin=2, theta=3.766930, up=999999999999999983222784.000000
ITER 2: row=14, varin=70, theta=1.232858, up=1.000000
ITER 3: row=14, varin=9, theta=0.478586, up=999999999999999983222784.000000
ITER 4: row=1, varin=4, theta=1.441724, up=999999999999999983222784.000000
ITER 5: row=10, varin=10, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=4, varin=28, theta=0.448805, up=1.000000
DEBUG EVAL: Branch var 12 = 1 gives z=27280231.536344
  % 	x12 = 1,	Z1 = 27280231.5363439        
DEBUG EVAL: First branch cutoff check: z=27280231.536344, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 12 = 0
ITER 1: row=2, varin=31, theta=0.837443, up=1.000000
ITER 2: row=14, varin=41, theta=0.154259, up=1.000000
ITER 3: row=13, varin=68, theta=-0.674887, up=1.000000
ITER 4: row=1, varin=4, theta=0.605229, up=999999999999999983222784.000000
ITER 5: row=4, varin=14, theta=0.139340, up=999999999999999983222784.000000
  % 	x12 = 0,	Z0 = 27137722.3590832        
DEBUG EVAL: Second branch cutoff check: z=27137722.359083, best_z=INF, threshold=INF
  % Best branch is x19, Z0 = 27280231.5363439        , Z1 = 27147995.7658641        

DEBUG CAREFUL: Final result - returning best.var = 19
DEBUG BB: Branching variable chosen: j=19
 % @NC    3    2	x19 = 1	27147995.765864
 % @NC    4    2	x19 = 0	27280231.536344
 %       2     3 27103470.4185               27141071.2121   x20 U     0     1
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ad4c49c0e0
% @LO 0.00  27.10347041854459249066 99.9000000000
% @LN 0.00  27.14107121206168216077 99.9000000000
% Resuming node 1 at  27.14107121206168216077
DEBUG CONSTRNT: LP rows=25, pool->nlprows=25, pool->npend=0
DEBUG CONSTRNT: Checking 25 LP rows (pool tracks 25, total LP rows 25)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=24, expected 24
 % @PAP adding 32 rows, 191 nz to LP
DEBUG BB: Processing node 1, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 1 LP 2 Solution, length = 27141071.212062, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 1.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.400000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.400000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.200000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.200000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.561519 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.800000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.600000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.438481 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.200000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.200000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.200000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.600000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.438481 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.200000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.200000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.438481 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=27141071.212062, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=27141071.212062, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 3 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 1 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 1
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=1.000000
DEBUG CAREFUL: Skipping var 1: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=1.000000
DEBUG CAREFUL: Skipping var 2: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.400000
DEBUG CAREFUL: Adding var 5 to fractional list (xi=0.400000)
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.400000
DEBUG CAREFUL: Adding var 7 to fractional list (xi=0.400000)
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.200000
DEBUG CAREFUL: Adding var 12 to fractional list (xi=0.200000)
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.200000
DEBUG CAREFUL: Adding var 13 to fractional list (xi=0.200000)
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.561519
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.561519)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.800000
DEBUG CAREFUL: Adding var 19 to fractional list (xi=0.800000)
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 6 fractional variables

  %  Carefully choosing branching variable, nfrac = 6
DEBUG CAREFUL: Testing fvar[0] = var 12
DEBUG CAREFUL: Calling compare_branch_vars for var 12
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 12
DEBUG CAREFUL: New best var: 12
DEBUG CAREFUL: Testing fvar[1] = var 13
DEBUG CAREFUL: Calling compare_branch_vars for var 13
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 13
DEBUG CAREFUL: Testing fvar[2] = var 19
DEBUG CAREFUL: Calling compare_branch_vars for var 19
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 19
DEBUG CAREFUL: Testing fvar[3] = var 7
DEBUG CAREFUL: Calling compare_branch_vars for var 7
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 7
DEBUG CAREFUL: Testing fvar[4] = var 5
DEBUG CAREFUL: Calling compare_branch_vars for var 5
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 5
DEBUG CAREFUL: Testing fvar[5] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
  % Initial guess is x12, Z0 = 27141071.2120617        , Z1 = 27195614.2596919        

DEBUG EVAL: Testing var 12 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=11, varin=30, theta=4.000000, up=999999999999999983222784.000000
ITER 2: row=1, varin=28, theta=4.000000, up=999999999999999983222784.000000
ITER 3: row=27, varin=26, theta=1.777778, up=999999999999999983222784.000000
ITER 4: row=28, varin=4, theta=4.000000, up=999999999999999983222784.000000
ITER 5: row=4, varin=2, theta=4.000000, up=999999999999999983222784.000000
ITER 6: row=20, varin=5, theta=3.000000, up=999999999999999983222784.000000
ITER 7: row=6, varin=25, theta=2.000000, up=999999999999999983222784.000000
ITER 8: row=25, varin=9, theta=1.905645, up=999999999999999983222784.000000
ITER 9: row=30, varin=6, theta=0.905645, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 12 = 1 gives z=27307203.073344
  % 	x12 = 1,	Z1 = 27307203.0733444        
DEBUG EVAL: First branch cutoff check: z=27307203.073344, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 12 = 0
ITER 1: row=11, varin=48, theta=0.250000, up=1.000000
ITER 2: row=13, varin=36, theta=0.500000, up=1.000000
  % 	x12 = 0,	Z0 = 27175701.8616122        
DEBUG EVAL: Second branch cutoff check: z=27175701.861612, best_z=INF, threshold=INF
  %   New best:  x12, Z = 27175701.8616122        
DEBUG EVAL: Testing var 13 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=12, varin=30, theta=4.000000, up=999999999999999983222784.000000
ITER 2: row=1, varin=28, theta=4.000000, up=999999999999999983222784.000000
ITER 3: row=27, varin=26, theta=1.777778, up=999999999999999983222784.000000
ITER 4: row=28, varin=4, theta=4.000000, up=999999999999999983222784.000000
ITER 5: row=4, varin=2, theta=4.000000, up=999999999999999983222784.000000
ITER 6: row=20, varin=5, theta=3.000000, up=999999999999999983222784.000000
ITER 7: row=6, varin=25, theta=2.000000, up=999999999999999983222784.000000
ITER 8: row=25, varin=9, theta=1.905645, up=999999999999999983222784.000000
ITER 9: row=30, varin=6, theta=0.905645, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 13 = 1 gives z=27307203.073344
  % 	x13 = 1,	Z1 = 27307203.0733444        
DEBUG EVAL: First branch cutoff check: z=27307203.073344, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 13 = 0
ITER 1: row=12, varin=47, theta=0.166667, up=1.000000
ITER 2: row=15, varin=13, theta=0.200000, up=999999999999999983222784.000000
  % 	x13 = 0,	Z0 = 27164762.0472786        
DEBUG EVAL: Second branch cutoff check: z=27164762.047279, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 19 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=5, varin=36, theta=0.500000, up=1.000000
DEBUG EVAL: Branch var 19 = 1 gives z=27175701.861612
  % 	x19 = 1,	Z1 = 27175701.8616122        
DEBUG EVAL: First branch cutoff check: z=27175701.861612, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 19 = 0
ITER 1: row=5, varin=30, theta=4.000000, up=999999999999999983222784.000000
ITER 2: row=1, varin=28, theta=4.000000, up=999999999999999983222784.000000
ITER 3: row=27, varin=26, theta=1.777778, up=999999999999999983222784.000000
ITER 4: row=28, varin=4, theta=4.000000, up=999999999999999983222784.000000
ITER 5: row=4, varin=2, theta=4.000000, up=999999999999999983222784.000000
ITER 6: row=20, varin=5, theta=3.000000, up=999999999999999983222784.000000
ITER 7: row=6, varin=25, theta=2.000000, up=999999999999999983222784.000000
ITER 8: row=25, varin=9, theta=1.905645, up=999999999999999983222784.000000
ITER 9: row=30, varin=6, theta=0.905645, up=999999999999999983222784.000000
  % 	x19 = 0,	Z0 = 27307203.0733444        
DEBUG EVAL: Second branch cutoff check: z=27307203.073344, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 7 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=2, varin=2, theta=0.800000, up=999999999999999983222784.000000
ITER 2: row=31, varin=20, theta=0.666667, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 7 = 0 gives z=27185549.885924
  % 	x7 = 0,	Z0 = 27185549.8859241        
DEBUG EVAL: First branch cutoff check: z=27185549.885924, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 7 = 1
ITER 1: row=2, varin=30, theta=1.500000, up=999999999999999983222784.000000
ITER 2: row=1, varin=47, theta=0.333333, up=1.000000
ITER 3: row=15, varin=12, theta=0.222222, up=999999999999999983222784.000000
ITER 4: row=13, varin=36, theta=1.000000, up=1.000000
ITER 5: row=16, varin=13, theta=0.023672, up=999999999999999983222784.000000
  % 	x7 = 1,	Z1 = 27227762.230239         
DEBUG EVAL: Second branch cutoff check: z=27227762.230239, best_z=INF, threshold=INF
  %   New best:  x7, Z = 27185549.8859241        
DEBUG EVAL: Testing var 5 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=30, theta=0.666667, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 5 = 0 gives z=27151969.825293
  % 	x5 = 0,	Z0 = 27151969.8252935        
DEBUG EVAL: First branch cutoff check: z=27151969.825293, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 17 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=16, varin=28, theta=0.673259, up=999999999999999983222784.000000
ITER 2: row=27, varin=26, theta=0.487129, up=999999999999999983222784.000000
ITER 3: row=28, varin=23, theta=0.522355, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 17 = 1 gives z=27205621.165708
  % 	x17 = 1,	Z1 = 27205621.1657075        
DEBUG EVAL: First branch cutoff check: z=27205621.165708, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 17 = 0
ITER 1: row=16, varin=87, theta=0.993402, up=1.000000
  % 	x17 = 0,	Z0 = 27160446.0208433        
DEBUG EVAL: Second branch cutoff check: z=27160446.020843, best_z=INF, threshold=INF
  % Best branch is x7, Z0 = 27185549.8859241        , Z1 = 27227762.230239         

DEBUG CAREFUL: Final result - returning best.var = 7
DEBUG BB: Branching variable chosen: j=7
 % @NC    5    1	x7 = 0	27185549.885924
 % @NC    6    1	x7 = 1	27227762.230239
 %       1     4 27141071.2121               27147995.7659   x20 D     0     1
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ad4c48c600
% @LO 0.00  27.14107121206168216077 99.9000000000
% @LN 0.00  27.14799576586408846879 99.9000000000
% Resuming node 3 at  27.14799576586408846879
DEBUG CONSTRNT: LP rows=32, pool->nlprows=32, pool->npend=0
DEBUG CONSTRNT: Checking 32 LP rows (pool tracks 32, total LP rows 32)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 91
DEBUG CONSTRNT: Pool row 91 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=31, expected 31
 % @PAP adding 25 rows, 162 nz to LP
DEBUG BB: Processing node 3, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=6, varin=31, theta=0.837443, up=1.000000
ITER 2: row=1, varin=4, theta=0.605229, up=999999999999999983222784.000000
ITER 3: row=4, varin=28, theta=0.614930, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=25)
DEBUG SOLUTION: LP solution array indices: FST[26-65], not_covered[66-85]
DEBUG SOLUTION: lp->best_solution[0] = 27147995.765864
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 25 rows, 60 cols, 222 nonzeros, 0 slack, 25 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 5 rows, 21 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=28, varin=45, theta=0.393192, up=1.000000
ITER 2: row=30, varin=41, theta=0.935353, up=1.000000
ITER 3: row=12, varin=25, theta=0.466262, up=999999999999999983222784.000000
ITER 4: row=14, varin=46, theta=0.854381, up=1.000000
ITER 5: row=13, varin=52, theta=0.611908, up=1.000000
ITER 6: row=18, varin=57, theta=0.800594, up=1.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=30)
DEBUG SOLUTION: LP solution array indices: FST[31-70], not_covered[71-90]
DEBUG SOLUTION: lp->best_solution[0] = 27269299.849874
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 30 rows, 60 cols, 243 nonzeros, 0 slack, 30 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 11 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=33, varin=62, theta=0.957115, up=1.000000
ITER 2: row=31, varin=51, theta=0.031157, up=1.000000
ITER 3: row=13, varin=52, theta=0.022549, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=34)
DEBUG SOLUTION: LP solution array indices: FST[35-74], not_covered[75-94]
DEBUG SOLUTION: lp->best_solution[0] = 27309979.576436
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 34 rows, 60 cols, 254 nonzeros, 0 slack, 34 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 7 rows, 29 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=35, varin=64, theta=0.709675, up=1.000000
ITER 2: row=36, varin=65, theta=0.837667, up=1.000000
ITER 3: row=27, varin=71, theta=1.001869, up=1.000000
ITER 4: row=27, varin=67, theta=0.001652, up=1.000000
ITER 5: row=16, varin=66, theta=0.001649, up=1.000000
ITER 6: row=1, varin=19, theta=0.002380, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=41)
DEBUG SOLUTION: LP solution array indices: FST[42-81], not_covered[82-101]
DEBUG SOLUTION: lp->best_solution[0] = 27335320.274196
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 41 rows, 60 cols, 283 nonzeros, 1 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 4 rows, 13 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=41, varin=74, theta=1.000000, up=1.000000
ITER 2: row=34, varin=62, theta=0.057835, up=1.000000
ITER 3: row=35, varin=45, theta=0.109615, up=1.000000
ITER 4: row=42, varin=41, theta=0.123326, up=999999999999999983222784.000000
ITER 5: row=41, varin=50, theta=0.069282, up=1.000000
ITER 6: row=25, varin=46, theta=0.021702, up=1.000000
ITER 7: row=4, varin=5, theta=0.020668, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=7)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 27382908.047892
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 0.979332
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 44 rows, 60 cols, 294 nonzeros, 2 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 8 rows, 22 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=45, varin=58, theta=0.268686, up=1.000000
ITER 2: row=50, varin=80, theta=1.486852, up=1.000000
ITER 3: row=50, varin=24, theta=0.466730, up=999999999999999983222784.000000
ITER 4: row=41, varin=80, theta=1.000000, up=1.000000
ITER 5: row=11, varin=105, theta=1.332056, up=1.000000
ITER 6: row=11, varin=104, theta=0.313854, up=1.000000
ITER 7: row=32, varin=105, theta=1.000000, up=1.000000
ITER 8: row=27, varin=64, theta=0.843750, up=1.000000
ITER 9: row=13, varin=60, theta=0.457627, up=1.000000
ITER 10: row=20, varin=83, theta=0.343728, up=1.000000
LP PHASE: Switching to primal (iter=16)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 27646334.505925
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 50 rows, 60 cols, 312 nonzeros, 2 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 5 rows, 26 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=50, varin=56, theta=0.500000, up=1.000000
ITER 2: row=49, varin=88, theta=0.992937, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=53)
DEBUG SOLUTION: LP solution array indices: FST[54-93], not_covered[94-113]
DEBUG SOLUTION: lp->best_solution[0] = 27861252.780838
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 53 rows, 60 cols, 334 nonzeros, 3 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 2 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=52, varin=97, theta=0.263405, up=1.000000
ITER 2: row=20, varin=23, theta=0.159367, up=999999999999999983222784.000000
ITER 3: row=11, varin=77, theta=0.345212, up=1.000000
ITER 4: row=42, varin=49, theta=1.360719, up=999999999999999983222784.000000
ITER 5: row=31, varin=75, theta=0.217601, up=1.000000
ITER 6: row=32, varin=2, theta=0.279266, up=999999999999999983222784.000000
ITER 7: row=2, varin=4, theta=0.758288, up=999999999999999983222784.000000
ITER 8: row=45, varin=61, theta=0.416345, up=1.000000
ITER 9: row=12, varin=109, theta=0.344055, up=1.000000
ITER 10: row=4, varin=43, theta=0.366077, up=999999999999999983222784.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 999999999999999983222784.000000
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 52 rows, 60 cols, 316 nonzeros, 5 slack, 47 tight.
  % Node 3 LP 1 Solution, length = 999999999999999983222784.000000, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.500000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.049439 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 1.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.500000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.901123 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.007063 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.992937 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.500000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
DEBUG BB: compute_good_lower_bound returned status=1
DEBUG BB: Node 3 is INFEASIBLE
 %       3     3    infeasible               27185549.8859   x19 U     2     2
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ad4c49c780
% @LO 0.00  27.14799576586408846879 99.9000000000
% @LN 0.00  27.18554988592413224069 99.9000000000
% Resuming node 5 at  27.18554988592413224069
DEBUG CONSTRNT: LP rows=52, pool->nlprows=52, pool->npend=0
DEBUG CONSTRNT: Checking 52 LP rows (pool tracks 52, total LP rows 52)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 85
DEBUG CONSTRNT: Pool row 85 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 133
DEBUG CONSTRNT: Pool row 133 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 141
DEBUG CONSTRNT: Pool row 141 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 145
DEBUG CONSTRNT: Pool row 145 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 159
DEBUG CONSTRNT: Pool row 159 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 134
DEBUG CONSTRNT: Pool row 134 has lprow=51, expected 51
 % @PAP adding 32 rows, 191 nz to LP
DEBUG BB: Processing node 5, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=2, varin=2, theta=0.800000, up=999999999999999983222784.000000
ITER 2: row=31, varin=20, theta=0.666667, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=32)
DEBUG SOLUTION: LP solution array indices: FST[33-72], not_covered[73-92]
DEBUG SOLUTION: lp->best_solution[0] = 27185549.885924
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 0.333333
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 32 rows, 60 cols, 251 nonzeros, 2 slack, 30 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 5 LP 1 Solution, length = 27185549.885924, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 1.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.666667 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.333333 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.333333 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.605754 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.666667 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.333333 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.394246 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.333333 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.333333 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.333333 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.333333 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.394246 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.333333 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.333333 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.394246 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=27185549.885924, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=27185549.885924, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 3 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 5 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 5
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=1.000000
DEBUG CAREFUL: Skipping var 1: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=1.000000
DEBUG CAREFUL: Skipping var 2: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.666667
DEBUG CAREFUL: Adding var 5 to fractional list (xi=0.666667)
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.333333
DEBUG CAREFUL: Adding var 12 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.333333
DEBUG CAREFUL: Adding var 13 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.605754
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.605754)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.666667
DEBUG CAREFUL: Adding var 19 to fractional list (xi=0.666667)
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 13
DEBUG CAREFUL: Calling compare_branch_vars for var 13
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 13
DEBUG CAREFUL: New best var: 13
DEBUG CAREFUL: Testing fvar[1] = var 19
DEBUG CAREFUL: Calling compare_branch_vars for var 19
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 19
DEBUG CAREFUL: Testing fvar[2] = var 12
DEBUG CAREFUL: Calling compare_branch_vars for var 12
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 12
DEBUG CAREFUL: Testing fvar[3] = var 5
DEBUG CAREFUL: Calling compare_branch_vars for var 5
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 5
DEBUG CAREFUL: Testing fvar[4] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
  % Initial guess is x13, Z0 = 27185549.8859241        , Z1 = 27307203.0733444        

DEBUG EVAL: Testing var 13 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=12, varin=28, theta=4.000000, up=999999999999999983222784.000000
ITER 2: row=27, varin=26, theta=1.777778, up=999999999999999983222784.000000
ITER 3: row=28, varin=4, theta=4.000000, up=999999999999999983222784.000000
ITER 4: row=4, varin=8, theta=4.000000, up=999999999999999983222784.000000
ITER 5: row=9, varin=9, theta=3.000000, up=999999999999999983222784.000000
ITER 6: row=31, varin=6, theta=2.000000, up=999999999999999983222784.000000
ITER 7: row=7, varin=24, theta=1.000000, up=999999999999999983222784.000000
ITER 8: row=24, varin=5, theta=0.905645, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 13 = 1 gives z=27307203.073344
  % 	x13 = 1,	Z1 = 27307203.0733444        
DEBUG EVAL: First branch cutoff check: z=27307203.073344, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 13 = 0
ITER 1: row=12, varin=42, theta=1.000000, up=1.000000
ITER 2: row=27, varin=87, theta=0.250000, up=1.000000
  % 	x13 = 0,	Z0 = 27195163.9319827        
DEBUG EVAL: Second branch cutoff check: z=27195163.931983, best_z=INF, threshold=INF
  %   New best:  x13, Z = 27195163.9319827        
DEBUG EVAL: Testing var 19 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=5, varin=42, theta=1.000000, up=1.000000
ITER 2: row=27, varin=87, theta=0.250000, up=1.000000
DEBUG EVAL: Branch var 19 = 1 gives z=27195163.931983
  % 	x19 = 1,	Z1 = 27195163.9319827        
DEBUG EVAL: First branch cutoff check: z=27195163.931983, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 19 = 0
ITER 1: row=5, varin=28, theta=4.000000, up=999999999999999983222784.000000
ITER 2: row=27, varin=26, theta=1.777778, up=999999999999999983222784.000000
ITER 3: row=28, varin=4, theta=4.000000, up=999999999999999983222784.000000
ITER 4: row=4, varin=8, theta=4.000000, up=999999999999999983222784.000000
ITER 5: row=9, varin=9, theta=3.000000, up=999999999999999983222784.000000
ITER 6: row=31, varin=6, theta=2.000000, up=999999999999999983222784.000000
ITER 7: row=7, varin=24, theta=1.000000, up=999999999999999983222784.000000
ITER 8: row=24, varin=5, theta=0.905645, up=999999999999999983222784.000000
  % 	x19 = 0,	Z0 = 27307203.0733444        
DEBUG EVAL: Second branch cutoff check: z=27307203.073344, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 12 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=11, varin=28, theta=4.000000, up=999999999999999983222784.000000
ITER 2: row=27, varin=26, theta=1.777778, up=999999999999999983222784.000000
ITER 3: row=28, varin=4, theta=4.000000, up=999999999999999983222784.000000
ITER 4: row=4, varin=8, theta=4.000000, up=999999999999999983222784.000000
ITER 5: row=9, varin=9, theta=3.000000, up=999999999999999983222784.000000
ITER 6: row=31, varin=6, theta=2.000000, up=999999999999999983222784.000000
ITER 7: row=7, varin=24, theta=1.000000, up=999999999999999983222784.000000
ITER 8: row=24, varin=5, theta=0.905645, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 12 = 1 gives z=27307203.073344
  % 	x12 = 1,	Z1 = 27307203.0733444        
DEBUG EVAL: First branch cutoff check: z=27307203.073344, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 12 = 0
ITER 1: row=11, varin=42, theta=1.000000, up=1.000000
ITER 2: row=27, varin=87, theta=0.250000, up=1.000000
  % 	x12 = 0,	Z0 = 27195163.9319827        
DEBUG EVAL: Second branch cutoff check: z=27195163.931983, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 5 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=47, theta=0.333333, up=1.000000
ITER 2: row=15, varin=12, theta=0.222222, up=999999999999999983222784.000000
ITER 3: row=13, varin=36, theta=1.000000, up=1.000000
ITER 4: row=16, varin=13, theta=0.038326, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 5 = 1 gives z=27278801.976367
  % 	x5 = 1,	Z1 = 27278801.9763668        
DEBUG EVAL: First branch cutoff check: z=27278801.976367, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 5 = 0
ITER 1: row=1, varin=42, theta=1.000000, up=1.000000
ITER 2: row=27, varin=87, theta=0.250000, up=1.000000
  % 	x5 = 0,	Z0 = 27195163.9319827        
DEBUG EVAL: Second branch cutoff check: z=27195163.931983, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 17 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=16, varin=28, theta=0.615796, up=999999999999999983222784.000000
ITER 2: row=27, varin=26, theta=0.450438, up=999999999999999983222784.000000
ITER 3: row=28, varin=23, theta=0.509969, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 17 = 1 gives z=27214545.114044
  % 	x17 = 1,	Z1 = 27214545.1140438        
DEBUG EVAL: First branch cutoff check: z=27214545.114044, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 17 = 0
ITER 1: row=16, varin=42, theta=2.487672, up=1.000000
ITER 2: row=16, varin=87, theta=0.640870, up=1.000000
  % 	x17 = 0,	Z0 = 27202787.2684646        
DEBUG EVAL: Second branch cutoff check: z=27202787.268465, best_z=INF, threshold=INF
  %   New best:  x17, Z = 27202787.2684646        
  % Best branch is x17, Z0 = 27202787.2684646        , Z1 = 27214545.1140438        

DEBUG CAREFUL: Final result - returning best.var = 17
DEBUG BB: Branching variable chosen: j=17
 % @NC    7    5	x17 = 0	27202787.268465
 % @NC    8    5	x17 = 1	27214545.114044
 %       5     4 27185549.8859               27202787.2685    x7 D     1     2
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ad4c48c600
% @LO 0.00  27.18554988592413224069 99.9000000000
% @LN 0.00  27.20278726846458638988 99.9000000000
% Resuming node 7 at  27.20278726846458638988
DEBUG CONSTRNT: LP rows=32, pool->nlprows=32, pool->npend=0
DEBUG CONSTRNT: Checking 32 LP rows (pool tracks 32, total LP rows 32)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 91
DEBUG CONSTRNT: Pool row 91 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=31, expected 31
 % @PAP adding 32 rows, 191 nz to LP
DEBUG BB: Processing node 7, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=16, varin=42, theta=2.487672, up=1.000000
ITER 2: row=16, varin=87, theta=0.640870, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=32)
DEBUG SOLUTION: LP solution array indices: FST[33-72], not_covered[73-92]
DEBUG SOLUTION: lp->best_solution[0] = 27202787.268465
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 32 rows, 60 cols, 251 nonzeros, 3 slack, 29 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 5 rows, 25 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=33, varin=47, theta=0.600000, up=1.000000
ITER 2: row=36, varin=32, theta=1.091059, up=999999999999999983222784.000000
ITER 3: row=11, varin=41, theta=0.056016, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=37)
DEBUG SOLUTION: LP solution array indices: FST[38-77], not_covered[78-97]
DEBUG SOLUTION: lp->best_solution[0] = 27242066.734225
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 0.688797
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 37 rows, 60 cols, 276 nonzeros, 9 slack, 28 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 9 slack rows
  % @PAP adding 5 rows, 21 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=31, varin=44, theta=0.099223, up=1.000000
ITER 2: row=29, varin=48, theta=0.056409, up=1.000000
ITER 3: row=14, varin=34, theta=0.114791, up=1.000000
LP PHASE: Switching to primal (iter=3)
ITER 4: row=31, varin=10, theta=520195.000000, up=999999999999999983222784.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=33)
DEBUG SOLUTION: LP solution array indices: FST[34-73], not_covered[74-93]
DEBUG SOLUTION: lp->best_solution[0] = 28635595.898470
DEBUG SOLUTION: lp->best_solution[1] = 19.896249
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1458602.635862
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 33 rows, 60 cols, 259 nonzeros, 1 slack, 32 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 5 rows, 17 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=57, theta=4.750000, up=1.000000
ITER 2: row=1, varin=51, theta=5.000000, up=1.000000
ITER 3: row=1, varin=54, theta=4.000000, up=1.000000
ITER 4: row=1, varin=53, theta=3.000000, up=1.000000
ITER 5: row=1, varin=52, theta=2.000000, up=1.000000
ITER 6: row=1, varin=50, theta=1.500000, up=1.000000
ITER 7: row=1, varin=40, theta=0.500000, up=1.000000
ITER 8: row=19, varin=52, theta=5.000000, up=1.000000
ITER 9: row=19, varin=54, theta=2.000000, up=1.000000
ITER 10: row=19, varin=51, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=58)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=37)
DEBUG SOLUTION: LP solution array indices: FST[38-77], not_covered[78-97]
DEBUG SOLUTION: lp->best_solution[0] = 27244749.440812
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 37 rows, 60 cols, 236 nonzeros, 2 slack, 35 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 7 LP 1 Solution, length = 27244749.440812, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 1.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.333333 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.333333 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.666667 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.333333 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.333333 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.666667 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.666667 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.333333 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.333333 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.333333 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.666667 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.333333 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.333333 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.333333 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.333333 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.333333 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=27244749.440812, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 7 at  27.24474944081156024822
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ad4c49c0e0
% @LO 0.00  27.20278726846458638988 99.9000000000
% @LN 0.00  27.21454511404381904072 99.9000000000
% Resuming node 8 at  27.21454511404381904072
DEBUG CONSTRNT: LP rows=37, pool->nlprows=37, pool->npend=0
DEBUG CONSTRNT: Checking 37 LP rows (pool tracks 37, total LP rows 37)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 91
DEBUG CONSTRNT: Pool row 91 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 142
DEBUG CONSTRNT: Pool row 142 has lprow=36, expected 36
 % @PAP adding 32 rows, 191 nz to LP
DEBUG BB: Processing node 8, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=16, varin=28, theta=0.615796, up=999999999999999983222784.000000
ITER 2: row=27, varin=26, theta=0.450438, up=999999999999999983222784.000000
ITER 3: row=28, varin=23, theta=0.509969, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=32)
DEBUG SOLUTION: LP solution array indices: FST[33-72], not_covered[73-92]
DEBUG SOLUTION: lp->best_solution[0] = 27214545.114044
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 0.843303
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 32 rows, 60 cols, 251 nonzeros, 3 slack, 29 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=30, varin=28, theta=0.231306, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=30)
DEBUG SOLUTION: LP solution array indices: FST[31-70], not_covered[71-90]
DEBUG SOLUTION: lp->best_solution[0] = 27220304.485658
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 30 rows, 60 cols, 237 nonzeros, 1 slack, 29 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 8 LP 1 Solution, length = 27220304.485658, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 1.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.140578 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.371884 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.371884 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 1.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.628116 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.859422 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.371884 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.371884 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.371884 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.628116 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.371884 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.371884 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=27220304.485658, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
 % @LO 0.00  27.21454511404381904072 99.9000000000
 % @LN 0.00  27.22030448565792681848 99.9000000000
DEBUG CG: Second cutoff check: z=27220304.485658, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 3 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 8 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 8
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=1.000000
DEBUG CAREFUL: Skipping var 1: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=1.000000
DEBUG CAREFUL: Skipping var 2: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.140578
DEBUG CAREFUL: Adding var 5 to fractional list (xi=0.140578)
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.371884
DEBUG CAREFUL: Adding var 12 to fractional list (xi=0.371884)
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.371884
DEBUG CAREFUL: Adding var 13 to fractional list (xi=0.371884)
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=1.000000
DEBUG CAREFUL: Skipping var 17: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.628116
DEBUG CAREFUL: Adding var 19 to fractional list (xi=0.628116)
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 4 fractional variables

  %  Carefully choosing branching variable, nfrac = 4
DEBUG CAREFUL: Testing fvar[0] = var 19
DEBUG CAREFUL: Calling compare_branch_vars for var 19
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 19
DEBUG CAREFUL: New best var: 19
DEBUG CAREFUL: Testing fvar[1] = var 13
DEBUG CAREFUL: Calling compare_branch_vars for var 13
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 13
DEBUG CAREFUL: Testing fvar[2] = var 12
DEBUG CAREFUL: Calling compare_branch_vars for var 12
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 12
DEBUG CAREFUL: Testing fvar[3] = var 5
DEBUG CAREFUL: Calling compare_branch_vars for var 5
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 5
  % Initial guess is x19, Z0 = 27307203.0733444        , Z1 = 27220304.4856579        

DEBUG EVAL: Testing var 19 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=4, varin=40, theta=1.594195, up=1.000000
ITER 2: row=4, varin=74, theta=0.423179, up=1.000000
ITER 3: row=25, varin=40, theta=1.000000, up=1.000000
ITER 4: row=2, varin=39, theta=0.299207, up=1.000000
DEBUG EVAL: Branch var 19 = 1 gives z=27252401.981694
  % 	x19 = 1,	Z1 = 27252401.9816942        
DEBUG EVAL: First branch cutoff check: z=27252401.981694, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 19 = 0
ITER 1: row=4, varin=4, theta=2.877950, up=999999999999999983222784.000000
ITER 2: row=5, varin=7, theta=1.877950, up=999999999999999983222784.000000
ITER 3: row=8, varin=3, theta=0.877950, up=999999999999999983222784.000000
ITER 4: row=3, varin=5, theta=0.877950, up=999999999999999983222784.000000
ITER 5: row=1, varin=45, theta=0.138241, up=1.000000
ITER 6: row=12, varin=2, theta=0.243724, up=999999999999999983222784.000000
  % 	x19 = 0,	Z0 = 27330223.2433278        
DEBUG EVAL: Second branch cutoff check: z=27330223.243328, best_z=INF, threshold=INF
  %   New best:  x19, Z = 27252401.9816942        
DEBUG EVAL: Testing var 13 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=11, varin=4, theta=2.877950, up=999999999999999983222784.000000
ITER 2: row=5, varin=7, theta=1.877950, up=999999999999999983222784.000000
ITER 3: row=8, varin=3, theta=0.877950, up=999999999999999983222784.000000
ITER 4: row=3, varin=5, theta=0.877950, up=999999999999999983222784.000000
ITER 5: row=1, varin=45, theta=0.138241, up=1.000000
ITER 6: row=12, varin=2, theta=0.243724, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 13 = 1 gives z=27330223.243328
  % 	x13 = 1,	Z1 = 27330223.2433278        
DEBUG EVAL: First branch cutoff check: z=27330223.243328, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 13 = 0
ITER 1: row=11, varin=12, theta=0.321967, up=999999999999999983222784.000000
  % 	x13 = 0,	Z0 = 27256287.3539261        
DEBUG EVAL: Second branch cutoff check: z=27256287.353926, best_z=INF, threshold=INF
  %   New best:  x13, Z = 27256287.3539261        
DEBUG EVAL: Testing var 12 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=10, varin=4, theta=2.877950, up=999999999999999983222784.000000
ITER 2: row=5, varin=3, theta=1.877950, up=999999999999999983222784.000000
ITER 3: row=3, varin=7, theta=1.877950, up=999999999999999983222784.000000
ITER 4: row=8, varin=6, theta=0.877950, up=999999999999999983222784.000000
ITER 5: row=1, varin=2, theta=0.243724, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 12 = 1 gives z=27330223.243328
  % 	x12 = 1,	Z1 = 27330223.2433278        
DEBUG EVAL: First branch cutoff check: z=27330223.243328, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 12 = 0
ITER 1: row=10, varin=40, theta=1.594195, up=1.000000
ITER 2: row=10, varin=74, theta=0.423179, up=1.000000
ITER 3: row=25, varin=40, theta=1.000000, up=1.000000
ITER 4: row=2, varin=45, theta=0.058635, up=1.000000
ITER 5: row=12, varin=12, theta=0.048659, up=999999999999999983222784.000000
  % 	x12 = 0,	Z0 = 27249320.1524219        
DEBUG EVAL: Second branch cutoff check: z=27249320.152422, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 5 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=74, theta=1.347634, up=1.000000
ITER 2: row=1, varin=2, theta=0.405686, up=999999999999999983222784.000000
ITER 3: row=2, varin=32, theta=0.412189, up=1.000000
DEBUG EVAL: Branch var 5 = 1 gives z=27273303.705193
  % 	x5 = 1,	Z1 = 27278801.9763668        
DEBUG EVAL: First branch cutoff check: z=27278801.976367, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 5 = 0
ITER 1: row=1, varin=40, theta=0.221862, up=1.000000
ITER 2: row=25, varin=39, theta=0.132739, up=1.000000
  % 	x5 = 0,	Z0 = 27226982.1412605        
DEBUG EVAL: Second branch cutoff check: z=27226982.141260, best_z=INF, threshold=INF
  % Best branch is x13, Z0 = 27256287.3539261        , Z1 = 27330223.2433278        

DEBUG CAREFUL: Final result - returning best.var = 13
DEBUG BB: Branching variable chosen: j=13
 % @NC    9    8	x13 = 0	27256287.353926
 % @NC   10    8	x13 = 1	27330223.243328
 %       8     5 27220304.4857               27227762.2302   x17 U     5     3
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ad4c4a0510
% @LO 0.00  27.22030448565792681848 99.9000000000
% @LN 0.00  27.22776223023901920328 99.9000000000
% Resuming node 6 at  27.22776223023901920328
DEBUG CONSTRNT: LP rows=29, pool->nlprows=29, pool->npend=0
DEBUG CONSTRNT: Checking 29 LP rows (pool tracks 29, total LP rows 29)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 91
DEBUG CONSTRNT: Pool row 91 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=28, expected 28
 % @PAP adding 32 rows, 191 nz to LP
DEBUG BB: Processing node 6, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=2, varin=30, theta=1.500000, up=999999999999999983222784.000000
ITER 2: row=1, varin=47, theta=0.333333, up=1.000000
ITER 3: row=15, varin=12, theta=0.222222, up=999999999999999983222784.000000
ITER 4: row=13, varin=36, theta=1.000000, up=1.000000
ITER 5: row=16, varin=13, theta=0.023672, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=32)
DEBUG SOLUTION: LP solution array indices: FST[33-72], not_covered[73-92]
DEBUG SOLUTION: lp->best_solution[0] = 27227762.230239
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.976328
DEBUG SOLUTION: lp->best_solution[13] = 0.976328
DEBUG SOLUTION: lp->best_solution[14] = 0.976328
  % @PL 32 rows, 60 cols, 251 nonzeros, 5 slack, 27 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % @PAP adding 6 rows, 27 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=28, varin=51, theta=0.333971, up=1.000000
ITER 2: row=30, varin=78, theta=0.911765, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=33)
DEBUG SOLUTION: LP solution array indices: FST[34-73], not_covered[74-93]
DEBUG SOLUTION: lp->best_solution[0] = 27243354.826005
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 33 rows, 60 cols, 257 nonzeros, 2 slack, 31 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 3 rows, 14 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=32, varin=35, theta=0.075331, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=34)
DEBUG SOLUTION: LP solution array indices: FST[35-74], not_covered[75-94]
DEBUG SOLUTION: lp->best_solution[0] = 27244815.902688
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 34 rows, 60 cols, 256 nonzeros, 0 slack, 34 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=35, varin=7, theta=0.081101, up=999999999999999983222784.000000
ITER 2: row=31, varin=55, theta=0.040405, up=1.000000
ITER 3: row=24, varin=91, theta=0.009570, up=1.000000
ITER 4: row=34, varin=24, theta=0.728372, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
ITER 5: row=1, varin=34, theta=0.000000, up=999999999999999983222784.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=36)
DEBUG SOLUTION: LP solution array indices: FST[37-76], not_covered[77-96]
DEBUG SOLUTION: lp->best_solution[0] = 27248519.931677
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 36 rows, 60 cols, 262 nonzeros, 3 slack, 33 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % Node 6 LP 1 Solution, length = 27248519.931677, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.500000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.182093 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.500000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.500000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.817907 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.817907 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.500000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.500000 (terminal 19)
 % 3 fractional variables
DEBUG CG: LP optimal, z=27248519.931677, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 6 at  27.24851993167739649948
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ad4c48c600
% @LO 0.00  27.22776223023901920328 99.9000000000
% @LN 0.00  27.24474944081156024822 99.9000000000
% Resuming node 7 at  27.24474944081156024822
DEBUG CONSTRNT: LP rows=33, pool->nlprows=33, pool->npend=0
DEBUG CONSTRNT: Checking 33 LP rows (pool tracks 33, total LP rows 33)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=32, expected 32
 % @PAP adding 37 rows, 176 nz to LP
DEBUG BB: Processing node 7, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 7 LP 2 Solution, length = 27244749.440812, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 1.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.333333 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.333333 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.666667 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.333333 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.333333 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.666667 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.666667 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.333333 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.333333 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.333333 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.666667 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.333333 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.333333 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.333333 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.333333 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.333333 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=27244749.440812, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=27244749.440812, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 3 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 7 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 7
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=1.000000
DEBUG CAREFUL: Skipping var 1: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=1.000000
DEBUG CAREFUL: Skipping var 2: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.333333
DEBUG CAREFUL: Adding var 5 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.333333
DEBUG CAREFUL: Adding var 9 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.666667
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.666667)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.333333
DEBUG CAREFUL: Adding var 12 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.333333
DEBUG CAREFUL: Adding var 13 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.666667
DEBUG CAREFUL: Adding var 19 to fractional list (xi=0.666667)
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 6 fractional variables

  %  Carefully choosing branching variable, nfrac = 6
DEBUG CAREFUL: Testing fvar[0] = var 19
DEBUG CAREFUL: Calling compare_branch_vars for var 19
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 19
DEBUG CAREFUL: New best var: 19
DEBUG CAREFUL: Testing fvar[1] = var 13
DEBUG CAREFUL: Calling compare_branch_vars for var 13
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 13
DEBUG CAREFUL: Testing fvar[2] = var 12
DEBUG CAREFUL: Calling compare_branch_vars for var 12
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 12
DEBUG CAREFUL: Testing fvar[3] = var 9
DEBUG CAREFUL: Calling compare_branch_vars for var 9
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 9
DEBUG CAREFUL: Testing fvar[4] = var 5
DEBUG CAREFUL: Calling compare_branch_vars for var 5
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 5
DEBUG CAREFUL: Testing fvar[5] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
  % Initial guess is x19, Z0 = 28635595.8984697        , Z1 = 28635595.8984697        

DEBUG EVAL: Testing var 19 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=4, varin=30, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=36, varin=38, theta=0.562500, up=1.000000
ITER 3: row=33, varin=56, theta=0.431507, up=1.000000
ITER 4: row=35, varin=36, theta=0.975000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 19 = 1 gives z=27294115.417827
  % 	x19 = 1,	Z1 = 28635595.8984697        
DEBUG EVAL: First branch cutoff check: z=28635595.898470, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 19 = 0
ITER 1: row=4, varin=26, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=24, varin=25, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=19, varin=28, theta=1.076923, up=999999999999999983222784.000000
ITER 4: row=28, varin=4, theta=2.000000, up=999999999999999983222784.000000
ITER 5: row=5, varin=5, theta=1.000000, up=999999999999999983222784.000000
  % 	x19 = 0,	Z0 = 28635595.8984697        
DEBUG EVAL: Second branch cutoff check: z=28635595.898470, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 13 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=10, varin=30, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=36, varin=38, theta=0.562500, up=1.000000
ITER 3: row=33, varin=54, theta=0.219512, up=1.000000
ITER 4: row=35, varin=36, theta=1.090909, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 13 = 0 gives z=27271936.102332
  % 	x13 = 0,	Z0 = 28635595.8984697        
DEBUG EVAL: First branch cutoff check: z=28635595.898470, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 13 = 1
ITER 1: row=10, varin=26, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=24, varin=25, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=19, varin=28, theta=1.076923, up=999999999999999983222784.000000
ITER 4: row=28, varin=4, theta=2.000000, up=999999999999999983222784.000000
ITER 5: row=5, varin=7, theta=1.000000, up=999999999999999983222784.000000
  % 	x13 = 1,	Z1 = 28635595.8984697        
DEBUG EVAL: Second branch cutoff check: z=28635595.898470, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 12 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=13, varin=30, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=36, varin=38, theta=0.562500, up=1.000000
ITER 3: row=33, varin=56, theta=0.431507, up=1.000000
ITER 4: row=35, varin=36, theta=0.975000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 12 = 0 gives z=27294115.417827
  % 	x12 = 0,	Z0 = 28635595.8984697        
DEBUG EVAL: First branch cutoff check: z=28635595.898470, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 12 = 1
ITER 1: row=13, varin=26, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=24, varin=25, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=19, varin=28, theta=1.076923, up=999999999999999983222784.000000
ITER 4: row=28, varin=4, theta=2.000000, up=999999999999999983222784.000000
ITER 5: row=5, varin=7, theta=1.000000, up=999999999999999983222784.000000
  % 	x12 = 1,	Z1 = 28635595.8984697        
DEBUG EVAL: Second branch cutoff check: z=28635595.898470, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 9 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=24, varin=26, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 9 = 0 gives z=27249682.574257
  % 	x9 = 0,	Z0 = 28635595.8984697        
DEBUG EVAL: First branch cutoff check: z=28635595.898470, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 9 = 1
ITER 1: row=24, varin=25, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=19, varin=30, theta=0.600000, up=999999999999999983222784.000000
ITER 3: row=1, varin=48, theta=2.000000, up=1.000000
ITER 4: row=1, varin=38, theta=0.500000, up=1.000000
ITER 5: row=36, varin=48, theta=0.250000, up=1.000000
ITER 6: row=35, varin=36, theta=3.000000, up=999999999999999983222784.000000
ITER 7: row=33, varin=56, theta=0.700000, up=1.000000
  % 	x9 = 1,	Z1 = 28635595.8984697        
DEBUG EVAL: Second branch cutoff check: z=28635595.898470, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 5 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=25, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=19, varin=28, theta=0.269231, up=999999999999999983222784.000000
ITER 3: row=28, varin=30, theta=0.200000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 5 = 0 gives z=27258325.334802
  % 	x5 = 0,	Z0 = 28635595.8984697        
DEBUG EVAL: First branch cutoff check: z=28635595.898470, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 5 = 1
ITER 1: row=1, varin=26, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=24, varin=30, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=36, varin=38, theta=1.000000, up=1.000000
ITER 4: row=33, varin=56, theta=0.767123, up=1.000000
  % 	x5 = 1,	Z1 = 28635595.8984697        
DEBUG EVAL: Second branch cutoff check: z=28635595.898470, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 10 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=19, varin=38, theta=0.166667, up=1.000000
ITER 2: row=33, varin=25, theta=0.200000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 1 gives z=27247515.838928
  % 	x10 = 1,	Z1 = 28635595.8984697        
DEBUG EVAL: First branch cutoff check: z=28635595.898470, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 0
ITER 1: row=19, varin=28, theta=0.358974, up=999999999999999983222784.000000
ITER 2: row=28, varin=30, theta=0.200000, up=999999999999999983222784.000000
ITER 3: row=35, varin=26, theta=0.666667, up=999999999999999983222784.000000
  % 	x10 = 0,	Z0 = 28635595.8984697        
DEBUG EVAL: Second branch cutoff check: z=28635595.898470, best_z=INF, threshold=INF
  % 6 consecutive failures: giving up.
  % Best branch is x19, Z0 = 28635595.8984697        , Z1 = 28635595.8984697        

DEBUG CAREFUL: Final result - returning best.var = 19
DEBUG BB: Branching variable chosen: j=19
 % @NC   11    7	x19 = 0	28635595.898470
 % @NC   12    7	x19 = 1	28635595.898470
 %       7     6 27244749.4408               27248519.9317   x17 D     5     3
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ad4c4a0510
% @LO 0.00  27.24474944081156024822 99.9000000000
% @LN 0.00  27.24851993167739649948 99.9000000000
% Resuming node 6 at  27.24851993167739649948
DEBUG CONSTRNT: LP rows=37, pool->nlprows=37, pool->npend=0
DEBUG CONSTRNT: Checking 37 LP rows (pool tracks 37, total LP rows 37)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 91
DEBUG CONSTRNT: Pool row 91 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 142
DEBUG CONSTRNT: Pool row 142 has lprow=36, expected 36
 % @PAP adding 33 rows, 191 nz to LP
DEBUG BB: Processing node 6, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 6 LP 2 Solution, length = 27248519.931677, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.500000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.182093 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.500000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.500000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.817907 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.817907 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.500000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.500000 (terminal 19)
 % 3 fractional variables
DEBUG CG: LP optimal, z=27248519.931677, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=27248519.931677, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 6 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 6
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=1.000000
DEBUG CAREFUL: Skipping var 2: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.500000
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=1.000000
DEBUG CAREFUL: Skipping var 7: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.182093
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.182093)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.500000
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 3 fractional variables

  %  Carefully choosing branching variable, nfrac = 3
DEBUG CAREFUL: Testing fvar[0] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 3
DEBUG CAREFUL: New best var: 3
DEBUG CAREFUL: Testing fvar[1] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[2] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
  % Initial guess is x3, Z0 = 27248519.9316774        , Z1 = 27248519.9316774        

DEBUG EVAL: Testing var 3 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=25, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=11, varin=29, theta=0.579684, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 3 = 0 gives z=27296342.856489
  % 	x3 = 0,	Z0 = 27296342.856489         
DEBUG EVAL: First branch cutoff check: z=27296342.856489, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 3 = 1
ITER 1: row=1, varin=20, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=27, varin=21, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=31, varin=70, theta=1.000000, up=1.000000
ITER 4: row=11, varin=49, theta=0.047125, up=1.000000
  % 	x3 = 1,	Z1 = 27454022.4504253        
DEBUG EVAL: Second branch cutoff check: z=27454022.450425, best_z=INF, threshold=INF
  %   New best:  x3, Z = 27296342.856489         
DEBUG EVAL: Testing var 17 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=20, varin=29, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 17 = 0 gives z=27310845.557445
  % 	x17 = 0,	Z0 = 27310845.5574454        
DEBUG EVAL: First branch cutoff check: z=27310845.557445, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 17 = 1
ITER 1: row=20, varin=25, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=11, varin=49, theta=0.381032, up=1.000000
ITER 3: row=22, varin=32, theta=0.106351, up=999999999999999983222784.000000
ITER 4: row=32, varin=29, theta=0.111810, up=999999999999999983222784.000000
ITER 5: row=1, varin=36, theta=0.190447, up=1.000000
  % 	x17 = 1,	Z1 = 27324513.0102502        
DEBUG EVAL: Second branch cutoff check: z=27324513.010250, best_z=INF, threshold=INF
  %   New best:  x17, Z = 27310845.5574454        
DEBUG EVAL: Testing var 10 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=11, varin=35, theta=0.121216, up=1.000000
ITER 2: row=31, varin=70, theta=0.133432, up=1.000000
DEBUG EVAL: Branch var 10 = 0 gives z=27250145.565915
  % 	x10 = 0,	Z0 = 27250145.5659153        
DEBUG EVAL: First branch cutoff check: z=27250145.565915, best_z=INF, threshold=INF
  % Best branch is x17, Z0 = 27310845.5574454        , Z1 = 27324513.0102502        

DEBUG CAREFUL: Final result - returning best.var = 17
DEBUG BB: Branching variable chosen: j=17
 % @NC   13    6	x17 = 0	27310845.557445
 % @NC   14    6	x17 = 1	27324513.010250
 %       6     7 27248519.9317               27256287.3539    x7 U     1     2
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ad4c49c780
% @LO 0.01  27.24851993167739649948 99.9000000000
% @LN 0.01  27.25628735392614743205 99.9000000000
% Resuming node 9 at  27.25628735392614743205
DEBUG CONSTRNT: LP rows=33, pool->nlprows=33, pool->npend=0
DEBUG CONSTRNT: Checking 33 LP rows (pool tracks 33, total LP rows 33)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=32, expected 32
 % @PAP adding 29 rows, 175 nz to LP
DEBUG BB: Processing node 9, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=11, varin=12, theta=0.321967, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
ITER 2: row=2, varin=74, theta=1.000000, up=1.000000
ITER 3: row=14, varin=44, theta=0.000000, up=1.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=29)
DEBUG SOLUTION: LP solution array indices: FST[30-69], not_covered[70-89]
DEBUG SOLUTION: lp->best_solution[0] = 27241640.037975
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.961612
DEBUG SOLUTION: lp->best_solution[13] = 0.961612
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 29 rows, 60 cols, 235 nonzeros, 2 slack, 27 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 3 rows, 13 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=32, varin=43, theta=1.022618, up=1.000000
ITER 2: row=32, varin=29, theta=0.002250, up=999999999999999983222784.000000
ITER 3: row=25, varin=43, theta=1.000000, up=1.000000
ITER 4: row=30, varin=14, theta=0.931415, up=999999999999999983222784.000000
ITER 5: row=31, varin=34, theta=1.470134, up=1.000000
ITER 6: row=31, varin=42, theta=0.184734, up=1.000000
ITER 7: row=30, varin=32, theta=3.256635, up=999999999999999983222784.000000
ITER 8: row=31, varin=34, theta=0.347823, up=1.000000
LP PHASE: Switching to primal (iter=8)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=32)
DEBUG SOLUTION: LP solution array indices: FST[33-72], not_covered[73-92]
DEBUG SOLUTION: lp->best_solution[0] = 27265986.106827
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.724637
DEBUG SOLUTION: lp->best_solution[13] = 0.724637
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 32 rows, 60 cols, 248 nonzeros, 4 slack, 28 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % Node 9 LP 1 Solution, length = 27265986.106827, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.652177 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.275363 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.275363 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.275363 (FST 16)
  % DEBUG LP_VARS: x[17] = 1.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.724637 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.724637 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.347823 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.347823 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.275363 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.275363 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.275363 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.347823 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.724637 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.275363 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.275363 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=27265986.106827, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
 % @LO 0.01  27.25628735392614743205 99.9000000000
 % @LN 0.01  27.26598610682733081489 99.9000000000
DEBUG CG: Second cutoff check: z=27265986.106827, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 3 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 9 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 9
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.652177
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.652177)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=1.000000
DEBUG CAREFUL: Skipping var 2: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.275363
DEBUG CAREFUL: Adding var 5 to fractional list (xi=0.275363)
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.275363
DEBUG CAREFUL: Adding var 12 to fractional list (xi=0.275363)
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.275363
DEBUG CAREFUL: Adding var 16 to fractional list (xi=0.275363)
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=1.000000
DEBUG CAREFUL: Skipping var 17: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.724637
DEBUG CAREFUL: Adding var 19 to fractional list (xi=0.724637)
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 16
DEBUG CAREFUL: Calling compare_branch_vars for var 16
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 16
DEBUG CAREFUL: New best var: 16
DEBUG CAREFUL: Testing fvar[1] = var 19
DEBUG CAREFUL: Calling compare_branch_vars for var 19
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 19
DEBUG CAREFUL: New best var: 19
DEBUG CAREFUL: Testing fvar[2] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 1
DEBUG CAREFUL: Testing fvar[3] = var 12
DEBUG CAREFUL: Calling compare_branch_vars for var 12
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 12
DEBUG CAREFUL: Testing fvar[4] = var 5
DEBUG CAREFUL: Calling compare_branch_vars for var 5
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 5
  % Initial guess is x19, Z0 = 27330223.2433278        , Z1 = 27265986.1068273        

DEBUG EVAL: Testing var 16 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=12, varin=38, theta=0.641619, up=1.000000
DEBUG EVAL: Branch var 16 = 0 gives z=27266987.005695
  % 	x16 = 0,	Z0 = 27266987.0056951        
DEBUG EVAL: First branch cutoff check: z=27266987.005695, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 16 = 1
ITER 1: row=12, varin=12, theta=1.083390, up=999999999999999983222784.000000
ITER 2: row=1, varin=23, theta=1.147289, up=999999999999999983222784.000000
ITER 3: row=23, varin=27, theta=0.807997, up=999999999999999983222784.000000
ITER 4: row=11, varin=30, theta=2.724657, up=1.000000
ITER 5: row=11, varin=6, theta=2.588318, up=999999999999999983222784.000000
ITER 6: row=7, varin=8, theta=1.588318, up=999999999999999983222784.000000
ITER 7: row=28, varin=5, theta=0.588318, up=999999999999999983222784.000000
ITER 8: row=13, varin=25, theta=0.411682, up=999999999999999983222784.000000
ITER 9: row=2, varin=30, theta=0.822093, up=1.000000
ITER 10: row=6, varin=4, theta=0.822093, up=999999999999999983222784.000000
  % 	x16 = 1,	Z1 = 27503305.2946785        
DEBUG EVAL: Second branch cutoff check: z=27503305.294678, best_z=INF, threshold=INF
  %   New best:  x16, Z = 27266987.0056951        
DEBUG EVAL: Testing var 19 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=4, varin=38, theta=0.641619, up=1.000000
DEBUG EVAL: Branch var 19 = 1 gives z=27266987.005695
  % 	x19 = 1,	Z1 = 27266987.0056951        
DEBUG EVAL: First branch cutoff check: z=27266987.005695, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 19 = 0
ITER 1: row=4, varin=23, theta=2.091671, up=999999999999999983222784.000000
ITER 2: row=23, varin=27, theta=2.275343, up=999999999999999983222784.000000
ITER 3: row=3, varin=12, theta=1.658695, up=999999999999999983222784.000000
ITER 4: row=27, varin=15, theta=2.588318, up=999999999999999983222784.000000
ITER 5: row=15, varin=4, theta=2.588318, up=999999999999999983222784.000000
ITER 6: row=5, varin=5, theta=1.588318, up=999999999999999983222784.000000
ITER 7: row=6, varin=18, theta=0.588318, up=999999999999999983222784.000000
ITER 8: row=18, varin=19, theta=0.588318, up=999999999999999983222784.000000
ITER 9: row=19, varin=20, theta=0.588318, up=999999999999999983222784.000000
ITER 10: row=20, varin=25, theta=0.588318, up=999999999999999983222784.000000
  % 	x19 = 0,	Z0 = 27494677.3774254        
DEBUG EVAL: Second branch cutoff check: z=27494677.377425, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 1 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=27, theta=0.381870, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 1 = 1 gives z=27277614.390839
  % 	x1 = 1,	Z1 = 27277614.3908387        
DEBUG EVAL: First branch cutoff check: z=27277614.390839, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 1 = 0
ITER 1: row=1, varin=38, theta=0.841506, up=1.000000
ITER 2: row=4, varin=12, theta=0.111542, up=999999999999999983222784.000000
ITER 3: row=11, varin=28, theta=0.174056, up=999999999999999983222784.000000
  % 	x1 = 0,	Z0 = 27270973.2494726        
DEBUG EVAL: Second branch cutoff check: z=27270973.249473, best_z=INF, threshold=INF
  %   New best:  x1, Z = 27270973.2494726        
DEBUG EVAL: Testing var 12 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=10, varin=23, theta=2.091671, up=999999999999999983222784.000000
ITER 2: row=23, varin=27, theta=2.275343, up=999999999999999983222784.000000
ITER 3: row=1, varin=12, theta=1.658695, up=999999999999999983222784.000000
ITER 4: row=11, varin=22, theta=12.941592, up=999999999999999983222784.000000
ITER 5: row=22, varin=7, theta=1.588318, up=999999999999999983222784.000000
ITER 6: row=8, varin=6, theta=0.588318, up=999999999999999983222784.000000
ITER 7: row=13, varin=25, theta=0.411682, up=999999999999999983222784.000000
ITER 8: row=2, varin=43, theta=0.734549, up=1.000000
ITER 9: row=1, varin=30, theta=0.822093, up=1.000000
ITER 10: row=7, varin=2, theta=0.822093, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 12 = 1 gives z=27503305.294678
  % 	x12 = 1,	Z1 = 27503305.2946785        
DEBUG EVAL: First branch cutoff check: z=27503305.294678, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 12 = 0
ITER 1: row=10, varin=38, theta=0.641619, up=1.000000
  % 	x12 = 0,	Z0 = 27266987.0056951        
DEBUG EVAL: Second branch cutoff check: z=27266987.005695, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 5 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=2, varin=12, theta=1.083390, up=999999999999999983222784.000000
ITER 2: row=1, varin=23, theta=1.147289, up=999999999999999983222784.000000
ITER 3: row=23, varin=28, theta=1.406288, up=999999999999999983222784.000000
ITER 4: row=2, varin=31, theta=0.651518, up=1.000000
DEBUG EVAL: Branch var 5 = 1 gives z=27345412.025671
  % 	x5 = 1,	Z1 = 27345412.0256711        
DEBUG EVAL: First branch cutoff check: z=27345412.025671, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 5 = 0
ITER 1: row=2, varin=38, theta=0.641619, up=1.000000
  % 	x5 = 0,	Z0 = 27266987.0056951        
DEBUG EVAL: Second branch cutoff check: z=27266987.005695, best_z=INF, threshold=INF
  % Best branch is x1, Z0 = 27270973.2494726        , Z1 = 27277614.3908387        

DEBUG CAREFUL: Final result - returning best.var = 1
DEBUG BB: Branching variable chosen: j=1
 % @NC   15    9	x1 = 0	27270973.249473
 % @NC   16    9	x1 = 1	27277614.390839
 %       9     8 27265986.1068               27270973.2495   x13 D     8     4
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ad4c4a0510
% @LO 0.01  27.26598610682733081489 99.9000000000
% @LN 0.01  27.27097324947256851146 99.9000000000
% Resuming node 15 at  27.27097324947256851146
DEBUG CONSTRNT: LP rows=28, pool->nlprows=28, pool->npend=0
DEBUG CONSTRNT: Checking 28 LP rows (pool tracks 28, total LP rows 28)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 91
DEBUG CONSTRNT: Pool row 91 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 82
DEBUG CONSTRNT: Pool row 82 has lprow=27, expected 27
 % @PAP adding 28 rows, 168 nz to LP
DEBUG BB: Processing node 15, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=38, theta=0.841506, up=1.000000
ITER 2: row=4, varin=12, theta=0.111542, up=999999999999999983222784.000000
ITER 3: row=11, varin=28, theta=0.174056, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=28)
DEBUG SOLUTION: LP solution array indices: FST[29-68], not_covered[69-88]
DEBUG SOLUTION: lp->best_solution[0] = 27270973.249473
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 28 rows, 60 cols, 228 nonzeros, 3 slack, 25 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=30, varin=50, theta=0.166667, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=30)
DEBUG SOLUTION: LP solution array indices: FST[31-70], not_covered[71-90]
DEBUG SOLUTION: lp->best_solution[0] = 27278112.063012
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 30 rows, 60 cols, 232 nonzeros, 2 slack, 28 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % Node 15 LP 1 Solution, length = 27278112.063012, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.678885 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.166667 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.166667 (FST 16)
  % DEBUG LP_VARS: x[17] = 1.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.833333 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.321115 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.166667 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.166667 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.166667 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.321115 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.166667 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.166667 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=27278112.063012, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 15 at  27.27811206301244340011
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ad4c4ad660
% @LO 0.01  27.27097324947256851146 99.9000000000
% @LN 0.01  27.27761439083868211242 99.9000000000
% Resuming node 16 at  27.27761439083868211242
DEBUG CONSTRNT: LP rows=28, pool->nlprows=28, pool->npend=0
DEBUG CONSTRNT: Checking 28 LP rows (pool tracks 28, total LP rows 28)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 91
DEBUG CONSTRNT: Pool row 91 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=27, expected 27
 % @PAP adding 28 rows, 168 nz to LP
DEBUG BB: Processing node 16, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=27, theta=0.381870, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=28)
DEBUG SOLUTION: LP solution array indices: FST[29-68], not_covered[69-88]
DEBUG SOLUTION: lp->best_solution[0] = 27277614.390839
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 28 rows, 60 cols, 228 nonzeros, 1 slack, 27 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 2 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=28, varin=23, theta=1.248305, up=999999999999999983222784.000000
ITER 2: row=23, varin=45, theta=0.207958, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=29)
DEBUG SOLUTION: LP solution array indices: FST[30-69], not_covered[70-89]
DEBUG SOLUTION: lp->best_solution[0] = 27299570.351561
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 29 rows, 60 cols, 234 nonzeros, 1 slack, 28 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 16 LP 1 Solution, length = 27299570.351561, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 1.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.194695 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.194695 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.207958 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.194695 (FST 16)
  % DEBUG LP_VARS: x[17] = 1.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.597347 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.805305 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.402653 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.402653 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.402653 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.805305 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.402653 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.402653 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=27299570.351561, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 16 at  27.29957035156149913746
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ad4c4a0510
% @LO 0.01  27.27761439083868211242 99.9000000000
% @LN 0.01  27.27811206301244340011 99.9000000000
% Resuming node 15 at  27.27811206301244340011
DEBUG CONSTRNT: LP rows=28, pool->nlprows=28, pool->npend=0
DEBUG CONSTRNT: Checking 28 LP rows (pool tracks 28, total LP rows 28)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 91
DEBUG CONSTRNT: Pool row 91 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 82
DEBUG CONSTRNT: Pool row 82 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=27, expected 27
 % @PAP adding 28 rows, 168 nz to LP
DEBUG BB: Processing node 15, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 15 LP 2 Solution, length = 27278112.063012, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.678885 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.166667 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.166667 (FST 16)
  % DEBUG LP_VARS: x[17] = 1.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.833333 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.321115 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.166667 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.166667 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.166667 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.321115 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.166667 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.166667 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=27278112.063012, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=27278112.063012, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 15 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 15
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=1.000000
DEBUG CAREFUL: Skipping var 2: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.678885
DEBUG CAREFUL: Adding var 5 to fractional list (xi=0.678885)
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.166667
DEBUG CAREFUL: Adding var 12 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.166667
DEBUG CAREFUL: Adding var 16 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=1.000000
DEBUG CAREFUL: Skipping var 17: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.833333
DEBUG CAREFUL: Adding var 19 to fractional list (xi=0.833333)
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 4 fractional variables

  %  Carefully choosing branching variable, nfrac = 4
DEBUG CAREFUL: Testing fvar[0] = var 16
DEBUG CAREFUL: Calling compare_branch_vars for var 16
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 16
DEBUG CAREFUL: New best var: 16
DEBUG CAREFUL: Testing fvar[1] = var 12
DEBUG CAREFUL: Calling compare_branch_vars for var 12
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 12
DEBUG CAREFUL: Testing fvar[2] = var 19
DEBUG CAREFUL: Calling compare_branch_vars for var 19
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 19
DEBUG CAREFUL: Testing fvar[3] = var 5
DEBUG CAREFUL: Calling compare_branch_vars for var 5
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 5
  % Initial guess is x16, Z0 = 27278112.0630124        , Z1 = 27503305.2946785        

DEBUG EVAL: Testing var 16 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=11, varin=28, theta=2.222222, up=999999999999999983222784.000000
ITER 2: row=10, varin=23, theta=2.777778, up=999999999999999983222784.000000
ITER 3: row=23, varin=6, theta=5.000000, up=999999999999999983222784.000000
ITER 4: row=7, varin=4, theta=4.000000, up=999999999999999983222784.000000
ITER 5: row=5, varin=5, theta=3.000000, up=999999999999999983222784.000000
ITER 6: row=6, varin=2, theta=2.000000, up=999999999999999983222784.000000
ITER 7: row=2, varin=3, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 16 = 1 gives z=27515043.486858
  % 	x16 = 1,	Z1 = 27515043.4868582        
DEBUG EVAL: First branch cutoff check: z=27515043.486858, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 16 = 0
ITER 1: row=11, varin=43, theta=0.166667, up=1.000000
ITER 2: row=12, varin=83, theta=0.800000, up=1.000000
ITER 3: row=21, varin=22, theta=1.500000, up=999999999999999983222784.000000
ITER 4: row=25, varin=44, theta=0.033316, up=1.000000
  % 	x16 = 0,	Z0 = 27301320.693554         
DEBUG EVAL: Second branch cutoff check: z=27301320.693554, best_z=INF, threshold=INF
  %   New best:  x16, Z = 27301320.693554         
DEBUG EVAL: Testing var 12 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=13, varin=28, theta=2.222222, up=999999999999999983222784.000000
ITER 2: row=10, varin=23, theta=2.777778, up=999999999999999983222784.000000
ITER 3: row=23, varin=6, theta=5.000000, up=999999999999999983222784.000000
ITER 4: row=7, varin=4, theta=4.000000, up=999999999999999983222784.000000
ITER 5: row=5, varin=5, theta=3.000000, up=999999999999999983222784.000000
ITER 6: row=6, varin=2, theta=2.000000, up=999999999999999983222784.000000
ITER 7: row=2, varin=3, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 12 = 1 gives z=27515043.486858
  % 	x12 = 1,	Z1 = 27515043.4868582        
DEBUG EVAL: First branch cutoff check: z=27515043.486858, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 12 = 0
ITER 1: row=13, varin=83, theta=0.800000, up=1.000000
ITER 2: row=21, varin=22, theta=1.500000, up=999999999999999983222784.000000
ITER 3: row=25, varin=44, theta=0.033316, up=1.000000
  % 	x12 = 0,	Z0 = 27301320.693554         
DEBUG EVAL: Second branch cutoff check: z=27301320.693554, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 19 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=4, varin=83, theta=0.800000, up=1.000000
ITER 2: row=21, varin=22, theta=1.500000, up=999999999999999983222784.000000
ITER 3: row=25, varin=43, theta=0.230614, up=1.000000
ITER 4: row=11, varin=32, theta=0.114438, up=1.000000
DEBUG EVAL: Branch var 19 = 1 gives z=27304341.048174
  % 	x19 = 1,	Z1 = 27304341.0481742        
DEBUG EVAL: First branch cutoff check: z=27304341.048174, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 19 = 0
ITER 1: row=4, varin=28, theta=2.222222, up=999999999999999983222784.000000
ITER 2: row=10, varin=23, theta=2.777778, up=999999999999999983222784.000000
ITER 3: row=23, varin=6, theta=5.000000, up=999999999999999983222784.000000
ITER 4: row=7, varin=5, theta=4.000000, up=999999999999999983222784.000000
ITER 5: row=6, varin=4, theta=3.000000, up=999999999999999983222784.000000
ITER 6: row=5, varin=2, theta=2.000000, up=999999999999999983222784.000000
ITER 7: row=2, varin=3, theta=1.000000, up=999999999999999983222784.000000
  % 	x19 = 0,	Z0 = 27515043.4868582        
DEBUG EVAL: Second branch cutoff check: z=27515043.486858, best_z=INF, threshold=INF
  %   New best:  x19, Z = 27304341.0481742        
DEBUG EVAL: Testing var 5 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=28, theta=0.282705, up=999999999999999983222784.000000
ITER 2: row=10, varin=23, theta=0.618909, up=999999999999999983222784.000000
ITER 3: row=23, varin=43, theta=0.572954, up=1.000000
ITER 4: row=12, varin=31, theta=0.651518, up=1.000000
DEBUG EVAL: Branch var 5 = 1 gives z=27345412.025671
  % 	x5 = 1,	Z1 = 27345412.0256711        
DEBUG EVAL: First branch cutoff check: z=27345412.025671, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 5 = 0
ITER 1: row=1, varin=83, theta=0.785771, up=1.000000
ITER 2: row=21, varin=22, theta=1.260098, up=999999999999999983222784.000000
  % 	x5 = 0,	Z0 = 27294387.5545618        
DEBUG EVAL: Second branch cutoff check: z=27294387.554562, best_z=INF, threshold=INF
  % Best branch is x19, Z0 = 27515043.4868582        , Z1 = 27304341.0481742        

DEBUG CAREFUL: Final result - returning best.var = 19
DEBUG BB: Branching variable chosen: j=19
 % @NC   17   15	x19 = 1	27304341.048174
 % @NC   18   15	x19 = 0	27515043.486858
 %      15     9 27278112.0630               27280231.5363    x1 D     9     5
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ad4c4a0450
% @LO 0.01  27.27811206301244340011 99.9000000000
% @LN 0.01  27.28023153634394049050 99.9000000000
% Resuming node 4 at  27.28023153634394049050
DEBUG CONSTRNT: LP rows=28, pool->nlprows=28, pool->npend=0
DEBUG CONSTRNT: Checking 28 LP rows (pool tracks 28, total LP rows 28)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 91
DEBUG CONSTRNT: Pool row 91 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=27, expected 27
 % @PAP adding 25 rows, 162 nz to LP
DEBUG BB: Processing node 4, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=6, varin=2, theta=3.766930, up=999999999999999983222784.000000
ITER 2: row=14, varin=70, theta=1.232858, up=1.000000
ITER 3: row=14, varin=6, theta=0.478586, up=999999999999999983222784.000000
ITER 4: row=1, varin=41, theta=0.817750, up=1.000000
ITER 5: row=13, varin=4, theta=1.441724, up=999999999999999983222784.000000
ITER 6: row=7, varin=8, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=4, varin=28, theta=0.448805, up=1.000000
LP PHASE: Switching to primal (iter=7)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=25)
DEBUG SOLUTION: LP solution array indices: FST[26-65], not_covered[66-85]
DEBUG SOLUTION: lp->best_solution[0] = 27280231.536344
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 0.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 25 rows, 60 cols, 222 nonzeros, 4 slack, 21 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % @PAP adding 7 rows, 26 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=23, varin=4, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=25, varin=5, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=1, varin=71, theta=1.000000, up=1.000000
ITER 4: row=27, varin=6, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=1, varin=73, theta=1.000000, up=1.000000
ITER 6: row=22, varin=15, theta=0.448805, up=999999999999999983222784.000000
ITER 7: row=1, varin=76, theta=0.448805, up=1.000000
LP PHASE: Switching to primal (iter=7)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=28)
DEBUG SOLUTION: LP solution array indices: FST[29-68], not_covered[69-88]
DEBUG SOLUTION: lp->best_solution[0] = 27280231.536344
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 0.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 0.000000
DEBUG SOLUTION: lp->best_solution[8] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 28 rows, 60 cols, 240 nonzeros, 7 slack, 21 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 20 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=32, varin=82, theta=0.153846, up=1.000000
ITER 2: row=30, varin=32, theta=11.000000, up=999999999999999983222784.000000
ITER 3: row=29, varin=10, theta=0.278420, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=32)
DEBUG SOLUTION: LP solution array indices: FST[33-72], not_covered[73-92]
DEBUG SOLUTION: lp->best_solution[0] = 27310414.564969
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.278420
DEBUG SOLUTION: lp->best_solution[5] = 0.278420
DEBUG SOLUTION: lp->best_solution[6] = 0.278420
DEBUG SOLUTION: lp->best_solution[7] = 0.000000
DEBUG SOLUTION: lp->best_solution[8] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.721580
DEBUG SOLUTION: lp->best_solution[11] = 0.721580
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 32 rows, 60 cols, 260 nonzeros, 10 slack, 22 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 10 slack rows
  % Node 4 LP 1 Solution, length = 27310414.564969, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.886318 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.721580 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.721580 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.278420 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 1.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.278420 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.278420 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.278420 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.278420 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.113682 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.278420 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.278420 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=27310414.564969, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 4 at  27.31041456496879860083
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ad4c4ad660
% @LO 0.01  27.28023153634394049050 99.9000000000
% @LN 0.01  27.29957035156149913746 99.9000000000
% Resuming node 16 at  27.29957035156149913746
DEBUG CONSTRNT: LP rows=22, pool->nlprows=22, pool->npend=0
DEBUG CONSTRNT: Checking 22 LP rows (pool tracks 22, total LP rows 22)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 65
DEBUG CONSTRNT: Pool row 65 has lprow=21, expected 21
 % @PAP adding 28 rows, 168 nz to LP
DEBUG BB: Processing node 16, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 16 LP 2 Solution, length = 27299570.351561, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 1.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.194695 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.194695 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.207958 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.194695 (FST 16)
  % DEBUG LP_VARS: x[17] = 1.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.597347 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.805305 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.402653 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.402653 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.402653 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.805305 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.402653 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.402653 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=27299570.351561, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=27299570.351561, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 3 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 16 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 16
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=1.000000
DEBUG CAREFUL: Skipping var 1: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=1.000000
DEBUG CAREFUL: Skipping var 2: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.194695
DEBUG CAREFUL: Adding var 5 to fractional list (xi=0.194695)
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.194695
DEBUG CAREFUL: Adding var 12 to fractional list (xi=0.194695)
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.207958
DEBUG CAREFUL: Adding var 15 to fractional list (xi=0.207958)
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.194695
DEBUG CAREFUL: Adding var 16 to fractional list (xi=0.194695)
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=1.000000
DEBUG CAREFUL: Skipping var 17: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.597347
DEBUG CAREFUL: Adding var 19 to fractional list (xi=0.597347)
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 15
DEBUG CAREFUL: Calling compare_branch_vars for var 15
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 15
DEBUG CAREFUL: New best var: 15
DEBUG CAREFUL: Testing fvar[1] = var 19
DEBUG CAREFUL: Calling compare_branch_vars for var 19
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 19
DEBUG CAREFUL: New best var: 19
DEBUG CAREFUL: Testing fvar[2] = var 16
DEBUG CAREFUL: Calling compare_branch_vars for var 16
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 16
DEBUG CAREFUL: New best var: 16
DEBUG CAREFUL: Testing fvar[3] = var 12
DEBUG CAREFUL: Calling compare_branch_vars for var 12
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 12
DEBUG CAREFUL: Testing fvar[4] = var 5
DEBUG CAREFUL: Calling compare_branch_vars for var 5
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 5
  % Initial guess is x16, Z0 = 27299570.3515615        , Z1 = 27503305.2946785        

DEBUG EVAL: Testing var 15 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=12, varin=39, theta=4.754371, up=1.000000
ITER 2: row=12, varin=28, theta=1.148502, up=999999999999999983222784.000000
ITER 3: row=23, varin=39, theta=1.000000, up=1.000000
ITER 4: row=10, varin=23, theta=2.312052, up=999999999999999983222784.000000
ITER 5: row=23, varin=12, theta=1.583640, up=999999999999999983222784.000000
ITER 6: row=12, varin=25, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=11, varin=8, theta=2.942398, up=999999999999999983222784.000000
ITER 8: row=28, varin=4, theta=1.942398, up=999999999999999983222784.000000
ITER 9: row=5, varin=28, theta=0.942398, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 15 = 1 gives z=27546884.990287
  % 	x15 = 1,	Z1 = 27546884.9902873        
DEBUG EVAL: First branch cutoff check: z=27546884.990287, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 15 = 0
ITER 1: row=12, varin=31, theta=0.554261, up=1.000000
  % 	x15 = 0,	Z0 = 27316772.5898758        
DEBUG EVAL: Second branch cutoff check: z=27316772.589876, best_z=INF, threshold=INF
  %   New best:  x15, Z = 27316772.5898758        
DEBUG EVAL: Testing var 19 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=4, varin=39, theta=1.647049, up=1.000000
ITER 2: row=4, varin=38, theta=1.086839, up=1.000000
ITER 3: row=4, varin=32, theta=0.042934, up=1.000000
ITER 4: row=23, varin=39, theta=1.000000, up=1.000000
ITER 5: row=1, varin=31, theta=1.820398, up=1.000000
ITER 6: row=1, varin=38, theta=0.859354, up=1.000000
DEBUG EVAL: Branch var 19 = 1 gives z=27447170.476762
  % 	x19 = 1,	Z1 = 27447170.4767619        
DEBUG EVAL: First branch cutoff check: z=27447170.476762, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 19 = 0
ITER 1: row=4, varin=25, theta=2.666362, up=999999999999999983222784.000000
ITER 2: row=1, varin=8, theta=2.000000, up=999999999999999983222784.000000
ITER 3: row=28, varin=5, theta=1.000000, up=999999999999999983222784.000000
  % 	x19 = 0,	Z0 = 27494677.3774254        
DEBUG EVAL: Second branch cutoff check: z=27494677.377425, best_z=INF, threshold=INF
  %   New best:  x19, Z = 27447170.4767619        
DEBUG EVAL: Testing var 16 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=13, varin=25, theta=1.459049, up=999999999999999983222784.000000
ITER 2: row=1, varin=31, theta=1.012932, up=1.000000
ITER 3: row=1, varin=11, theta=0.012526, up=999999999999999983222784.000000
ITER 4: row=12, varin=12, theta=0.242074, up=999999999999999983222784.000000
ITER 5: row=11, varin=13, theta=0.524894, up=999999999999999983222784.000000
ITER 6: row=1, varin=8, theta=2.701023, up=999999999999999983222784.000000
ITER 7: row=28, varin=7, theta=1.701023, up=999999999999999983222784.000000
ITER 8: row=8, varin=6, theta=0.701023, up=999999999999999983222784.000000
ITER 9: row=11, varin=31, theta=0.164729, up=1.000000
DEBUG EVAL: Branch var 16 = 1 gives z=27535345.201853
  % 	x16 = 1,	Z1 = 27535345.2018528        
DEBUG EVAL: First branch cutoff check: z=27535345.201853, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 16 = 0
ITER 1: row=13, varin=39, theta=0.473639, up=1.000000
ITER 2: row=23, varin=28, theta=0.367543, up=999999999999999983222784.000000
  % 	x16 = 0,	Z0 = 27320702.6004314        
DEBUG EVAL: Second branch cutoff check: z=27320702.600431, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 12 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=10, varin=25, theta=1.459049, up=999999999999999983222784.000000
ITER 2: row=1, varin=31, theta=1.012932, up=1.000000
ITER 3: row=1, varin=11, theta=0.004580, up=999999999999999983222784.000000
ITER 4: row=12, varin=8, theta=2.060233, up=999999999999999983222784.000000
ITER 5: row=28, varin=28, theta=1.060233, up=999999999999999983222784.000000
ITER 6: row=25, varin=7, theta=1.120465, up=999999999999999983222784.000000
ITER 7: row=8, varin=6, theta=0.120465, up=999999999999999983222784.000000
ITER 8: row=1, varin=31, theta=0.164729, up=1.000000
DEBUG EVAL: Branch var 12 = 1 gives z=27535345.201853
  % 	x12 = 1,	Z1 = 27535345.2018528        
DEBUG EVAL: First branch cutoff check: z=27535345.201853, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 12 = 0
ITER 1: row=10, varin=39, theta=0.473639, up=1.000000
ITER 2: row=23, varin=28, theta=0.367543, up=999999999999999983222784.000000
  % 	x12 = 0,	Z0 = 27320702.6004314        
DEBUG EVAL: Second branch cutoff check: z=27320702.600431, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 5 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=28, theta=1.712392, up=999999999999999983222784.000000
ITER 2: row=10, varin=31, theta=1.339388, up=1.000000
ITER 3: row=10, varin=11, theta=0.116526, up=999999999999999983222784.000000
ITER 4: row=13, varin=41, theta=0.328732, up=1.000000
DEBUG EVAL: Branch var 5 = 1 gives z=27456459.922399
  % 	x5 = 1,	Z1 = 27456459.9223993        
DEBUG EVAL: First branch cutoff check: z=27456459.922399, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 5 = 0
ITER 1: row=1, varin=39, theta=0.473639, up=1.000000
ITER 2: row=23, varin=25, theta=0.434526, up=999999999999999983222784.000000
  % 	x5 = 0,	Z0 = 27313309.9640089        
DEBUG EVAL: Second branch cutoff check: z=27313309.964009, best_z=INF, threshold=INF
  % Best branch is x19, Z0 = 27494677.3774254        , Z1 = 27447170.4767619        

DEBUG CAREFUL: Final result - returning best.var = 19
DEBUG BB: Branching variable chosen: j=19
 % @NC   19   16	x19 = 1	27447170.476762
 % @NC   20   16	x19 = 0	27494677.377425
 %      16    10 27299570.3516               27304341.0482    x1 U     9     5
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ad4c49c780
% @LO 0.01  27.29957035156149913746 99.9000000000
% @LN 0.01  27.30434104817418017319 99.9000000000
% Resuming node 17 at  27.30434104817418017319
DEBUG CONSTRNT: LP rows=28, pool->nlprows=28, pool->npend=0
DEBUG CONSTRNT: Checking 28 LP rows (pool tracks 28, total LP rows 28)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 91
DEBUG CONSTRNT: Pool row 91 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 82
DEBUG CONSTRNT: Pool row 82 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=27, expected 27
 % @PAP adding 28 rows, 168 nz to LP
DEBUG BB: Processing node 17, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=4, varin=83, theta=0.800000, up=1.000000
ITER 2: row=21, varin=22, theta=1.500000, up=999999999999999983222784.000000
ITER 3: row=22, varin=43, theta=0.230614, up=1.000000
ITER 4: row=11, varin=32, theta=0.114438, up=1.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=28)
DEBUG SOLUTION: LP solution array indices: FST[29-68], not_covered[69-88]
DEBUG SOLUTION: lp->best_solution[0] = 27304341.048174
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 28 rows, 60 cols, 228 nonzeros, 3 slack, 25 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 5 rows, 25 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=26, varin=47, theta=0.776978, up=1.000000
ITER 2: row=11, varin=73, theta=0.204498, up=1.000000
ITER 3: row=28, varin=31, theta=0.301606, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=30)
DEBUG SOLUTION: LP solution array indices: FST[31-70], not_covered[71-90]
DEBUG SOLUTION: lp->best_solution[0] = 27326712.162781
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 30 rows, 60 cols, 242 nonzeros, 1 slack, 29 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 6 rows, 21 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=30, varin=72, theta=0.677305, up=1.000000
LP PHASE: Switching to primal (iter=1)
ITER 2: row=11, varin=50, theta=0.000000, up=1.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=35)
DEBUG SOLUTION: LP solution array indices: FST[36-75], not_covered[76-95]
DEBUG SOLUTION: lp->best_solution[0] = 27361661.660630
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 35 rows, 60 cols, 254 nonzeros, 0 slack, 35 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 3 rows, 10 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=36, varin=73, theta=0.481550, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=38)
DEBUG SOLUTION: LP solution array indices: FST[39-78], not_covered[79-98]
DEBUG SOLUTION: lp->best_solution[0] = 27364889.374022
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 38 rows, 60 cols, 264 nonzeros, 1 slack, 37 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=38, varin=57, theta=0.145138, up=1.000000
ITER 2: row=29, varin=65, theta=0.193139, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=38)
DEBUG SOLUTION: LP solution array indices: FST[39-78], not_covered[79-98]
DEBUG SOLUTION: lp->best_solution[0] = 27368199.105568
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 38 rows, 60 cols, 260 nonzeros, 0 slack, 38 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 17 LP 1 Solution, length = 27368199.105568, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.201715 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.201715 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.201715 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 1.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.193139 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.201715 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.201715 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.798285 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.798285 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.798285 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.798285 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=27368199.105568, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 17 at  27.36819910556780044431
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ad4c4a0450
% @LO 0.01  27.30434104817418017319 99.9000000000
% @LN 0.01  27.31041456496879860083 99.9000000000
% Resuming node 4 at  27.31041456496879860083
DEBUG CONSTRNT: LP rows=38, pool->nlprows=38, pool->npend=0
DEBUG CONSTRNT: Checking 38 LP rows (pool tracks 38, total LP rows 38)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=37, expected 37
 % @PAP adding 22 rows, 151 nz to LP
DEBUG BB: Processing node 4, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 4 LP 2 Solution, length = 27310414.564969, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.886318 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.721580 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.721580 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.278420 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 1.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.278420 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.278420 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.278420 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.278420 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.113682 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.278420 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.278420 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=27310414.564969, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=27310414.564969, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 4 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 4
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.886318
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.886318)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.721580
DEBUG CAREFUL: Adding var 12 to fractional list (xi=0.721580)
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.721580
DEBUG CAREFUL: Adding var 13 to fractional list (xi=0.721580)
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.278420
DEBUG CAREFUL: Adding var 15 to fractional list (xi=0.278420)
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=1.000000
DEBUG CAREFUL: Skipping var 20: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 4 fractional variables

  %  Carefully choosing branching variable, nfrac = 4
DEBUG CAREFUL: Testing fvar[0] = var 15
DEBUG CAREFUL: Calling compare_branch_vars for var 15
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 15
DEBUG CAREFUL: New best var: 15
DEBUG CAREFUL: Testing fvar[1] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[2] = var 13
DEBUG CAREFUL: Calling compare_branch_vars for var 13
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 13
DEBUG CAREFUL: Testing fvar[3] = var 12
DEBUG CAREFUL: Calling compare_branch_vars for var 12
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 12
  % Initial guess is x15, Z0 = 27310414.5649688        , Z1 = 27310414.5649688        

DEBUG EVAL: Testing var 15 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=8, varin=37, theta=0.408174, up=1.000000
ITER 2: row=7, varin=8, theta=0.288638, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 15 = 0 gives z=27338692.092218
  % 	x15 = 0,	Z0 = 27338692.0922182        
DEBUG EVAL: First branch cutoff check: z=27338692.092218, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 15 = 1
ITER 1: row=8, varin=12, theta=3.754854, up=999999999999999983222784.000000
ITER 2: row=18, varin=2, theta=4.509707, up=999999999999999983222784.000000
ITER 3: row=2, varin=19, theta=4.509707, up=999999999999999983222784.000000
ITER 4: row=21, varin=15, theta=3.509707, up=999999999999999983222784.000000
ITER 5: row=15, varin=18, theta=2.509707, up=999999999999999983222784.000000
ITER 6: row=19, varin=3, theta=1.509707, up=999999999999999983222784.000000
ITER 7: row=1, varin=24, theta=0.742944, up=1.000000
  % 	x15 = 1,	Z1 = 27417594.8238357        
DEBUG EVAL: Second branch cutoff check: z=27417594.823836, best_z=INF, threshold=INF
  %   New best:  x15, Z = 27338692.0922182        
DEBUG EVAL: Testing var 2 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=12, theta=0.491469, up=999999999999999983222784.000000
ITER 2: row=18, varin=2, theta=0.491469, up=999999999999999983222784.000000
ITER 3: row=2, varin=3, theta=0.491469, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 1 gives z=27320653.374091
  % 	x2 = 1,	Z1 = 27320653.3740909        
DEBUG EVAL: First branch cutoff check: z=27320653.374091, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 13 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=6, varin=8, theta=0.985603, up=999999999999999983222784.000000
ITER 2: row=22, varin=21, theta=3.082776, up=999999999999999983222784.000000
ITER 3: row=5, varin=44, theta=1.197343, up=1.000000
ITER 4: row=5, varin=49, theta=0.235276, up=1.000000
DEBUG EVAL: Branch var 13 = 1 gives z=27734343.678552
  % 	x13 = 1,	Z1 = 27734343.6785519        
DEBUG EVAL: First branch cutoff check: z=27734343.678552, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 13 = 0
ITER 1: row=6, varin=37, theta=2.269922, up=1.000000
ITER 2: row=6, varin=12, theta=2.100676, up=999999999999999983222784.000000
ITER 3: row=18, varin=2, theta=2.201353, up=999999999999999983222784.000000
ITER 4: row=2, varin=19, theta=2.201353, up=999999999999999983222784.000000
ITER 5: row=21, varin=15, theta=2.201353, up=999999999999999983222784.000000
ITER 6: row=15, varin=18, theta=1.201353, up=999999999999999983222784.000000
ITER 7: row=19, varin=17, theta=1.201353, up=999999999999999983222784.000000
ITER 8: row=7, varin=37, theta=1.000000, up=1.000000
ITER 9: row=1, varin=24, theta=0.742944, up=1.000000
  % 	x13 = 0,	Z0 = 27417594.8238357        
DEBUG EVAL: Second branch cutoff check: z=27417594.823836, best_z=INF, threshold=INF
  %   New best:  x13, Z = 27417594.8238357        
DEBUG EVAL: Testing var 12 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=5, varin=37, theta=0.408174, up=1.000000
ITER 2: row=7, varin=39, theta=0.600576, up=1.000000
DEBUG EVAL: Branch var 12 = 1 gives z=27397718.043415
  % 	x12 = 1,	Z1 = 27397718.0434153        
DEBUG EVAL: First branch cutoff check: z=27397718.043415, best_z=INF, threshold=INF
  % Best branch is x13, Z0 = 27417594.8238357        , Z1 = 27734343.6785519        

DEBUG CAREFUL: Final result - returning best.var = 13
DEBUG BB: Branching variable chosen: j=13
 % @NC   21    4	x13 = 0	27417594.823836
 % @NC   22    4	x13 = 1	27734343.678552
 %       4    11 27310414.5650               27310845.5574   x19 D     2     2
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ad4c48c600
% @LO 0.01  27.31041456496879860083 99.9000000000
% @LN 0.01  27.31084555744540764977 99.9000000000
% Resuming node 13 at  27.31084555744540764977
DEBUG CONSTRNT: LP rows=22, pool->nlprows=22, pool->npend=0
DEBUG CONSTRNT: Checking 22 LP rows (pool tracks 22, total LP rows 22)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 65
DEBUG CONSTRNT: Pool row 65 has lprow=21, expected 21
 % @PAP adding 33 rows, 191 nz to LP
DEBUG BB: Processing node 13, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=20, varin=29, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=33)
DEBUG SOLUTION: LP solution array indices: FST[34-73], not_covered[74-93]
DEBUG SOLUTION: lp->best_solution[0] = 27310845.557445
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 33 rows, 60 cols, 251 nonzeros, 3 slack, 30 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 6 rows, 28 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=38, varin=41, theta=0.921333, up=1.000000
ITER 2: row=22, varin=24, theta=0.056321, up=999999999999999983222784.000000
ITER 3: row=34, varin=76, theta=1.645652, up=1.000000
ITER 4: row=34, varin=20, theta=0.526541, up=999999999999999983222784.000000
ITER 5: row=27, varin=92, theta=0.953692, up=1.000000
ITER 6: row=36, varin=21, theta=0.159203, up=999999999999999983222784.000000
ITER 7: row=37, varin=45, theta=0.272650, up=1.000000
ITER 8: row=3, varin=81, theta=0.079181, up=1.000000
LP PHASE: Switching to primal (iter=8)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=39)
DEBUG SOLUTION: LP solution array indices: FST[40-79], not_covered[80-99]
DEBUG SOLUTION: lp->best_solution[0] = 27348713.002305
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 0.769795
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 39 rows, 60 cols, 279 nonzeros, 6 slack, 33 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 6 slack rows
  % @PAP adding 2 rows, 7 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=34, varin=80, theta=2.625874, up=1.000000
ITER 2: row=34, varin=51, theta=0.832847, up=1.000000
ITER 3: row=11, varin=72, theta=1.000000, up=1.000000
ITER 4: row=1, varin=80, theta=0.848628, up=1.000000
ITER 5: row=35, varin=33, theta=0.781339, up=999999999999999983222784.000000
ITER 6: row=5, varin=36, theta=0.125914, up=1.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=35)
DEBUG SOLUTION: LP solution array indices: FST[36-75], not_covered[76-95]
DEBUG SOLUTION: lp->best_solution[0] = 27390071.839931
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 35 rows, 60 cols, 262 nonzeros, 5 slack, 30 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % @PAP adding 4 rows, 15 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=33, varin=54, theta=0.221079, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=34)
DEBUG SOLUTION: LP solution array indices: FST[35-74], not_covered[75-94]
DEBUG SOLUTION: lp->best_solution[0] = 27395060.549776
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 34 rows, 60 cols, 253 nonzeros, 2 slack, 32 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % Node 13 LP 1 Solution, length = 27395060.549776, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.500000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.500000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.168382 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.168382 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.221079 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.168382 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.778921 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.500000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.831618 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.500000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.500000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.221079 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.221079 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.500000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.831618 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.831618 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.831618 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.221079 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.221079 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.831618 (terminal 19)
 % 7 fractional variables
DEBUG CG: LP optimal, z=27395060.549776, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 13 at  27.39506054977588789257
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ad4c4a4590
% @LO 0.01  27.31084555744540764977 99.9000000000
% @LN 0.01  27.32451301025016121571 99.9000000000
% Resuming node 14 at  27.32451301025016121571
DEBUG CONSTRNT: LP rows=32, pool->nlprows=32, pool->npend=0
DEBUG CONSTRNT: Checking 32 LP rows (pool tracks 32, total LP rows 32)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 142
DEBUG CONSTRNT: Pool row 142 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=31, expected 31
 % @PAP adding 33 rows, 191 nz to LP
DEBUG BB: Processing node 14, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=20, varin=25, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=11, varin=49, theta=0.381032, up=1.000000
ITER 3: row=22, varin=32, theta=0.106351, up=999999999999999983222784.000000
ITER 4: row=32, varin=29, theta=0.111810, up=999999999999999983222784.000000
ITER 5: row=1, varin=36, theta=0.190447, up=1.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=33)
DEBUG SOLUTION: LP solution array indices: FST[34-73], not_covered[74-93]
DEBUG SOLUTION: lp->best_solution[0] = 27324513.010250
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 0.666667
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 33 rows, 60 cols, 251 nonzeros, 3 slack, 30 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=31, varin=14, theta=0.170279, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=31)
DEBUG SOLUTION: LP solution array indices: FST[32-71], not_covered[72-91]
DEBUG SOLUTION: lp->best_solution[0] = 27344119.791933
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.829721
  % @PL 31 rows, 60 cols, 247 nonzeros, 1 slack, 30 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 14 LP 1 Solution, length = 27344119.791933, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.829721 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.390093 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 1.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.609907 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.390093 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.390093 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.170279 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.390093 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.390093 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 3 fractional variables
DEBUG CG: LP optimal, z=27344119.791933, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 14 at  27.34411979193251340803
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ad4c4a5090
% @LO 0.01  27.32451301025016121571 99.9000000000
% @LN 0.01  27.33022324332776520350 99.9000000000
% Resuming node 10 at  27.33022324332776520350
DEBUG CONSTRNT: LP rows=30, pool->nlprows=30, pool->npend=0
DEBUG CONSTRNT: Checking 30 LP rows (pool tracks 30, total LP rows 30)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=29, expected 29
 % @PAP adding 29 rows, 175 nz to LP
DEBUG BB: Processing node 10, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=11, varin=4, theta=2.877950, up=999999999999999983222784.000000
ITER 2: row=5, varin=7, theta=1.877950, up=999999999999999983222784.000000
ITER 3: row=8, varin=3, theta=0.877950, up=999999999999999983222784.000000
ITER 4: row=3, varin=5, theta=0.877950, up=999999999999999983222784.000000
ITER 5: row=1, varin=45, theta=0.138241, up=1.000000
ITER 6: row=12, varin=2, theta=0.243724, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=29)
DEBUG SOLUTION: LP solution array indices: FST[30-69], not_covered[70-89]
DEBUG SOLUTION: lp->best_solution[0] = 27330223.243328
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 0.756276
DEBUG SOLUTION: lp->best_solution[3] = 0.756276
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 0.243724
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 0.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 29 rows, 60 cols, 235 nonzeros, 5 slack, 24 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 6 rows, 29 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=33, varin=6, theta=0.153846, up=999999999999999983222784.000000
ITER 2: row=34, varin=8, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=30, varin=80, theta=1.397570, up=1.000000
ITER 4: row=30, varin=81, theta=0.397570, up=1.000000
ITER 5: row=31, varin=33, theta=11.000000, up=999999999999999983222784.000000
ITER 6: row=3, varin=83, theta=1.000000, up=1.000000
ITER 7: row=2, varin=80, theta=0.756276, up=1.000000
ITER 8: row=3, varin=93, theta=0.756276, up=1.000000
LP PHASE: Switching to primal (iter=8)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=35)
DEBUG SOLUTION: LP solution array indices: FST[36-75], not_covered[76-95]
DEBUG SOLUTION: lp->best_solution[0] = 27330223.243328
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 0.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 0.756276
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 35 rows, 60 cols, 264 nonzeros, 6 slack, 29 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 20 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=36, varin=87, theta=1.000000, up=1.000000
ITER 2: row=39, varin=56, theta=0.570763, up=1.000000
ITER 3: row=38, varin=39, theta=12.206764, up=999999999999999983222784.000000
ITER 4: row=2, varin=45, theta=0.670039, up=1.000000
ITER 5: row=32, varin=50, theta=0.581267, up=1.000000
ITER 6: row=25, varin=49, theta=0.915013, up=1.000000
ITER 7: row=2, varin=31, theta=0.276442, up=999999999999999983222784.000000
ITER 8: row=39, varin=2, theta=0.487378, up=999999999999999983222784.000000
ITER 9: row=3, varin=42, theta=0.495191, up=1.000000
LP PHASE: Switching to primal (iter=9)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=39)
DEBUG SOLUTION: LP solution array indices: FST[40-79], not_covered[80-99]
DEBUG SOLUTION: lp->best_solution[0] = 27471521.031449
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 0.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 0.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 39 rows, 60 cols, 284 nonzeros, 11 slack, 28 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 11 slack rows
  % @PAP adding 4 rows, 22 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=31, varin=36, theta=0.500000, up=1.000000
ITER 2: row=17, varin=38, theta=0.027152, up=1.000000
ITER 3: row=32, varin=78, theta=0.034626, up=1.000000
ITER 4: row=2, varin=87, theta=0.039225, up=1.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=32)
DEBUG SOLUTION: LP solution array indices: FST[33-72], not_covered[73-92]
DEBUG SOLUTION: lp->best_solution[0] = 27476193.378255
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 32 rows, 60 cols, 255 nonzeros, 2 slack, 30 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 4 rows, 16 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=32, varin=35, theta=0.503961, up=1.000000
ITER 2: row=18, varin=2, theta=0.008400, up=999999999999999983222784.000000
ITER 3: row=2, varin=30, theta=0.006817, up=999999999999999983222784.000000
ITER 4: row=19, varin=88, theta=0.008535, up=1.000000
ITER 5: row=28, varin=29, theta=0.009743, up=999999999999999983222784.000000
ITER 6: row=29, varin=61, theta=0.018448, up=1.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=34)
DEBUG SOLUTION: LP solution array indices: FST[35-74], not_covered[75-94]
DEBUG SOLUTION: lp->best_solution[0] = 27497326.031414
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 34 rows, 60 cols, 266 nonzeros, 0 slack, 34 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 8 rows, 26 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=35, varin=52, theta=0.265754, up=1.000000
ITER 2: row=41, varin=64, theta=0.458044, up=1.000000
ITER 3: row=11, varin=70, theta=0.551104, up=1.000000
ITER 4: row=29, varin=11, theta=2.209493, up=999999999999999983222784.000000
ITER 5: row=41, varin=85, theta=0.242417, up=1.000000
ITER 6: row=30, varin=97, theta=0.353602, up=1.000000
ITER 7: row=31, varin=79, theta=0.626888, up=1.000000
LP PHASE: Switching to primal (iter=7)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 27570951.036368
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 42 rows, 60 cols, 292 nonzeros, 0 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 3 rows, 10 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=43, varin=28, theta=0.403352, up=999999999999999983222784.000000
ITER 2: row=45, varin=64, theta=0.228170, up=1.000000
ITER 3: row=43, varin=75, theta=0.571075, up=1.000000
ITER 4: row=40, varin=67, theta=0.454975, up=1.000000
ITER 5: row=11, varin=47, theta=0.202964, up=1.000000
ITER 6: row=2, varin=71, theta=0.508048, up=1.000000
ITER 7: row=9, varin=69, theta=0.481887, up=1.000000
ITER 8: row=44, varin=10, theta=0.195041, up=999999999999999983222784.000000
ITER 9: row=34, varin=70, theta=2.637907, up=1.000000
ITER 10: row=34, varin=3, theta=0.238541, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=22)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 27686845.664171
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.801504
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 45 rows, 60 cols, 302 nonzeros, 3 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 3 rows, 7 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=44, varin=69, theta=0.661875, up=1.000000
ITER 2: row=41, varin=48, theta=0.423137, up=1.000000
ITER 3: row=26, varin=68, theta=0.646317, up=1.000000
ITER 4: row=30, varin=70, theta=0.711687, up=1.000000
ITER 5: row=35, varin=78, theta=0.935463, up=1.000000
ITER 6: row=36, varin=31, theta=0.844121, up=999999999999999983222784.000000
ITER 7: row=31, varin=90, theta=0.216476, up=1.000000
ITER 8: row=4, varin=21, theta=0.081438, up=999999999999999983222784.000000
ITER 9: row=43, varin=56, theta=0.426248, up=1.000000
LP PHASE: Switching to primal (iter=9)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 27712005.968340
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.000000
DEBUG SOLUTION: lp->best_solution[4] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.713124
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 45 rows, 60 cols, 299 nonzeros, 2 slack, 43 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % Node 10 LP 1 Solution, length = 27712005.968340, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.426248 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.713124 (FST 12)
  % DEBUG LP_VARS: x[13] = 1.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 1.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.286876 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.286876 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.426248 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.573752 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.573752 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.286876 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.286876 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=27712005.968340, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 10 at  27.71200596833951124154
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ad4c4a4590
% @LO 0.01  27.33022324332776520350 99.9000000000
% @LN 0.01  27.34411979193251340803 99.9000000000
% Resuming node 14 at  27.34411979193251340803
DEBUG CONSTRNT: LP rows=43, pool->nlprows=43, pool->npend=0
DEBUG CONSTRNT: Checking 43 LP rows (pool tracks 43, total LP rows 43)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 65
DEBUG CONSTRNT: Pool row 65 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 133
DEBUG CONSTRNT: Pool row 133 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=42, expected 42
 % @PAP adding 30 rows, 185 nz to LP
DEBUG BB: Processing node 14, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 14 LP 2 Solution, length = 27344119.791933, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.829721 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.390093 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 1.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.609907 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.390093 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.390093 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.170279 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.390093 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.390093 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 3 fractional variables
DEBUG CG: LP optimal, z=27344119.791933, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=27344119.791933, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 14 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 14
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.829721
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.829721)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=1.000000
DEBUG CAREFUL: Skipping var 7: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.390093
DEBUG CAREFUL: Adding var 15 to fractional list (xi=0.390093)
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=1.000000
DEBUG CAREFUL: Skipping var 17: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.609907
DEBUG CAREFUL: Adding var 19 to fractional list (xi=0.609907)
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 3 fractional variables

  %  Carefully choosing branching variable, nfrac = 3
DEBUG CAREFUL: Testing fvar[0] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 2
DEBUG CAREFUL: New best var: 2
DEBUG CAREFUL: Testing fvar[1] = var 15
DEBUG CAREFUL: Calling compare_branch_vars for var 15
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 15
DEBUG CAREFUL: Testing fvar[2] = var 19
DEBUG CAREFUL: Calling compare_branch_vars for var 19
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 19
  % Initial guess is x2, Z0 = 27392987.2659616        , Z1 = 27344119.7919325        

DEBUG EVAL: Testing var 2 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=17, theta=0.179324, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 1 gives z=27361218.195027
  % 	x2 = 1,	Z1 = 27361218.1950265        
DEBUG EVAL: First branch cutoff check: z=27361218.195027, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 0
ITER 1: row=1, varin=34, theta=0.544816, up=1.000000
ITER 2: row=25, varin=31, theta=0.518216, up=1.000000
ITER 3: row=28, varin=49, theta=0.232419, up=1.000000
ITER 4: row=27, varin=67, theta=0.823487, up=1.000000
  % 	x2 = 0,	Z0 = 27563624.338335         
DEBUG EVAL: Second branch cutoff check: z=27563624.338335, best_z=INF, threshold=INF
  %   New best:  x2, Z = 27361218.1950265        
DEBUG EVAL: Testing var 15 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=12, varin=17, theta=0.396764, up=999999999999999983222784.000000
ITER 2: row=16, varin=12, theta=0.191625, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 15 = 0 gives z=27386059.362488
  % 	x15 = 0,	Z0 = 27386059.3624884        
DEBUG EVAL: First branch cutoff check: z=27386059.362488, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 15 = 1
ITER 1: row=12, varin=24, theta=0.274668, up=999999999999999983222784.000000
ITER 2: row=10, varin=11, theta=2.097057, up=999999999999999983222784.000000
ITER 3: row=11, varin=5, theta=2.046434, up=999999999999999983222784.000000
ITER 4: row=6, varin=7, theta=1.046434, up=999999999999999983222784.000000
ITER 5: row=1, varin=45, theta=0.088591, up=1.000000
ITER 6: row=8, varin=6, theta=0.132886, up=999999999999999983222784.000000
ITER 7: row=10, varin=32, theta=0.045701, up=1.000000
ITER 8: row=7, varin=78, theta=0.045701, up=1.000000
  % 	x15 = 1,	Z1 = 27556584.0656415        
DEBUG EVAL: Second branch cutoff check: z=27556584.065642, best_z=INF, threshold=INF
  %   New best:  x15, Z = 27386059.3624884        
DEBUG EVAL: Testing var 19 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=5, varin=52, theta=1.601070, up=1.000000
ITER 2: row=5, varin=57, theta=0.716607, up=1.000000
ITER 3: row=13, varin=52, theta=1.000000, up=1.000000
ITER 4: row=5, varin=58, theta=0.981465, up=1.000000
DEBUG EVAL: Branch var 19 = 1 gives z=27737733.868481
  % 	x19 = 1,	Z1 = 27737733.8684811        
DEBUG EVAL: First branch cutoff check: z=27737733.868481, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 19 = 0
ITER 1: row=5, varin=7, theta=2.046434, up=999999999999999983222784.000000
ITER 2: row=8, varin=5, theta=1.046434, up=999999999999999983222784.000000
ITER 3: row=16, varin=32, theta=0.045701, up=1.000000
  % 	x19 = 0,	Z0 = 27556584.0656416        
DEBUG EVAL: Second branch cutoff check: z=27556584.065642, best_z=INF, threshold=INF
  %   New best:  x19, Z = 27556584.0656416        
  % Best branch is x19, Z0 = 27556584.0656416        , Z1 = 27737733.8684811        

DEBUG CAREFUL: Final result - returning best.var = 19
DEBUG BB: Branching variable chosen: j=19
 % @NC   23   14	x19 = 0	27556584.065642
 % @NC   24   14	x19 = 1	27737733.868481
 %      14    12 27344119.7919               27368199.1056   x17 U     6     3
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ad4c49c780
% @LO 0.01  27.34411979193251340803 99.9000000000
% @LN 0.01  27.36819910556780044431 99.9000000000
% Resuming node 17 at  27.36819910556780044431
DEBUG CONSTRNT: LP rows=30, pool->nlprows=30, pool->npend=0
DEBUG CONSTRNT: Checking 30 LP rows (pool tracks 30, total LP rows 30)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=29, expected 29
 % @PAP adding 38 rows, 200 nz to LP
DEBUG BB: Processing node 17, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 17 LP 2 Solution, length = 27368199.105568, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.201715 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.201715 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.201715 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 1.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.193139 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.201715 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.201715 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.798285 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.798285 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.798285 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.798285 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=27368199.105568, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=27368199.105568, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 17 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 17
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=1.000000
DEBUG CAREFUL: Skipping var 2: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.201715
DEBUG CAREFUL: Adding var 5 to fractional list (xi=0.201715)
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.201715
DEBUG CAREFUL: Adding var 9 to fractional list (xi=0.201715)
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.201715
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.201715)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=1.000000
DEBUG CAREFUL: Skipping var 17: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.193139
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.193139)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.201715
DEBUG CAREFUL: Adding var 34 to fractional list (xi=0.201715)
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.201715
DEBUG CAREFUL: Adding var 36 to fractional list (xi=0.201715)
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 6 fractional variables

  %  Carefully choosing branching variable, nfrac = 6
DEBUG CAREFUL: Testing fvar[0] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 26
DEBUG CAREFUL: New best var: 26
DEBUG CAREFUL: Testing fvar[1] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[2] = var 9
DEBUG CAREFUL: Calling compare_branch_vars for var 9
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 9
DEBUG CAREFUL: Testing fvar[3] = var 34
DEBUG CAREFUL: Calling compare_branch_vars for var 34
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 34
DEBUG CAREFUL: Testing fvar[4] = var 5
DEBUG CAREFUL: Calling compare_branch_vars for var 5
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 5
DEBUG CAREFUL: Testing fvar[5] = var 36
DEBUG CAREFUL: Calling compare_branch_vars for var 36
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 36
  % Initial guess is x26, Z0 = 27368199.1055678        , Z1 = 27453979.0202176        

DEBUG EVAL: Testing var 26 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=22, varin=29, theta=0.606328, up=999999999999999983222784.000000
ITER 2: row=29, varin=38, theta=1.289764, up=999999999999999983222784.000000
ITER 3: row=25, varin=36, theta=1.036442, up=999999999999999983222784.000000
ITER 4: row=36, varin=55, theta=1.145382, up=1.000000
ITER 5: row=36, varin=30, theta=0.039054, up=999999999999999983222784.000000
ITER 6: row=11, varin=55, theta=1.000000, up=1.000000
ITER 7: row=30, varin=27, theta=0.301460, up=999999999999999983222784.000000
ITER 8: row=27, varin=26, theta=0.641935, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 26 = 1 gives z=27453979.020218
  % 	x26 = 1,	Z1 = 27453979.0202176        
DEBUG EVAL: First branch cutoff check: z=27453979.020218, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 26 = 0
ITER 1: row=22, varin=66, theta=0.199409, up=1.000000
  % 	x26 = 0,	Z0 = 27372222.4927696        
DEBUG EVAL: Second branch cutoff check: z=27372222.492770, best_z=INF, threshold=INF
  %   New best:  x26, Z = 27372222.4927696        
DEBUG EVAL: Testing var 10 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=20, varin=20, theta=0.246318, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 0 gives z=27389179.042275
  % 	x10 = 0,	Z0 = 27389179.0422752        
DEBUG EVAL: First branch cutoff check: z=27389179.042275, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 1
ITER 1: row=20, varin=29, theta=1.912899, up=999999999999999983222784.000000
ITER 2: row=29, varin=38, theta=8.528404, up=999999999999999983222784.000000
ITER 3: row=25, varin=36, theta=6.554599, up=999999999999999983222784.000000
ITER 4: row=36, varin=25, theta=1.049266, up=999999999999999983222784.000000
ITER 5: row=22, varin=41, theta=0.181043, up=1.000000
  % 	x10 = 1,	Z1 = 27533755.533865         
DEBUG EVAL: Second branch cutoff check: z=27533755.533865, best_z=INF, threshold=INF
  %   New best:  x10, Z = 27389179.0422752        
DEBUG EVAL: Testing var 9 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=10, varin=66, theta=25.664262, up=1.000000
ITER 2: row=10, varin=26, theta=0.376168, up=999999999999999983222784.000000
ITER 3: row=22, varin=66, theta=0.776007, up=1.000000
DEBUG EVAL: Branch var 9 = 0 gives z=27414189.784950
  % 	x9 = 0,	Z0 = 27414189.7849501        
DEBUG EVAL: First branch cutoff check: z=27414189.784950, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 9 = 1
ITER 1: row=10, varin=29, theta=1.912899, up=999999999999999983222784.000000
ITER 2: row=29, varin=38, theta=8.528404, up=999999999999999983222784.000000
ITER 3: row=25, varin=36, theta=6.554599, up=999999999999999983222784.000000
ITER 4: row=36, varin=41, theta=3.855834, up=1.000000
ITER 5: row=36, varin=24, theta=1.665571, up=999999999999999983222784.000000
ITER 6: row=25, varin=20, theta=0.976070, up=999999999999999983222784.000000
  % 	x9 = 1,	Z1 = 27625840.7306005        
DEBUG EVAL: Second branch cutoff check: z=27625840.730601, best_z=INF, threshold=INF
  %   New best:  x9, Z = 27414189.7849501        
DEBUG EVAL: Testing var 34 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=25, varin=29, theta=1.912899, up=999999999999999983222784.000000
ITER 2: row=29, varin=36, theta=7.425249, up=999999999999999983222784.000000
ITER 3: row=36, varin=26, theta=1.425285, up=999999999999999983222784.000000
ITER 4: row=21, varin=41, theta=1.330864, up=1.000000
ITER 5: row=21, varin=24, theta=0.192966, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 34 = 1 gives z=27549830.997528
  % 	x34 = 1,	Z1 = 27549830.9975279        
DEBUG EVAL: First branch cutoff check: z=27549830.997528, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 34 = 0
ITER 1: row=25, varin=38, theta=0.222546, up=999999999999999983222784.000000
  % 	x34 = 0,	Z0 = 27370584.8840484        
DEBUG EVAL: Second branch cutoff check: z=27370584.884048, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 5 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=66, theta=25.664262, up=1.000000
ITER 2: row=1, varin=24, theta=0.309210, up=999999999999999983222784.000000
ITER 3: row=22, varin=66, theta=0.634325, up=1.000000
DEBUG EVAL: Branch var 5 = 0 gives z=27415650.355043
  % 	x5 = 0,	Z0 = 27415650.3550429        
DEBUG EVAL: First branch cutoff check: z=27415650.355043, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 5 = 1
ITER 1: row=1, varin=29, theta=1.912899, up=999999999999999983222784.000000
ITER 2: row=29, varin=38, theta=8.528404, up=999999999999999983222784.000000
ITER 3: row=25, varin=36, theta=6.554599, up=999999999999999983222784.000000
ITER 4: row=36, varin=26, theta=1.232153, up=999999999999999983222784.000000
ITER 5: row=22, varin=41, theta=0.726486, up=1.000000
  % 	x5 = 1,	Z1 = 27529022.9232115        
DEBUG EVAL: Second branch cutoff check: z=27529022.923211, best_z=INF, threshold=INF
  %   New best:  x5, Z = 27415650.3550429        
DEBUG EVAL: Testing var 36 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=36, varin=29, theta=1.912899, up=999999999999999983222784.000000
ITER 2: row=29, varin=38, theta=8.528404, up=999999999999999983222784.000000
ITER 3: row=25, varin=26, theta=1.453978, up=999999999999999983222784.000000
ITER 4: row=20, varin=41, theta=1.420656, up=1.000000
ITER 5: row=20, varin=22, theta=0.245334, up=999999999999999983222784.000000
ITER 6: row=37, varin=25, theta=0.255583, up=999999999999999983222784.000000
ITER 7: row=10, varin=30, theta=0.454629, up=999999999999999983222784.000000
ITER 8: row=30, varin=27, theta=0.502071, up=999999999999999983222784.000000
ITER 9: row=27, varin=24, theta=0.300397, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 36 = 1 gives z=27629663.890570
  % 	x36 = 1,	Z1 = 27629663.8905699        
DEBUG EVAL: First branch cutoff check: z=27629663.890570, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 36 = 0
ITER 1: row=36, varin=36, theta=0.226014, up=999999999999999983222784.000000
  % 	x36 = 0,	Z0 = 27371820.505175         
DEBUG EVAL: Second branch cutoff check: z=27371820.505175, best_z=INF, threshold=INF
  % Best branch is x5, Z0 = 27415650.3550429        , Z1 = 27529022.9232115        

DEBUG CAREFUL: Final result - returning best.var = 5
DEBUG BB: Branching variable chosen: j=5
 % @NC   25   17	x5 = 0	27415650.355043
 % @NC   26   17	x5 = 1	27529022.923211
 %      17    13 27368199.1056               27395060.5498   x19 U    15     6
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ad4c48c600
% @LO 0.01  27.36819910556780044431 99.9000000000
% @LN 0.01  27.39506054977588789257 99.9000000000
% Resuming node 13 at  27.39506054977588789257
DEBUG CONSTRNT: LP rows=38, pool->nlprows=38, pool->npend=0
DEBUG CONSTRNT: Checking 38 LP rows (pool tracks 38, total LP rows 38)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=37, expected 37
 % @PAP adding 32 rows, 182 nz to LP
DEBUG BB: Processing node 13, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 13 LP 2 Solution, length = 27395060.549776, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.500000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.500000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.168382 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.168382 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.221079 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.168382 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.778921 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.500000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.831618 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.500000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.500000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.221079 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.221079 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.500000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.831618 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.831618 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.831618 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.221079 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.221079 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.831618 (terminal 19)
 % 7 fractional variables
DEBUG CG: LP optimal, z=27395060.549776, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=27395060.549776, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 3 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 13 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 13
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.500000
DEBUG CAREFUL: Adding var 0 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.500000
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=1.000000
DEBUG CAREFUL: Skipping var 2: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.168382
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.168382)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=1.000000
DEBUG CAREFUL: Skipping var 7: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.168382
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.168382)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.221079
DEBUG CAREFUL: Adding var 15 to fractional list (xi=0.221079)
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.168382
DEBUG CAREFUL: Adding var 18 to fractional list (xi=0.168382)
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.778921
DEBUG CAREFUL: Adding var 19 to fractional list (xi=0.778921)
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 7 fractional variables

  %  Carefully choosing branching variable, nfrac = 7
DEBUG CAREFUL: Testing fvar[0] = var 0
DEBUG CAREFUL: Calling compare_branch_vars for var 0
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 0
DEBUG CAREFUL: New best var: 0
DEBUG CAREFUL: Testing fvar[1] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 1
DEBUG CAREFUL: Testing fvar[2] = var 15
DEBUG CAREFUL: Calling compare_branch_vars for var 15
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 15
DEBUG CAREFUL: Testing fvar[3] = var 19
DEBUG CAREFUL: Calling compare_branch_vars for var 19
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 19
DEBUG CAREFUL: New best var: 19
DEBUG CAREFUL: Testing fvar[4] = var 18
DEBUG CAREFUL: Calling compare_branch_vars for var 18
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 18
DEBUG CAREFUL: New best var: 18
DEBUG CAREFUL: Testing fvar[5] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 3
DEBUG CAREFUL: Testing fvar[6] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
  % Initial guess is x18, Z0 = 27395060.5497759        , Z1 = 27566726.4895537        

DEBUG EVAL: Testing var 0 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=4, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=31, varin=3, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 0 = 1 gives z=27659962.063356
  % 	x0 = 1,	Z1 = 27659962.0633559        
DEBUG EVAL: First branch cutoff check: z=27659962.063356, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 0 = 0
ITER 1: row=1, varin=32, theta=1.000000, up=999999999999999983222784.000000
  % 	x0 = 0,	Z0 = 27401728.4188683        
DEBUG EVAL: Second branch cutoff check: z=27401728.418868, best_z=INF, threshold=INF
  %   New best:  x0, Z = 27401728.4188683        
DEBUG EVAL: Testing var 1 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=3, varin=30, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 1 = 0 gives z=27404025.962458
  % 	x1 = 0,	Z0 = 27404025.9624581        
DEBUG EVAL: First branch cutoff check: z=27404025.962458, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 1 = 1
ITER 1: row=3, varin=32, theta=1.000000, up=999999999999999983222784.000000
  % 	x1 = 1,	Z1 = 27401728.4188682        
DEBUG EVAL: Second branch cutoff check: z=27401728.418868, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 15 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=12, varin=45, theta=0.222751, up=1.000000
ITER 2: row=25, varin=12, theta=0.225130, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 15 = 0 gives z=27409025.430407
  % 	x15 = 0,	Z0 = 27409025.430407         
DEBUG EVAL: First branch cutoff check: z=27409025.430407, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 15 = 1
ITER 1: row=12, varin=32, theta=2.636017, up=999999999999999983222784.000000
ITER 2: row=3, varin=30, theta=2.844311, up=999999999999999983222784.000000
ITER 3: row=1, varin=10, theta=1270654.500000, up=999999999999999983222784.000000
ITER 4: row=23, varin=29, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=25, varin=21, theta=0.333333, up=999999999999999983222784.000000
ITER 6: row=10, varin=26, theta=0.500000, up=999999999999999983222784.000000
ITER 7: row=19, varin=28, theta=0.333333, up=999999999999999983222784.000000
ITER 8: row=21, varin=43, theta=1.000000, up=1.000000
  % 	x15 = 1,	Z1 = 27493992.123692         
DEBUG EVAL: Second branch cutoff check: z=27493992.123692, best_z=INF, threshold=INF
  %   New best:  x15, Z = 27409025.430407         
DEBUG EVAL: Testing var 19 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=5, varin=30, theta=1.761188, up=999999999999999983222784.000000
ITER 2: row=3, varin=59, theta=0.328286, up=1.000000
DEBUG EVAL: Branch var 19 = 1 gives z=27425418.506995
  % 	x19 = 1,	Z1 = 27425418.5069951        
DEBUG EVAL: First branch cutoff check: z=27425418.506995, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 19 = 0
ITER 1: row=5, varin=32, theta=2.636017, up=999999999999999983222784.000000
ITER 2: row=3, varin=30, theta=2.844311, up=999999999999999983222784.000000
ITER 3: row=1, varin=10, theta=1270654.500000, up=999999999999999983222784.000000
ITER 4: row=23, varin=29, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=25, varin=21, theta=0.333333, up=999999999999999983222784.000000
ITER 6: row=10, varin=26, theta=0.500000, up=999999999999999983222784.000000
ITER 7: row=19, varin=28, theta=0.333333, up=999999999999999983222784.000000
ITER 8: row=21, varin=43, theta=1.000000, up=1.000000
  % 	x19 = 0,	Z0 = 27493992.123692         
DEBUG EVAL: Second branch cutoff check: z=27493992.123692, best_z=INF, threshold=INF
  %   New best:  x19, Z = 27425418.5069951        
DEBUG EVAL: Testing var 18 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=21, varin=30, theta=4.416637, up=999999999999999983222784.000000
ITER 2: row=3, varin=32, theta=2.625237, up=999999999999999983222784.000000
ITER 3: row=1, varin=23, theta=2.770060, up=999999999999999983222784.000000
ITER 4: row=10, varin=27, theta=1.891042, up=999999999999999983222784.000000
ITER 5: row=19, varin=29, theta=1.172984, up=999999999999999983222784.000000
ITER 6: row=25, varin=35, theta=1.321845, up=1.000000
ITER 7: row=25, varin=18, theta=0.142044, up=999999999999999983222784.000000
ITER 8: row=18, varin=45, theta=0.303048, up=1.000000
ITER 9: row=12, varin=24, theta=0.078583, up=999999999999999983222784.000000
ITER 10: row=24, varin=11, theta=0.090760, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 18 = 1 gives z=27821716.714362
  % 	x18 = 1,	Z1 = 27821716.7143623        
DEBUG EVAL: First branch cutoff check: z=27821716.714362, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 18 = 0
ITER 1: row=21, varin=45, theta=14.947684, up=1.000000
ITER 2: row=21, varin=26, theta=0.731164, up=999999999999999983222784.000000
ITER 3: row=25, varin=45, theta=1.000000, up=1.000000
  % 	x18 = 0,	Z0 = 27465078.0863575        
DEBUG EVAL: Second branch cutoff check: z=27465078.086358, best_z=INF, threshold=INF
  %   New best:  x18, Z = 27465078.0863575        
DEBUG EVAL: Testing var 3 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=10, varin=30, theta=4.416637, up=999999999999999983222784.000000
ITER 2: row=3, varin=32, theta=2.625237, up=999999999999999983222784.000000
ITER 3: row=1, varin=26, theta=0.819405, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 3 = 1 gives z=27477244.085137
  % 	x3 = 1,	Z1 = 27477244.0851369        
DEBUG EVAL: First branch cutoff check: z=27477244.085137, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 3 = 0
ITER 1: row=10, varin=23, theta=0.219317, up=999999999999999983222784.000000
  % 	x3 = 0,	Z0 = 27405243.3112322        
DEBUG EVAL: Second branch cutoff check: z=27405243.311232, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 10 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=19, varin=27, theta=0.215153, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 0 gives z=27404570.423520
  % 	x10 = 0,	Z0 = 27404570.4235198        
DEBUG EVAL: First branch cutoff check: z=27404570.423520, best_z=INF, threshold=INF
  % Best branch is x18, Z0 = 27465078.0863575        , Z1 = 27821716.7143623        

DEBUG CAREFUL: Final result - returning best.var = 18
DEBUG BB: Branching variable chosen: j=18
 % @NC   27   13	x18 = 0	27465078.086358
 % @NC   28   13	x18 = 1	27821716.714362
 %      13    14 27395060.5498               27415650.3550   x17 D     6     3
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ad4c4a4590
% @LO 0.01  27.39506054977588789257 99.9000000000
% @LN 0.01  27.41565035504292779933 99.9000000000
% Resuming node 25 at  27.41565035504292779933
DEBUG CONSTRNT: LP rows=32, pool->nlprows=32, pool->npend=0
DEBUG CONSTRNT: Checking 32 LP rows (pool tracks 32, total LP rows 32)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 142
DEBUG CONSTRNT: Pool row 142 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=31, expected 31
 % @PAP adding 38 rows, 200 nz to LP
DEBUG BB: Processing node 25, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=66, theta=25.664262, up=1.000000
ITER 2: row=1, varin=24, theta=0.309210, up=999999999999999983222784.000000
ITER 3: row=22, varin=66, theta=0.634325, up=1.000000
LP PHASE: Switching to primal (iter=3)
ITER 4: row=20, varin=65, theta=0.356506, up=1.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=38)
DEBUG SOLUTION: LP solution array indices: FST[39-78], not_covered[79-98]
DEBUG SOLUTION: lp->best_solution[0] = 27408851.507519
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 38 rows, 60 cols, 260 nonzeros, 2 slack, 36 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 5 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=39, varin=68, theta=0.036118, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=40)
DEBUG SOLUTION: LP solution array indices: FST[41-80], not_covered[81-100]
DEBUG SOLUTION: lp->best_solution[0] = 27409523.036014
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 40 rows, 60 cols, 265 nonzeros, 2 slack, 38 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=41, varin=71, theta=0.037148, up=1.000000
ITER 2: row=35, varin=63, theta=0.031666, up=1.000000
ITER 3: row=14, varin=44, theta=0.020405, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=41)
DEBUG SOLUTION: LP solution array indices: FST[42-81], not_covered[82-101]
DEBUG SOLUTION: lp->best_solution[0] = 27410631.659725
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 41 rows, 60 cols, 267 nonzeros, 2 slack, 39 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=42, varin=68, theta=0.034264, up=1.000000
ITER 2: row=12, varin=66, theta=0.033004, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 27411977.280242
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 42 rows, 60 cols, 269 nonzeros, 2 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 13 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=43, varin=3, theta=0.010088, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=46)
DEBUG SOLUTION: LP solution array indices: FST[47-86], not_covered[87-106]
DEBUG SOLUTION: lp->best_solution[0] = 27412715.668356
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.989912
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 46 rows, 60 cols, 282 nonzeros, 4 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 3 rows, 7 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=48, varin=74, theta=0.034234, up=1.000000
ITER 2: row=31, varin=82, theta=0.048541, up=1.000000
ITER 3: row=33, varin=91, theta=0.030241, up=1.000000
ITER 4: row=46, varin=72, theta=0.049309, up=1.000000
ITER 5: row=27, varin=78, theta=0.036305, up=1.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 27423447.759674
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 49 rows, 60 cols, 289 nonzeros, 2 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 1 rows, 5 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=48, varin=2, theta=0.021306, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 27424096.387874
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 0.978694
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 48 rows, 60 cols, 290 nonzeros, 2 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=47, varin=64, theta=0.030784, up=1.000000
ITER 2: row=10, varin=52, theta=0.057825, up=1.000000
ITER 3: row=26, varin=79, theta=0.046906, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 27430193.696895
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 47 rows, 60 cols, 288 nonzeros, 0 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=48, varin=14, theta=0.028689, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 27431124.933707
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.971311
  % @PL 48 rows, 60 cols, 290 nonzeros, 1 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 25 LP 1 Solution, length = 27431124.933707, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.971311 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.323770 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.323770 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 1.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.323770 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.028689 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.028689 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.323770 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.676230 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.676230 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.028689 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.676230 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 7 fractional variables
DEBUG CG: LP optimal, z=27431124.933707, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 25 at  27.43112493370701088224
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ad4c4ad660
% @LO 0.01  27.41565035504292779933 99.9000000000
% @LN 0.01  27.41759482383566393082 99.9000000000
% Resuming node 21 at  27.41759482383566393082
DEBUG CONSTRNT: LP rows=47, pool->nlprows=47, pool->npend=0
DEBUG CONSTRNT: Checking 47 LP rows (pool tracks 47, total LP rows 47)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 133
DEBUG CONSTRNT: Pool row 133 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 134
DEBUG CONSTRNT: Pool row 134 has lprow=46, expected 46
 % @PAP adding 22 rows, 151 nz to LP
DEBUG BB: Processing node 21, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=6, varin=37, theta=2.269922, up=1.000000
ITER 2: row=6, varin=12, theta=2.100676, up=999999999999999983222784.000000
ITER 3: row=18, varin=2, theta=2.201353, up=999999999999999983222784.000000
ITER 4: row=2, varin=19, theta=2.201353, up=999999999999999983222784.000000
ITER 5: row=21, varin=15, theta=2.201353, up=999999999999999983222784.000000
ITER 6: row=15, varin=18, theta=1.201353, up=999999999999999983222784.000000
ITER 7: row=19, varin=17, theta=1.201353, up=999999999999999983222784.000000
ITER 8: row=7, varin=37, theta=1.000000, up=1.000000
ITER 9: row=1, varin=24, theta=0.742944, up=1.000000
LP PHASE: Switching to primal (iter=9)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=22)
DEBUG SOLUTION: LP solution array indices: FST[23-62], not_covered[63-82]
DEBUG SOLUTION: lp->best_solution[0] = 27417594.823836
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 22 rows, 60 cols, 211 nonzeros, 3 slack, 19 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 6 rows, 36 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=22, varin=17, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=1, varin=69, theta=1.000000, up=1.000000
ITER 3: row=2, varin=77, theta=1.000000, up=1.000000
ITER 4: row=24, varin=18, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=2, varin=79, theta=1.000000, up=1.000000
ITER 6: row=12, varin=83, theta=1.000000, up=1.000000
ITER 7: row=20, varin=70, theta=0.742944, up=1.000000
ITER 8: row=12, varin=84, theta=0.742944, up=1.000000
LP PHASE: Switching to primal (iter=8)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=25)
DEBUG SOLUTION: LP solution array indices: FST[26-65], not_covered[66-85]
DEBUG SOLUTION: lp->best_solution[0] = 27417594.823836
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 25 rows, 60 cols, 241 nonzeros, 6 slack, 19 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 3 rows, 9 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=26, varin=86, theta=1.000000, up=1.000000
ITER 2: row=28, varin=45, theta=0.224518, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=28)
DEBUG SOLUTION: LP solution array indices: FST[29-68], not_covered[69-88]
DEBUG SOLUTION: lp->best_solution[0] = 27421749.128809
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 28 rows, 60 cols, 250 nonzeros, 7 slack, 21 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 7 slack rows
  % @PAP adding 4 rows, 19 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=22, varin=68, theta=0.257716, up=1.000000
ITER 2: row=24, varin=77, theta=0.302435, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=25)
DEBUG SOLUTION: LP solution array indices: FST[26-65], not_covered[66-85]
DEBUG SOLUTION: lp->best_solution[0] = 27423190.835625
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 25 rows, 60 cols, 228 nonzeros, 2 slack, 23 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % Node 21 LP 1 Solution, length = 27423190.835625, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.209740 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.302435 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.697565 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.302435 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 1.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.697565 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.790260 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.790260 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.302435 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.302435 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.790260 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.697565 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.302435 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.302435 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=27423190.835625, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
 % @LO 0.02  27.41759482383566393082 99.9000000000
 % @LN 0.02  27.42319083562505710461 99.9000000000
DEBUG CG: Second cutoff check: z=27423190.835625, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 3 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 21 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 21
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.209740
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.209740)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=1.000000
DEBUG CAREFUL: Skipping var 2: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.302435
DEBUG CAREFUL: Adding var 12 to fractional list (xi=0.302435)
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.697565
DEBUG CAREFUL: Adding var 15 to fractional list (xi=0.697565)
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.302435
DEBUG CAREFUL: Adding var 16 to fractional list (xi=0.302435)
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=1.000000
DEBUG CAREFUL: Skipping var 20: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 4 fractional variables

  %  Carefully choosing branching variable, nfrac = 4
DEBUG CAREFUL: Testing fvar[0] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 1
DEBUG CAREFUL: New best var: 1
DEBUG CAREFUL: Testing fvar[1] = var 16
DEBUG CAREFUL: Calling compare_branch_vars for var 16
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 16
DEBUG CAREFUL: New best var: 16
DEBUG CAREFUL: Testing fvar[2] = var 15
DEBUG CAREFUL: Calling compare_branch_vars for var 15
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 15
DEBUG CAREFUL: Testing fvar[3] = var 12
DEBUG CAREFUL: Calling compare_branch_vars for var 12
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 12
  % Initial guess is x16, Z0 = 27423190.8356251        , Z1 = 27455780.8854585        

DEBUG EVAL: Testing var 1 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=21, theta=0.685601, up=999999999999999983222784.000000
ITER 2: row=23, varin=3, theta=0.264201, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 1 = 0 gives z=27425392.071485
  % 	x1 = 0,	Z0 = 27425392.0714846        
DEBUG EVAL: First branch cutoff check: z=27425392.071485, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 1 = 1
ITER 1: row=1, varin=8, theta=0.719827, up=999999999999999983222784.000000
ITER 2: row=8, varin=6, theta=0.326585, up=999999999999999983222784.000000
  % 	x1 = 1,	Z1 = 27480865.123558         
DEBUG EVAL: Second branch cutoff check: z=27480865.123558, best_z=INF, threshold=INF
  %   New best:  x1, Z = 27425392.0714846        
DEBUG EVAL: Testing var 16 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=7, varin=2, theta=4.020093, up=999999999999999983222784.000000
ITER 2: row=2, varin=10, theta=4.020093, up=999999999999999983222784.000000
ITER 3: row=20, varin=3, theta=2.000000, up=999999999999999983222784.000000
ITER 4: row=1, varin=26, theta=1.036445, up=1.000000
ITER 5: row=1, varin=7, theta=0.055711, up=999999999999999983222784.000000
ITER 6: row=5, varin=6, theta=0.038624, up=999999999999999983222784.000000
ITER 7: row=10, varin=17, theta=0.115871, up=999999999999999983222784.000000
ITER 8: row=18, varin=18, theta=0.038624, up=999999999999999983222784.000000
ITER 9: row=19, varin=19, theta=0.038624, up=999999999999999983222784.000000
ITER 10: row=21, varin=20, theta=0.038624, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 16 = 1 gives z=27483342.897298
  % 	x16 = 1,	Z1 = 27483342.8972979        
DEBUG EVAL: First branch cutoff check: z=27483342.897298, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 16 = 0
ITER 1: row=7, varin=8, theta=0.416842, up=999999999999999983222784.000000
  % 	x16 = 0,	Z0 = 27453887.2336745        
DEBUG EVAL: Second branch cutoff check: z=27453887.233674, best_z=INF, threshold=INF
  %   New best:  x16, Z = 27453887.2336745        
DEBUG EVAL: Testing var 15 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=6, varin=31, theta=0.447455, up=1.000000
ITER 2: row=10, varin=3, theta=0.204677, up=999999999999999983222784.000000
ITER 3: row=17, varin=8, theta=0.129400, up=999999999999999983222784.000000
ITER 4: row=8, varin=22, theta=0.322777, up=999999999999999983222784.000000
ITER 5: row=22, varin=34, theta=0.470343, up=1.000000
DEBUG EVAL: Branch var 15 = 1 gives z=27493760.412376
  % 	x15 = 1,	Z1 = 27493760.412376         
DEBUG EVAL: First branch cutoff check: z=27493760.412376, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 15 = 0
ITER 1: row=6, varin=2, theta=4.020093, up=999999999999999983222784.000000
ITER 2: row=2, varin=10, theta=4.020093, up=999999999999999983222784.000000
ITER 3: row=20, varin=3, theta=2.000000, up=999999999999999983222784.000000
ITER 4: row=1, varin=26, theta=1.036445, up=1.000000
ITER 5: row=1, varin=6, theta=0.013326, up=999999999999999983222784.000000
  % 	x15 = 0,	Z0 = 27475885.6776088        
DEBUG EVAL: Second branch cutoff check: z=27475885.677609, best_z=INF, threshold=INF
  %   New best:  x15, Z = 27475885.6776088        
DEBUG EVAL: Testing var 12 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=3, varin=8, theta=0.416842, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 12 = 0 gives z=27453887.233674
  % 	x12 = 0,	Z0 = 27453887.2336745        
DEBUG EVAL: First branch cutoff check: z=27453887.233674, best_z=INF, threshold=INF
  % Best branch is x15, Z0 = 27475885.6776088        , Z1 = 27493760.412376         

DEBUG CAREFUL: Final result - returning best.var = 15
DEBUG BB: Branching variable chosen: j=15
 % @NC   29   21	x15 = 0	27475885.677609
 % @NC   30   21	x15 = 1	27493760.412376
 %      21    15 27423190.8356               27431124.9337   x13 D     4     3
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ad4c4a4590
% @LO 0.02  27.42319083562505710461 99.9000000000
% @LN 0.02  27.43112493370701088224 99.9000000000
% Resuming node 25 at  27.43112493370701088224
DEBUG CONSTRNT: LP rows=23, pool->nlprows=23, pool->npend=0
DEBUG CONSTRNT: Checking 23 LP rows (pool tracks 23, total LP rows 23)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 82
DEBUG CONSTRNT: Pool row 82 has lprow=22, expected 22
 % @PAP adding 47 rows, 228 nz to LP
DEBUG BB: Processing node 25, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 25 LP 2 Solution, length = 27431124.933707, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.971311 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.323770 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.323770 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 1.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.323770 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.028689 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.028689 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.323770 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.676230 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.676230 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.028689 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.676230 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 7 fractional variables
DEBUG CG: LP optimal, z=27431124.933707, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=27431124.933707, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 25 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 25
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.971311
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.971311)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.323770
DEBUG CAREFUL: Adding var 9 to fractional list (xi=0.323770)
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.323770
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.323770)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=1.000000
DEBUG CAREFUL: Skipping var 17: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.323770
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.323770)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.028689
DEBUG CAREFUL: Adding var 27 to fractional list (xi=0.028689)
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.028689
DEBUG CAREFUL: Adding var 31 to fractional list (xi=0.028689)
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.323770
DEBUG CAREFUL: Adding var 34 to fractional list (xi=0.323770)
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 7 fractional variables

  %  Carefully choosing branching variable, nfrac = 7
DEBUG CAREFUL: Testing fvar[0] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 2
DEBUG CAREFUL: New best var: 2
DEBUG CAREFUL: Testing fvar[1] = var 27
DEBUG CAREFUL: Calling compare_branch_vars for var 27
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 27
DEBUG CAREFUL: Testing fvar[2] = var 31
DEBUG CAREFUL: Calling compare_branch_vars for var 31
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 31
DEBUG CAREFUL: New best var: 31
DEBUG CAREFUL: Testing fvar[3] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[4] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
DEBUG CAREFUL: Testing fvar[5] = var 9
DEBUG CAREFUL: Calling compare_branch_vars for var 9
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 9
DEBUG CAREFUL: Testing fvar[6] = var 34
DEBUG CAREFUL: Calling compare_branch_vars for var 34
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 34
  % Initial guess is x31, Z0 = 27431124.933707         , Z1 = 27896876.6706039        

DEBUG EVAL: Testing var 2 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=9, varin=78, theta=0.103177, up=1.000000
DEBUG EVAL: Branch var 2 = 1 gives z=27454427.750340
  % 	x2 = 1,	Z1 = 27454427.7503395        
DEBUG EVAL: First branch cutoff check: z=27454427.750340, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 0
ITER 1: row=9, varin=47, theta=1.588087, up=999999999999999983222784.000000
ITER 2: row=34, varin=25, theta=0.724997, up=999999999999999983222784.000000
ITER 3: row=25, varin=62, theta=0.385955, up=1.000000
ITER 4: row=10, varin=46, theta=0.801384, up=999999999999999983222784.000000
ITER 5: row=29, varin=45, theta=0.455183, up=999999999999999983222784.000000
ITER 6: row=45, varin=51, theta=0.618227, up=1.000000
ITER 7: row=24, varin=41, theta=0.559706, up=999999999999999983222784.000000
ITER 8: row=41, varin=43, theta=0.632403, up=999999999999999983222784.000000
ITER 9: row=43, varin=38, theta=0.413797, up=999999999999999983222784.000000
ITER 10: row=38, varin=11, theta=0.429597, up=999999999999999983222784.000000
  % 	x2 = 0,	Z0 = 27721816.4496779        
DEBUG EVAL: Second branch cutoff check: z=27721816.449678, best_z=INF, threshold=INF
  %   New best:  x2, Z = 27454427.7503395        
DEBUG EVAL: Testing var 27 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=27, varin=47, theta=1.588087, up=999999999999999983222784.000000
ITER 2: row=34, varin=25, theta=0.724997, up=999999999999999983222784.000000
ITER 3: row=25, varin=62, theta=0.385955, up=1.000000
ITER 4: row=10, varin=46, theta=0.801384, up=999999999999999983222784.000000
ITER 5: row=29, varin=45, theta=0.455183, up=999999999999999983222784.000000
ITER 6: row=45, varin=51, theta=0.618227, up=1.000000
ITER 7: row=24, varin=41, theta=0.559706, up=999999999999999983222784.000000
ITER 8: row=41, varin=43, theta=0.632403, up=999999999999999983222784.000000
ITER 9: row=43, varin=38, theta=0.413797, up=999999999999999983222784.000000
ITER 10: row=38, varin=11, theta=0.429597, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 27 = 1 gives z=27730235.870614
  % 	x27 = 1,	Z1 = 27730235.8706143        
DEBUG EVAL: First branch cutoff check: z=27730235.870614, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 27 = 0
ITER 1: row=27, varin=78, theta=0.103177, up=1.000000
  % 	x27 = 0,	Z0 = 27454427.7503395        
DEBUG EVAL: Second branch cutoff check: z=27454427.750340, best_z=INF, threshold=INF
  %   New best:  x27, Z = 27454427.7503395        
DEBUG EVAL: Testing var 31 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=34, varin=25, theta=1.957803, up=999999999999999983222784.000000
ITER 2: row=25, varin=62, theta=1.042245, up=1.000000
ITER 3: row=25, varin=46, theta=0.087716, up=999999999999999983222784.000000
ITER 4: row=10, varin=62, theta=1.000000, up=1.000000
ITER 5: row=29, varin=45, theta=1.229189, up=999999999999999983222784.000000
ITER 6: row=45, varin=51, theta=1.669479, up=1.000000
ITER 7: row=45, varin=41, theta=0.606106, up=999999999999999983222784.000000
ITER 8: row=34, varin=51, theta=1.000000, up=1.000000
ITER 9: row=41, varin=43, theta=1.707760, up=999999999999999983222784.000000
ITER 10: row=43, varin=24, theta=1.088748, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 31 = 1 gives z=28166647.185195
  % 	x31 = 1,	Z1 = 28166647.1851951        
DEBUG EVAL: First branch cutoff check: z=28166647.185195, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 31 = 0
ITER 1: row=34, varin=47, theta=0.073868, up=999999999999999983222784.000000
  % 	x31 = 0,	Z0 = 27432591.4655218        
DEBUG EVAL: Second branch cutoff check: z=27432591.465522, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 10 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=18, varin=47, theta=5.223511, up=999999999999999983222784.000000
ITER 2: row=27, varin=25, theta=1.187637, up=999999999999999983222784.000000
ITER 3: row=25, varin=22, theta=0.756712, up=999999999999999983222784.000000
ITER 4: row=34, varin=75, theta=0.714872, up=1.000000
DEBUG EVAL: Branch var 10 = 1 gives z=27612962.881838
  % 	x10 = 1,	Z1 = 27612962.8818379        
DEBUG EVAL: First branch cutoff check: z=27612962.881838, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 0
ITER 1: row=18, varin=104, theta=0.683974, up=1.000000
ITER 2: row=30, varin=78, theta=1.107573, up=1.000000
ITER 3: row=30, varin=81, theta=0.129462, up=1.000000
ITER 4: row=27, varin=18, theta=0.349851, up=999999999999999983222784.000000
ITER 5: row=30, varin=78, theta=0.374874, up=1.000000
  % 	x10 = 0,	Z0 = 27817239.8663727        
DEBUG EVAL: Second branch cutoff check: z=27817239.866373, best_z=INF, threshold=INF
  %   New best:  x10, Z = 27612962.8818379        
DEBUG EVAL: Testing var 26 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=22, varin=47, theta=5.223511, up=999999999999999983222784.000000
ITER 2: row=27, varin=25, theta=1.187637, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 26 = 1 gives z=27579712.508622
  % 	x26 = 1,	Z1 = 27579712.5086222        
DEBUG EVAL: First branch cutoff check: z=27579712.508622, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 9 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=15, varin=47, theta=5.223511, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 9 = 1 gives z=27534829.718258
  % 	x9 = 1,	Z1 = 27625840.7306005        
DEBUG EVAL: First branch cutoff check: z=27625840.730601, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 9 = 0
ITER 1: row=15, varin=22, theta=0.897660, up=999999999999999983222784.000000
  % 	x9 = 0,	Z0 = 27589272.0997453        
DEBUG EVAL: Second branch cutoff check: z=27589272.099745, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 34 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=33, varin=47, theta=5.223511, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 34 = 1 gives z=27534829.718258
  % 	x34 = 1,	Z1 = 27549830.9975279        
DEBUG EVAL: First branch cutoff check: z=27549830.997528, best_z=INF, threshold=INF
  % Best branch is x10, Z0 = 27817239.8663727        , Z1 = 27612962.8818379        

DEBUG CAREFUL: Final result - returning best.var = 10
DEBUG BB: Branching variable chosen: j=10
 % @NC   31   25	x10 = 1	27612962.881838
 % @NC   32   25	x10 = 0	27817239.866373
 %      25    16 27431124.9337               27447170.4768    x5 D    17     7
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ad4c4a0510
% @LO 0.02  27.43112493370701088224 99.9000000000
% @LN 0.02  27.44717047676190802008 99.9000000000
% Resuming node 19 at  27.44717047676190802008
DEBUG CONSTRNT: LP rows=47, pool->nlprows=47, pool->npend=0
DEBUG CONSTRNT: Checking 47 LP rows (pool tracks 47, total LP rows 47)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 133
DEBUG CONSTRNT: Pool row 133 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 134
DEBUG CONSTRNT: Pool row 134 has lprow=46, expected 46
 % @PAP adding 28 rows, 168 nz to LP
DEBUG BB: Processing node 19, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=4, varin=39, theta=1.647049, up=1.000000
ITER 2: row=4, varin=38, theta=1.086839, up=1.000000
ITER 3: row=4, varin=32, theta=0.042934, up=1.000000
ITER 4: row=23, varin=39, theta=1.000000, up=1.000000
ITER 5: row=1, varin=31, theta=1.820398, up=1.000000
ITER 6: row=1, varin=38, theta=0.859354, up=1.000000
LP PHASE: Switching to primal (iter=6)
ITER 7: row=13, varin=34, theta=0.000000, up=1.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=28)
DEBUG SOLUTION: LP solution array indices: FST[29-68], not_covered[69-88]
DEBUG SOLUTION: lp->best_solution[0] = 27447170.476762
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 28 rows, 60 cols, 228 nonzeros, 2 slack, 26 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 9 rows, 41 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=29, varin=38, theta=0.265460, up=1.000000
ITER 2: row=33, varin=51, theta=0.813176, up=1.000000
ITER 3: row=31, varin=36, theta=1.066500, up=1.000000
ITER 4: row=31, varin=62, theta=0.074417, up=1.000000
ITER 5: row=28, varin=29, theta=7.000000, up=999999999999999983222784.000000
ITER 6: row=22, varin=57, theta=0.806317, up=1.000000
ITER 7: row=14, varin=63, theta=0.953579, up=1.000000
ITER 8: row=10, varin=25, theta=0.253829, up=999999999999999983222784.000000
ITER 9: row=26, varin=36, theta=1.157066, up=1.000000
ITER 10: row=26, varin=23, theta=0.096237, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=19)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=35)
DEBUG SOLUTION: LP solution array indices: FST[36-75], not_covered[76-95]
DEBUG SOLUTION: lp->best_solution[0] = 27729334.455803
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 35 rows, 60 cols, 265 nonzeros, 3 slack, 32 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 7 rows, 19 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=33, varin=63, theta=1.000000, up=1.000000
ITER 2: row=39, varin=64, theta=1.081965, up=1.000000
ITER 3: row=39, varin=13, theta=0.091431, up=999999999999999983222784.000000
ITER 4: row=37, varin=64, theta=1.000000, up=1.000000
ITER 5: row=12, varin=40, theta=1.713256, up=1.000000
ITER 6: row=12, varin=68, theta=0.506487, up=1.000000
ITER 7: row=35, varin=40, theta=1.167915, up=1.000000
ITER 8: row=35, varin=67, theta=0.218924, up=1.000000
ITER 9: row=38, varin=40, theta=0.215585, up=1.000000
ITER 10: row=12, varin=94, theta=1.553788, up=1.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=39)
DEBUG SOLUTION: LP solution array indices: FST[40-79], not_covered[80-99]
DEBUG SOLUTION: lp->best_solution[0] = 999999999999999983222784.000000
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 39 rows, 60 cols, 270 nonzeros, 3 slack, 36 tight.
  % Node 19 LP 1 Solution, length = 999999999999999983222784.000000, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 1.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.988530 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 1.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 1.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 1.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.011470 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.011470 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
DEBUG BB: compute_good_lower_bound returned status=1
DEBUG BB: Node 19 is INFEASIBLE
 %      19    15    infeasible               27465078.0864   x19 U    16     6
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ad4c49c780
% @LO 0.02  27.44717047676190802008 99.9000000000
% @LN 0.02  27.46507808635753278281 99.9000000000
% Resuming node 27 at  27.46507808635753278281
DEBUG CONSTRNT: LP rows=39, pool->nlprows=39, pool->npend=0
DEBUG CONSTRNT: Checking 39 LP rows (pool tracks 39, total LP rows 39)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 91
DEBUG CONSTRNT: Pool row 91 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 82
DEBUG CONSTRNT: Pool row 82 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 85
DEBUG CONSTRNT: Pool row 85 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 133
DEBUG CONSTRNT: Pool row 133 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 143
DEBUG CONSTRNT: Pool row 143 has lprow=38, expected 38
 % @PAP adding 32 rows, 182 nz to LP
DEBUG BB: Processing node 27, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=21, varin=45, theta=14.947684, up=1.000000
ITER 2: row=21, varin=26, theta=0.731164, up=999999999999999983222784.000000
ITER 3: row=25, varin=45, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=3)
ITER 4: row=11, varin=69, theta=0.000000, up=1.000000
ITER 5: row=10, varin=10, theta=295052.333333, up=999999999999999983222784.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=32)
DEBUG SOLUTION: LP solution array indices: FST[33-72], not_covered[73-92]
DEBUG SOLUTION: lp->best_solution[0] = 27399616.075067
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1504947.666667
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 32 rows, 60 cols, 242 nonzeros, 1 slack, 31 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 27 LP 1 Solution, length = 27399616.075067, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.500000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.500000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.333333 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.666667 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.500000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.500000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.500000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.333333 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.333333 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.500000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.333333 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.333333 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=27399616.075067, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=27399616.075067, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 3 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 27 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 27
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.500000
DEBUG CAREFUL: Adding var 0 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.500000
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=1.000000
DEBUG CAREFUL: Skipping var 2: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=1.000000
DEBUG CAREFUL: Skipping var 7: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.333333
DEBUG CAREFUL: Adding var 15 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.666667
DEBUG CAREFUL: Adding var 19 to fractional list (xi=0.666667)
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 4 fractional variables

  %  Carefully choosing branching variable, nfrac = 4
DEBUG CAREFUL: Testing fvar[0] = var 15
DEBUG CAREFUL: Calling compare_branch_vars for var 15
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 15
DEBUG CAREFUL: New best var: 15
DEBUG CAREFUL: Testing fvar[1] = var 0
DEBUG CAREFUL: Calling compare_branch_vars for var 0
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 0
DEBUG CAREFUL: Testing fvar[2] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 1
DEBUG CAREFUL: Testing fvar[3] = var 19
DEBUG CAREFUL: Calling compare_branch_vars for var 19
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 19
DEBUG CAREFUL: New best var: 19
  % Initial guess is x19, Z0 = 27493992.123692         , Z1 = 27425418.5069951        

DEBUG EVAL: Testing var 15 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=12, varin=45, theta=0.333333, up=1.000000
ITER 2: row=25, varin=12, theta=0.333333, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 15 = 0 gives z=27420049.416793
  % 	x15 = 0,	Z0 = 27420049.4167927        
DEBUG EVAL: First branch cutoff check: z=27420049.416793, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 0 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=32, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 0 = 0 gives z=27407819.630135
  % 	x0 = 0,	Z0 = 27407819.6301351        
DEBUG EVAL: First branch cutoff check: z=27407819.630135, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 1 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=3, varin=32, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 1 = 1 gives z=27407819.630135
  % 	x1 = 1,	Z1 = 27407819.6301351        
DEBUG EVAL: First branch cutoff check: z=27407819.630135, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 19 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=5, varin=59, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 19 = 1 gives z=27463064.838935
  % 	x19 = 1,	Z1 = 27463064.8389354        
DEBUG EVAL: First branch cutoff check: z=27463064.838935, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 19 = 0
ITER 1: row=5, varin=32, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=1, varin=29, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=25, varin=28, theta=1.000000, up=999999999999999983222784.000000
  % 	x19 = 0,	Z0 = 27493992.123692         
DEBUG EVAL: Second branch cutoff check: z=27493992.123692, best_z=INF, threshold=INF
  %   New best:  x19, Z = 27463064.8389354        
  % Best branch is x19, Z0 = 27493992.123692         , Z1 = 27463064.8389354        

DEBUG CAREFUL: Final result - returning best.var = 19
DEBUG BB: Branching variable chosen: j=19
 % @NC   33   27	x19 = 1	27463064.838935
 % @NC   34   27	x19 = 0	27493992.123692
 %      27    16 27399616.0751               27463064.8389   x18 D    13     4
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ad4c4a0510
% Resuming node 33 at  27.46306483893539862606
DEBUG CONSTRNT: LP rows=32, pool->nlprows=32, pool->npend=0
DEBUG CONSTRNT: Checking 32 LP rows (pool tracks 32, total LP rows 32)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 142
DEBUG CONSTRNT: Pool row 142 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=31, expected 31
 % @PAP adding 32 rows, 182 nz to LP
DEBUG BB: Processing node 33, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=5, varin=59, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=32)
DEBUG SOLUTION: LP solution array indices: FST[33-72], not_covered[73-92]
DEBUG SOLUTION: lp->best_solution[0] = 27463064.838935
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1616063.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 32 rows, 60 cols, 242 nonzeros, 1 slack, 31 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 17 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=33, varin=64, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=36)
DEBUG SOLUTION: LP solution array indices: FST[37-76], not_covered[77-96]
DEBUG SOLUTION: lp->best_solution[0] = 27476096.422161
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1629094.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 36 rows, 60 cols, 259 nonzeros, 1 slack, 35 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=36, varin=66, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=36)
DEBUG SOLUTION: LP solution array indices: FST[37-76], not_covered[77-96]
DEBUG SOLUTION: lp->best_solution[0] = 27483339.583285
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 36 rows, 60 cols, 221 nonzeros, 0 slack, 36 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 9 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=37, varin=52, theta=0.250000, up=1.000000
ITER 2: row=35, varin=27, theta=0.035714, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=40)
DEBUG SOLUTION: LP solution array indices: FST[41-80], not_covered[81-100]
DEBUG SOLUTION: lp->best_solution[0] = 27491033.766117
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 40 rows, 60 cols, 230 nonzeros, 1 slack, 39 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 3 rows, 12 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=40, varin=47, theta=0.250000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 27494465.436437
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 42 rows, 60 cols, 240 nonzeros, 1 slack, 41 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 3 rows, 11 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=42, varin=48, theta=0.125000, up=1.000000
ITER 2: row=44, varin=66, theta=0.500000, up=1.000000
ITER 3: row=12, varin=42, theta=0.178571, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 27509425.766854
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 44 rows, 60 cols, 249 nonzeros, 4 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % @PAP adding 2 rows, 42 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=42, varin=75, theta=0.122801, up=1.000000
ITER 2: row=41, varin=42, theta=123617.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 27512385.533304
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 42 rows, 60 cols, 272 nonzeros, 1 slack, 41 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 33 LP 1 Solution, length = 27512385.533304, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.500000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.500000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.500000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.500000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.500000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.500000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.500000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.500000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=27512385.533304, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 33 at  27.51238553330376035433
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ad4c48c600
% @LO 0.02  27.46507808635753278281 99.9000000000
% @LN 0.02  27.47588567760878319746 99.9000000000
% Resuming node 29 at  27.47588567760878319746
DEBUG CONSTRNT: LP rows=41, pool->nlprows=41, pool->npend=0
DEBUG CONSTRNT: Checking 41 LP rows (pool tracks 41, total LP rows 41)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 142
DEBUG CONSTRNT: Pool row 142 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 133
DEBUG CONSTRNT: Pool row 133 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 143
DEBUG CONSTRNT: Pool row 143 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=40, expected 40
 % @PAP adding 23 rows, 153 nz to LP
DEBUG BB: Processing node 29, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=6, varin=2, theta=4.020093, up=999999999999999983222784.000000
ITER 2: row=2, varin=10, theta=4.020093, up=999999999999999983222784.000000
ITER 3: row=20, varin=3, theta=2.000000, up=999999999999999983222784.000000
ITER 4: row=1, varin=26, theta=1.036445, up=1.000000
ITER 5: row=1, varin=6, theta=0.013326, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=23)
DEBUG SOLUTION: LP solution array indices: FST[24-63], not_covered[64-83]
DEBUG SOLUTION: lp->best_solution[0] = 27475885.677609
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.013326
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.986674
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 23 rows, 60 cols, 213 nonzeros, 3 slack, 20 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 9 rows, 47 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=28, varin=19, theta=0.152821, up=999999999999999983222784.000000
ITER 2: row=29, varin=20, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=31, varin=21, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=1, varin=76, theta=1.166147, up=1.000000
ITER 5: row=1, varin=83, theta=0.166147, up=1.000000
ITER 6: row=2, varin=76, theta=1.000000, up=1.000000
ITER 7: row=24, varin=18, theta=0.986674, up=999999999999999983222784.000000
ITER 8: row=1, varin=35, theta=1.121283, up=1.000000
ITER 9: row=1, varin=8, theta=0.041130, up=999999999999999983222784.000000
ITER 10: row=26, varin=28, theta=8.232066, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=10)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=32)
DEBUG SOLUTION: LP solution array indices: FST[33-72], not_covered[73-92]
DEBUG SOLUTION: lp->best_solution[0] = 27478123.441350
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.767934
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.750000
DEBUG SOLUTION: lp->best_solution[9] = 0.750000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 32 rows, 60 cols, 260 nonzeros, 12 slack, 20 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 12 slack rows
  % @PAP adding 2 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=21, varin=71, theta=0.333333, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=22)
DEBUG SOLUTION: LP solution array indices: FST[23-62], not_covered[63-82]
DEBUG SOLUTION: lp->best_solution[0] = 27478585.884444
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.666667
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 22 rows, 60 cols, 206 nonzeros, 2 slack, 20 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % Node 29 LP 1 Solution, length = 27478585.884444, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.666667 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.333333 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.483570 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 1.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.516430 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.516430 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.666667 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.333333 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.516430 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.333333 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.333333 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 3 fractional variables
DEBUG CG: LP optimal, z=27478585.884444, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
 % @LO 0.02  27.47588567760878319746 99.9000000000
 % @LN 0.02  27.47858588444373140192 99.9000000000
DEBUG CG: Second cutoff check: z=27478585.884444, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 29 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 29
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=1.000000
DEBUG CAREFUL: Skipping var 2: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.666667
DEBUG CAREFUL: Adding var 12 to fractional list (xi=0.666667)
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.333333
DEBUG CAREFUL: Adding var 14 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.483570
DEBUG CAREFUL: Adding var 16 to fractional list (xi=0.483570)
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=1.000000
DEBUG CAREFUL: Skipping var 20: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 3 fractional variables

  %  Carefully choosing branching variable, nfrac = 3
DEBUG CAREFUL: Testing fvar[0] = var 14
DEBUG CAREFUL: Calling compare_branch_vars for var 14
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 14
DEBUG CAREFUL: New best var: 14
DEBUG CAREFUL: Testing fvar[1] = var 12
DEBUG CAREFUL: Calling compare_branch_vars for var 12
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 12
DEBUG CAREFUL: Testing fvar[2] = var 16
DEBUG CAREFUL: Calling compare_branch_vars for var 16
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 16
DEBUG CAREFUL: New best var: 16
  % Initial guess is x16, Z0 = 27478585.8844437        , Z1 = 27483342.8972979        

DEBUG EVAL: Testing var 14 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=5, varin=22, theta=1.000000, up=1.000000
ITER 2: row=3, varin=29, theta=0.500000, up=1.000000
DEBUG EVAL: Branch var 14 = 0 gives z=27547666.396075
  % 	x14 = 0,	Z0 = 27547666.3960745        
DEBUG EVAL: First branch cutoff check: z=27547666.396075, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 14 = 1
ITER 1: row=5, varin=23, theta=2.000000, up=1.000000
ITER 2: row=5, varin=14, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=14, varin=16, theta=0.574300, up=999999999999999983222784.000000
ITER 4: row=15, varin=2, theta=0.148601, up=999999999999999983222784.000000
ITER 5: row=2, varin=8, theta=0.148601, up=999999999999999983222784.000000
ITER 6: row=8, varin=9, theta=0.148601, up=999999999999999983222784.000000
  % 	x14 = 1,	Z1 = 27481434.9947353        
DEBUG EVAL: Second branch cutoff check: z=27481434.994735, best_z=INF, threshold=INF
  %   New best:  x14, Z = 27481434.9947353        
DEBUG EVAL: Testing var 12 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=22, theta=1.000000, up=1.000000
ITER 2: row=3, varin=29, theta=0.500000, up=1.000000
DEBUG EVAL: Branch var 12 = 1 gives z=27547666.396075
  % 	x12 = 1,	Z1 = 27547666.3960745        
DEBUG EVAL: First branch cutoff check: z=27547666.396075, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 12 = 0
ITER 1: row=1, varin=23, theta=2.000000, up=1.000000
ITER 2: row=1, varin=14, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=14, varin=16, theta=0.574300, up=999999999999999983222784.000000
ITER 4: row=15, varin=2, theta=0.148601, up=999999999999999983222784.000000
ITER 5: row=2, varin=8, theta=0.148601, up=999999999999999983222784.000000
ITER 6: row=8, varin=9, theta=0.148601, up=999999999999999983222784.000000
  % 	x12 = 0,	Z0 = 27481434.9947353        
DEBUG EVAL: Second branch cutoff check: z=27481434.994735, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 16 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=6, varin=23, theta=2.263174, up=1.000000
ITER 2: row=6, varin=6, theta=0.931917, up=999999999999999983222784.000000
ITER 3: row=1, varin=42, theta=0.592739, up=1.000000
DEBUG EVAL: Branch var 16 = 1 gives z=27729960.782026
  % 	x16 = 1,	Z1 = 27729960.782026         
DEBUG EVAL: First branch cutoff check: z=27729960.782026, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 16 = 0
ITER 1: row=6, varin=14, theta=3.517948, up=999999999999999983222784.000000
ITER 2: row=14, varin=2, theta=2.517948, up=999999999999999983222784.000000
ITER 3: row=2, varin=8, theta=2.517948, up=999999999999999983222784.000000
ITER 4: row=8, varin=9, theta=2.517948, up=999999999999999983222784.000000
ITER 5: row=9, varin=10, theta=2.517948, up=999999999999999983222784.000000
ITER 6: row=10, varin=11, theta=2.517948, up=999999999999999983222784.000000
ITER 7: row=11, varin=12, theta=2.517948, up=999999999999999983222784.000000
ITER 8: row=12, varin=13, theta=2.517948, up=999999999999999983222784.000000
ITER 9: row=13, varin=62, theta=1.517948, up=1.000000
ITER 10: row=13, varin=66, theta=0.517948, up=1.000000
  % 	x16 = 0,	Z0 = 27504659.8932244        
DEBUG EVAL: Second branch cutoff check: z=27504659.893224, best_z=INF, threshold=INF
  %   New best:  x16, Z = 27504659.8932244        
  % Best branch is x16, Z0 = 27504659.8932244        , Z1 = 27729960.782026         

DEBUG CAREFUL: Final result - returning best.var = 16
DEBUG BB: Branching variable chosen: j=16
 % @NC   35   29	x16 = 0	27504659.893224
 % @NC   36   29	x16 = 1	27729960.782026
 %      29    17 27478585.8844               27493760.4124   x15 D    21     4
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ad4c4b75a0
% @LO 0.02  27.47858588444373140192 99.9000000000
% @LN 0.02  27.49376041237597334543 99.9000000000
% Resuming node 30 at  27.49376041237597334543
DEBUG CONSTRNT: LP rows=20, pool->nlprows=20, pool->npend=0
DEBUG CONSTRNT: Checking 20 LP rows (pool tracks 20, total LP rows 20)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 82
DEBUG CONSTRNT: Pool row 82 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 49
DEBUG CONSTRNT: Pool row 49 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=19, expected 19
 % @PAP adding 23 rows, 153 nz to LP
DEBUG BB: Processing node 30, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=6, varin=31, theta=0.447455, up=1.000000
ITER 2: row=1, varin=8, theta=0.129400, up=999999999999999983222784.000000
ITER 3: row=8, varin=22, theta=0.322777, up=999999999999999983222784.000000
ITER 4: row=22, varin=34, theta=0.470343, up=1.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=23)
DEBUG SOLUTION: LP solution array indices: FST[24-63], not_covered[64-83]
DEBUG SOLUTION: lp->best_solution[0] = 27493760.412376
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 23 rows, 60 cols, 213 nonzeros, 0 slack, 23 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 7 rows, 28 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=28, varin=39, theta=0.660000, up=1.000000
ITER 2: row=27, varin=82, theta=0.128133, up=1.000000
ITER 3: row=6, varin=57, theta=0.378162, up=1.000000
ITER 4: row=29, varin=52, theta=0.318844, up=1.000000
ITER 5: row=25, varin=48, theta=0.275572, up=1.000000
ITER 6: row=9, varin=45, theta=0.217231, up=1.000000
ITER 7: row=7, varin=58, theta=0.235340, up=1.000000
LP PHASE: Switching to primal (iter=7)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=30)
DEBUG SOLUTION: LP solution array indices: FST[31-70], not_covered[71-90]
DEBUG SOLUTION: lp->best_solution[0] = 27541861.787202
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 30 rows, 60 cols, 241 nonzeros, 0 slack, 30 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 7 rows, 29 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=32, varin=50, theta=0.887961, up=1.000000
ITER 2: row=31, varin=80, theta=0.108520, up=1.000000
ITER 3: row=32, varin=67, theta=0.529116, up=1.000000
ITER 4: row=26, varin=50, theta=0.450309, up=1.000000
ITER 5: row=7, varin=38, theta=0.470630, up=1.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=37)
DEBUG SOLUTION: LP solution array indices: FST[38-77], not_covered[78-97]
DEBUG SOLUTION: lp->best_solution[0] = 27589743.985330
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 37 rows, 60 cols, 270 nonzeros, 0 slack, 37 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 9 rows, 28 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=44, varin=61, theta=0.648297, up=1.000000
ITER 2: row=38, varin=71, theta=0.869874, up=1.000000
ITER 3: row=39, varin=52, theta=0.576856, up=1.000000
ITER 4: row=7, varin=38, theta=0.521947, up=999999999999999983222784.000000
ITER 5: row=43, varin=70, theta=0.622776, up=1.000000
ITER 6: row=6, varin=59, theta=0.038394, up=1.000000
ITER 7: row=8, varin=23, theta=0.037436, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=7)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=46)
DEBUG SOLUTION: LP solution array indices: FST[47-86], not_covered[87-106]
DEBUG SOLUTION: lp->best_solution[0] = 27664242.257430
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 46 rows, 60 cols, 298 nonzeros, 3 slack, 43 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 5 rows, 11 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=47, varin=103, theta=0.736357, up=1.000000
ITER 2: row=27, varin=51, theta=0.706722, up=1.000000
ITER 3: row=46, varin=58, theta=0.410959, up=1.000000
ITER 4: row=44, varin=46, theta=0.050847, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 27740025.310642
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 48 rows, 60 cols, 303 nonzeros, 2 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 4 rows, 10 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=49, varin=83, theta=0.262511, up=1.000000
ITER 2: row=48, varin=3, theta=0.141344, up=999999999999999983222784.000000
ITER 3: row=38, varin=85, theta=0.638889, up=1.000000
ITER 4: row=47, varin=92, theta=0.500000, up=1.000000
ITER 5: row=37, varin=49, theta=1.990653, up=999999999999999983222784.000000
ITER 6: row=46, varin=22, theta=0.333333, up=999999999999999983222784.000000
ITER 7: row=37, varin=23, theta=0.142293, up=999999999999999983222784.000000
ITER 8: row=46, varin=25, theta=0.034420, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=8)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 27808353.660703
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 50 rows, 60 cols, 309 nonzeros, 3 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 2 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=48, varin=22, theta=0.490482, up=999999999999999983222784.000000
ITER 2: row=49, varin=78, theta=0.297341, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 27829094.813655
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 49 rows, 60 cols, 305 nonzeros, 1 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 4 rows, 12 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=49, varin=89, theta=1.042402, up=1.000000
ITER 2: row=49, varin=84, theta=0.017103, up=1.000000
ITER 3: row=5, varin=34, theta=0.480464, up=999999999999999983222784.000000
ITER 4: row=34, varin=89, theta=0.376824, up=1.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 27877065.796209
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 52 rows, 60 cols, 311 nonzeros, 2 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 3 rows, 10 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=51, varin=59, theta=0.126079, up=1.000000
ITER 2: row=53, varin=51, theta=0.086099, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=53)
DEBUG SOLUTION: LP solution array indices: FST[54-93], not_covered[94-113]
DEBUG SOLUTION: lp->best_solution[0] = 27918674.383537
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 53 rows, 60 cols, 317 nonzeros, 2 slack, 51 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 2 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=52, varin=22, theta=0.293701, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
ITER 2: row=32, varin=54, theta=0.000000, up=1.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=53)
DEBUG SOLUTION: LP solution array indices: FST[54-93], not_covered[94-113]
DEBUG SOLUTION: lp->best_solution[0] = 27947758.758382
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 53 rows, 60 cols, 313 nonzeros, 1 slack, 52 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 30 LP 1 Solution, length = 27947758.758382, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.500000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.097900 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.097900 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.097900 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 1.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 1.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.500000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.412598 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.097900 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.097900 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.902100 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.902100 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.500000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 8 fractional variables
DEBUG CG: LP optimal, z=27947758.758382, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 30 at  27.94775875838207213064
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ad4c4a4590
% @LO 0.02  27.49376041237597334543 99.9000000000
% @LN 0.02  27.49399212369200284911 99.9000000000
% Resuming node 34 at  27.49399212369200284911
DEBUG CONSTRNT: LP rows=52, pool->nlprows=52, pool->npend=0
DEBUG CONSTRNT: Checking 52 LP rows (pool tracks 52, total LP rows 52)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 133
DEBUG CONSTRNT: Pool row 133 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 141
DEBUG CONSTRNT: Pool row 141 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 145
DEBUG CONSTRNT: Pool row 145 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 159
DEBUG CONSTRNT: Pool row 159 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 58
DEBUG CONSTRNT: Pool row 58 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=51, expected 51
 % @PAP adding 32 rows, 182 nz to LP
DEBUG BB: Processing node 34, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=5, varin=32, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=1, varin=29, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=25, varin=28, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=32)
DEBUG SOLUTION: LP solution array indices: FST[33-72], not_covered[73-92]
DEBUG SOLUTION: lp->best_solution[0] = 27493992.123692
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1755990.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 32 rows, 60 cols, 242 nonzeros, 4 slack, 28 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 6 rows, 29 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=33, varin=5, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=35, varin=51, theta=1.000000, up=1.000000
ITER 3: row=10, varin=12, theta=1.005373, up=999999999999999983222784.000000
ITER 4: row=34, varin=7, theta=0.100000, up=999999999999999983222784.000000
ITER 5: row=38, varin=8, theta=0.166667, up=999999999999999983222784.000000
ITER 6: row=29, varin=10, theta=141109.933333, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=38)
DEBUG SOLUTION: LP solution array indices: FST[39-78], not_covered[79-98]
DEBUG SOLUTION: lp->best_solution[0] = 27567525.456768
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 0.900000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 0.900000
DEBUG SOLUTION: lp->best_solution[8] = 0.833333
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1658890.066667
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.100000
DEBUG SOLUTION: lp->best_solution[13] = 0.100000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 38 rows, 60 cols, 271 nonzeros, 11 slack, 27 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 11 slack rows
  % @PAP adding 4 rows, 12 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=29, varin=25, theta=9.000000, up=999999999999999983222784.000000
ITER 2: row=1, varin=5, theta=1.166667, up=999999999999999983222784.000000
ITER 3: row=29, varin=32, theta=0.133333, up=1.000000
ITER 4: row=28, varin=25, theta=4.000000, up=999999999999999983222784.000000
ITER 5: row=31, varin=28, theta=0.666667, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=31)
DEBUG SOLUTION: LP solution array indices: FST[32-71], not_covered[72-91]
DEBUG SOLUTION: lp->best_solution[0] = 27682341.244400
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 0.833333
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 31 rows, 60 cols, 217 nonzeros, 4 slack, 27 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=28, varin=25, theta=2.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=28)
DEBUG SOLUTION: LP solution array indices: FST[29-68], not_covered[69-88]
DEBUG SOLUTION: lp->best_solution[0] = 27702774.586126
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 0.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 2.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 28 rows, 60 cols, 198 nonzeros, 1 slack, 27 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 34 LP 1 Solution, length = 27702774.586126, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.500000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.500000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.500000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.500000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.500000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.500000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.500000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.500000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.500000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.500000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.500000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=27702774.586126, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 34 at  27.70277458612553189710
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ad4c4af9e0
% @LO 0.02  27.49399212369200284911 99.9000000000
% @LN 0.02  27.49467737742541117996 99.9000000000
% Resuming node 20 at  27.49467737742541117996
DEBUG CONSTRNT: LP rows=27, pool->nlprows=27, pool->npend=0
DEBUG CONSTRNT: Checking 27 LP rows (pool tracks 27, total LP rows 27)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 142
DEBUG CONSTRNT: Pool row 142 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=26, expected 26
 % @PAP adding 28 rows, 168 nz to LP
DEBUG BB: Processing node 20, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=4, varin=25, theta=2.666362, up=999999999999999983222784.000000
ITER 2: row=1, varin=8, theta=2.000000, up=999999999999999983222784.000000
ITER 3: row=28, varin=5, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=28)
DEBUG SOLUTION: LP solution array indices: FST[29-68], not_covered[69-88]
DEBUG SOLUTION: lp->best_solution[0] = 27494677.377425
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 0.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 28 rows, 60 cols, 228 nonzeros, 3 slack, 25 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 10 rows, 44 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=35, varin=6, theta=0.117977, up=999999999999999983222784.000000
ITER 2: row=31, varin=4, theta=0.100000, up=999999999999999983222784.000000
ITER 3: row=38, varin=7, theta=0.250000, up=999999999999999983222784.000000
ITER 4: row=30, varin=31, theta=4.337064, up=999999999999999983222784.000000
ITER 5: row=34, varin=35, theta=5.404477, up=999999999999999983222784.000000
ITER 6: row=1, varin=97, theta=0.317413, up=1.000000
ITER 7: row=36, varin=38, theta=1.134826, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=7)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=38)
DEBUG SOLUTION: LP solution array indices: FST[39-78], not_covered[79-98]
DEBUG SOLUTION: lp->best_solution[0] = 27494677.377425
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.466294
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.466294
DEBUG SOLUTION: lp->best_solution[7] = 0.466294
DEBUG SOLUTION: lp->best_solution[8] = 0.601119
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 38 rows, 60 cols, 272 nonzeros, 11 slack, 27 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=39, varin=46, theta=0.020645, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=40)
DEBUG SOLUTION: LP solution array indices: FST[41-80], not_covered[81-100]
DEBUG SOLUTION: lp->best_solution[0] = 27496964.804534
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.489677
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.489677
DEBUG SOLUTION: lp->best_solution[7] = 0.489677
DEBUG SOLUTION: lp->best_solution[8] = 0.489677
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 40 rows, 60 cols, 276 nonzeros, 12 slack, 28 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 12 slack rows
  % Node 20 LP 1 Solution, length = 27496964.804534, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 1.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.020645 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.510323 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.489677 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.510323 (FST 16)
  % DEBUG LP_VARS: x[17] = 1.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.489677 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.489677 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.489677 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.489677 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.489677 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.489677 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=27496964.804534, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
 % @LO 0.02  27.49467737742541117996 99.9000000000
 % @LN 0.02  27.49696480453381042253 99.9000000000
DEBUG CG: Second cutoff check: z=27496964.804534, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 3 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 20 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 20
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=1.000000
DEBUG CAREFUL: Skipping var 1: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=1.000000
DEBUG CAREFUL: Skipping var 2: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.020645
DEBUG CAREFUL: Adding var 5 to fractional list (xi=0.020645)
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.510323
DEBUG CAREFUL: Adding var 12 to fractional list (xi=0.510323)
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.489677
DEBUG CAREFUL: Adding var 15 to fractional list (xi=0.489677)
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.510323
DEBUG CAREFUL: Adding var 16 to fractional list (xi=0.510323)
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=1.000000
DEBUG CAREFUL: Skipping var 17: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 4 fractional variables

  %  Carefully choosing branching variable, nfrac = 4
DEBUG CAREFUL: Testing fvar[0] = var 15
DEBUG CAREFUL: Calling compare_branch_vars for var 15
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 15
DEBUG CAREFUL: New best var: 15
DEBUG CAREFUL: Testing fvar[1] = var 16
DEBUG CAREFUL: Calling compare_branch_vars for var 16
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 16
DEBUG CAREFUL: Testing fvar[2] = var 12
DEBUG CAREFUL: Calling compare_branch_vars for var 12
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 12
DEBUG CAREFUL: Testing fvar[3] = var 5
DEBUG CAREFUL: Calling compare_branch_vars for var 5
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 5
DEBUG CAREFUL: New best var: 5
  % Initial guess is x5, Z0 = 27496964.8045338        , Z1 = 27605474.734036         

DEBUG EVAL: Testing var 15 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=8, varin=8, theta=0.574585, up=999999999999999983222784.000000
ITER 2: row=7, varin=27, theta=2.942398, up=999999999999999983222784.000000
ITER 3: row=27, varin=24, theta=1.942398, up=999999999999999983222784.000000
ITER 4: row=23, varin=26, theta=0.942398, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 15 = 1 gives z=27546884.990287
  % 	x15 = 1,	Z1 = 27546884.9902873        
DEBUG EVAL: First branch cutoff check: z=27546884.990287, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 15 = 0
ITER 1: row=8, varin=9, theta=0.505600, up=999999999999999983222784.000000
ITER 2: row=1, varin=31, theta=0.031726, up=1.000000
  % 	x15 = 0,	Z0 = 27538803.2222429        
DEBUG EVAL: Second branch cutoff check: z=27538803.222243, best_z=INF, threshold=INF
  %   New best:  x15, Z = 27538803.2222429        
DEBUG EVAL: Testing var 16 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=9, varin=8, theta=4.378318, up=999999999999999983222784.000000
ITER 2: row=7, varin=31, theta=2.864195, up=1.000000
ITER 3: row=7, varin=39, theta=5.442105, up=1.000000
ITER 4: row=7, varin=9, theta=3.237765, up=999999999999999983222784.000000
ITER 5: row=6, varin=55, theta=1.502042, up=1.000000
ITER 6: row=6, varin=50, theta=0.422506, up=1.000000
ITER 7: row=20, varin=55, theta=2.000000, up=1.000000
ITER 8: row=20, varin=39, theta=1.000000, up=1.000000
ITER 9: row=10, varin=32, theta=0.999588, up=1.000000
ITER 10: row=1, varin=56, theta=0.763266, up=1.000000
DEBUG EVAL: Branch var 16 = 1 gives z=28182149.560685
  % 	x16 = 1,	Z1 = 28182149.560685         
DEBUG EVAL: First branch cutoff check: z=28182149.560685, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 16 = 0
ITER 1: row=9, varin=22, theta=2.942398, up=999999999999999983222784.000000
ITER 2: row=26, varin=2, theta=1.942398, up=999999999999999983222784.000000
ITER 3: row=2, varin=24, theta=1.942398, up=999999999999999983222784.000000
ITER 4: row=23, varin=26, theta=0.942398, up=999999999999999983222784.000000
  % 	x16 = 0,	Z0 = 27546884.9902872        
DEBUG EVAL: Second branch cutoff check: z=27546884.990287, best_z=INF, threshold=INF
  %   New best:  x16, Z = 27546884.9902872        
DEBUG EVAL: Testing var 12 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=6, varin=37, theta=0.715557, up=1.000000
ITER 2: row=25, varin=26, theta=0.958473, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 12 = 1 gives z=27680800.019791
  % 	x12 = 1,	Z1 = 27680800.0197912        
DEBUG EVAL: First branch cutoff check: z=27680800.019791, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 12 = 0
ITER 1: row=6, varin=8, theta=0.574585, up=999999999999999983222784.000000
ITER 2: row=7, varin=22, theta=2.942398, up=999999999999999983222784.000000
ITER 3: row=26, varin=24, theta=1.942398, up=999999999999999983222784.000000
ITER 4: row=23, varin=26, theta=0.942398, up=999999999999999983222784.000000
  % 	x12 = 0,	Z0 = 27546884.9902872        
DEBUG EVAL: Second branch cutoff check: z=27546884.990287, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 5 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=18, theta=31.978989, up=999999999999999983222784.000000
ITER 2: row=18, varin=24, theta=5.395798, up=999999999999999983222784.000000
ITER 3: row=23, varin=2, theta=3.796848, up=999999999999999983222784.000000
ITER 4: row=2, varin=3, theta=3.796848, up=999999999999999983222784.000000
ITER 5: row=3, varin=11, theta=3.796848, up=999999999999999983222784.000000
ITER 6: row=11, varin=12, theta=3.796848, up=999999999999999983222784.000000
ITER 7: row=12, varin=14, theta=3.796848, up=999999999999999983222784.000000
ITER 8: row=14, varin=15, theta=3.796848, up=999999999999999983222784.000000
ITER 9: row=15, varin=16, theta=3.796848, up=999999999999999983222784.000000
ITER 10: row=16, varin=21, theta=3.796848, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 5 = 1 gives z=27664629.675043
  % 	x5 = 1,	Z1 = 27664629.6750433        
DEBUG EVAL: First branch cutoff check: z=27664629.675043, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 5 = 0
ITER 1: row=1, varin=39, theta=0.026371, up=1.000000
ITER 2: row=19, varin=38, theta=0.019600, up=1.000000
  % 	x5 = 0,	Z0 = 27498531.7140111        
DEBUG EVAL: Second branch cutoff check: z=27498531.714011, best_z=INF, threshold=INF
  % Best branch is x16, Z0 = 27546884.9902872        , Z1 = 28182149.560685         

DEBUG CAREFUL: Final result - returning best.var = 16
DEBUG BB: Branching variable chosen: j=16
 % @NC   37   20	x16 = 0	27546884.990287
 % @NC   38   20	x16 = 1	28182149.560685
 %      20    18 27496964.8045               27504659.8932   x19 D    16     6
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ad4c49c780
% @LO 0.02  27.49696480453381042253 99.9000000000
% @LN 0.02  27.50465989322443505216 99.9000000000
% Resuming node 35 at  27.50465989322443505216
DEBUG CONSTRNT: LP rows=28, pool->nlprows=28, pool->npend=0
DEBUG CONSTRNT: Checking 28 LP rows (pool tracks 28, total LP rows 28)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 91
DEBUG CONSTRNT: Pool row 91 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 82
DEBUG CONSTRNT: Pool row 82 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 49
DEBUG CONSTRNT: Pool row 49 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 68
DEBUG CONSTRNT: Pool row 68 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=27, expected 27
 % @PAP adding 20 rows, 138 nz to LP
DEBUG BB: Processing node 35, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=6, varin=14, theta=3.517948, up=999999999999999983222784.000000
ITER 2: row=14, varin=2, theta=2.517948, up=999999999999999983222784.000000
ITER 3: row=2, varin=8, theta=2.517948, up=999999999999999983222784.000000
ITER 4: row=8, varin=9, theta=2.517948, up=999999999999999983222784.000000
ITER 5: row=9, varin=10, theta=2.517948, up=999999999999999983222784.000000
ITER 6: row=10, varin=11, theta=2.517948, up=999999999999999983222784.000000
ITER 7: row=11, varin=12, theta=2.517948, up=999999999999999983222784.000000
ITER 8: row=12, varin=13, theta=2.517948, up=999999999999999983222784.000000
ITER 9: row=13, varin=62, theta=1.517948, up=1.000000
ITER 10: row=13, varin=66, theta=0.517948, up=1.000000
LP PHASE: Switching to primal (iter=13)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=20)
DEBUG SOLUTION: LP solution array indices: FST[21-60], not_covered[61-80]
DEBUG SOLUTION: lp->best_solution[0] = 27504659.893224
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.561641
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 20 rows, 60 cols, 198 nonzeros, 2 slack, 18 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 6 rows, 38 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=19, varin=14, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=1, varin=67, theta=1.000000, up=1.000000
ITER 3: row=21, varin=15, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=1, varin=68, theta=1.000000, up=1.000000
ITER 5: row=2, varin=69, theta=1.000000, up=1.000000
ITER 6: row=23, varin=17, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=2, varin=71, theta=1.000000, up=1.000000
ITER 8: row=12, varin=77, theta=1.000000, up=1.000000
ITER 9: row=8, varin=78, theta=1.000000, up=1.000000
ITER 10: row=9, varin=80, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=13)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=24)
DEBUG SOLUTION: LP solution array indices: FST[25-64], not_covered[65-84]
DEBUG SOLUTION: lp->best_solution[0] = 27525280.290766
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.461187
  % @PL 24 rows, 60 cols, 232 nonzeros, 6 slack, 18 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 6 slack rows
  % @PAP adding 6 rows, 26 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=21, varin=70, theta=1.000000, up=1.000000
ITER 2: row=19, varin=33, theta=0.390775, up=1.000000
ITER 3: row=24, varin=13, theta=0.050062, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=24)
DEBUG SOLUTION: LP solution array indices: FST[25-64], not_covered[65-84]
DEBUG SOLUTION: lp->best_solution[0] = 27538409.256126
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.949938
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 24 rows, 60 cols, 220 nonzeros, 2 slack, 22 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 2 rows, 10 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=23, varin=67, theta=0.401789, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=24)
DEBUG SOLUTION: LP solution array indices: FST[25-64], not_covered[65-84]
DEBUG SOLUTION: lp->best_solution[0] = 27548104.549322
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 24 rows, 60 cols, 226 nonzeros, 2 slack, 22 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=23, varin=21, theta=1.409679, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=23)
DEBUG SOLUTION: LP solution array indices: FST[24-63], not_covered[64-83]
DEBUG SOLUTION: lp->best_solution[0] = 27548748.047224
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 23 rows, 60 cols, 214 nonzeros, 1 slack, 22 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 35 LP 1 Solution, length = 27548748.047224, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.234946 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.234946 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.265054 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.734946 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 1.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.765054 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.265054 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.265054 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.265054 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.765054 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.734946 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.265054 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=27548748.047224, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 35 at  27.54874804722373227150
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ad4c4a0510
% @LO 0.02  27.50465989322443505216 99.9000000000
% @LN 0.02  27.51238553330376035433 99.9000000000
% Resuming node 33 at  27.51238553330376035433
DEBUG CONSTRNT: LP rows=22, pool->nlprows=22, pool->npend=0
DEBUG CONSTRNT: Checking 22 LP rows (pool tracks 22, total LP rows 22)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 79
DEBUG CONSTRNT: Pool row 79 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=21, expected 21
 % @PAP adding 41 rows, 172 nz to LP
DEBUG BB: Processing node 33, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 33 LP 2 Solution, length = 27512385.533304, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.500000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.500000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.500000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.500000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.500000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.500000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.500000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.500000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=27512385.533304, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=27512385.533304, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 33 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 33
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.500000
DEBUG CAREFUL: Adding var 0 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.500000
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=1.000000
DEBUG CAREFUL: Skipping var 2: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=1.000000
DEBUG CAREFUL: Skipping var 7: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.500000
DEBUG CAREFUL: Adding var 29 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.500000
DEBUG CAREFUL: Adding var 32 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 4 fractional variables

  %  Carefully choosing branching variable, nfrac = 4
DEBUG CAREFUL: Testing fvar[0] = var 0
DEBUG CAREFUL: Calling compare_branch_vars for var 0
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 0
DEBUG CAREFUL: New best var: 0
DEBUG CAREFUL: Testing fvar[1] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 1
DEBUG CAREFUL: Testing fvar[2] = var 32
DEBUG CAREFUL: Calling compare_branch_vars for var 32
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 32
DEBUG CAREFUL: Testing fvar[3] = var 29
DEBUG CAREFUL: Calling compare_branch_vars for var 29
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 29
  % Initial guess is x0, Z0 = 27512385.5333038        , Z1 = 27659962.0633559        

DEBUG EVAL: Testing var 0 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=27, varin=4, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=28, varin=3, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=36, varin=35, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=1, varin=33, theta=1.250000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 0 = 1 gives z=27955883.441750
  % 	x0 = 1,	Z1 = 27955883.4417504        
DEBUG EVAL: First branch cutoff check: z=27955883.441750, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 0 = 0
ITER 1: row=27, varin=27, theta=1.000000, up=999999999999999983222784.000000
  % 	x0 = 0,	Z0 = 27555491.0770864        
DEBUG EVAL: Second branch cutoff check: z=27555491.077086, best_z=INF, threshold=INF
  %   New best:  x0, Z = 27555491.0770864        
DEBUG EVAL: Testing var 1 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=4, varin=27, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 1 = 0 gives z=27555491.077086
  % 	x1 = 0,	Z0 = 27555491.0770864        
DEBUG EVAL: First branch cutoff check: z=27555491.077086, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 1 = 1
ITER 1: row=4, varin=29, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=38, varin=35, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=1, varin=33, theta=1.250000, up=999999999999999983222784.000000
  % 	x1 = 1,	Z1 = 27699782.0534175        
DEBUG EVAL: Second branch cutoff check: z=27699782.053417, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 32 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=41, theta=0.178571, up=999999999999999983222784.000000
ITER 2: row=20, varin=12, theta=0.500000, up=999999999999999983222784.000000
ITER 3: row=12, varin=40, theta=0.214286, up=999999999999999983222784.000000
ITER 4: row=33, varin=39, theta=0.250000, up=999999999999999983222784.000000
ITER 5: row=40, varin=30, theta=0.500000, up=999999999999999983222784.000000
ITER 6: row=30, varin=35, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 32 = 1 gives z=27541431.483323
  % 	x32 = 1,	Z1 = 27541431.483323         
DEBUG EVAL: First branch cutoff check: z=27541431.483323, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 29 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=35, varin=35, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 29 = 0 gives z=27541431.483323
  % 	x29 = 0,	Z0 = 27541431.483323         
DEBUG EVAL: First branch cutoff check: z=27541431.483323, best_z=INF, threshold=INF
  % Best branch is x0, Z0 = 27555491.0770864        , Z1 = 27955883.4417504        

DEBUG CAREFUL: Final result - returning best.var = 0
DEBUG BB: Branching variable chosen: j=0
 % @NC   39   33	x0 = 0	27555491.077086
 % @NC   40   33	x0 = 1	27955883.441750
 %      33    19 27512385.5333               27515043.4869   x19 U    27     5
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ad4c4ae540
% @LO 0.02  27.51238553330376035433 99.9000000000
% @LN 0.02  27.51504348685816125908 99.9000000000
% Resuming node 18 at  27.51504348685816125908
DEBUG CONSTRNT: LP rows=41, pool->nlprows=41, pool->npend=0
DEBUG CONSTRNT: Checking 41 LP rows (pool tracks 41, total LP rows 41)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 142
DEBUG CONSTRNT: Pool row 142 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 133
DEBUG CONSTRNT: Pool row 133 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 143
DEBUG CONSTRNT: Pool row 143 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=40, expected 40
 % @PAP adding 28 rows, 168 nz to LP
DEBUG BB: Processing node 18, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=4, varin=28, theta=2.222222, up=999999999999999983222784.000000
ITER 2: row=10, varin=23, theta=2.777778, up=999999999999999983222784.000000
ITER 3: row=23, varin=6, theta=5.000000, up=999999999999999983222784.000000
ITER 4: row=7, varin=5, theta=4.000000, up=999999999999999983222784.000000
ITER 5: row=6, varin=4, theta=3.000000, up=999999999999999983222784.000000
ITER 6: row=5, varin=2, theta=2.000000, up=999999999999999983222784.000000
ITER 7: row=2, varin=3, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=7)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=28)
DEBUG SOLUTION: LP solution array indices: FST[29-68], not_covered[69-88]
DEBUG SOLUTION: lp->best_solution[0] = 27515043.486858
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 0.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 0.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 28 rows, 60 cols, 228 nonzeros, 5 slack, 23 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 12 rows, 57 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=33, varin=7, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=35, varin=8, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=1, varin=85, theta=1.000000, up=1.000000
ITER 4: row=29, varin=25, theta=0.910909, up=999999999999999983222784.000000
ITER 5: row=1, varin=88, theta=0.910909, up=1.000000
ITER 6: row=31, varin=27, theta=0.910909, up=999999999999999983222784.000000
ITER 7: row=1, varin=89, theta=0.821818, up=1.000000
ITER 8: row=37, varin=55, theta=0.202689, up=1.000000
ITER 9: row=12, varin=50, theta=0.079473, up=1.000000
ITER 10: row=40, varin=51, theta=0.121848, up=1.000000
LP PHASE: Switching to primal (iter=12)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=40)
DEBUG SOLUTION: LP solution array indices: FST[41-80], not_covered[81-100]
DEBUG SOLUTION: lp->best_solution[0] = 27522485.371853
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 0.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 40 rows, 60 cols, 285 nonzeros, 13 slack, 27 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 13 slack rows
  % @PAP adding 2 rows, 13 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=28, varin=77, theta=1.000000, up=1.000000
ITER 2: row=1, varin=79, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=29)
DEBUG SOLUTION: LP solution array indices: FST[30-69], not_covered[70-89]
DEBUG SOLUTION: lp->best_solution[0] = 27522485.371853
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 29 rows, 60 cols, 248 nonzeros, 2 slack, 27 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 3 rows, 18 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=32, varin=48, theta=0.030303, up=1.000000
ITER 2: row=30, varin=32, theta=9.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=32)
DEBUG SOLUTION: LP solution array indices: FST[33-72], not_covered[73-92]
DEBUG SOLUTION: lp->best_solution[0] = 27537158.325074
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.166667
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 32 rows, 60 cols, 266 nonzeros, 3 slack, 29 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % Node 18 LP 1 Solution, length = 27537158.325074, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.166667 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.095151 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.833333 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.166667 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.833333 (FST 16)
  % DEBUG LP_VARS: x[17] = 1.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.166667 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.166667 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.166667 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.166667 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.904849 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.904849 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.166667 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.166667 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=27537158.325074, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 18 at  27.53715832507445071542
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ad4c4b2e60
% @LO 0.02  27.51504348685816125908 99.9000000000
% @LN 0.02  27.52902292321145694132 99.9000000000
% Resuming node 26 at  27.52902292321145694132
DEBUG CONSTRNT: LP rows=29, pool->nlprows=29, pool->npend=0
DEBUG CONSTRNT: Checking 29 LP rows (pool tracks 29, total LP rows 29)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 82
DEBUG CONSTRNT: Pool row 82 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 137
DEBUG CONSTRNT: Pool row 137 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 49
DEBUG CONSTRNT: Pool row 49 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 68
DEBUG CONSTRNT: Pool row 68 has lprow=28, expected 28
 % @PAP adding 38 rows, 200 nz to LP
DEBUG BB: Processing node 26, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=29, theta=1.912899, up=999999999999999983222784.000000
ITER 2: row=29, varin=38, theta=8.528404, up=999999999999999983222784.000000
ITER 3: row=25, varin=36, theta=6.554599, up=999999999999999983222784.000000
ITER 4: row=36, varin=26, theta=1.232153, up=999999999999999983222784.000000
ITER 5: row=22, varin=41, theta=0.726486, up=1.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=38)
DEBUG SOLUTION: LP solution array indices: FST[39-78], not_covered[79-98]
DEBUG SOLUTION: lp->best_solution[0] = 27529022.923211
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 38 rows, 60 cols, 260 nonzeros, 4 slack, 34 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % @PAP adding 3 rows, 7 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=36, varin=64, theta=0.666667, up=1.000000
ITER 2: row=35, varin=74, theta=5.071272, up=1.000000
ITER 3: row=35, varin=65, theta=1.431583, up=1.000000
ITER 4: row=35, varin=72, theta=0.976184, up=1.000000
ITER 5: row=20, varin=74, theta=9.656011, up=1.000000
ITER 6: row=20, varin=59, theta=1.055763, up=1.000000
ITER 7: row=20, varin=67, theta=0.079307, up=1.000000
ITER 8: row=35, varin=20, theta=0.561101, up=999999999999999983222784.000000
ITER 9: row=14, varin=59, theta=1.000000, up=1.000000
ITER 10: row=34, varin=61, theta=1.184160, up=1.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=37)
DEBUG SOLUTION: LP solution array indices: FST[38-77], not_covered[78-97]
DEBUG SOLUTION: lp->best_solution[0] = 999999999999999983222784.000000
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 37 rows, 60 cols, 259 nonzeros, 2 slack, 35 tight.
  % Node 26 LP 1 Solution, length = 999999999999999983222784.000000, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.273514 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 1.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 1.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.726486 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.726486 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
DEBUG BB: compute_good_lower_bound returned status=1
DEBUG BB: Node 26 is INFEASIBLE
 %      26    18    infeasible               27537158.3251    x5 U    17     7
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ad4c4ae540
% @LO 0.02  27.52902292321145694132 99.9000000000
% @LN 0.02  27.53715832507445071542 99.9000000000
% Resuming node 18 at  27.53715832507445071542
DEBUG CONSTRNT: LP rows=37, pool->nlprows=37, pool->npend=0
DEBUG CONSTRNT: Checking 37 LP rows (pool tracks 37, total LP rows 37)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=36, expected 36
 % @PAP adding 29 rows, 179 nz to LP
DEBUG BB: Processing node 18, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 18 LP 2 Solution, length = 27537158.325074, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.166667 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.095151 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.833333 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.166667 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.833333 (FST 16)
  % DEBUG LP_VARS: x[17] = 1.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.166667 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.166667 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.166667 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.166667 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.904849 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.904849 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.166667 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.166667 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=27537158.325074, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=27537158.325074, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 18 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 18
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=1.000000
DEBUG CAREFUL: Skipping var 2: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.166667
DEBUG CAREFUL: Adding var 5 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.095151
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.095151)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.833333
DEBUG CAREFUL: Adding var 12 to fractional list (xi=0.833333)
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.166667
DEBUG CAREFUL: Adding var 15 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.833333
DEBUG CAREFUL: Adding var 16 to fractional list (xi=0.833333)
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=1.000000
DEBUG CAREFUL: Skipping var 17: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 15
DEBUG CAREFUL: Calling compare_branch_vars for var 15
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 15
DEBUG CAREFUL: New best var: 15
DEBUG CAREFUL: Testing fvar[1] = var 16
DEBUG CAREFUL: Calling compare_branch_vars for var 16
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 16
DEBUG CAREFUL: Testing fvar[2] = var 12
DEBUG CAREFUL: Calling compare_branch_vars for var 12
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 12
DEBUG CAREFUL: Testing fvar[3] = var 5
DEBUG CAREFUL: Calling compare_branch_vars for var 5
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 5
DEBUG CAREFUL: Testing fvar[4] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
  % Initial guess is x15, Z0 = 27537158.3250744        , Z1 = 27612864.3331487        

DEBUG EVAL: Testing var 15 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=9, varin=22, theta=5.000000, up=999999999999999983222784.000000
ITER 2: row=28, varin=19, theta=4.000000, up=999999999999999983222784.000000
ITER 3: row=20, varin=20, theta=3.000000, up=999999999999999983222784.000000
ITER 4: row=21, varin=27, theta=2.000000, up=999999999999999983222784.000000
ITER 5: row=23, varin=21, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=16, varin=26, theta=0.025003, up=999999999999999983222784.000000
ITER 7: row=6, varin=8, theta=0.063767, up=999999999999999983222784.000000
ITER 8: row=7, varin=23, theta=0.028028, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 15 = 1 gives z=27612864.333149
  % 	x15 = 1,	Z1 = 27612864.3331487        
DEBUG EVAL: First branch cutoff check: z=27612864.333149, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 15 = 0
ITER 1: row=9, varin=9, theta=0.166667, up=999999999999999983222784.000000
  % 	x15 = 0,	Z0 = 27548411.4688107        
DEBUG EVAL: Second branch cutoff check: z=27548411.468811, best_z=INF, threshold=INF
  %   New best:  x15, Z = 27548411.4688107        
DEBUG EVAL: Testing var 16 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=19, varin=33, theta=0.500000, up=1.000000
ITER 2: row=16, varin=8, theta=0.398199, up=999999999999999983222784.000000
ITER 3: row=7, varin=9, theta=0.459164, up=999999999999999983222784.000000
ITER 4: row=29, varin=32, theta=0.552459, up=1.000000
DEBUG EVAL: Branch var 16 = 1 gives z=27668821.539904
  % 	x16 = 1,	Z1 = 27668821.5399036        
DEBUG EVAL: First branch cutoff check: z=27668821.539904, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 16 = 0
ITER 1: row=19, varin=22, theta=5.000000, up=999999999999999983222784.000000
ITER 2: row=28, varin=19, theta=4.000000, up=999999999999999983222784.000000
ITER 3: row=20, varin=20, theta=3.000000, up=999999999999999983222784.000000
ITER 4: row=21, varin=27, theta=2.000000, up=999999999999999983222784.000000
ITER 5: row=23, varin=21, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=16, varin=26, theta=0.025003, up=999999999999999983222784.000000
ITER 7: row=6, varin=23, theta=0.028028, up=999999999999999983222784.000000
  % 	x16 = 0,	Z0 = 27612864.3331487        
DEBUG EVAL: Second branch cutoff check: z=27612864.333149, best_z=INF, threshold=INF
  %   New best:  x16, Z = 27612864.3331487        
DEBUG EVAL: Testing var 12 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=8, varin=33, theta=0.500000, up=1.000000
ITER 2: row=16, varin=7, theta=0.404919, up=999999999999999983222784.000000
ITER 3: row=8, varin=38, theta=0.106260, up=1.000000
ITER 4: row=25, varin=23, theta=0.121223, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 12 = 1 gives z=27612016.420885
  % 	x12 = 1,	Z1 = 27612016.4208847        
DEBUG EVAL: First branch cutoff check: z=27612016.420885, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 5 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=23, theta=0.166667, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 5 = 0 gives z=27547547.771183
  % 	x5 = 0,	Z0 = 27547547.7711829        
DEBUG EVAL: First branch cutoff check: z=27547547.771183, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 10 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=16, varin=26, theta=0.611468, up=999999999999999983222784.000000
ITER 2: row=6, varin=23, theta=0.688473, up=999999999999999983222784.000000
ITER 3: row=1, varin=11, theta=1.909002, up=999999999999999983222784.000000
ITER 4: row=11, varin=20, theta=1.909002, up=999999999999999983222784.000000
ITER 5: row=21, varin=17, theta=1.181752, up=999999999999999983222784.000000
ITER 6: row=26, varin=22, theta=1.181752, up=999999999999999983222784.000000
ITER 7: row=28, varin=12, theta=0.454501, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 1 gives z=27647259.033019
  % 	x10 = 1,	Z1 = 27647259.0330188        
DEBUG EVAL: First branch cutoff check: z=27647259.033019, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 0
ITER 1: row=16, varin=6, theta=36244.666667, up=999999999999999983222784.000000
  % 	x10 = 0,	Z0 = 27541923.6460638        
DEBUG EVAL: Second branch cutoff check: z=27541923.646064, best_z=INF, threshold=INF
  % Best branch is x16, Z0 = 27612864.3331487        , Z1 = 27668821.5399036        

DEBUG CAREFUL: Final result - returning best.var = 16
DEBUG BB: Branching variable chosen: j=16
 % @NC   41   18	x16 = 0	27612864.333149
 % @NC   42   18	x16 = 1	27668821.539904
 %      18    19 27537158.3251               27546884.9903   x19 D    15     6
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ad4c48c600
% @LO 0.02  27.53715832507445071542 99.9000000000
% @LN 0.02  27.54688499028722503681 99.9000000000
% Resuming node 37 at  27.54688499028722503681
DEBUG CONSTRNT: LP rows=29, pool->nlprows=29, pool->npend=0
DEBUG CONSTRNT: Checking 29 LP rows (pool tracks 29, total LP rows 29)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 82
DEBUG CONSTRNT: Pool row 82 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 137
DEBUG CONSTRNT: Pool row 137 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 49
DEBUG CONSTRNT: Pool row 49 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 68
DEBUG CONSTRNT: Pool row 68 has lprow=28, expected 28
 % @PAP adding 28 rows, 168 nz to LP
DEBUG BB: Processing node 37, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=9, varin=22, theta=2.942398, up=999999999999999983222784.000000
ITER 2: row=26, varin=2, theta=1.942398, up=999999999999999983222784.000000
ITER 3: row=2, varin=24, theta=1.942398, up=999999999999999983222784.000000
ITER 4: row=23, varin=26, theta=0.942398, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=28)
DEBUG SOLUTION: LP solution array indices: FST[29-68], not_covered[69-88]
DEBUG SOLUTION: lp->best_solution[0] = 27546884.990287
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 0.000000
DEBUG SOLUTION: lp->best_solution[6] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 28 rows, 60 cols, 228 nonzeros, 4 slack, 24 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % @PAP adding 7 rows, 26 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=28, varin=23, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=27, varin=76, theta=1.057602, up=1.000000
ITER 3: row=27, varin=79, theta=0.057602, up=1.000000
ITER 4: row=2, varin=76, theta=1.000000, up=1.000000
ITER 5: row=30, varin=24, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=27, varin=83, theta=1.057602, up=1.000000
ITER 7: row=27, varin=9, theta=0.020438, up=999999999999999983222784.000000
ITER 8: row=25, varin=22, theta=0.454696, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=8)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=31)
DEBUG SOLUTION: LP solution array indices: FST[32-71], not_covered[72-91]
DEBUG SOLUTION: lp->best_solution[0] = 27560536.275435
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 0.000000
DEBUG SOLUTION: lp->best_solution[6] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.818232
DEBUG SOLUTION: lp->best_solution[10] = 0.818232
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 31 rows, 60 cols, 246 nonzeros, 8 slack, 23 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 8 slack rows
  % @PAP adding 8 rows, 36 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=27, varin=79, theta=0.145017, up=1.000000
ITER 2: row=26, varin=27, theta=4.653539, up=999999999999999983222784.000000
ITER 3: row=30, varin=83, theta=0.425803, up=1.000000
ITER 4: row=28, varin=80, theta=0.666667, up=1.000000
ITER 5: row=25, varin=40, theta=0.142857, up=1.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=31)
DEBUG SOLUTION: LP solution array indices: FST[32-71], not_covered[72-91]
DEBUG SOLUTION: lp->best_solution[0] = 27599636.937419
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.571429
DEBUG SOLUTION: lp->best_solution[5] = 0.000000
DEBUG SOLUTION: lp->best_solution[6] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 31 rows, 60 cols, 251 nonzeros, 5 slack, 26 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % Node 37 LP 1 Solution, length = 27599636.937419, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 1.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.373712 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.142857 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.142857 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.428571 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.428571 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 1.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.626288 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.571429 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.571429 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.571429 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.626288 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.571429 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.571429 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=27599636.937419, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 37 at  27.59963693741929446901
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ad4c49c780
% @LO 0.02  27.54688499028722503681 99.9000000000
% @LN 0.02  27.54874804722373227150 99.9000000000
% Resuming node 35 at  27.54874804722373227150
DEBUG CONSTRNT: LP rows=26, pool->nlprows=26, pool->npend=0
DEBUG CONSTRNT: Checking 26 LP rows (pool tracks 26, total LP rows 26)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 91
DEBUG CONSTRNT: Pool row 91 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=25, expected 25
 % @PAP adding 22 rows, 145 nz to LP
DEBUG BB: Processing node 35, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 35 LP 2 Solution, length = 27548748.047224, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.234946 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.234946 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.265054 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.734946 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 1.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.765054 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.265054 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.265054 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.265054 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.765054 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.734946 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.265054 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=27548748.047224, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=27548748.047224, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 35 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 35
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=1.000000
DEBUG CAREFUL: Skipping var 2: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.234946
DEBUG CAREFUL: Adding var 7 to fractional list (xi=0.234946)
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.234946
DEBUG CAREFUL: Adding var 8 to fractional list (xi=0.234946)
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.265054
DEBUG CAREFUL: Adding var 12 to fractional list (xi=0.265054)
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.734946
DEBUG CAREFUL: Adding var 14 to fractional list (xi=0.734946)
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=1.000000
DEBUG CAREFUL: Skipping var 20: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 4 fractional variables

  %  Carefully choosing branching variable, nfrac = 4
DEBUG CAREFUL: Testing fvar[0] = var 7
DEBUG CAREFUL: Calling compare_branch_vars for var 7
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 7
DEBUG CAREFUL: New best var: 7
DEBUG CAREFUL: Testing fvar[1] = var 8
DEBUG CAREFUL: Calling compare_branch_vars for var 8
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 8
DEBUG CAREFUL: Testing fvar[2] = var 14
DEBUG CAREFUL: Calling compare_branch_vars for var 14
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 14
DEBUG CAREFUL: Testing fvar[3] = var 12
DEBUG CAREFUL: Calling compare_branch_vars for var 12
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 12
  % Initial guess is x7, Z0 = 27548748.0472237        , Z1 = 27623169.6551798        

DEBUG EVAL: Testing var 7 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=67, theta=-8.171036, up=1.000000
ITER 2: row=20, varin=21, theta=1.272476, up=999999999999999983222784.000000
ITER 3: row=5, varin=19, theta=0.678027, up=999999999999999983222784.000000
ITER 4: row=19, varin=13, theta=1.402884, up=999999999999999983222784.000000
ITER 5: row=17, varin=2, theta=1.604326, up=999999999999999983222784.000000
ITER 6: row=2, varin=18, theta=1.604326, up=999999999999999983222784.000000
ITER 7: row=18, varin=14, theta=1.604326, up=999999999999999983222784.000000
ITER 8: row=14, varin=15, theta=0.402884, up=999999999999999983222784.000000
ITER 9: row=13, varin=25, theta=0.227185, up=1.000000
ITER 10: row=15, varin=65, theta=0.227185, up=1.000000
DEBUG EVAL: Branch var 7 = 1 gives z=27623826.883600
  % 	x7 = 1,	Z1 = 27623826.8836005        
DEBUG EVAL: First branch cutoff check: z=27623826.883600, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 7 = 0
ITER 1: row=1, varin=22, theta=0.484968, up=999999999999999983222784.000000
  % 	x7 = 0,	Z0 = 27549654.215119         
DEBUG EVAL: Second branch cutoff check: z=27549654.215119, best_z=INF, threshold=INF
  %   New best:  x7, Z = 27549654.215119         
DEBUG EVAL: Testing var 8 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=5, varin=22, theta=1.483978, up=999999999999999983222784.000000
ITER 2: row=1, varin=19, theta=1.185864, up=999999999999999983222784.000000
ITER 3: row=19, varin=13, theta=2.136691, up=999999999999999983222784.000000
ITER 4: row=17, varin=2, theta=2.205037, up=999999999999999983222784.000000
ITER 5: row=2, varin=18, theta=2.205037, up=999999999999999983222784.000000
ITER 6: row=18, varin=14, theta=1.205037, up=999999999999999983222784.000000
ITER 7: row=14, varin=15, theta=0.136691, up=999999999999999983222784.000000
ITER 8: row=13, varin=25, theta=0.077080, up=1.000000
ITER 9: row=14, varin=65, theta=0.077080, up=1.000000
DEBUG EVAL: Branch var 8 = 1 gives z=27618531.128801
  % 	x8 = 1,	Z1 = 27618531.1288009        
DEBUG EVAL: First branch cutoff check: z=27618531.128801, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 8 = 0
ITER 1: row=5, varin=28, theta=0.359405, up=1.000000
  % 	x8 = 0,	Z0 = 27557450.2357454        
DEBUG EVAL: Second branch cutoff check: z=27557450.235745, best_z=INF, threshold=INF
  %   New best:  x8, Z = 27557450.2357454        
DEBUG EVAL: Testing var 14 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=13, varin=28, theta=0.765407, up=1.000000
ITER 2: row=1, varin=19, theta=0.436816, up=999999999999999983222784.000000
ITER 3: row=3, varin=33, theta=0.813684, up=1.000000
ITER 4: row=13, varin=3, theta=0.623782, up=999999999999999983222784.000000
ITER 5: row=7, varin=21, theta=0.585875, up=999999999999999983222784.000000
ITER 6: row=5, varin=44, theta=0.305940, up=1.000000
DEBUG EVAL: Branch var 14 = 1 gives z=27648126.079235
  % 	x14 = 1,	Z1 = 27648126.0792352        
DEBUG EVAL: First branch cutoff check: z=27648126.079235, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 14 = 0
ITER 1: row=13, varin=67, theta=1.238055, up=1.000000
ITER 2: row=13, varin=21, theta=0.354383, up=999999999999999983222784.000000
  % 	x14 = 0,	Z0 = 27568768.7104324        
DEBUG EVAL: Second branch cutoff check: z=27568768.710432, best_z=INF, threshold=INF
  %   New best:  x14, Z = 27568768.7104324        
DEBUG EVAL: Testing var 12 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=6, varin=28, theta=0.765407, up=1.000000
ITER 2: row=1, varin=19, theta=0.436816, up=999999999999999983222784.000000
ITER 3: row=3, varin=6, theta=0.169900, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 12 = 0 gives z=27585383.975264
  % 	x12 = 0,	Z0 = 27585383.9752645        
DEBUG EVAL: First branch cutoff check: z=27585383.975264, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 12 = 1
ITER 1: row=6, varin=67, theta=1.238055, up=1.000000
ITER 2: row=6, varin=21, theta=0.354383, up=999999999999999983222784.000000
  % 	x12 = 1,	Z1 = 27568768.7104324        
DEBUG EVAL: Second branch cutoff check: z=27568768.710432, best_z=INF, threshold=INF
  % Best branch is x14, Z0 = 27568768.7104324        , Z1 = 27648126.0792352        

DEBUG CAREFUL: Final result - returning best.var = 14
DEBUG BB: Branching variable chosen: j=14
 % @NC   43   35	x14 = 0	27568768.710432
 % @NC   44   35	x14 = 1	27648126.079235
 %      35    20 27548748.0472               27555491.0771   x16 D    29     5
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ad4c4af9e0
% @LO 0.02  27.54874804722373227150 99.9000000000
% @LN 0.02  27.55549107708641543013 99.9000000000
% Resuming node 39 at  27.55549107708641543013
DEBUG CONSTRNT: LP rows=22, pool->nlprows=22, pool->npend=0
DEBUG CONSTRNT: Checking 22 LP rows (pool tracks 22, total LP rows 22)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 79
DEBUG CONSTRNT: Pool row 79 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=21, expected 21
 % @PAP adding 41 rows, 172 nz to LP
DEBUG BB: Processing node 39, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=27, varin=27, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=41)
DEBUG SOLUTION: LP solution array indices: FST[42-81], not_covered[82-101]
DEBUG SOLUTION: lp->best_solution[0] = 27555491.077086
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 41 rows, 60 cols, 232 nonzeros, 2 slack, 39 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 7 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=42, varin=33, theta=1.250000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 27563822.683856
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 43 rows, 60 cols, 239 nonzeros, 3 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % Node 39 LP 1 Solution, length = 27563822.683856, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.250000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.250000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.250000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.250000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.250000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.750000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.750000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.750000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.750000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.750000 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=27563822.683856, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 39 at  27.56382268385624101370
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ad4c4a0450
% @LO 0.02  27.55549107708641543013 99.9000000000
% @LN 0.02  27.55658406564155171736 99.9000000000
% Resuming node 23 at  27.55658406564155171736
DEBUG CONSTRNT: LP rows=40, pool->nlprows=40, pool->npend=0
DEBUG CONSTRNT: Checking 40 LP rows (pool tracks 40, total LP rows 40)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 133
DEBUG CONSTRNT: Pool row 133 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=39, expected 39
 % @PAP adding 30 rows, 185 nz to LP
DEBUG BB: Processing node 23, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=5, varin=7, theta=2.046434, up=999999999999999983222784.000000
ITER 2: row=8, varin=5, theta=1.046434, up=999999999999999983222784.000000
ITER 3: row=16, varin=32, theta=0.045701, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=30)
DEBUG SOLUTION: LP solution array indices: FST[31-70], not_covered[71-90]
DEBUG SOLUTION: lp->best_solution[0] = 27556584.065641
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 0.045701
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 0.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 30 rows, 60 cols, 245 nonzeros, 2 slack, 28 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 3 rows, 11 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=32, varin=8, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=31, varin=91, theta=1.045701, up=1.000000
ITER 3: row=31, varin=12, theta=0.020951, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=33)
DEBUG SOLUTION: LP solution array indices: FST[34-73], not_covered[74-93]
DEBUG SOLUTION: lp->best_solution[0] = 27558408.203672
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 0.020951
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.020951
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.979049
DEBUG SOLUTION: lp->best_solution[13] = 0.979049
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 33 rows, 60 cols, 256 nonzeros, 5 slack, 28 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % @PAP adding 4 rows, 15 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=31, varin=90, theta=0.671298, up=1.000000
ITER 2: row=29, varin=5, theta=0.479393, up=999999999999999983222784.000000
ITER 3: row=4, varin=3, theta=0.044950, up=999999999999999983222784.000000
ITER 4: row=10, varin=13, theta=0.040496, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=32)
DEBUG SOLUTION: LP solution array indices: FST[33-72], not_covered[73-92]
DEBUG SOLUTION: lp->best_solution[0] = 27601682.585801
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 0.540496
DEBUG SOLUTION: lp->best_solution[6] = 0.500000
DEBUG SOLUTION: lp->best_solution[7] = 0.000000
DEBUG SOLUTION: lp->best_solution[8] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.959504
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 32 rows, 60 cols, 253 nonzeros, 5 slack, 27 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % Node 23 LP 1 Solution, length = 27601682.585801, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.040496 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.459504 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.500000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 1.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.500000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.540496 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.500000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 3 fractional variables
DEBUG CG: LP optimal, z=27601682.585801, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 23 at  27.60168258580067046637
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ad4c4af9e0
% @LO 0.02  27.55658406564155171736 99.9000000000
% @LN 0.02  27.56382268385624101370 99.9000000000
% Resuming node 39 at  27.56382268385624101370
DEBUG CONSTRNT: LP rows=27, pool->nlprows=27, pool->npend=0
DEBUG CONSTRNT: Checking 27 LP rows (pool tracks 27, total LP rows 27)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=26, expected 26
 % @PAP adding 40 rows, 164 nz to LP
DEBUG BB: Processing node 39, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 39 LP 2 Solution, length = 27563822.683856, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.250000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.250000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.250000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.250000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.250000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.750000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.750000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.750000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.750000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.750000 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=27563822.683856, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=27563822.683856, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 39 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 39
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=1.000000
DEBUG CAREFUL: Skipping var 2: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.250000
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.250000
DEBUG CAREFUL: Adding var 4 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=1.000000
DEBUG CAREFUL: Skipping var 7: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.250000
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.250000
DEBUG CAREFUL: Adding var 11 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.250000
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 10
DEBUG CAREFUL: New best var: 10
DEBUG CAREFUL: Testing fvar[1] = var 4
DEBUG CAREFUL: Calling compare_branch_vars for var 4
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 4
DEBUG CAREFUL: New best var: 4
DEBUG CAREFUL: Testing fvar[2] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 3
DEBUG CAREFUL: Testing fvar[3] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
DEBUG CAREFUL: Testing fvar[4] = var 11
DEBUG CAREFUL: Calling compare_branch_vars for var 11
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 11
  % Initial guess is x4, Z0 = 27563822.6838562        , Z1 = 27721710.6446553        

DEBUG EVAL: Testing var 10 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=18, varin=64, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 10 = 0 gives z=27579696.758735
  % 	x10 = 0,	Z0 = 27579696.7587352        
DEBUG EVAL: First branch cutoff check: z=27579696.758735, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 1
ITER 1: row=18, varin=39, theta=3.000000, up=999999999999999983222784.000000
ITER 2: row=39, varin=38, theta=1.500000, up=999999999999999983222784.000000
ITER 3: row=1, varin=12, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=12, varin=37, theta=0.500000, up=999999999999999983222784.000000
  % 	x10 = 1,	Z1 = 27658584.9081049        
DEBUG EVAL: Second branch cutoff check: z=27658584.908105, best_z=INF, threshold=INF
  %   New best:  x10, Z = 27579696.7587352        
DEBUG EVAL: Testing var 4 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=20, varin=39, theta=3.000000, up=999999999999999983222784.000000
ITER 2: row=39, varin=38, theta=1.500000, up=999999999999999983222784.000000
ITER 3: row=1, varin=12, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=12, varin=36, theta=0.500000, up=999999999999999983222784.000000
ITER 5: row=36, varin=33, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=33, varin=32, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=32, varin=29, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 4 = 1 gives z=27690424.126085
  % 	x4 = 1,	Z1 = 27721710.6446553        
DEBUG EVAL: First branch cutoff check: z=27721710.644655, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 4 = 0
ITER 1: row=20, varin=64, theta=1.000000, up=1.000000
  % 	x4 = 0,	Z0 = 27579696.7587352        
DEBUG EVAL: Second branch cutoff check: z=27579696.758735, best_z=INF, threshold=INF
  %   New best:  x4, Z = 27579696.7587352        
DEBUG EVAL: Testing var 3 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=39, theta=3.000000, up=999999999999999983222784.000000
ITER 2: row=39, varin=36, theta=0.750000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 3 = 1 gives z=27626478.851277
  % 	x3 = 1,	Z1 = 27626478.8512766        
DEBUG EVAL: First branch cutoff check: z=27626478.851277, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 3 = 0
ITER 1: row=1, varin=64, theta=1.000000, up=1.000000
  % 	x3 = 0,	Z0 = 27579696.7587352        
DEBUG EVAL: Second branch cutoff check: z=27579696.758735, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 26 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=29, varin=64, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 26 = 0 gives z=27579696.758735
  % 	x26 = 0,	Z0 = 27579696.7587352        
DEBUG EVAL: First branch cutoff check: z=27579696.758735, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 26 = 1
ITER 1: row=29, varin=39, theta=3.000000, up=999999999999999983222784.000000
ITER 2: row=39, varin=38, theta=1.500000, up=999999999999999983222784.000000
ITER 3: row=1, varin=12, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=12, varin=37, theta=0.500000, up=999999999999999983222784.000000
  % 	x26 = 1,	Z1 = 27658584.9081049        
DEBUG EVAL: Second branch cutoff check: z=27658584.908105, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 11 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=36, varin=39, theta=3.000000, up=999999999999999983222784.000000
ITER 2: row=39, varin=12, theta=3.000000, up=999999999999999983222784.000000
ITER 3: row=12, varin=37, theta=1.500000, up=999999999999999983222784.000000
ITER 4: row=20, varin=33, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=33, varin=32, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=32, varin=29, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 11 = 1 gives z=27760239.001367
  % 	x11 = 1,	Z1 = 27760239.0013675        
DEBUG EVAL: First branch cutoff check: z=27760239.001367, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 11 = 0
ITER 1: row=36, varin=64, theta=1.000000, up=1.000000
  % 	x11 = 0,	Z0 = 27579696.7587352        
DEBUG EVAL: Second branch cutoff check: z=27579696.758735, best_z=INF, threshold=INF
  %   New best:  x11, Z = 27579696.7587352        
  % Best branch is x11, Z0 = 27579696.7587352        , Z1 = 27760239.0013675        

DEBUG CAREFUL: Final result - returning best.var = 11
DEBUG BB: Branching variable chosen: j=11
 % @NC   45   39	x11 = 0	27579696.758735
 % @NC   46   39	x11 = 1	27760239.001367
 %      39    21 27563822.6839               27568768.7104    x0 D    33     6
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ad4c4ae540
% @LO 0.03  27.56382268385624101370 99.9000000000
% @LN 0.03  27.56876871043242616111 99.9000000000
% Resuming node 43 at  27.56876871043242616111
DEBUG CONSTRNT: LP rows=40, pool->nlprows=40, pool->npend=0
DEBUG CONSTRNT: Checking 40 LP rows (pool tracks 40, total LP rows 40)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 133
DEBUG CONSTRNT: Pool row 133 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=39, expected 39
 % @PAP adding 22 rows, 145 nz to LP
DEBUG BB: Processing node 43, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=13, varin=67, theta=1.238055, up=1.000000
ITER 2: row=13, varin=21, theta=0.354383, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=22)
DEBUG SOLUTION: LP solution array indices: FST[23-62], not_covered[63-82]
DEBUG SOLUTION: lp->best_solution[0] = 27568768.710432
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 22 rows, 60 cols, 205 nonzeros, 2 slack, 20 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 5 rows, 27 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=25, varin=16, theta=0.104497, up=999999999999999983222784.000000
ITER 2: row=26, varin=17, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=24, varin=25, theta=11.567665, up=999999999999999983222784.000000
ITER 4: row=21, varin=72, theta=1.053071, up=1.000000
ITER 5: row=21, varin=33, theta=0.090977, up=1.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=27)
DEBUG SOLUTION: LP solution array indices: FST[28-67], not_covered[68-87]
DEBUG SOLUTION: lp->best_solution[0] = 27614227.038901
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 27 rows, 60 cols, 232 nonzeros, 5 slack, 22 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % @PAP adding 3 rows, 15 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=25, varin=15, theta=0.052632, up=999999999999999983222784.000000
ITER 2: row=24, varin=25, theta=1.918514, up=999999999999999983222784.000000
ITER 3: row=23, varin=36, theta=0.090553, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=25)
DEBUG SOLUTION: LP solution array indices: FST[26-65], not_covered[66-85]
DEBUG SOLUTION: lp->best_solution[0] = 27632862.850576
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 25 rows, 60 cols, 220 nonzeros, 2 slack, 23 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 3 rows, 9 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=24, varin=44, theta=0.068130, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=26)
DEBUG SOLUTION: LP solution array indices: FST[27-66], not_covered[67-86]
DEBUG SOLUTION: lp->best_solution[0] = 27633090.491459
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 26 rows, 60 cols, 216 nonzeros, 0 slack, 26 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 6 rows, 27 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=27, varin=16, theta=0.208246, up=999999999999999983222784.000000
ITER 2: row=3, varin=6, theta=0.088901, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=32)
DEBUG SOLUTION: LP solution array indices: FST[33-72], not_covered[73-92]
DEBUG SOLUTION: lp->best_solution[0] = 27637272.264257
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.911099
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 32 rows, 60 cols, 243 nonzeros, 1 slack, 31 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 43 LP 1 Solution, length = 27637272.264257, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.303700 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.303700 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.303700 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.911099 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 1.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.696300 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.696300 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.088901 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.696300 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.088901 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.088901 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=27637272.264257, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 43 at  27.63727226425704230905
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ad4c49c780
% @LO 0.03  27.56876871043242616111 99.9000000000
% @LN 0.03  27.57969675873523840437 99.9000000000
% Resuming node 45 at  27.57969675873523840437
DEBUG CONSTRNT: LP rows=31, pool->nlprows=31, pool->npend=0
DEBUG CONSTRNT: Checking 31 LP rows (pool tracks 31, total LP rows 31)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 79
DEBUG CONSTRNT: Pool row 79 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 45
DEBUG CONSTRNT: Pool row 45 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 141
DEBUG CONSTRNT: Pool row 141 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 145
DEBUG CONSTRNT: Pool row 145 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 159
DEBUG CONSTRNT: Pool row 159 has lprow=30, expected 30
 % @PAP adding 40 rows, 164 nz to LP
DEBUG BB: Processing node 45, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=36, varin=64, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=40)
DEBUG SOLUTION: LP solution array indices: FST[41-80], not_covered[81-100]
DEBUG SOLUTION: lp->best_solution[0] = 27579696.758735
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 40 rows, 60 cols, 224 nonzeros, 0 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 5 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=41, varin=38, theta=0.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 27583774.279392
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 42 rows, 60 cols, 229 nonzeros, 1 slack, 41 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 2 rows, 9 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=42, varin=66, theta=1.000000, up=1.000000
ITER 2: row=43, varin=68, theta=1.000000, up=1.000000
ITER 3: row=41, varin=36, theta=0.166667, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 27602570.755343
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 43 rows, 60 cols, 236 nonzeros, 1 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 2 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=43, varin=11, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=11, varin=42, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 27614057.906507
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 44 rows, 60 cols, 238 nonzeros, 1 slack, 43 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 45 LP 1 Solution, length = 27614057.906507, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.333333 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.333333 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.333333 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.333333 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.333333 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.666667 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.666667 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.666667 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.666667 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.666667 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=27614057.906507, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 45 at  27.61405790650746183701
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ad4c48c600
% @LO 0.03  27.57969675873523840437 99.9000000000
% @LN 0.03  27.59963693741929446901 99.9000000000
% Resuming node 37 at  27.59963693741929446901
DEBUG CONSTRNT: LP rows=43, pool->nlprows=43, pool->npend=0
DEBUG CONSTRNT: Checking 43 LP rows (pool tracks 43, total LP rows 43)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 133
DEBUG CONSTRNT: Pool row 133 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=42, expected 42
 % @PAP adding 26 rows, 161 nz to LP
DEBUG BB: Processing node 37, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 37 LP 2 Solution, length = 27599636.937419, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 1.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.373712 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.142857 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.142857 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.428571 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.428571 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 1.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.626288 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.571429 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.571429 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.571429 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.626288 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.571429 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.571429 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=27599636.937419, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=27599636.937419, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 3 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 37 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 37
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=1.000000
DEBUG CAREFUL: Skipping var 1: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=1.000000
DEBUG CAREFUL: Skipping var 2: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.373712
DEBUG CAREFUL: Adding var 5 to fractional list (xi=0.373712)
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.142857
DEBUG CAREFUL: Adding var 8 to fractional list (xi=0.142857)
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.142857
DEBUG CAREFUL: Adding var 12 to fractional list (xi=0.142857)
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.428571
DEBUG CAREFUL: Adding var 14 to fractional list (xi=0.428571)
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.428571
DEBUG CAREFUL: Adding var 15 to fractional list (xi=0.428571)
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=1.000000
DEBUG CAREFUL: Skipping var 17: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 8
DEBUG CAREFUL: Calling compare_branch_vars for var 8
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 8
DEBUG CAREFUL: New best var: 8
DEBUG CAREFUL: Testing fvar[1] = var 14
DEBUG CAREFUL: Calling compare_branch_vars for var 14
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 14
DEBUG CAREFUL: Testing fvar[2] = var 12
DEBUG CAREFUL: Calling compare_branch_vars for var 12
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 12
DEBUG CAREFUL: Testing fvar[3] = var 15
DEBUG CAREFUL: Calling compare_branch_vars for var 15
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 15
DEBUG CAREFUL: Testing fvar[4] = var 5
DEBUG CAREFUL: Calling compare_branch_vars for var 5
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 5
  % Initial guess is x8, Z0 = 27599636.9374193        , Z1 = 27690840.2020288        

DEBUG EVAL: Testing var 8 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=5, varin=23, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=24, varin=25, theta=0.750000, up=999999999999999983222784.000000
ITER 3: row=7, varin=2, theta=3.000000, up=999999999999999983222784.000000
ITER 4: row=2, varin=19, theta=3.000000, up=999999999999999983222784.000000
ITER 5: row=20, varin=3, theta=2.061162, up=999999999999999983222784.000000
ITER 6: row=3, varin=8, theta=2.061162, up=999999999999999983222784.000000
ITER 7: row=8, varin=9, theta=2.061162, up=999999999999999983222784.000000
ITER 8: row=9, varin=11, theta=2.061162, up=999999999999999983222784.000000
ITER 9: row=11, varin=12, theta=2.061162, up=999999999999999983222784.000000
ITER 10: row=12, varin=13, theta=2.061162, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 8 = 1 gives z=27690840.202029
  % 	x8 = 1,	Z1 = 27690840.2020288        
DEBUG EVAL: First branch cutoff check: z=27690840.202029, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 8 = 0
ITER 1: row=5, varin=37, theta=0.277778, up=1.000000
ITER 2: row=16, varin=36, theta=0.277778, up=1.000000
  % 	x8 = 0,	Z0 = 27604560.1289323        
DEBUG EVAL: Second branch cutoff check: z=27604560.128932, best_z=INF, threshold=INF
  %   New best:  x8, Z = 27604560.1289323        
DEBUG EVAL: Testing var 14 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=7, varin=23, theta=0.600000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 14 = 0 gives z=27604467.074984
  % 	x14 = 0,	Z0 = 27604467.0749839        
DEBUG EVAL: First branch cutoff check: z=27604467.074984, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 12 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=6, varin=23, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=24, varin=25, theta=0.750000, up=999999999999999983222784.000000
ITER 3: row=7, varin=2, theta=3.000000, up=999999999999999983222784.000000
ITER 4: row=2, varin=19, theta=3.000000, up=999999999999999983222784.000000
ITER 5: row=20, varin=3, theta=2.061162, up=999999999999999983222784.000000
ITER 6: row=3, varin=8, theta=2.061162, up=999999999999999983222784.000000
ITER 7: row=8, varin=9, theta=2.061162, up=999999999999999983222784.000000
ITER 8: row=9, varin=11, theta=2.061162, up=999999999999999983222784.000000
ITER 9: row=11, varin=12, theta=2.061162, up=999999999999999983222784.000000
ITER 10: row=12, varin=13, theta=2.061162, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 12 = 1 gives z=27690840.202029
  % 	x12 = 1,	Z1 = 27690840.2020288        
DEBUG EVAL: First branch cutoff check: z=27690840.202029, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 12 = 0
ITER 1: row=6, varin=37, theta=0.277778, up=1.000000
ITER 2: row=16, varin=36, theta=0.277778, up=1.000000
  % 	x12 = 0,	Z0 = 27604560.1289323        
DEBUG EVAL: Second branch cutoff check: z=27604560.128932, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 15 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=19, varin=24, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 15 = 0 gives z=27621987.796348
  % 	x15 = 0,	Z0 = 27621987.7963481        
DEBUG EVAL: First branch cutoff check: z=27621987.796348, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 15 = 1
ITER 1: row=19, varin=37, theta=2.222222, up=1.000000
ITER 2: row=19, varin=23, theta=1.100000, up=999999999999999983222784.000000
ITER 3: row=16, varin=37, theta=1.000000, up=1.000000
ITER 4: row=24, varin=36, theta=1.111111, up=1.000000
ITER 5: row=24, varin=25, theta=0.200000, up=999999999999999983222784.000000
ITER 6: row=1, varin=36, theta=1.306182, up=1.000000
ITER 7: row=1, varin=29, theta=0.339420, up=1.000000
ITER 8: row=7, varin=36, theta=1.111111, up=1.000000
ITER 9: row=7, varin=30, theta=0.100000, up=1.000000
ITER 10: row=1, varin=36, theta=0.487160, up=1.000000
  % 	x15 = 1,	Z1 = 27791481.591389         
DEBUG EVAL: Second branch cutoff check: z=27791481.591389, best_z=INF, threshold=INF
  %   New best:  x15, Z = 27621987.7963481        
DEBUG EVAL: Testing var 5 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=6, theta=0.939334, up=999999999999999983222784.000000
ITER 2: row=5, varin=23, theta=0.726881, up=999999999999999983222784.000000
ITER 3: row=7, varin=29, theta=0.443841, up=1.000000
DEBUG EVAL: Branch var 5 = 1 gives z=27717406.083095
  % 	x5 = 1,	Z1 = 27717406.0830952        
DEBUG EVAL: First branch cutoff check: z=27717406.083095, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 5 = 0
ITER 1: row=1, varin=37, theta=0.687429, up=1.000000
ITER 2: row=16, varin=36, theta=0.400339, up=1.000000
ITER 3: row=5, varin=23, theta=0.128726, up=999999999999999983222784.000000
  % 	x5 = 0,	Z0 = 27607497.6208139        
DEBUG EVAL: Second branch cutoff check: z=27607497.620814, best_z=INF, threshold=INF
  % Best branch is x15, Z0 = 27621987.7963481        , Z1 = 27791481.591389         

DEBUG CAREFUL: Final result - returning best.var = 15
DEBUG BB: Branching variable chosen: j=15
 % @NC   47   37	x15 = 0	27621987.796348
 % @NC   48   37	x15 = 1	27791481.591389
 %      37    22 27599636.9374               27601682.5858   x16 D    20     7
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ad4c4a0450
% @LO 0.03  27.59963693741929446901 99.9000000000
% @LN 0.03  27.60168258580067046637 99.9000000000
% Resuming node 23 at  27.60168258580067046637
DEBUG CONSTRNT: LP rows=26, pool->nlprows=26, pool->npend=0
DEBUG CONSTRNT: Checking 26 LP rows (pool tracks 26, total LP rows 26)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 91
DEBUG CONSTRNT: Pool row 91 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=25, expected 25
 % @PAP adding 27 rows, 166 nz to LP
DEBUG BB: Processing node 23, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 23 LP 2 Solution, length = 27601682.585801, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.040496 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.459504 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.500000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 1.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.500000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.540496 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.500000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 3 fractional variables
DEBUG CG: LP optimal, z=27601682.585801, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=27601682.585801, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 23 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 23
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=1.000000
DEBUG CAREFUL: Skipping var 2: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=1.000000
DEBUG CAREFUL: Skipping var 7: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.040496
DEBUG CAREFUL: Adding var 12 to fractional list (xi=0.040496)
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.459504
DEBUG CAREFUL: Adding var 14 to fractional list (xi=0.459504)
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.500000
DEBUG CAREFUL: Adding var 15 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=1.000000
DEBUG CAREFUL: Skipping var 17: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 3 fractional variables

  %  Carefully choosing branching variable, nfrac = 3
DEBUG CAREFUL: Testing fvar[0] = var 15
DEBUG CAREFUL: Calling compare_branch_vars for var 15
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 15
DEBUG CAREFUL: New best var: 15
DEBUG CAREFUL: Testing fvar[1] = var 12
DEBUG CAREFUL: Calling compare_branch_vars for var 12
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 12
DEBUG CAREFUL: Testing fvar[2] = var 14
DEBUG CAREFUL: Calling compare_branch_vars for var 14
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 14
  % Initial guess is x15, Z0 = 27601682.5858007        , Z1 = 27601682.5858007        

DEBUG EVAL: Testing var 15 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=7, varin=4, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=4, varin=25, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 15 = 0 gives z=27648373.264628
  % 	x15 = 0,	Z0 = 27648373.2646276        
DEBUG EVAL: First branch cutoff check: z=27648373.264628, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 15 = 1
ITER 1: row=7, varin=33, theta=0.500000, up=1.000000
ITER 2: row=6, varin=54, theta=1.382571, up=1.000000
ITER 3: row=6, varin=49, theta=0.321962, up=1.000000
ITER 4: row=7, varin=4, theta=0.321357, up=999999999999999983222784.000000
ITER 5: row=4, varin=54, theta=2.032266, up=1.000000
ITER 6: row=4, varin=81, theta=0.166430, up=1.000000
ITER 7: row=6, varin=54, theta=0.198421, up=1.000000
  % 	x15 = 1,	Z1 = 27902927.2291761        
DEBUG EVAL: Second branch cutoff check: z=27902927.229176, best_z=INF, threshold=INF
  %   New best:  x15, Z = 27648373.2646276        
DEBUG EVAL: Testing var 12 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=4, theta=0.049431, up=999999999999999983222784.000000
ITER 2: row=4, varin=81, theta=0.050304, up=1.000000
DEBUG EVAL: Branch var 12 = 0 gives z=27604236.050406
  % 	x12 = 0,	Z0 = 27604236.0504056        
DEBUG EVAL: First branch cutoff check: z=27604236.050406, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 14 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=6, varin=73, theta=0.510050, up=1.000000
ITER 2: row=3, varin=33, theta=0.174340, up=1.000000
DEBUG EVAL: Branch var 14 = 0 gives z=27620501.295482
  % 	x14 = 0,	Z0 = 27620501.2954818        
DEBUG EVAL: First branch cutoff check: z=27620501.295482, best_z=INF, threshold=INF
  % Best branch is x15, Z0 = 27648373.2646276        , Z1 = 27902927.2291761        

DEBUG CAREFUL: Final result - returning best.var = 15
DEBUG BB: Branching variable chosen: j=15
 % @NC   49   23	x15 = 0	27648373.264628
 % @NC   50   23	x15 = 1	27902927.229176
 %      23    23 27601682.5858               27612864.3331   x19 D    14     4
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ad4c4b2e60
% @LO 0.03  27.60168258580067046637 99.9000000000
% @LN 0.03  27.61286433314871757716 99.9000000000
% Resuming node 41 at  27.61286433314871757716
DEBUG CONSTRNT: LP rows=27, pool->nlprows=27, pool->npend=0
DEBUG CONSTRNT: Checking 27 LP rows (pool tracks 27, total LP rows 27)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=26, expected 26
 % @PAP adding 29 rows, 179 nz to LP
DEBUG BB: Processing node 41, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=19, varin=22, theta=5.000000, up=999999999999999983222784.000000
ITER 2: row=28, varin=19, theta=4.000000, up=999999999999999983222784.000000
ITER 3: row=20, varin=20, theta=3.000000, up=999999999999999983222784.000000
ITER 4: row=21, varin=27, theta=2.000000, up=999999999999999983222784.000000
ITER 5: row=23, varin=21, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=16, varin=26, theta=0.025003, up=999999999999999983222784.000000
ITER 7: row=6, varin=23, theta=0.028028, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=7)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=29)
DEBUG SOLUTION: LP solution array indices: FST[30-69], not_covered[70-89]
DEBUG SOLUTION: lp->best_solution[0] = 27612864.333149
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 0.000000
DEBUG SOLUTION: lp->best_solution[6] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 29 rows, 60 cols, 239 nonzeros, 9 slack, 20 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 9 slack rows
  % @PAP adding 3 rows, 18 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=21, varin=19, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=23, varin=66, theta=1.056057, up=1.000000
ITER 3: row=23, varin=71, theta=0.056057, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=23)
DEBUG SOLUTION: LP solution array indices: FST[24-63], not_covered[64-83]
DEBUG SOLUTION: lp->best_solution[0] = 27612864.333149
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 0.000000
DEBUG SOLUTION: lp->best_solution[6] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 23 rows, 60 cols, 225 nonzeros, 3 slack, 20 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 12 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=24, varin=70, theta=0.971972, up=1.000000
ITER 2: row=27, varin=79, theta=1.028028, up=1.000000
ITER 3: row=27, varin=86, theta=0.028028, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=27)
DEBUG SOLUTION: LP solution array indices: FST[28-67], not_covered[68-87]
DEBUG SOLUTION: lp->best_solution[0] = 27612864.333149
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 0.000000
DEBUG SOLUTION: lp->best_solution[6] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 27 rows, 60 cols, 237 nonzeros, 5 slack, 22 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 3 rows, 13 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=28, varin=82, theta=0.971972, up=1.000000
ITER 2: row=30, varin=9, theta=0.250000, up=999999999999999983222784.000000
ITER 3: row=26, varin=40, theta=0.126473, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=30)
DEBUG SOLUTION: LP solution array indices: FST[31-70], not_covered[71-90]
DEBUG SOLUTION: lp->best_solution[0] = 27636053.192041
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 0.000000
DEBUG SOLUTION: lp->best_solution[6] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.813237
DEBUG SOLUTION: lp->best_solution[10] = 0.813237
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 30 rows, 60 cols, 250 nonzeros, 7 slack, 23 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 7 slack rows
  % @PAP adding 4 rows, 16 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=24, varin=76, theta=0.227170, up=1.000000
ITER 2: row=26, varin=36, theta=0.297218, up=1.000000
ITER 3: row=25, varin=21, theta=0.102000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=27)
DEBUG SOLUTION: LP solution array indices: FST[28-67], not_covered[68-87]
DEBUG SOLUTION: lp->best_solution[0] = 27644592.049035
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 0.000000
DEBUG SOLUTION: lp->best_solution[6] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 27 rows, 60 cols, 226 nonzeros, 1 slack, 26 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 2 rows, 16 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=28, varin=39, theta=0.074587, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=28)
DEBUG SOLUTION: LP solution array indices: FST[29-68], not_covered[69-88]
DEBUG SOLUTION: lp->best_solution[0] = 27645171.986233
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 0.000000
DEBUG SOLUTION: lp->best_solution[6] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 28 rows, 60 cols, 240 nonzeros, 2 slack, 26 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=27, varin=24, theta=0.234750, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=27)
DEBUG SOLUTION: LP solution array indices: FST[28-67], not_covered[68-87]
DEBUG SOLUTION: lp->best_solution[0] = 27645450.596642
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.941313
DEBUG SOLUTION: lp->best_solution[5] = 0.000000
DEBUG SOLUTION: lp->best_solution[6] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 27 rows, 60 cols, 232 nonzeros, 2 slack, 25 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % Node 41 LP 1 Solution, length = 27645450.596642, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.800000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.141313 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.058687 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.058687 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.141313 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.058687 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.800000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 1.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.200000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.200000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.941313 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.200000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.200000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.941313 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.941313 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.200000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.200000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 7 fractional variables
DEBUG CG: LP optimal, z=27645450.596642, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 41 at  27.64545059664152759638
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ad4c4ad660
% @LO 0.03  27.61286433314871757716 99.9000000000
% @LN 0.03  27.61296288183794089832 99.9000000000
% Resuming node 31 at  27.61296288183794089832
DEBUG CONSTRNT: LP rows=25, pool->nlprows=25, pool->npend=0
DEBUG CONSTRNT: Checking 25 LP rows (pool tracks 25, total LP rows 25)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=24, expected 24
 % @PAP adding 47 rows, 228 nz to LP
DEBUG BB: Processing node 31, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=18, varin=47, theta=5.223511, up=999999999999999983222784.000000
ITER 2: row=27, varin=25, theta=1.187637, up=999999999999999983222784.000000
ITER 3: row=25, varin=22, theta=0.756712, up=999999999999999983222784.000000
ITER 4: row=34, varin=75, theta=0.714872, up=1.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 27612962.881838
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 47 rows, 60 cols, 288 nonzeros, 2 slack, 45 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=46, varin=33, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=9, varin=78, theta=0.887971, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=46)
DEBUG SOLUTION: LP solution array indices: FST[47-86], not_covered[87-106]
DEBUG SOLUTION: lp->best_solution[0] = 28240441.367179
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 46 rows, 60 cols, 286 nonzeros, 2 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 2 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=46, varin=49, theta=0.333333, up=1.000000
ITER 2: row=45, varin=46, theta=0.500000, up=999999999999999983222784.000000
ITER 3: row=22, varin=51, theta=0.314592, up=1.000000
ITER 4: row=24, varin=77, theta=0.531187, up=1.000000
ITER 5: row=43, varin=24, theta=0.654572, up=999999999999999983222784.000000
ITER 6: row=22, varin=26, theta=0.789951, up=999999999999999983222784.000000
ITER 7: row=1, varin=50, theta=1.149478, up=1.000000
ITER 8: row=1, varin=25, theta=0.078854, up=999999999999999983222784.000000
ITER 9: row=24, varin=50, theta=3.441577, up=1.000000
ITER 10: row=24, varin=58, theta=23.463952, up=1.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=46)
DEBUG SOLUTION: LP solution array indices: FST[47-86], not_covered[87-106]
DEBUG SOLUTION: lp->best_solution[0] = 999999999999999983222784.000000
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 46 rows, 60 cols, 287 nonzeros, 4 slack, 42 tight.
  % Node 31 LP 1 Solution, length = 999999999999999983222784.000000, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.056015 (FST 9)
  % DEBUG LP_VARS: x[10] = 1.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 1.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 1.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.887971 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.056015 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.943985 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
DEBUG BB: compute_good_lower_bound returned status=1
DEBUG BB: Node 31 is INFEASIBLE
 %      31    22    infeasible               27614057.9065   x10 U    25     8
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ad4c49c780
% @LO 0.03  27.61296288183794089832 99.9000000000
% @LN 0.03  27.61405790650746183701 99.9000000000
% Resuming node 45 at  27.61405790650746183701
DEBUG CONSTRNT: LP rows=46, pool->nlprows=46, pool->npend=0
DEBUG CONSTRNT: Checking 46 LP rows (pool tracks 46, total LP rows 46)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 133
DEBUG CONSTRNT: Pool row 133 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 158
DEBUG CONSTRNT: Pool row 158 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=45, expected 45
 % @PAP adding 43 rows, 171 nz to LP
DEBUG BB: Processing node 45, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 45 LP 2 Solution, length = 27614057.906507, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.333333 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.333333 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.333333 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.333333 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.333333 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.666667 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.666667 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.666667 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.666667 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.666667 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=27614057.906507, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=27614057.906507, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 45 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 45
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=1.000000
DEBUG CAREFUL: Skipping var 2: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.333333
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.333333
DEBUG CAREFUL: Adding var 4 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=1.000000
DEBUG CAREFUL: Skipping var 7: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.333333
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.333333
DEBUG CAREFUL: Adding var 22 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.333333
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 3
DEBUG CAREFUL: New best var: 3
DEBUG CAREFUL: Testing fvar[1] = var 22
DEBUG CAREFUL: Calling compare_branch_vars for var 22
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 22
DEBUG CAREFUL: Testing fvar[2] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 10
DEBUG CAREFUL: New best var: 10
DEBUG CAREFUL: Testing fvar[3] = var 4
DEBUG CAREFUL: Calling compare_branch_vars for var 4
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 4
DEBUG CAREFUL: New best var: 4
DEBUG CAREFUL: Testing fvar[4] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
  % Initial guess is x4, Z0 = 27614057.9065075        , Z1 = 27721710.6446553        

DEBUG EVAL: Testing var 3 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=59, theta=2.000000, up=1.000000
ITER 2: row=1, varin=40, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=10, varin=59, theta=1.000000, up=1.000000
ITER 4: row=40, varin=42, theta=2.000000, up=999999999999999983222784.000000
ITER 5: row=36, varin=41, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 3 = 1 gives z=27667315.835953
  % 	x3 = 1,	Z1 = 27667315.8359526        
DEBUG EVAL: First branch cutoff check: z=27667315.835953, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 3 = 0
ITER 1: row=1, varin=28, theta=1.000000, up=999999999999999983222784.000000
  % 	x3 = 0,	Z0 = 27633358.5466093        
DEBUG EVAL: Second branch cutoff check: z=27633358.546609, best_z=INF, threshold=INF
  %   New best:  x3, Z = 27633358.5466093        
DEBUG EVAL: Testing var 22 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=36, varin=42, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 22 = 0 gives z=27625545.057672
  % 	x22 = 0,	Z0 = 27625545.0576723        
DEBUG EVAL: First branch cutoff check: z=27625545.057672, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 10 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=18, varin=59, theta=2.000000, up=1.000000
ITER 2: row=18, varin=40, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=10, varin=59, theta=1.000000, up=1.000000
ITER 4: row=40, varin=42, theta=2.000000, up=999999999999999983222784.000000
ITER 5: row=36, varin=39, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=39, varin=37, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=37, varin=36, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 1 gives z=27700355.686385
  % 	x10 = 1,	Z1 = 27700355.6863851        
DEBUG EVAL: First branch cutoff check: z=27700355.686385, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 0
ITER 1: row=18, varin=28, theta=1.000000, up=999999999999999983222784.000000
  % 	x10 = 0,	Z0 = 27633358.5466093        
DEBUG EVAL: Second branch cutoff check: z=27633358.546609, best_z=INF, threshold=INF
  %   New best:  x10, Z = 27633358.5466093        
DEBUG EVAL: Testing var 4 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=20, varin=59, theta=2.000000, up=1.000000
ITER 2: row=20, varin=40, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=10, varin=59, theta=1.000000, up=1.000000
ITER 4: row=40, varin=42, theta=2.000000, up=999999999999999983222784.000000
ITER 5: row=36, varin=39, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=39, varin=37, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=37, varin=12, theta=1.000000, up=999999999999999983222784.000000
ITER 8: row=12, varin=33, theta=1.000000, up=999999999999999983222784.000000
ITER 9: row=33, varin=32, theta=1.000000, up=999999999999999983222784.000000
ITER 10: row=32, varin=29, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 4 = 1 gives z=27773965.682646
  % 	x4 = 1,	Z1 = 27773965.6826458        
DEBUG EVAL: First branch cutoff check: z=27773965.682646, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 4 = 0
ITER 1: row=20, varin=28, theta=1.000000, up=999999999999999983222784.000000
  % 	x4 = 0,	Z0 = 27633358.5466093        
DEBUG EVAL: Second branch cutoff check: z=27633358.546609, best_z=INF, threshold=INF
  %   New best:  x4, Z = 27633358.5466093        
DEBUG EVAL: Testing var 26 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=29, varin=59, theta=2.000000, up=1.000000
ITER 2: row=29, varin=40, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=10, varin=59, theta=1.000000, up=1.000000
ITER 4: row=40, varin=42, theta=2.000000, up=999999999999999983222784.000000
ITER 5: row=36, varin=39, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=39, varin=37, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=37, varin=36, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 26 = 1 gives z=27700355.686385
  % 	x26 = 1,	Z1 = 27700355.6863851        
DEBUG EVAL: First branch cutoff check: z=27700355.686385, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 26 = 0
ITER 1: row=29, varin=28, theta=1.000000, up=999999999999999983222784.000000
  % 	x26 = 0,	Z0 = 27633358.5466093        
DEBUG EVAL: Second branch cutoff check: z=27633358.546609, best_z=INF, threshold=INF
  % Best branch is x4, Z0 = 27633358.5466093        , Z1 = 27773965.6826458        

DEBUG CAREFUL: Final result - returning best.var = 4
DEBUG BB: Branching variable chosen: j=4
 % @NC   51   45	x4 = 0	27633358.546609
 % @NC   52   45	x4 = 1	27773965.682646
 %      45    23 27614057.9065               27621987.7963   x11 D    39     7
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ad4c4af9e0
% @LO 0.03  27.61405790650746183701 99.9000000000
% @LN 0.03  27.62198779634813305961 99.9000000000
% Resuming node 47 at  27.62198779634813305961
DEBUG CONSTRNT: LP rows=43, pool->nlprows=43, pool->npend=0
DEBUG CONSTRNT: Checking 43 LP rows (pool tracks 43, total LP rows 43)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 133
DEBUG CONSTRNT: Pool row 133 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=42, expected 42
 % @PAP adding 26 rows, 161 nz to LP
DEBUG BB: Processing node 47, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=19, varin=24, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=26)
DEBUG SOLUTION: LP solution array indices: FST[27-66], not_covered[67-86]
DEBUG SOLUTION: lp->best_solution[0] = 27621987.796348
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 26 rows, 60 cols, 221 nonzeros, 1 slack, 25 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 25 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=28, varin=20, theta=0.078947, up=999999999999999983222784.000000
ITER 2: row=30, varin=22, theta=0.166667, up=999999999999999983222784.000000
ITER 3: row=27, varin=28, theta=7.916667, up=999999999999999983222784.000000
ITER 4: row=29, varin=30, theta=2.600000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=30)
DEBUG SOLUTION: LP solution array indices: FST[31-70], not_covered[71-90]
DEBUG SOLUTION: lp->best_solution[0] = 27649528.758620
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 30 rows, 60 cols, 246 nonzeros, 5 slack, 25 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % @PAP adding 3 rows, 9 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=27, varin=20, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=26, varin=23, theta=0.416621, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=28)
DEBUG SOLUTION: LP solution array indices: FST[29-68], not_covered[69-88]
DEBUG SOLUTION: lp->best_solution[0] = 27663585.347278
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 28 rows, 60 cols, 228 nonzeros, 3 slack, 25 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 4 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=28, varin=40, theta=0.261233, up=1.000000
ITER 2: row=16, varin=22, theta=0.820310, up=999999999999999983222784.000000
ITER 3: row=26, varin=39, theta=0.411226, up=1.000000
ITER 4: row=1, varin=32, theta=0.183839, up=1.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=29)
DEBUG SOLUTION: LP solution array indices: FST[30-69], not_covered[70-89]
DEBUG SOLUTION: lp->best_solution[0] = 27695527.725070
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.944444
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.944444
  % @PL 29 rows, 60 cols, 227 nonzeros, 2 slack, 27 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 2 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=29, varin=33, theta=0.250000, up=1.000000
ITER 2: row=1, varin=35, theta=0.062782, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=29)
DEBUG SOLUTION: LP solution array indices: FST[30-69], not_covered[70-89]
DEBUG SOLUTION: lp->best_solution[0] = 27698697.634729
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 5.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 29 rows, 60 cols, 227 nonzeros, 0 slack, 29 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 3 rows, 14 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=30, varin=33, theta=0.226242, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=32)
DEBUG SOLUTION: LP solution array indices: FST[33-72], not_covered[73-92]
DEBUG SOLUTION: lp->best_solution[0] = 27708545.178310
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 5.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 32 rows, 60 cols, 241 nonzeros, 0 slack, 32 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 3 rows, 9 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=33, varin=38, theta=0.566506, up=1.000000
ITER 2: row=28, varin=62, theta=0.330396, up=1.000000
ITER 3: row=15, varin=90, theta=0.257657, up=1.000000
ITER 4: row=18, varin=63, theta=0.113457, up=1.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=35)
DEBUG SOLUTION: LP solution array indices: FST[36-75], not_covered[76-95]
DEBUG SOLUTION: lp->best_solution[0] = 27735611.852401
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 5.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 35 rows, 60 cols, 250 nonzeros, 0 slack, 35 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=36, varin=80, theta=0.159527, up=1.000000
ITER 2: row=37, varin=59, theta=0.306811, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=37)
DEBUG SOLUTION: LP solution array indices: FST[38-77], not_covered[78-97]
DEBUG SOLUTION: lp->best_solution[0] = 27741871.156262
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 5.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 37 rows, 60 cols, 254 nonzeros, 0 slack, 37 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 47 LP 1 Solution, length = 27741871.156262, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 1.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.193189 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.500000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.500000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.500000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 1.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.306811 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.806811 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.500000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.500000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.500000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.500000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=27741871.156262, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 47 at  27.74187115626175170746
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ad4c4ad660
% @LO 0.03  27.62198779634813305961 99.9000000000
% @LN 0.03  27.63335854660926216297 99.9000000000
% Resuming node 51 at  27.63335854660926216297
DEBUG CONSTRNT: LP rows=37, pool->nlprows=37, pool->npend=0
DEBUG CONSTRNT: Checking 37 LP rows (pool tracks 37, total LP rows 37)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 91
DEBUG CONSTRNT: Pool row 91 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 79
DEBUG CONSTRNT: Pool row 79 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 45
DEBUG CONSTRNT: Pool row 45 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 62
DEBUG CONSTRNT: Pool row 62 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 142
DEBUG CONSTRNT: Pool row 142 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 133
DEBUG CONSTRNT: Pool row 133 has lprow=36, expected 36
 % @PAP adding 43 rows, 171 nz to LP
DEBUG BB: Processing node 51, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=20, varin=28, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 27633358.546609
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 43 rows, 60 cols, 231 nonzeros, 3 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=44, varin=47, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 27650870.752790
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 44 rows, 60 cols, 233 nonzeros, 3 slack, 41 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % Node 51 LP 1 Solution, length = 27650870.752790, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.500000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.500000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.500000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.500000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.500000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.500000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.500000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.500000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.500000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.500000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=27650870.752790, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 51 at  27.65087075279037520659
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ad4c4ae540
% @LO 0.03  27.63335854660926216297 99.9000000000
% @LN 0.03  27.63727226425704230905 99.9000000000
% Resuming node 43 at  27.63727226425704230905
DEBUG CONSTRNT: LP rows=41, pool->nlprows=41, pool->npend=0
DEBUG CONSTRNT: Checking 41 LP rows (pool tracks 41, total LP rows 41)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 133
DEBUG CONSTRNT: Pool row 133 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 143
DEBUG CONSTRNT: Pool row 143 has lprow=40, expected 40
 % @PAP adding 31 rows, 178 nz to LP
DEBUG BB: Processing node 43, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 43 LP 2 Solution, length = 27637272.264257, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.303700 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.303700 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.303700 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.911099 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 1.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.696300 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.696300 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.088901 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.696300 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.088901 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.088901 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=27637272.264257, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=27637272.264257, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 43 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 43
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=1.000000
DEBUG CAREFUL: Skipping var 2: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.303700
DEBUG CAREFUL: Adding var 5 to fractional list (xi=0.303700)
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.303700
DEBUG CAREFUL: Adding var 7 to fractional list (xi=0.303700)
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.303700
DEBUG CAREFUL: Adding var 8 to fractional list (xi=0.303700)
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.911099
DEBUG CAREFUL: Adding var 12 to fractional list (xi=0.911099)
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=1.000000
DEBUG CAREFUL: Skipping var 20: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 4 fractional variables

  %  Carefully choosing branching variable, nfrac = 4
DEBUG CAREFUL: Testing fvar[0] = var 5
DEBUG CAREFUL: Calling compare_branch_vars for var 5
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 5
DEBUG CAREFUL: New best var: 5
DEBUG CAREFUL: Testing fvar[1] = var 12
DEBUG CAREFUL: Calling compare_branch_vars for var 12
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 12
DEBUG CAREFUL: Testing fvar[2] = var 7
DEBUG CAREFUL: Calling compare_branch_vars for var 7
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 7
DEBUG CAREFUL: Testing fvar[3] = var 8
DEBUG CAREFUL: Calling compare_branch_vars for var 8
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 8
  % Initial guess is x5, Z0 = 27637272.264257         , Z1 = 27687193.15463          

DEBUG EVAL: Testing var 5 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=18, theta=2.075297, up=999999999999999983222784.000000
ITER 2: row=5, varin=22, theta=1.147178, up=999999999999999983222784.000000
ITER 3: row=1, varin=26, theta=0.081918, up=999999999999999983222784.000000
ITER 4: row=26, varin=23, theta=0.136372, up=999999999999999983222784.000000
ITER 5: row=23, varin=17, theta=0.121706, up=999999999999999983222784.000000
ITER 6: row=14, varin=3, theta=0.222400, up=999999999999999983222784.000000
ITER 7: row=3, varin=34, theta=0.224826, up=1.000000
DEBUG EVAL: Branch var 5 = 1 gives z=27709472.459959
  % 	x5 = 1,	Z1 = 27709472.4599586        
DEBUG EVAL: First branch cutoff check: z=27709472.459959, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 5 = 0
ITER 1: row=1, varin=41, theta=0.674592, up=1.000000
ITER 2: row=19, varin=77, theta=0.552354, up=1.000000
ITER 3: row=15, varin=21, theta=0.218887, up=999999999999999983222784.000000
  % 	x5 = 0,	Z0 = 27660834.9964269        
DEBUG EVAL: Second branch cutoff check: z=27660834.996427, best_z=INF, threshold=INF
  %   New best:  x5, Z = 27660834.9964269        
DEBUG EVAL: Testing var 12 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=12, varin=41, theta=0.136896, up=1.000000
DEBUG EVAL: Branch var 12 = 1 gives z=27640225.545271
  % 	x12 = 1,	Z1 = 27640225.5452707        
DEBUG EVAL: First branch cutoff check: z=27640225.545271, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 7 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=5, varin=18, theta=0.457047, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 7 = 0 gives z=27646411.619363
  % 	x7 = 0,	Z0 = 27646411.6193632        
DEBUG EVAL: First branch cutoff check: z=27646411.619363, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 8 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=14, varin=41, theta=0.674592, up=1.000000
ITER 2: row=12, varin=77, theta=0.552354, up=1.000000
ITER 3: row=15, varin=22, theta=0.629372, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 8 = 0 gives z=27667049.378348
  % 	x8 = 0,	Z0 = 27667049.3783478        
DEBUG EVAL: First branch cutoff check: z=27667049.378348, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 8 = 1
ITER 1: row=14, varin=18, theta=2.075297, up=999999999999999983222784.000000
ITER 2: row=5, varin=26, theta=0.638506, up=999999999999999983222784.000000
ITER 3: row=26, varin=23, theta=1.062950, up=999999999999999983222784.000000
ITER 4: row=23, varin=21, theta=0.867664, up=999999999999999983222784.000000
  % 	x8 = 1,	Z1 = 27717272.1395128        
DEBUG EVAL: Second branch cutoff check: z=27717272.139513, best_z=INF, threshold=INF
  %   New best:  x8, Z = 27667049.3783478        
  % Best branch is x8, Z0 = 27667049.3783478        , Z1 = 27717272.1395128        

DEBUG CAREFUL: Final result - returning best.var = 8
DEBUG BB: Branching variable chosen: j=8
 % @NC   53   43	x8 = 0	27667049.378348
 % @NC   54   43	x8 = 1	27717272.139513
 %      43    24 27637272.2643               27645450.5966   x14 D    35     6
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ad4c4b2e60
% @LO 0.03  27.63727226425704230905 99.9000000000
% @LN 0.03  27.64545059664152759638 99.9000000000
% Resuming node 41 at  27.64545059664152759638
DEBUG CONSTRNT: LP rows=31, pool->nlprows=31, pool->npend=0
DEBUG CONSTRNT: Checking 31 LP rows (pool tracks 31, total LP rows 31)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 79
DEBUG CONSTRNT: Pool row 79 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 45
DEBUG CONSTRNT: Pool row 45 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 141
DEBUG CONSTRNT: Pool row 141 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 145
DEBUG CONSTRNT: Pool row 145 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 159
DEBUG CONSTRNT: Pool row 159 has lprow=30, expected 30
 % @PAP adding 25 rows, 164 nz to LP
DEBUG BB: Processing node 41, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 41 LP 2 Solution, length = 27645450.596642, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.800000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.141313 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.058687 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.058687 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.141313 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.058687 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.800000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 1.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.200000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.200000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.941313 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.200000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.200000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.941313 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.941313 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.200000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.200000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 7 fractional variables
DEBUG CG: LP optimal, z=27645450.596642, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=27645450.596642, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 41 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 41
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=1.000000
DEBUG CAREFUL: Skipping var 2: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.800000
DEBUG CAREFUL: Adding var 5 to fractional list (xi=0.800000)
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.141313
DEBUG CAREFUL: Adding var 8 to fractional list (xi=0.141313)
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.058687
DEBUG CAREFUL: Adding var 9 to fractional list (xi=0.058687)
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.058687
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.058687)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.141313
DEBUG CAREFUL: Adding var 12 to fractional list (xi=0.141313)
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.058687
DEBUG CAREFUL: Adding var 14 to fractional list (xi=0.058687)
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.800000
DEBUG CAREFUL: Adding var 15 to fractional list (xi=0.800000)
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=1.000000
DEBUG CAREFUL: Skipping var 17: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 7 fractional variables

  %  Carefully choosing branching variable, nfrac = 7
DEBUG CAREFUL: Testing fvar[0] = var 15
DEBUG CAREFUL: Calling compare_branch_vars for var 15
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 15
DEBUG CAREFUL: New best var: 15
DEBUG CAREFUL: Testing fvar[1] = var 5
DEBUG CAREFUL: Calling compare_branch_vars for var 5
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 5
DEBUG CAREFUL: Testing fvar[2] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 10
DEBUG CAREFUL: New best var: 10
DEBUG CAREFUL: Testing fvar[3] = var 8
DEBUG CAREFUL: Calling compare_branch_vars for var 8
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 8
DEBUG CAREFUL: New best var: 8
DEBUG CAREFUL: Testing fvar[4] = var 9
DEBUG CAREFUL: Calling compare_branch_vars for var 9
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 9
DEBUG CAREFUL: Testing fvar[5] = var 14
DEBUG CAREFUL: Calling compare_branch_vars for var 14
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 14
DEBUG CAREFUL: Testing fvar[6] = var 12
DEBUG CAREFUL: Calling compare_branch_vars for var 12
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 12
  % Initial guess is x8, Z0 = 27645450.5966415        , Z1 = 27756819.5448903        

DEBUG EVAL: Testing var 15 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=16, varin=19, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=22, varin=24, theta=0.454120, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 15 = 1 gives z=27679624.696206
  % 	x15 = 1,	Z1 = 27679624.6962059        
DEBUG EVAL: First branch cutoff check: z=27679624.696206, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 15 = 0
ITER 1: row=16, varin=25, theta=1.333333, up=999999999999999983222784.000000
ITER 2: row=1, varin=13, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=13, varin=24, theta=0.478780, up=999999999999999983222784.000000
ITER 4: row=18, varin=17, theta=0.894007, up=999999999999999983222784.000000
ITER 5: row=1, varin=23, theta=0.105993, up=999999999999999983222784.000000
ITER 6: row=6, varin=31, theta=0.118820, up=1.000000
ITER 7: row=21, varin=13, theta=0.118820, up=999999999999999983222784.000000
  % 	x15 = 0,	Z0 = 27687967.1392096        
DEBUG EVAL: Second branch cutoff check: z=27687967.139210, best_z=INF, threshold=INF
  %   New best:  x15, Z = 27679624.6962059        
DEBUG EVAL: Testing var 5 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=25, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=14, varin=13, theta=0.107068, up=999999999999999983222784.000000
ITER 3: row=24, varin=23, theta=0.091577, up=999999999999999983222784.000000
ITER 4: row=6, varin=14, theta=0.114658, up=999999999999999983222784.000000
ITER 5: row=13, varin=24, theta=0.321397, up=999999999999999983222784.000000
ITER 6: row=5, varin=6, theta=0.132092, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 5 = 1 gives z=27665197.790207
  % 	x5 = 1,	Z1 = 27665197.7902073        
DEBUG EVAL: First branch cutoff check: z=27665197.790207, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 10 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=13, varin=24, theta=2.598876, up=999999999999999983222784.000000
ITER 2: row=18, varin=23, theta=1.063354, up=999999999999999983222784.000000
ITER 3: row=5, varin=40, theta=0.490606, up=1.000000
ITER 4: row=6, varin=19, theta=0.456125, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 1 gives z=27698973.879737
  % 	x10 = 1,	Z1 = 27698973.8797374        
DEBUG EVAL: First branch cutoff check: z=27698973.879737, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 0
ITER 1: row=13, varin=13, theta=0.131569, up=999999999999999983222784.000000
  % 	x10 = 0,	Z0 = 27645916.1211207        
DEBUG EVAL: Second branch cutoff check: z=27645916.121121, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 8 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=5, varin=23, theta=1.800296, up=999999999999999983222784.000000
ITER 2: row=22, varin=22, theta=0.666667, up=999999999999999983222784.000000
ITER 3: row=18, varin=25, theta=1.333333, up=999999999999999983222784.000000
ITER 4: row=6, varin=14, theta=4.000000, up=999999999999999983222784.000000
ITER 5: row=24, varin=19, theta=3.768546, up=999999999999999983222784.000000
ITER 6: row=20, varin=18, theta=2.768546, up=999999999999999983222784.000000
ITER 7: row=19, varin=21, theta=1.768546, up=999999999999999983222784.000000
ITER 8: row=25, varin=16, theta=0.768546, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 8 = 1 gives z=27803758.704582
  % 	x8 = 1,	Z1 = 27803758.7045823        
DEBUG EVAL: First branch cutoff check: z=27803758.704582, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 8 = 0
ITER 1: row=5, varin=13, theta=0.399254, up=999999999999999983222784.000000
ITER 2: row=13, varin=24, theta=0.075820, up=999999999999999983222784.000000
  % 	x8 = 0,	Z0 = 27647055.3612085        
DEBUG EVAL: Second branch cutoff check: z=27647055.361209, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 9 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=6, varin=13, theta=1.699299, up=999999999999999983222784.000000
ITER 2: row=24, varin=24, theta=1.069495, up=999999999999999983222784.000000
ITER 3: row=5, varin=14, theta=0.859225, up=999999999999999983222784.000000
ITER 4: row=13, varin=19, theta=1.149046, up=999999999999999983222784.000000
ITER 5: row=19, varin=18, theta=0.153698, up=999999999999999983222784.000000
ITER 6: row=23, varin=20, theta=0.158649, up=999999999999999983222784.000000
ITER 7: row=1, varin=6, theta=0.268137, up=999999999999999983222784.000000
ITER 8: row=18, varin=28, theta=0.302403, up=1.000000
DEBUG EVAL: Branch var 9 = 1 gives z=27716547.165026
  % 	x9 = 1,	Z1 = 27716547.165026         
DEBUG EVAL: First branch cutoff check: z=27716547.165026, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 9 = 0
ITER 1: row=6, varin=25, theta=0.275308, up=999999999999999983222784.000000
  % 	x9 = 0,	Z0 = 27646478.9718459        
DEBUG EVAL: Second branch cutoff check: z=27646478.971846, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 14 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=18, varin=19, theta=0.082675, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 14 = 0 gives z=27647933.597824
  % 	x14 = 0,	Z0 = 27647933.5978238        
DEBUG EVAL: First branch cutoff check: z=27647933.597824, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 12 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=7, varin=13, theta=0.399254, up=999999999999999983222784.000000
ITER 2: row=13, varin=24, theta=0.075820, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 12 = 0 gives z=27647055.361209
  % 	x12 = 0,	Z0 = 27647055.3612085        
DEBUG EVAL: First branch cutoff check: z=27647055.361209, best_z=INF, threshold=INF
  % Best branch is x15, Z0 = 27687967.1392096        , Z1 = 27679624.6962059        

DEBUG CAREFUL: Final result - returning best.var = 15
DEBUG BB: Branching variable chosen: j=15
 % @NC   55   41	x15 = 1	27679624.696206
 % @NC   56   41	x15 = 0	27687967.139210
 %      41    25 27645450.5966               27648126.0792   x16 D    18     7
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ad4c4c1bb0
% @LO 0.03  27.64545059664152759638 99.9000000000
% @LN 0.03  27.64812607923521525777 99.9000000000
% Resuming node 44 at  27.64812607923521525777
DEBUG CONSTRNT: LP rows=25, pool->nlprows=25, pool->npend=0
DEBUG CONSTRNT: Checking 25 LP rows (pool tracks 25, total LP rows 25)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=24, expected 24
 % @PAP adding 22 rows, 145 nz to LP
DEBUG BB: Processing node 44, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=13, varin=28, theta=0.765407, up=1.000000
ITER 2: row=1, varin=19, theta=0.436816, up=999999999999999983222784.000000
ITER 3: row=3, varin=33, theta=0.813684, up=1.000000
ITER 4: row=13, varin=3, theta=0.623782, up=999999999999999983222784.000000
ITER 5: row=7, varin=21, theta=0.585875, up=999999999999999983222784.000000
ITER 6: row=5, varin=44, theta=0.305940, up=1.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=22)
DEBUG SOLUTION: LP solution array indices: FST[23-62], not_covered[63-82]
DEBUG SOLUTION: lp->best_solution[0] = 27648126.079235
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 22 rows, 60 cols, 205 nonzeros, 0 slack, 22 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 5 rows, 16 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=23, varin=36, theta=0.275181, up=1.000000
ITER 2: row=25, varin=54, theta=0.552983, up=1.000000
ITER 3: row=24, varin=23, theta=1.126815, up=999999999999999983222784.000000
ITER 4: row=1, varin=55, theta=0.606671, up=1.000000
ITER 5: row=21, varin=38, theta=0.255675, up=1.000000
ITER 6: row=25, varin=78, theta=0.315827, up=1.000000
ITER 7: row=3, varin=45, theta=0.134436, up=1.000000
LP PHASE: Switching to primal (iter=7)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=27)
DEBUG SOLUTION: LP solution array indices: FST[28-67], not_covered[68-87]
DEBUG SOLUTION: lp->best_solution[0] = 27694861.993197
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 27 rows, 60 cols, 221 nonzeros, 0 slack, 27 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 7 rows, 29 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=28, varin=57, theta=0.454182, up=1.000000
ITER 2: row=29, varin=58, theta=0.660745, up=1.000000
ITER 3: row=28, varin=64, theta=2.069947, up=1.000000
ITER 4: row=28, varin=40, theta=0.109855, up=1.000000
ITER 5: row=29, varin=64, theta=0.276485, up=1.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=34)
DEBUG SOLUTION: LP solution array indices: FST[35-74], not_covered[75-94]
DEBUG SOLUTION: lp->best_solution[0] = 27722615.523743
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 34 rows, 60 cols, 250 nonzeros, 0 slack, 34 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 8 rows, 32 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=37, varin=66, theta=0.574944, up=1.000000
ITER 2: row=36, varin=43, theta=0.602178, up=1.000000
ITER 3: row=20, varin=67, theta=0.814392, up=1.000000
ITER 4: row=35, varin=97, theta=0.132812, up=1.000000
ITER 5: row=27, varin=49, theta=0.387053, up=1.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 27777861.513880
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 42 rows, 60 cols, 282 nonzeros, 0 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 7 rows, 28 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=47, varin=59, theta=0.164212, up=1.000000
ITER 2: row=43, varin=94, theta=0.324664, up=1.000000
ITER 3: row=38, varin=18, theta=0.210853, up=999999999999999983222784.000000
ITER 4: row=46, varin=3, theta=0.945266, up=999999999999999983222784.000000
ITER 5: row=3, varin=52, theta=0.892326, up=1.000000
ITER 6: row=42, varin=57, theta=0.078431, up=1.000000
ITER 7: row=1, varin=95, theta=0.142857, up=1.000000
ITER 8: row=44, varin=21, theta=0.067797, up=999999999999999983222784.000000
ITER 9: row=38, varin=43, theta=0.155844, up=999999999999999983222784.000000
ITER 10: row=5, varin=22, theta=0.066667, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=12)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 27928936.134005
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 49 rows, 60 cols, 310 nonzeros, 4 slack, 45 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % @PAP adding 4 rows, 10 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=47, varin=103, theta=0.500000, up=1.000000
ITER 2: row=49, varin=84, theta=2.276345, up=1.000000
ITER 3: row=49, varin=81, theta=0.331639, up=1.000000
ITER 4: row=18, varin=84, theta=0.335909, up=1.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 28107180.112127
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 49 rows, 60 cols, 312 nonzeros, 2 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=48, varin=58, theta=0.208125, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 28122487.221227
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 48 rows, 60 cols, 308 nonzeros, 0 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=49, varin=107, theta=0.145263, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28142105.421254
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 50 rows, 60 cols, 312 nonzeros, 2 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 4 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=49, varin=89, theta=0.117884, up=1.000000
ITER 2: row=52, varin=49, theta=0.049296, up=999999999999999983222784.000000
ITER 3: row=51, varin=52, theta=0.021182, up=999999999999999983222784.000000
ITER 4: row=32, varin=18, theta=0.008293, up=999999999999999983222784.000000
ITER 5: row=50, varin=38, theta=0.046144, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 28164861.622446
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 52 rows, 60 cols, 316 nonzeros, 2 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 3 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=53, varin=86, theta=0.310310, up=1.000000
ITER 2: row=51, varin=48, theta=0.033985, up=999999999999999983222784.000000
ITER 3: row=18, varin=95, theta=0.090396, up=1.000000
ITER 4: row=36, varin=77, theta=0.085682, up=1.000000
ITER 5: row=50, varin=55, theta=0.063905, up=1.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=53)
DEBUG SOLUTION: LP solution array indices: FST[54-93], not_covered[94-113]
DEBUG SOLUTION: lp->best_solution[0] = 28181907.973444
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 53 rows, 60 cols, 311 nonzeros, 2 slack, 51 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 4 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=52, varin=32, theta=0.070894, up=999999999999999983222784.000000
ITER 2: row=54, varin=80, theta=0.219814, up=1.000000
ITER 3: row=52, varin=86, theta=0.280013, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=55)
DEBUG SOLUTION: LP solution array indices: FST[56-95], not_covered[96-115]
DEBUG SOLUTION: lp->best_solution[0] = 28270178.488851
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 55 rows, 60 cols, 315 nonzeros, 2 slack, 53 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 4 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=57, varin=18, theta=0.095612, up=999999999999999983222784.000000
ITER 2: row=55, varin=69, theta=0.607875, up=1.000000
ITER 3: row=28, varin=35, theta=1.857961, up=999999999999999983222784.000000
ITER 4: row=3, varin=48, theta=0.418748, up=999999999999999983222784.000000
ITER 5: row=54, varin=91, theta=0.318636, up=1.000000
ITER 6: row=18, varin=3, theta=0.971549, up=999999999999999983222784.000000
ITER 7: row=28, varin=96, theta=21.190288, up=1.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=57)
DEBUG SOLUTION: LP solution array indices: FST[58-97], not_covered[98-117]
DEBUG SOLUTION: lp->best_solution[0] = 999999999999999983222784.000000
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 57 rows, 60 cols, 319 nonzeros, 2 slack, 55 tight.
  % Node 44 LP 1 Solution, length = 999999999999999983222784.000000, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.013570 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.097861 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.500000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.013570 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.013570 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.013570 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 1.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 1.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.027139 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.027139 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.500000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.097861 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.280013 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.500000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.130481 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.013570 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.013570 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.986430 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.986430 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.869519 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.902139 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.902139 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.986430 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.500000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 0.972861 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
DEBUG BB: compute_good_lower_bound returned status=1
DEBUG BB: Node 44 is INFEASIBLE
 %      44    24    infeasible               27648373.2646   x14 U    35     6
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ad4c48c600
% @LO 0.03  27.64812607923521525777 99.9000000000
% @LN 0.03  27.64837326462757260970 99.9000000000
% Resuming node 49 at  27.64837326462757260970
DEBUG CONSTRNT: LP rows=57, pool->nlprows=57, pool->npend=0
DEBUG CONSTRNT: Checking 57 LP rows (pool tracks 57, total LP rows 57)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 133
DEBUG CONSTRNT: Pool row 133 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 141
DEBUG CONSTRNT: Pool row 141 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 145
DEBUG CONSTRNT: Pool row 145 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 159
DEBUG CONSTRNT: Pool row 159 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 134
DEBUG CONSTRNT: Pool row 134 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=54, expected 54
DEBUG CONSTRNT: Checking LP row 55 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=55, expected 55
DEBUG CONSTRNT: Checking LP row 56 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=56, expected 56
 % @PAP adding 27 rows, 166 nz to LP
DEBUG BB: Processing node 49, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=7, varin=4, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=4, varin=25, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=27)
DEBUG SOLUTION: LP solution array indices: FST[28-67], not_covered[68-87]
DEBUG SOLUTION: lp->best_solution[0] = 27648373.264628
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 0.000000
DEBUG SOLUTION: lp->best_solution[6] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 27 rows, 60 cols, 226 nonzeros, 1 slack, 26 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 20 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=28, varin=24, theta=0.877836, up=999999999999999983222784.000000
ITER 2: row=30, varin=27, theta=0.122164, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=31)
DEBUG SOLUTION: LP solution array indices: FST[32-71], not_covered[72-91]
DEBUG SOLUTION: lp->best_solution[0] = 27648373.264628
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 0.000000
DEBUG SOLUTION: lp->best_solution[6] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 31 rows, 60 cols, 246 nonzeros, 4 slack, 27 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 3 rows, 11 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=34, varin=36, theta=0.166667, up=1.000000
ITER 2: row=33, varin=34, theta=1.770802, up=999999999999999983222784.000000
ITER 3: row=3, varin=79, theta=0.974399, up=1.000000
ITER 4: row=33, varin=40, theta=0.083333, up=1.000000
ITER 5: row=32, varin=34, theta=2.000000, up=999999999999999983222784.000000
ITER 6: row=3, varin=61, theta=0.115844, up=1.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=34)
DEBUG SOLUTION: LP solution array indices: FST[35-74], not_covered[75-94]
DEBUG SOLUTION: lp->best_solution[0] = 27716518.474234
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 0.000000
DEBUG SOLUTION: lp->best_solution[6] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 34 rows, 60 cols, 257 nonzeros, 6 slack, 28 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 6 slack rows
  % @PAP adding 3 rows, 9 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=31, varin=35, theta=0.321031, up=1.000000
ITER 2: row=18, varin=32, theta=0.290696, up=1.000000
ITER 3: row=21, varin=50, theta=0.099822, up=1.000000
ITER 4: row=29, varin=38, theta=0.160539, up=1.000000
ITER 5: row=20, varin=76, theta=0.098788, up=1.000000
ITER 6: row=4, varin=29, theta=0.297660, up=999999999999999983222784.000000
ITER 7: row=24, varin=73, theta=0.111232, up=1.000000
LP PHASE: Switching to primal (iter=7)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=31)
DEBUG SOLUTION: LP solution array indices: FST[32-71], not_covered[72-91]
DEBUG SOLUTION: lp->best_solution[0] = 27796607.496313
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 0.000000
DEBUG SOLUTION: lp->best_solution[6] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 31 rows, 60 cols, 237 nonzeros, 1 slack, 30 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 4 rows, 15 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=31, varin=45, theta=0.067660, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=34)
DEBUG SOLUTION: LP solution array indices: FST[35-74], not_covered[75-94]
DEBUG SOLUTION: lp->best_solution[0] = 27798090.539528
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 0.000000
DEBUG SOLUTION: lp->best_solution[6] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 34 rows, 60 cols, 248 nonzeros, 2 slack, 32 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % Node 49 LP 1 Solution, length = 27798090.539528, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.250000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.067660 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.500000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.500000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 1.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.500000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.500000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.932340 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.932340 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.500000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=27798090.539528, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 49 at  27.79809053952812902821
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ad4c4ad660
% @LO 0.03  27.64837326462757260970 99.9000000000
% @LN 0.03  27.65087075279037520659 99.9000000000
% Resuming node 51 at  27.65087075279037520659
DEBUG CONSTRNT: LP rows=32, pool->nlprows=32, pool->npend=0
DEBUG CONSTRNT: Checking 32 LP rows (pool tracks 32, total LP rows 32)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=31, expected 31
 % @PAP adding 41 rows, 164 nz to LP
DEBUG BB: Processing node 51, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 51 LP 2 Solution, length = 27650870.752790, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.500000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.500000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.500000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.500000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.500000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.500000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.500000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.500000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.500000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.500000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=27650870.752790, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=27650870.752790, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 51 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 51
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.500000
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.500000
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=1.000000
DEBUG CAREFUL: Skipping var 7: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.500000
DEBUG CAREFUL: Adding var 27 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.500000
DEBUG CAREFUL: Adding var 29 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.500000
DEBUG CAREFUL: Adding var 32 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 2
DEBUG CAREFUL: New best var: 2
DEBUG CAREFUL: Testing fvar[1] = var 27
DEBUG CAREFUL: Calling compare_branch_vars for var 27
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 27
DEBUG CAREFUL: Testing fvar[2] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 1
DEBUG CAREFUL: New best var: 1
DEBUG CAREFUL: Testing fvar[3] = var 29
DEBUG CAREFUL: Calling compare_branch_vars for var 29
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 29
DEBUG CAREFUL: Testing fvar[4] = var 32
DEBUG CAREFUL: Calling compare_branch_vars for var 32
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 32
  % Initial guess is x1, Z0 = 27650870.7527904        , Z1 = 27699782.0534175        

DEBUG EVAL: Testing var 2 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=3, varin=38, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 1 gives z=27653991.853674
  % 	x2 = 1,	Z1 = 27653991.8536737        
DEBUG EVAL: First branch cutoff check: z=27653991.853674, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 0
ITER 1: row=3, varin=41, theta=1.000000, up=999999999999999983222784.000000
  % 	x2 = 0,	Z0 = 27668382.9589715        
DEBUG EVAL: Second branch cutoff check: z=27668382.958971, best_z=INF, threshold=INF
  %   New best:  x2, Z = 27653991.8536737        
DEBUG EVAL: Testing var 27 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=13, varin=38, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 27 = 0 gives z=27653991.853674
  % 	x27 = 0,	Z0 = 27653991.8536737        
DEBUG EVAL: First branch cutoff check: z=27653991.853674, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 27 = 1
ITER 1: row=13, varin=41, theta=1.000000, up=999999999999999983222784.000000
  % 	x27 = 1,	Z1 = 27668382.9589715        
DEBUG EVAL: Second branch cutoff check: z=27668382.958971, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 1 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=31, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 1 = 1 gives z=27804342.328533
  % 	x1 = 1,	Z1 = 27804342.3285327        
DEBUG EVAL: First branch cutoff check: z=27804342.328533, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 1 = 0
ITER 1: row=1, varin=41, theta=1.000000, up=999999999999999983222784.000000
  % 	x1 = 0,	Z0 = 27668382.9589715        
DEBUG EVAL: Second branch cutoff check: z=27668382.958971, best_z=INF, threshold=INF
  %   New best:  x1, Z = 27668382.9589715        
DEBUG EVAL: Testing var 29 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=30, varin=41, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 29 = 0 gives z=27668382.958971
  % 	x29 = 0,	Z0 = 27668382.9589715        
DEBUG EVAL: First branch cutoff check: z=27668382.958971, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 29 = 1
ITER 1: row=30, varin=4, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=32, varin=14, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=3, varin=38, theta=1.000000, up=999999999999999983222784.000000
  % 	x29 = 1,	Z1 = 28285564.4575672        
DEBUG EVAL: Second branch cutoff check: z=28285564.457567, best_z=INF, threshold=INF
  %   New best:  x29, Z = 27668382.9589715        
DEBUG EVAL: Testing var 32 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=31, varin=41, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 32 = 0 gives z=27668382.958971
  % 	x32 = 0,	Z0 = 27668382.9589715        
DEBUG EVAL: First branch cutoff check: z=27668382.958971, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 32 = 1
ITER 1: row=31, varin=3, theta=0.500000, up=999999999999999983222784.000000
  % 	x32 = 1,	Z1 = 27789905.581536         
DEBUG EVAL: Second branch cutoff check: z=27789905.581536, best_z=INF, threshold=INF
  % Best branch is x29, Z0 = 27668382.9589715        , Z1 = 28285564.4575672        

DEBUG CAREFUL: Final result - returning best.var = 29
DEBUG BB: Branching variable chosen: j=29
 % @NC   57   51	x29 = 0	27668382.958971
 % @NC   58   51	x29 = 1	28285564.457567
 %      51    25 27650870.7528               27667049.3783    x4 D    45     8
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ad4c49c780
% @LO 0.03  27.65087075279037520659 99.9000000000
% @LN 0.03  27.66704937834779798322 99.9000000000
% Resuming node 53 at  27.66704937834779798322
DEBUG CONSTRNT: LP rows=41, pool->nlprows=41, pool->npend=0
DEBUG CONSTRNT: Checking 41 LP rows (pool tracks 41, total LP rows 41)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 133
DEBUG CONSTRNT: Pool row 133 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 143
DEBUG CONSTRNT: Pool row 143 has lprow=40, expected 40
 % @PAP adding 31 rows, 178 nz to LP
DEBUG BB: Processing node 53, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=14, varin=41, theta=0.674592, up=1.000000
ITER 2: row=12, varin=77, theta=0.552354, up=1.000000
ITER 3: row=15, varin=22, theta=0.629372, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=31)
DEBUG SOLUTION: LP solution array indices: FST[32-71], not_covered[72-91]
DEBUG SOLUTION: lp->best_solution[0] = 27667049.378348
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 31 rows, 60 cols, 238 nonzeros, 1 slack, 30 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 5 rows, 21 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=35, varin=17, theta=0.100831, up=999999999999999983222784.000000
ITER 2: row=31, varin=35, theta=0.794796, up=999999999999999983222784.000000
ITER 3: row=34, varin=48, theta=0.148410, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=35)
DEBUG SOLUTION: LP solution array indices: FST[36-75], not_covered[76-95]
DEBUG SOLUTION: lp->best_solution[0] = 27680604.674081
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 35 rows, 60 cols, 257 nonzeros, 3 slack, 32 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % Node 53 LP 1 Solution, length = 27680604.674081, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.283863 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.283863 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.283863 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.851590 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 1.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.716137 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.716137 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.148410 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.716137 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.148410 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.148410 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=27680604.674081, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 53 at  27.68060467408140823409
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ad4c4c1bb0
% @LO 0.03  27.66704937834779798322 99.9000000000
% @LN 0.03  27.66838295897149180291 99.9000000000
% Resuming node 57 at  27.66838295897149180291
DEBUG CONSTRNT: LP rows=32, pool->nlprows=32, pool->npend=0
DEBUG CONSTRNT: Checking 32 LP rows (pool tracks 32, total LP rows 32)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 141
DEBUG CONSTRNT: Pool row 141 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 145
DEBUG CONSTRNT: Pool row 145 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 159
DEBUG CONSTRNT: Pool row 159 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=31, expected 31
 % @PAP adding 41 rows, 164 nz to LP
DEBUG BB: Processing node 57, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=30, varin=41, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=41)
DEBUG SOLUTION: LP solution array indices: FST[42-81], not_covered[82-101]
DEBUG SOLUTION: lp->best_solution[0] = 27668382.958971
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 41 rows, 60 cols, 224 nonzeros, 1 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=42, varin=38, theta=0.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 27671504.059855
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 43 rows, 60 cols, 230 nonzeros, 3 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % Node 57 LP 1 Solution, length = 27671504.059855, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.500000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.500000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.500000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.500000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.500000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.500000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.500000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.500000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=27671504.059855, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 57 at  27.67150405985485406291
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ad4c4a0510
% @LO 0.03  27.66838295897149180291 99.9000000000
% @LN 0.03  27.66882153990362169793 99.9000000000
% Resuming node 42 at  27.66882153990362169793
DEBUG CONSTRNT: LP rows=40, pool->nlprows=40, pool->npend=0
DEBUG CONSTRNT: Checking 40 LP rows (pool tracks 40, total LP rows 40)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 133
DEBUG CONSTRNT: Pool row 133 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=39, expected 39
 % @PAP adding 29 rows, 179 nz to LP
DEBUG BB: Processing node 42, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=19, varin=33, theta=0.500000, up=1.000000
ITER 2: row=16, varin=8, theta=0.398199, up=999999999999999983222784.000000
ITER 3: row=7, varin=9, theta=0.459164, up=999999999999999983222784.000000
ITER 4: row=29, varin=32, theta=0.552459, up=1.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=29)
DEBUG SOLUTION: LP solution array indices: FST[30-69], not_covered[70-89]
DEBUG SOLUTION: lp->best_solution[0] = 27668821.539904
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 0.000000
DEBUG SOLUTION: lp->best_solution[6] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 29 rows, 60 cols, 239 nonzeros, 0 slack, 29 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 5 rows, 18 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=31, varin=26, theta=0.683715, up=999999999999999983222784.000000
ITER 2: row=32, varin=35, theta=1.327338, up=1.000000
ITER 3: row=32, varin=61, theta=0.286630, up=1.000000
ITER 4: row=26, varin=35, theta=1.144323, up=1.000000
ITER 5: row=26, varin=32, theta=0.159384, up=999999999999999983222784.000000
ITER 6: row=32, varin=28, theta=0.284143, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=34)
DEBUG SOLUTION: LP solution array indices: FST[35-74], not_covered[75-94]
DEBUG SOLUTION: lp->best_solution[0] = 27779528.681069
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 0.000000
DEBUG SOLUTION: lp->best_solution[6] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.715857
DEBUG SOLUTION: lp->best_solution[9] = 0.715857
DEBUG SOLUTION: lp->best_solution[10] = 0.715857
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 34 rows, 60 cols, 257 nonzeros, 5 slack, 29 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % @PAP adding 2 rows, 5 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=30, varin=58, theta=1.000000, up=1.000000
ITER 2: row=27, varin=53, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=31)
DEBUG SOLUTION: LP solution array indices: FST[32-71], not_covered[72-91]
DEBUG SOLUTION: lp->best_solution[0] = 27794111.932408
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 0.000000
DEBUG SOLUTION: lp->best_solution[6] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 31 rows, 60 cols, 246 nonzeros, 0 slack, 31 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 3 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=34, varin=35, theta=0.219950, up=1.000000
ITER 2: row=33, varin=62, theta=0.155309, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=34)
DEBUG SOLUTION: LP solution array indices: FST[35-74], not_covered[75-94]
DEBUG SOLUTION: lp->best_solution[0] = 27803864.991300
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 0.000000
DEBUG SOLUTION: lp->best_solution[6] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 34 rows, 60 cols, 254 nonzeros, 0 slack, 34 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 7 rows, 23 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=35, varin=33, theta=0.435154, up=999999999999999983222784.000000
ITER 2: row=41, varin=51, theta=0.164327, up=1.000000
ITER 3: row=32, varin=71, theta=0.331598, up=1.000000
ITER 4: row=40, varin=65, theta=0.272849, up=1.000000
ITER 5: row=23, varin=32, theta=0.766906, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=41)
DEBUG SOLUTION: LP solution array indices: FST[42-81], not_covered[82-101]
DEBUG SOLUTION: lp->best_solution[0] = 27847518.583325
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 0.000000
DEBUG SOLUTION: lp->best_solution[6] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 41 rows, 60 cols, 277 nonzeros, 2 slack, 39 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 2 rows, 5 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=40, varin=67, theta=0.804155, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=41)
DEBUG SOLUTION: LP solution array indices: FST[42-81], not_covered[82-101]
DEBUG SOLUTION: lp->best_solution[0] = 27847930.916179
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 0.000000
DEBUG SOLUTION: lp->best_solution[6] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 41 rows, 60 cols, 278 nonzeros, 0 slack, 41 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 5 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=42, varin=61, theta=0.048836, up=1.000000
ITER 2: row=29, varin=88, theta=0.088969, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 27862798.355734
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.911031
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 0.000000
DEBUG SOLUTION: lp->best_solution[6] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 42 rows, 60 cols, 283 nonzeros, 2 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 3 rows, 7 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=42, varin=80, theta=0.141641, up=1.000000
ITER 2: row=19, varin=68, theta=0.610892, up=1.000000
ITER 3: row=33, varin=85, theta=0.083116, up=1.000000
ITER 4: row=39, varin=76, theta=0.255289, up=1.000000
ITER 5: row=35, varin=66, theta=0.074765, up=1.000000
ITER 6: row=26, varin=54, theta=0.098711, up=1.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 27874075.609694
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 43 rows, 60 cols, 286 nonzeros, 0 slack, 43 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 42 LP 1 Solution, length = 27874075.609694, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.098711 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.549356 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 1.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 1.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.450644 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.450644 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.098711 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.901289 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.901289 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.450644 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.450644 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=27874075.609694, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 42 at  27.87407560969392150696
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ad4c4c1bb0
% @LO 0.03  27.66882153990362169793 99.9000000000
% @LN 0.03  27.67150405985485406291 99.9000000000
% Resuming node 57 at  27.67150405985485406291
DEBUG CONSTRNT: LP rows=43, pool->nlprows=43, pool->npend=0
DEBUG CONSTRNT: Checking 43 LP rows (pool tracks 43, total LP rows 43)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 82
DEBUG CONSTRNT: Pool row 82 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 137
DEBUG CONSTRNT: Pool row 137 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 49
DEBUG CONSTRNT: Pool row 49 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 68
DEBUG CONSTRNT: Pool row 68 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 133
DEBUG CONSTRNT: Pool row 133 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=42, expected 42
 % @PAP adding 40 rows, 162 nz to LP
DEBUG BB: Processing node 57, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 57 LP 2 Solution, length = 27671504.059855, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.500000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.500000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.500000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.500000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.500000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.500000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.500000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.500000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=27671504.059855, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=27671504.059855, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 57 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 57
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.500000
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.500000
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=1.000000
DEBUG CAREFUL: Skipping var 7: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.500000
DEBUG CAREFUL: Adding var 22 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.500000
DEBUG CAREFUL: Adding var 27 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 4 fractional variables

  %  Carefully choosing branching variable, nfrac = 4
DEBUG CAREFUL: Testing fvar[0] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 3
DEBUG CAREFUL: New best var: 3
DEBUG CAREFUL: Testing fvar[1] = var 22
DEBUG CAREFUL: Calling compare_branch_vars for var 22
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 22
DEBUG CAREFUL: Testing fvar[2] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[3] = var 27
DEBUG CAREFUL: Calling compare_branch_vars for var 27
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 27
  % Initial guess is x3, Z0 = 27671504.0598549        , Z1 = 27671504.0598549        

DEBUG EVAL: Testing var 3 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=13, varin=71, theta=0.500000, up=1.000000
DEBUG EVAL: Branch var 3 = 0 gives z=27693066.151740
  % 	x3 = 0,	Z0 = 27693066.1517398        
DEBUG EVAL: First branch cutoff check: z=27693066.151740, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 3 = 1
ITER 1: row=13, varin=40, theta=1.000000, up=999999999999999983222784.000000
  % 	x3 = 1,	Z1 = 27674625.1607382        
DEBUG EVAL: Second branch cutoff check: z=27674625.160738, best_z=INF, threshold=INF
  %   New best:  x3, Z = 27674625.1607382        
DEBUG EVAL: Testing var 22 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=20, varin=71, theta=0.500000, up=1.000000
DEBUG EVAL: Branch var 22 = 0 gives z=27693066.151740
  % 	x22 = 0,	Z0 = 27693066.1517398        
DEBUG EVAL: First branch cutoff check: z=27693066.151740, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 22 = 1
ITER 1: row=20, varin=40, theta=1.000000, up=999999999999999983222784.000000
  % 	x22 = 1,	Z1 = 27674625.1607382        
DEBUG EVAL: Second branch cutoff check: z=27674625.160738, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 2 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=30, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 0 gives z=27852852.103785
  % 	x2 = 0,	Z0 = 27852852.1037852        
DEBUG EVAL: First branch cutoff check: z=27852852.103785, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 1
ITER 1: row=1, varin=40, theta=1.000000, up=999999999999999983222784.000000
  % 	x2 = 1,	Z1 = 27674625.1607382        
DEBUG EVAL: Second branch cutoff check: z=27674625.160738, best_z=INF, threshold=INF
  %   New best:  x2, Z = 27674625.1607382        
DEBUG EVAL: Testing var 27 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=30, varin=40, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 27 = 0 gives z=27674625.160738
  % 	x27 = 0,	Z0 = 27674625.1607382        
DEBUG EVAL: First branch cutoff check: z=27674625.160738, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 27 = 1
ITER 1: row=30, varin=16, theta=1.000000, up=999999999999999983222784.000000
  % 	x27 = 1,	Z1 = 28065586.7001145        
DEBUG EVAL: Second branch cutoff check: z=28065586.700114, best_z=INF, threshold=INF
  %   New best:  x27, Z = 27674625.1607382        
  % Best branch is x27, Z0 = 27674625.1607382        , Z1 = 28065586.7001145        

DEBUG CAREFUL: Final result - returning best.var = 27
DEBUG BB: Branching variable chosen: j=27
 % @NC   59   57	x27 = 0	27674625.160738
 % @NC   60   57	x27 = 1	28065586.700114
 %      57    26 27671504.0599               27674625.1607   x29 D    51     9
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ad4c4ad660
% @LO 0.04  27.67150405985485406291 99.9000000000
% @LN 0.04  27.67462516073821632290 99.9000000000
% Resuming node 59 at  27.67462516073821632290
DEBUG CONSTRNT: LP rows=40, pool->nlprows=40, pool->npend=0
DEBUG CONSTRNT: Checking 40 LP rows (pool tracks 40, total LP rows 40)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 133
DEBUG CONSTRNT: Pool row 133 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=39, expected 39
 % @PAP adding 40 rows, 162 nz to LP
DEBUG BB: Processing node 59, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=30, varin=40, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=40)
DEBUG SOLUTION: LP solution array indices: FST[41-80], not_covered[81-100]
DEBUG SOLUTION: lp->best_solution[0] = 27674625.160738
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 40 rows, 60 cols, 222 nonzeros, 1 slack, 39 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=41, varin=72, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=41)
DEBUG SOLUTION: LP solution array indices: FST[42-81], not_covered[82-101]
DEBUG SOLUTION: lp->best_solution[0] = 27696187.252623
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 41 rows, 60 cols, 226 nonzeros, 1 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 4 rows, 15 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=41, varin=78, theta=0.500000, up=1.000000
ITER 2: row=44, varin=31, theta=0.125000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 27724106.134105
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 44 rows, 60 cols, 239 nonzeros, 4 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % @PAP adding 3 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=41, varin=50, theta=0.500000, up=1.000000
ITER 2: row=17, varin=40, theta=1.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 27764166.937404
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 43 rows, 60 cols, 235 nonzeros, 2 slack, 41 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % Node 59 LP 1 Solution, length = 27764166.937404, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.500000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.500000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.500000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.500000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.500000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.500000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.500000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.500000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.500000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.500000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=27764166.937404, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 59 at  27.76416693740379670885
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ad4c4ae540
% @LO 0.04  27.67462516073821632290 99.9000000000
% @LN 0.04  27.67962469620590226782 99.9000000000
% Resuming node 55 at  27.67962469620590226782
DEBUG CONSTRNT: LP rows=41, pool->nlprows=41, pool->npend=0
DEBUG CONSTRNT: Checking 41 LP rows (pool tracks 41, total LP rows 41)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 133
DEBUG CONSTRNT: Pool row 133 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=40, expected 40
 % @PAP adding 25 rows, 164 nz to LP
DEBUG BB: Processing node 55, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=16, varin=19, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=22, varin=24, theta=0.454120, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=25)
DEBUG SOLUTION: LP solution array indices: FST[26-65], not_covered[66-85]
DEBUG SOLUTION: lp->best_solution[0] = 27679624.696206
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 25 rows, 60 cols, 224 nonzeros, 2 slack, 23 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 11 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=26, varin=22, theta=0.410283, up=999999999999999983222784.000000
ITER 2: row=22, varin=31, theta=0.213260, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=27)
DEBUG SOLUTION: LP solution array indices: FST[28-67], not_covered[68-87]
DEBUG SOLUTION: lp->best_solution[0] = 27692399.111039
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 27 rows, 60 cols, 235 nonzeros, 3 slack, 24 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 3 rows, 14 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=25, varin=28, theta=0.217665, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=27)
DEBUG SOLUTION: LP solution array indices: FST[28-67], not_covered[68-87]
DEBUG SOLUTION: lp->best_solution[0] = 27700716.734645
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 27 rows, 60 cols, 226 nonzeros, 0 slack, 27 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 6 rows, 21 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=28, varin=70, theta=0.488802, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=33)
DEBUG SOLUTION: LP solution array indices: FST[34-73], not_covered[74-93]
DEBUG SOLUTION: lp->best_solution[0] = 27725939.331313
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 33 rows, 60 cols, 247 nonzeros, 0 slack, 33 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=34, varin=70, theta=0.217652, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=35)
DEBUG SOLUTION: LP solution array indices: FST[36-75], not_covered[76-95]
DEBUG SOLUTION: lp->best_solution[0] = 27727398.198881
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 35 rows, 60 cols, 251 nonzeros, 0 slack, 35 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 55 LP 1 Solution, length = 27727398.198881, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.260783 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.260783 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.260783 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 1.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 1.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.217652 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.260783 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.739217 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.739217 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.739217 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.739217 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=27727398.198881, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 55 at  27.72739819888053958152
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ad4c49c780
% @LO 0.04  27.67962469620590226782 99.9000000000
% @LN 0.04  27.68060467408140823409 99.9000000000
% Resuming node 53 at  27.68060467408140823409
DEBUG CONSTRNT: LP rows=35, pool->nlprows=35, pool->npend=0
DEBUG CONSTRNT: Checking 35 LP rows (pool tracks 35, total LP rows 35)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=34, expected 34
 % @PAP adding 32 rows, 180 nz to LP
DEBUG BB: Processing node 53, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 53 LP 2 Solution, length = 27680604.674081, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.283863 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.283863 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.283863 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.851590 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 1.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.716137 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.716137 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.148410 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.716137 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.148410 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.148410 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=27680604.674081, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=27680604.674081, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 53 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 53
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=1.000000
DEBUG CAREFUL: Skipping var 2: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.283863
DEBUG CAREFUL: Adding var 5 to fractional list (xi=0.283863)
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.283863
DEBUG CAREFUL: Adding var 7 to fractional list (xi=0.283863)
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.283863
DEBUG CAREFUL: Adding var 9 to fractional list (xi=0.283863)
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.851590
DEBUG CAREFUL: Adding var 12 to fractional list (xi=0.851590)
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=1.000000
DEBUG CAREFUL: Skipping var 20: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 4 fractional variables

  %  Carefully choosing branching variable, nfrac = 4
DEBUG CAREFUL: Testing fvar[0] = var 12
DEBUG CAREFUL: Calling compare_branch_vars for var 12
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 12
DEBUG CAREFUL: New best var: 12
DEBUG CAREFUL: Testing fvar[1] = var 9
DEBUG CAREFUL: Calling compare_branch_vars for var 9
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 9
DEBUG CAREFUL: New best var: 9
DEBUG CAREFUL: Testing fvar[2] = var 7
DEBUG CAREFUL: Calling compare_branch_vars for var 7
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 7
DEBUG CAREFUL: Testing fvar[3] = var 5
DEBUG CAREFUL: Calling compare_branch_vars for var 5
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 5
  % Initial guess is x9, Z0 = 27680604.6740814        , Z1 = 27785210.5662722        

DEBUG EVAL: Testing var 12 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=12, varin=15, theta=0.371936, up=999999999999999983222784.000000
ITER 2: row=3, varin=33, theta=0.145412, up=1.000000
ITER 3: row=16, varin=87, theta=0.637421, up=1.000000
ITER 4: row=23, varin=77, theta=0.045427, up=1.000000
DEBUG EVAL: Branch var 12 = 1 gives z=27699853.797203
  % 	x12 = 1,	Z1 = 27699853.7972027        
DEBUG EVAL: First branch cutoff check: z=27699853.797203, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 12 = 0
ITER 1: row=12, varin=32, theta=1.154506, up=999999999999999983222784.000000
ITER 2: row=14, varin=30, theta=1.126080, up=999999999999999983222784.000000
ITER 3: row=5, varin=21, theta=0.094308, up=999999999999999983222784.000000
ITER 4: row=21, varin=77, theta=0.079733, up=1.000000
  % 	x12 = 0,	Z0 = 27740208.2876152        
DEBUG EVAL: Second branch cutoff check: z=27740208.287615, best_z=INF, threshold=INF
  %   New best:  x12, Z = 27699853.7972027        
DEBUG EVAL: Testing var 9 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=14, varin=30, theta=2.189172, up=999999999999999983222784.000000
ITER 2: row=1, varin=15, theta=2.924730, up=999999999999999983222784.000000
ITER 3: row=3, varin=17, theta=1.240451, up=999999999999999983222784.000000
ITER 4: row=5, varin=24, theta=0.142779, up=999999999999999983222784.000000
ITER 5: row=24, varin=21, theta=0.237690, up=999999999999999983222784.000000
ITER 6: row=21, varin=3, theta=0.387634, up=999999999999999983222784.000000
ITER 7: row=6, varin=35, theta=0.391861, up=1.000000
DEBUG EVAL: Branch var 9 = 1 gives z=27823410.517626
  % 	x9 = 1,	Z1 = 27823410.5176258        
DEBUG EVAL: First branch cutoff check: z=27823410.517626, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 9 = 0
ITER 1: row=14, varin=32, theta=0.490089, up=999999999999999983222784.000000
  % 	x9 = 0,	Z0 = 27701512.7370871        
DEBUG EVAL: Second branch cutoff check: z=27701512.737087, best_z=INF, threshold=INF
  %   New best:  x9, Z = 27701512.7370871        
DEBUG EVAL: Testing var 7 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=5, varin=87, theta=1.110039, up=1.000000
ITER 2: row=5, varin=33, theta=0.086196, up=1.000000
ITER 3: row=23, varin=87, theta=1.000000, up=1.000000
ITER 4: row=16, varin=17, theta=0.790112, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 7 = 0 gives z=27741321.034299
  % 	x7 = 0,	Z0 = 27741321.034299         
DEBUG EVAL: First branch cutoff check: z=27741321.034299, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 7 = 1
ITER 1: row=5, varin=30, theta=2.189172, up=999999999999999983222784.000000
ITER 2: row=1, varin=15, theta=2.924730, up=999999999999999983222784.000000
ITER 3: row=3, varin=32, theta=0.924470, up=999999999999999983222784.000000
  % 	x7 = 1,	Z1 = 27729020.5895439        
DEBUG EVAL: Second branch cutoff check: z=27729020.589544, best_z=INF, threshold=INF
  %   New best:  x7, Z = 27729020.5895439        
DEBUG EVAL: Testing var 5 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=32, theta=1.701877, up=999999999999999983222784.000000
ITER 2: row=14, varin=15, theta=2.220515, up=999999999999999983222784.000000
ITER 3: row=3, varin=14, theta=0.941776, up=999999999999999983222784.000000
ITER 4: row=31, varin=24, theta=0.559221, up=999999999999999983222784.000000
ITER 5: row=18, varin=18, theta=1.939106, up=999999999999999983222784.000000
ITER 6: row=12, varin=59, theta=1.625821, up=1.000000
ITER 7: row=12, varin=54, theta=0.506678, up=1.000000
ITER 8: row=22, varin=59, theta=1.000000, up=1.000000
ITER 9: row=24, varin=17, theta=1.027560, up=999999999999999983222784.000000
ITER 10: row=12, varin=60, theta=0.071953, up=1.000000
DEBUG EVAL: Branch var 5 = 1 gives z=28100527.577083
  % 	x5 = 1,	Z1 = 28100527.5770825        
DEBUG EVAL: First branch cutoff check: z=28100527.577083, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 5 = 0
ITER 1: row=1, varin=30, theta=0.421867, up=999999999999999983222784.000000
  % 	x5 = 0,	Z0 = 27684391.5107838        
DEBUG EVAL: Second branch cutoff check: z=27684391.510784, best_z=INF, threshold=INF
  % Best branch is x7, Z0 = 27741321.034299         , Z1 = 27729020.5895439        

DEBUG CAREFUL: Final result - returning best.var = 7
DEBUG BB: Branching variable chosen: j=7
 % @NC   61   53	x7 = 1	27729020.589544
 % @NC   62   53	x7 = 0	27741321.034299
 %      53    27 27680604.6741               27687967.1392    x8 D    43     7
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ad4c4b6b40
% @LO 0.04  27.68060467408140823409 99.9000000000
% @LN 0.04  27.68796713920962559996 99.9000000000
% Resuming node 56 at  27.68796713920962559996
DEBUG CONSTRNT: LP rows=32, pool->nlprows=32, pool->npend=0
DEBUG CONSTRNT: Checking 32 LP rows (pool tracks 32, total LP rows 32)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 141
DEBUG CONSTRNT: Pool row 141 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 145
DEBUG CONSTRNT: Pool row 145 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 159
DEBUG CONSTRNT: Pool row 159 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=31, expected 31
 % @PAP adding 25 rows, 164 nz to LP
DEBUG BB: Processing node 56, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=16, varin=25, theta=1.333333, up=999999999999999983222784.000000
ITER 2: row=1, varin=13, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=13, varin=24, theta=0.478780, up=999999999999999983222784.000000
ITER 4: row=18, varin=17, theta=0.894007, up=999999999999999983222784.000000
ITER 5: row=1, varin=23, theta=0.105993, up=999999999999999983222784.000000
ITER 6: row=6, varin=31, theta=0.118820, up=1.000000
ITER 7: row=21, varin=13, theta=0.118820, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=7)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=25)
DEBUG SOLUTION: LP solution array indices: FST[26-65], not_covered[66-85]
DEBUG SOLUTION: lp->best_solution[0] = 27687967.139210
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.881180
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 25 rows, 60 cols, 224 nonzeros, 5 slack, 20 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 5 rows, 27 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=27, varin=16, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=29, varin=21, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=1, varin=88, theta=1.881180, up=1.000000
ITER 4: row=1, varin=45, theta=0.204013, up=1.000000
ITER 5: row=24, varin=41, theta=0.019982, up=1.000000
ITER 6: row=13, varin=40, theta=0.032733, up=1.000000
ITER 7: row=23, varin=83, theta=0.013748, up=1.000000
ITER 8: row=26, varin=23, theta=0.023703, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=8)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=30)
DEBUG SOLUTION: LP solution array indices: FST[31-70], not_covered[71-90]
DEBUG SOLUTION: lp->best_solution[0] = 27703185.303795
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 30 rows, 60 cols, 251 nonzeros, 6 slack, 24 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 6 slack rows
  % @PAP adding 2 rows, 7 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=25, varin=18, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=14, varin=84, theta=0.194333, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=26)
DEBUG SOLUTION: LP solution array indices: FST[27-66], not_covered[67-86]
DEBUG SOLUTION: lp->best_solution[0] = 27709413.058753
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 26 rows, 60 cols, 229 nonzeros, 3 slack, 23 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 2 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=24, varin=78, theta=0.043074, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=25)
DEBUG SOLUTION: LP solution array indices: FST[26-65], not_covered[66-85]
DEBUG SOLUTION: lp->best_solution[0] = 27709448.669523
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 25 rows, 60 cols, 228 nonzeros, 1 slack, 24 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 56 LP 1 Solution, length = 27709448.669523, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.728463 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.228463 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.043074 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.043074 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.228463 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.771537 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 1.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.271537 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.228463 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.228463 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.228463 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.271537 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.956926 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.956926 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.771537 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.228463 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=27709448.669523, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 56 at  27.70944866952316232300
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ad4c4a4590
% @LO 0.04  27.68796713920962559996 99.9000000000
% @LN 0.04  27.70277458612553189710 99.9000000000
% Resuming node 34 at  27.70277458612553189710
DEBUG CONSTRNT: LP rows=24, pool->nlprows=24, pool->npend=0
DEBUG CONSTRNT: Checking 24 LP rows (pool tracks 24, total LP rows 24)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=23, expected 23
 % @PAP adding 27 rows, 131 nz to LP
DEBUG BB: Processing node 34, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 34 LP 2 Solution, length = 27702774.586126, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.500000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.500000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.500000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.500000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.500000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.500000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.500000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.500000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.500000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.500000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.500000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=27702774.586126, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=27702774.586126, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 3 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 34 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 34
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.500000
DEBUG CAREFUL: Adding var 0 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.500000
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=1.000000
DEBUG CAREFUL: Skipping var 2: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=1.000000
DEBUG CAREFUL: Skipping var 7: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.500000
DEBUG CAREFUL: Adding var 14 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.500000
DEBUG CAREFUL: Adding var 15 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 4 fractional variables

  %  Carefully choosing branching variable, nfrac = 4
DEBUG CAREFUL: Testing fvar[0] = var 0
DEBUG CAREFUL: Calling compare_branch_vars for var 0
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 0
DEBUG CAREFUL: New best var: 0
DEBUG CAREFUL: Testing fvar[1] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 1
DEBUG CAREFUL: Testing fvar[2] = var 14
DEBUG CAREFUL: Calling compare_branch_vars for var 14
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 14
DEBUG CAREFUL: Testing fvar[3] = var 15
DEBUG CAREFUL: Calling compare_branch_vars for var 15
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 15
  % Initial guess is x0, Z0 = 27702774.5861255        , Z1 = 27723463.3337444        

DEBUG EVAL: Testing var 0 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=38, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 0 = 1 gives z=27780743.524614
  % 	x0 = 1,	Z1 = 27780743.524614         
DEBUG EVAL: First branch cutoff check: z=27780743.524614, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 0 = 0
ITER 1: row=1, varin=22, theta=1.000000, up=999999999999999983222784.000000
  % 	x0 = 0,	Z0 = 27716834.179889         
DEBUG EVAL: Second branch cutoff check: z=27716834.179889, best_z=INF, threshold=INF
  %   New best:  x0, Z = 27716834.179889         
DEBUG EVAL: Testing var 1 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=3, varin=22, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 1 = 0 gives z=27716834.179889
  % 	x1 = 0,	Z0 = 27716834.179889         
DEBUG EVAL: First branch cutoff check: z=27716834.179889, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 1 = 1
ITER 1: row=3, varin=34, theta=0.333333, up=1.000000
  % 	x1 = 1,	Z1 = 27755603.3036915        
DEBUG EVAL: Second branch cutoff check: z=27755603.303691, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 14 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=11, varin=26, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 14 = 0 gives z=27800175.267703
  % 	x14 = 0,	Z0 = 27800175.2677029        
DEBUG EVAL: First branch cutoff check: z=27800175.267703, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 14 = 1
ITER 1: row=11, varin=27, theta=1.000000, up=999999999999999983222784.000000
  % 	x14 = 1,	Z1 = 27733424.5987146        
DEBUG EVAL: Second branch cutoff check: z=27733424.598715, best_z=INF, threshold=INF
  %   New best:  x14, Z = 27733424.5987146        
DEBUG EVAL: Testing var 15 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=23, varin=27, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 15 = 0 gives z=27733424.598715
  % 	x15 = 0,	Z0 = 27733424.5987146        
DEBUG EVAL: First branch cutoff check: z=27733424.598715, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 15 = 1
ITER 1: row=23, varin=26, theta=1.000000, up=999999999999999983222784.000000
  % 	x15 = 1,	Z1 = 27800175.2677029        
DEBUG EVAL: Second branch cutoff check: z=27800175.267703, best_z=INF, threshold=INF
  % Best branch is x14, Z0 = 27800175.2677029        , Z1 = 27733424.5987146        

DEBUG CAREFUL: Final result - returning best.var = 14
DEBUG BB: Branching variable chosen: j=14
 % @NC   63   34	x14 = 1	27733424.598715
 % @NC   64   34	x14 = 0	27800175.267703
 %      34    28 27702774.5861               27709448.6695   x19 D    27     5
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ad4c4b6b40
% @LO 0.04  27.70277458612553189710 99.9000000000
% @LN 0.04  27.70944866952316232300 99.9000000000
% Resuming node 56 at  27.70944866952316232300
DEBUG CONSTRNT: LP rows=27, pool->nlprows=27, pool->npend=0
DEBUG CONSTRNT: Checking 27 LP rows (pool tracks 27, total LP rows 27)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 142
DEBUG CONSTRNT: Pool row 142 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=26, expected 26
 % @PAP adding 24 rows, 162 nz to LP
DEBUG BB: Processing node 56, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 56 LP 2 Solution, length = 27709448.669523, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.728463 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.228463 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.043074 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.043074 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.228463 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.771537 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 1.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.271537 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.228463 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.228463 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.228463 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.271537 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.956926 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.956926 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.771537 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.228463 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=27709448.669523, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=27709448.669523, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 56 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 56
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=1.000000
DEBUG CAREFUL: Skipping var 2: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.728463
DEBUG CAREFUL: Adding var 5 to fractional list (xi=0.728463)
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.228463
DEBUG CAREFUL: Adding var 8 to fractional list (xi=0.228463)
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.043074
DEBUG CAREFUL: Adding var 9 to fractional list (xi=0.043074)
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.043074
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.043074)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.228463
DEBUG CAREFUL: Adding var 12 to fractional list (xi=0.228463)
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.771537
DEBUG CAREFUL: Adding var 14 to fractional list (xi=0.771537)
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=1.000000
DEBUG CAREFUL: Skipping var 17: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 6 fractional variables

  %  Carefully choosing branching variable, nfrac = 6
DEBUG CAREFUL: Testing fvar[0] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 10
DEBUG CAREFUL: New best var: 10
DEBUG CAREFUL: Testing fvar[1] = var 8
DEBUG CAREFUL: Calling compare_branch_vars for var 8
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 8
DEBUG CAREFUL: New best var: 8
DEBUG CAREFUL: Testing fvar[2] = var 9
DEBUG CAREFUL: Calling compare_branch_vars for var 9
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 9
DEBUG CAREFUL: Testing fvar[3] = var 5
DEBUG CAREFUL: Calling compare_branch_vars for var 5
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 5
DEBUG CAREFUL: Testing fvar[4] = var 12
DEBUG CAREFUL: Calling compare_branch_vars for var 12
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 12
DEBUG CAREFUL: Testing fvar[5] = var 14
DEBUG CAREFUL: Calling compare_branch_vars for var 14
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 14
  % Initial guess is x8, Z0 = 27709448.6695232        , Z1 = 27803758.7045823        

DEBUG EVAL: Testing var 10 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=13, varin=24, theta=2.473352, up=999999999999999983222784.000000
ITER 2: row=6, varin=19, theta=0.679798, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 1 gives z=27766255.518531
  % 	x10 = 1,	Z1 = 27766255.5185315        
DEBUG EVAL: First branch cutoff check: z=27766255.518531, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 0
ITER 1: row=13, varin=6, theta=0.065478, up=999999999999999983222784.000000
  % 	x10 = 0,	Z0 = 27710253.5709584        
DEBUG EVAL: Second branch cutoff check: z=27710253.570958, best_z=INF, threshold=INF
  %   New best:  x10, Z = 27710253.5709584        
DEBUG EVAL: Testing var 8 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=5, varin=24, theta=2.516816, up=999999999999999983222784.000000
ITER 2: row=6, varin=17, theta=3.000000, up=999999999999999983222784.000000
ITER 3: row=21, varin=13, theta=2.000000, up=999999999999999983222784.000000
ITER 4: row=14, varin=8, theta=1.768546, up=999999999999999983222784.000000
ITER 5: row=8, varin=9, theta=1.768546, up=999999999999999983222784.000000
ITER 6: row=9, varin=10, theta=0.768546, up=999999999999999983222784.000000
ITER 7: row=10, varin=11, theta=0.768546, up=999999999999999983222784.000000
ITER 8: row=11, varin=12, theta=0.768546, up=999999999999999983222784.000000
ITER 9: row=12, varin=15, theta=0.768546, up=999999999999999983222784.000000
ITER 10: row=15, varin=18, theta=0.768546, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 8 = 1 gives z=27803758.704582
  % 	x8 = 1,	Z1 = 27803758.7045823        
DEBUG EVAL: First branch cutoff check: z=27803758.704582, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 8 = 0
ITER 1: row=5, varin=6, theta=1.335431, up=999999999999999983222784.000000
ITER 2: row=1, varin=19, theta=0.367852, up=999999999999999983222784.000000
  % 	x8 = 0,	Z0 = 27745349.0183772        
DEBUG EVAL: Second branch cutoff check: z=27745349.018377, best_z=INF, threshold=INF
  %   New best:  x8, Z = 27745349.0183772        
DEBUG EVAL: Testing var 9 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=6, varin=13, theta=1.266086, up=999999999999999983222784.000000
ITER 2: row=22, varin=14, theta=0.223824, up=999999999999999983222784.000000
ITER 3: row=13, varin=19, theta=0.239838, up=999999999999999983222784.000000
ITER 4: row=1, varin=6, theta=0.335212, up=999999999999999983222784.000000
ITER 5: row=5, varin=8, theta=0.862946, up=999999999999999983222784.000000
ITER 6: row=8, varin=9, theta=0.862946, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 9 = 1 gives z=27808697.719409
  % 	x9 = 1,	Z1 = 27808697.7194092        
DEBUG EVAL: First branch cutoff check: z=27808697.719409, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 9 = 0
ITER 1: row=6, varin=24, theta=0.070256, up=999999999999999983222784.000000
  % 	x9 = 0,	Z0 = 27709471.1413444        
DEBUG EVAL: Second branch cutoff check: z=27709471.141344, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 5 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=24, theta=0.885776, up=999999999999999983222784.000000
ITER 2: row=6, varin=6, theta=0.166667, up=999999999999999983222784.000000
ITER 3: row=1, varin=13, theta=0.103016, up=999999999999999983222784.000000
ITER 4: row=13, varin=19, theta=0.166429, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 5 = 1 gives z=27726690.583734
  % 	x5 = 1,	Z1 = 27726690.5837344        
DEBUG EVAL: First branch cutoff check: z=27726690.583734, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 12 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=7, varin=19, theta=0.544912, up=999999999999999983222784.000000
ITER 2: row=17, varin=7, theta=0.016692, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 12 = 0 gives z=27754955.863081
  % 	x12 = 0,	Z0 = 27754955.8630815        
DEBUG EVAL: First branch cutoff check: z=27754955.863081, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 12 = 1
ITER 1: row=7, varin=24, theta=2.516816, up=999999999999999983222784.000000
ITER 2: row=6, varin=6, theta=1.500000, up=999999999999999983222784.000000
ITER 3: row=1, varin=8, theta=2.000000, up=999999999999999983222784.000000
ITER 4: row=8, varin=17, theta=2.000000, up=999999999999999983222784.000000
ITER 5: row=21, varin=18, theta=2.000000, up=999999999999999983222784.000000
ITER 6: row=19, varin=9, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=7, varin=13, theta=0.000702, up=999999999999999983222784.000000
ITER 8: row=13, varin=30, theta=0.000913, up=1.000000
  % 	x12 = 1,	Z1 = 27778327.5045995        
DEBUG EVAL: Second branch cutoff check: z=27778327.504600, best_z=INF, threshold=INF
  %   New best:  x12, Z = 27754955.8630815        
DEBUG EVAL: Testing var 14 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=16, varin=19, theta=0.544912, up=999999999999999983222784.000000
ITER 2: row=1, varin=28, theta=0.039766, up=1.000000
DEBUG EVAL: Branch var 14 = 1 gives z=27757109.489510
  % 	x14 = 1,	Z1 = 27757109.4895102        
DEBUG EVAL: First branch cutoff check: z=27757109.489510, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 14 = 0
ITER 1: row=16, varin=24, theta=2.516816, up=999999999999999983222784.000000
ITER 2: row=6, varin=6, theta=1.500000, up=999999999999999983222784.000000
ITER 3: row=1, varin=8, theta=2.000000, up=999999999999999983222784.000000
ITER 4: row=8, varin=17, theta=2.000000, up=999999999999999983222784.000000
ITER 5: row=21, varin=18, theta=2.000000, up=999999999999999983222784.000000
ITER 6: row=19, varin=9, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=16, varin=13, theta=0.000702, up=999999999999999983222784.000000
ITER 8: row=13, varin=30, theta=0.000913, up=1.000000
  % 	x14 = 0,	Z0 = 27778327.5045995        
DEBUG EVAL: Second branch cutoff check: z=27778327.504600, best_z=INF, threshold=INF
  %   New best:  x14, Z = 27757109.4895102        
  % Best branch is x14, Z0 = 27778327.5045995        , Z1 = 27757109.4895102        

DEBUG CAREFUL: Final result - returning best.var = 14
DEBUG BB: Branching variable chosen: j=14
 % @NC   65   56	x14 = 1	27757109.489510
 % @NC   66   56	x14 = 0	27778327.504600
 %      56    29 27709448.6695               27712005.9683   x15 D    41     8
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ad4c4a5090
% @LO 0.04  27.70944866952316232300 99.9000000000
% @LN 0.04  27.71200596833951124154 99.9000000000
% Resuming node 10 at  27.71200596833951124154
DEBUG CONSTRNT: LP rows=24, pool->nlprows=24, pool->npend=0
DEBUG CONSTRNT: Checking 24 LP rows (pool tracks 24, total LP rows 24)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=23, expected 23
 % @PAP adding 43 rows, 234 nz to LP
DEBUG BB: Processing node 10, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 10 LP 2 Solution, length = 27712005.968340, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.426248 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.713124 (FST 12)
  % DEBUG LP_VARS: x[13] = 1.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 1.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.286876 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.286876 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.426248 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.573752 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.573752 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.286876 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.286876 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=27712005.968340, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=27712005.968340, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 10 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 10
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=1.000000
DEBUG CAREFUL: Skipping var 2: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.426248
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.426248)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.713124
DEBUG CAREFUL: Adding var 12 to fractional list (xi=0.713124)
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=1.000000
DEBUG CAREFUL: Skipping var 13: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=1.000000
DEBUG CAREFUL: Skipping var 17: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.286876
DEBUG CAREFUL: Adding var 21 to fractional list (xi=0.286876)
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.286876
DEBUG CAREFUL: Adding var 25 to fractional list (xi=0.286876)
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.426248
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.426248)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 26
DEBUG CAREFUL: New best var: 26
DEBUG CAREFUL: Testing fvar[1] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[2] = var 21
DEBUG CAREFUL: Calling compare_branch_vars for var 21
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 21
DEBUG CAREFUL: Testing fvar[3] = var 25
DEBUG CAREFUL: Calling compare_branch_vars for var 25
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 25
DEBUG CAREFUL: Testing fvar[4] = var 12
DEBUG CAREFUL: Calling compare_branch_vars for var 12
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 12
  % Initial guess is x26, Z0 = 27712005.9683395        , Z1 = 27712005.9683395        

DEBUG EVAL: Testing var 26 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=31, varin=42, theta=0.080771, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 26 = 0 gives z=27713216.398468
  % 	x26 = 0,	Z0 = 27713216.3984685        
DEBUG EVAL: First branch cutoff check: z=27713216.398468, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 26 = 1
ITER 1: row=31, varin=41, theta=0.083468, up=999999999999999983222784.000000
ITER 2: row=15, varin=47, theta=0.434563, up=1.000000
ITER 3: row=28, varin=34, theta=1.483847, up=999999999999999983222784.000000
ITER 4: row=34, varin=42, theta=2.585629, up=999999999999999983222784.000000
ITER 5: row=32, varin=31, theta=0.267518, up=999999999999999983222784.000000
ITER 6: row=28, varin=33, theta=0.363593, up=999999999999999983222784.000000
ITER 7: row=1, varin=30, theta=0.283853, up=999999999999999983222784.000000
ITER 8: row=30, varin=26, theta=0.274744, up=999999999999999983222784.000000
ITER 9: row=39, varin=8, theta=3.535753, up=999999999999999983222784.000000
ITER 10: row=21, varin=38, theta=0.411743, up=999999999999999983222784.000000
  % 	x26 = 1,	Z1 = 27875195.1171002        
DEBUG EVAL: Second branch cutoff check: z=27875195.117100, best_z=INF, threshold=INF
  %   New best:  x26, Z = 27713216.3984685        
DEBUG EVAL: Testing var 10 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=4, varin=42, theta=0.080771, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 0 gives z=27713216.398468
  % 	x10 = 0,	Z0 = 27713216.3984684        
DEBUG EVAL: First branch cutoff check: z=27713216.398468, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 1
ITER 1: row=4, varin=41, theta=0.083468, up=999999999999999983222784.000000
ITER 2: row=15, varin=47, theta=0.434563, up=1.000000
ITER 3: row=28, varin=34, theta=1.483847, up=999999999999999983222784.000000
ITER 4: row=34, varin=42, theta=2.585629, up=999999999999999983222784.000000
ITER 5: row=32, varin=31, theta=0.267518, up=999999999999999983222784.000000
ITER 6: row=28, varin=33, theta=0.363593, up=999999999999999983222784.000000
ITER 7: row=1, varin=30, theta=0.283853, up=999999999999999983222784.000000
ITER 8: row=30, varin=26, theta=0.274744, up=999999999999999983222784.000000
ITER 9: row=39, varin=8, theta=3.535753, up=999999999999999983222784.000000
ITER 10: row=21, varin=38, theta=0.411743, up=999999999999999983222784.000000
  % 	x10 = 1,	Z1 = 28068478.2952541        
DEBUG EVAL: Second branch cutoff check: z=28068478.295254, best_z=INF, threshold=INF
  %   New best:  x10, Z = 27713216.3984684        
DEBUG EVAL: Testing var 21 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=9, varin=42, theta=0.121487, up=999999999999999983222784.000000
ITER 2: row=4, varin=25, theta=0.133785, up=999999999999999983222784.000000
ITER 3: row=25, varin=47, theta=0.383159, up=1.000000
ITER 4: row=28, varin=16, theta=0.099856, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 21 = 0 gives z=27719414.535271
  % 	x21 = 0,	Z0 = 27719414.5352708        
DEBUG EVAL: First branch cutoff check: z=27719414.535271, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 21 = 1
ITER 1: row=9, varin=41, theta=0.215248, up=999999999999999983222784.000000
ITER 2: row=15, varin=47, theta=2.098337, up=1.000000
ITER 3: row=15, varin=34, theta=1.217188, up=999999999999999983222784.000000
ITER 4: row=34, varin=28, theta=0.840962, up=999999999999999983222784.000000
ITER 5: row=28, varin=24, theta=1.205260, up=999999999999999983222784.000000
ITER 6: row=10, varin=39, theta=1.885277, up=999999999999999983222784.000000
ITER 7: row=39, varin=42, theta=2.826970, up=999999999999999983222784.000000
ITER 8: row=32, varin=8, theta=1.950835, up=999999999999999983222784.000000
ITER 9: row=29, varin=47, theta=1.000000, up=1.000000
ITER 10: row=21, varin=33, theta=0.767582, up=999999999999999983222784.000000
  % 	x21 = 1,	Z1 = 27796769.3724955        
DEBUG EVAL: Second branch cutoff check: z=27796769.372496, best_z=INF, threshold=INF
  %   New best:  x21, Z = 27719414.5352708        
DEBUG EVAL: Testing var 25 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=21, varin=42, theta=0.121487, up=999999999999999983222784.000000
ITER 2: row=4, varin=25, theta=0.133785, up=999999999999999983222784.000000
ITER 3: row=25, varin=47, theta=0.383159, up=1.000000
ITER 4: row=28, varin=16, theta=0.099856, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 25 = 0 gives z=27719414.535271
  % 	x25 = 0,	Z0 = 27719414.5352708        
DEBUG EVAL: First branch cutoff check: z=27719414.535271, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 25 = 1
ITER 1: row=21, varin=41, theta=0.215248, up=999999999999999983222784.000000
ITER 2: row=15, varin=47, theta=2.098337, up=1.000000
ITER 3: row=15, varin=34, theta=1.217188, up=999999999999999983222784.000000
  % 	x25 = 1,	Z1 = 27722737.8830811        
DEBUG EVAL: Second branch cutoff check: z=27722737.883081, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 12 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=8, varin=42, theta=0.121487, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 12 = 1 gives z=27713826.572469
  % 	x12 = 1,	Z1 = 27713826.5724693        
DEBUG EVAL: First branch cutoff check: z=27713826.572469, best_z=INF, threshold=INF
  % Best branch is x21, Z0 = 27719414.5352708        , Z1 = 27796769.3724955        

DEBUG CAREFUL: Final result - returning best.var = 21
DEBUG BB: Branching variable chosen: j=21
 % @NC   67   10	x21 = 0	27719414.535271
 % @NC   68   10	x21 = 1	27796769.372496
 %      10    30 27712005.9683               27717272.1395   x13 U     8     4
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ad4c4c1a70
% @LO 0.04  27.71200596833951124154 99.9000000000
% @LN 0.04  27.71727213951277946080 99.9000000000
% Resuming node 54 at  27.71727213951277946080
DEBUG CONSTRNT: LP rows=43, pool->nlprows=43, pool->npend=0
DEBUG CONSTRNT: Checking 43 LP rows (pool tracks 43, total LP rows 43)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 65
DEBUG CONSTRNT: Pool row 65 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 133
DEBUG CONSTRNT: Pool row 133 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=42, expected 42
 % @PAP adding 31 rows, 178 nz to LP
DEBUG BB: Processing node 54, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=14, varin=18, theta=2.075297, up=999999999999999983222784.000000
ITER 2: row=5, varin=26, theta=0.638506, up=999999999999999983222784.000000
ITER 3: row=26, varin=23, theta=1.062950, up=999999999999999983222784.000000
ITER 4: row=23, varin=21, theta=0.867664, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=31)
DEBUG SOLUTION: LP solution array indices: FST[32-71], not_covered[72-91]
DEBUG SOLUTION: lp->best_solution[0] = 27717272.139513
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 31 rows, 60 cols, 238 nonzeros, 2 slack, 29 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 5 rows, 26 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=32, varin=45, theta=2.001203, up=1.000000
ITER 2: row=32, varin=52, theta=1.303610, up=1.000000
ITER 3: row=32, varin=18, theta=0.270628, up=999999999999999983222784.000000
ITER 4: row=1, varin=52, theta=1.333333, up=1.000000
ITER 5: row=1, varin=45, theta=0.500000, up=1.000000
ITER 6: row=5, varin=3, theta=1.271844, up=999999999999999983222784.000000
ITER 7: row=3, varin=56, theta=0.623788, up=1.000000
ITER 8: row=21, varin=61, theta=1.596265, up=1.000000
ITER 9: row=21, varin=36, theta=0.094286, up=1.000000
ITER 10: row=22, varin=61, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=13)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=34)
DEBUG SOLUTION: LP solution array indices: FST[35-74], not_covered[75-94]
DEBUG SOLUTION: lp->best_solution[0] = 27969249.072887
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 34 rows, 60 cols, 260 nonzeros, 1 slack, 33 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 3 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=34, varin=29, theta=0.358522, up=999999999999999983222784.000000
ITER 2: row=36, varin=64, theta=0.678414, up=1.000000
ITER 3: row=29, varin=36, theta=0.806260, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=36)
DEBUG SOLUTION: LP solution array indices: FST[37-76], not_covered[77-96]
DEBUG SOLUTION: lp->best_solution[0] = 27985433.629081
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 36 rows, 60 cols, 266 nonzeros, 1 slack, 35 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=36, varin=60, theta=0.633210, up=1.000000
ITER 2: row=30, varin=66, theta=1.032436, up=1.000000
ITER 3: row=30, varin=59, theta=0.007317, up=1.000000
ITER 4: row=23, varin=62, theta=0.022801, up=1.000000
ITER 5: row=5, varin=3, theta=0.011307, up=999999999999999983222784.000000
ITER 6: row=6, varin=39, theta=0.012844, up=1.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=36)
DEBUG SOLUTION: LP solution array indices: FST[37-76], not_covered[77-96]
DEBUG SOLUTION: lp->best_solution[0] = 28010116.812868
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 36 rows, 60 cols, 264 nonzeros, 0 slack, 36 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 13 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=37, varin=70, theta=1.000000, up=1.000000
ITER 2: row=1, varin=91, theta=0.136009, up=1.000000
ITER 3: row=3, varin=62, theta=0.274263, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=40)
DEBUG SOLUTION: LP solution array indices: FST[41-80], not_covered[81-100]
DEBUG SOLUTION: lp->best_solution[0] = 28017819.879484
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 40 rows, 60 cols, 277 nonzeros, 0 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=41, varin=3, theta=0.148854, up=999999999999999983222784.000000
ITER 2: row=3, varin=44, theta=0.127157, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=41)
DEBUG SOLUTION: LP solution array indices: FST[42-81], not_covered[82-101]
DEBUG SOLUTION: lp->best_solution[0] = 28021446.503721
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 41 rows, 60 cols, 279 nonzeros, 0 slack, 41 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 54 LP 1 Solution, length = 28021446.503721, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.872843 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 1.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.500000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 1.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.500000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.500000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.127157 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.127157 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.500000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28021446.503721, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 54 at  28.02144650372127898663
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ad4c4b6b40
% @LO 0.04  27.71727213951277946080 99.9000000000
% @LN 0.04  27.71941453527084320285 99.9000000000
% Resuming node 67 at  27.71941453527084320285
DEBUG CONSTRNT: LP rows=41, pool->nlprows=41, pool->npend=0
DEBUG CONSTRNT: Checking 41 LP rows (pool tracks 41, total LP rows 41)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 79
DEBUG CONSTRNT: Pool row 79 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 45
DEBUG CONSTRNT: Pool row 45 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 141
DEBUG CONSTRNT: Pool row 141 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 145
DEBUG CONSTRNT: Pool row 145 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 159
DEBUG CONSTRNT: Pool row 159 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 62
DEBUG CONSTRNT: Pool row 62 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 133
DEBUG CONSTRNT: Pool row 133 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=40, expected 40
 % @PAP adding 43 rows, 234 nz to LP
DEBUG BB: Processing node 67, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=9, varin=42, theta=0.121487, up=999999999999999983222784.000000
ITER 2: row=4, varin=25, theta=0.133785, up=999999999999999983222784.000000
ITER 3: row=25, varin=47, theta=0.383159, up=1.000000
ITER 4: row=28, varin=16, theta=0.099856, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 27719414.535271
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.000000
DEBUG SOLUTION: lp->best_solution[4] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 43 rows, 60 cols, 294 nonzeros, 3 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 8 rows, 17 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=48, varin=9, theta=0.339934, up=999999999999999983222784.000000
ITER 2: row=47, varin=71, theta=0.346083, up=1.000000
ITER 3: row=27, varin=32, theta=0.252700, up=999999999999999983222784.000000
ITER 4: row=43, varin=53, theta=0.329171, up=1.000000
ITER 5: row=28, varin=59, theta=0.478254, up=1.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 27753964.105822
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.000000
DEBUG SOLUTION: lp->best_solution[4] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.478254
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 48 rows, 60 cols, 304 nonzeros, 1 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=48, varin=30, theta=0.632312, up=999999999999999983222784.000000
ITER 2: row=43, varin=79, theta=0.038065, up=1.000000
ITER 3: row=44, varin=43, theta=0.047147, up=999999999999999983222784.000000
ITER 4: row=48, varin=82, theta=0.017723, up=1.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 27763755.740643
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.000000
DEBUG SOLUTION: lp->best_solution[4] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 48 rows, 60 cols, 302 nonzeros, 3 slack, 45 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 3 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=46, varin=32, theta=0.021547, up=999999999999999983222784.000000
ITER 2: row=48, varin=30, theta=0.021825, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 27764068.558582
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.000000
DEBUG SOLUTION: lp->best_solution[4] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 48 rows, 60 cols, 302 nonzeros, 1 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 67 LP 1 Solution, length = 27764068.558582, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.021825 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.021825 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.412701 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.500000 (FST 12)
  % DEBUG LP_VARS: x[13] = 1.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 1.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.500000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.412701 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.021825 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.021825 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.021825 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.021825 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.978175 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.978175 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.978175 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.978175 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.587299 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.587299 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.500000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 10 fractional variables
DEBUG CG: LP optimal, z=27764068.558582, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 67 at  27.76406855858192201936
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ad4c4ae540
% @LO 0.04  27.71941453527084320285 99.9000000000
% @LN 0.04  27.72739819888053958152 99.9000000000
% Resuming node 55 at  27.72739819888053958152
DEBUG CONSTRNT: LP rows=47, pool->nlprows=47, pool->npend=0
DEBUG CONSTRNT: Checking 47 LP rows (pool tracks 47, total LP rows 47)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 65
DEBUG CONSTRNT: Pool row 65 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 133
DEBUG CONSTRNT: Pool row 133 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=46, expected 46
 % @PAP adding 35 rows, 191 nz to LP
DEBUG BB: Processing node 55, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 55 LP 2 Solution, length = 27727398.198881, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.260783 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.260783 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.260783 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 1.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 1.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.217652 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.260783 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.739217 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.739217 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.739217 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.739217 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=27727398.198881, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=27727398.198881, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 55 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 55
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=1.000000
DEBUG CAREFUL: Skipping var 2: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.260783
DEBUG CAREFUL: Adding var 5 to fractional list (xi=0.260783)
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.260783
DEBUG CAREFUL: Adding var 9 to fractional list (xi=0.260783)
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.260783
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.260783)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=1.000000
DEBUG CAREFUL: Skipping var 15: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=1.000000
DEBUG CAREFUL: Skipping var 17: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.217652
DEBUG CAREFUL: Adding var 34 to fractional list (xi=0.217652)
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.260783
DEBUG CAREFUL: Adding var 36 to fractional list (xi=0.260783)
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 34
DEBUG CAREFUL: Calling compare_branch_vars for var 34
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 34
DEBUG CAREFUL: New best var: 34
DEBUG CAREFUL: Testing fvar[1] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[2] = var 9
DEBUG CAREFUL: Calling compare_branch_vars for var 9
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 9
DEBUG CAREFUL: Testing fvar[3] = var 5
DEBUG CAREFUL: Calling compare_branch_vars for var 5
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 5
DEBUG CAREFUL: Testing fvar[4] = var 36
DEBUG CAREFUL: Calling compare_branch_vars for var 36
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 36
  % Initial guess is x34, Z0 = 27727398.1988805        , Z1 = 27785592.2362022        

DEBUG EVAL: Testing var 34 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=18, varin=34, theta=0.838250, up=999999999999999983222784.000000
ITER 2: row=22, varin=28, theta=0.248850, up=999999999999999983222784.000000
ITER 3: row=28, varin=25, theta=0.243814, up=999999999999999983222784.000000
ITER 4: row=25, varin=24, theta=0.519182, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 34 = 1 gives z=27785592.236202
  % 	x34 = 1,	Z1 = 27785592.2362022        
DEBUG EVAL: First branch cutoff check: z=27785592.236202, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 34 = 0
ITER 1: row=18, varin=54, theta=0.092800, up=1.000000
ITER 2: row=27, varin=62, theta=0.150221, up=1.000000
  % 	x34 = 0,	Z0 = 27729972.4655044        
DEBUG EVAL: Second branch cutoff check: z=27729972.465504, best_z=INF, threshold=INF
  %   New best:  x34, Z = 27729972.4655044        
DEBUG EVAL: Testing var 10 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=13, varin=13, theta=0.303175, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 0 gives z=27751788.604392
  % 	x10 = 0,	Z0 = 27751788.6043921        
DEBUG EVAL: First branch cutoff check: z=27751788.604392, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 1
ITER 1: row=13, varin=22, theta=1.168282, up=999999999999999983222784.000000
ITER 2: row=18, varin=62, theta=0.295333, up=1.000000
ITER 3: row=22, varin=70, theta=0.711640, up=1.000000
  % 	x10 = 1,	Z1 = 27882623.3700962        
DEBUG EVAL: Second branch cutoff check: z=27882623.370096, best_z=INF, threshold=INF
  %   New best:  x10, Z = 27751788.6043921        
DEBUG EVAL: Testing var 9 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=5, varin=24, theta=0.497179, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 9 = 0 gives z=27780015.728032
  % 	x9 = 0,	Z0 = 27780015.7280325        
DEBUG EVAL: First branch cutoff check: z=27780015.728032, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 9 = 1
ITER 1: row=5, varin=34, theta=33.254034, up=999999999999999983222784.000000
ITER 2: row=22, varin=62, theta=4.791923, up=1.000000
ITER 3: row=22, varin=38, theta=2.291756, up=1.000000
ITER 4: row=22, varin=63, theta=2.333251, up=1.000000
ITER 5: row=22, varin=57, theta=1.002640, up=1.000000
ITER 6: row=22, varin=65, theta=0.003754, up=1.000000
ITER 7: row=18, varin=19, theta=1.273110, up=999999999999999983222784.000000
ITER 8: row=22, varin=57, theta=2.404124, up=1.000000
ITER 9: row=22, varin=63, theta=1.558179, up=1.000000
ITER 10: row=22, varin=62, theta=0.541659, up=1.000000
  % 	x9 = 1,	Z1 = 27958692.5046719        
DEBUG EVAL: Second branch cutoff check: z=27958692.504672, best_z=INF, threshold=INF
  %   New best:  x9, Z = 27780015.7280325        
DEBUG EVAL: Testing var 5 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=19, theta=0.371005, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 5 = 0 gives z=27771046.181944
  % 	x5 = 0,	Z0 = 27771046.1819444        
DEBUG EVAL: First branch cutoff check: z=27771046.181944, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 36 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=22, varin=24, theta=1.554691, up=999999999999999983222784.000000
ITER 2: row=13, varin=62, theta=1.762694, up=1.000000
ITER 3: row=13, varin=38, theta=0.460956, up=1.000000
ITER 4: row=18, varin=62, theta=1.000000, up=1.000000
ITER 5: row=8, varin=18, theta=0.038104, up=999999999999999983222784.000000
ITER 6: row=35, varin=22, theta=0.039696, up=999999999999999983222784.000000
ITER 7: row=5, varin=28, theta=0.070611, up=999999999999999983222784.000000
ITER 8: row=28, varin=25, theta=0.077979, up=999999999999999983222784.000000
ITER 9: row=25, varin=19, theta=0.046656, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 36 = 1 gives z=27898505.307317
  % 	x36 = 1,	Z1 = 27898505.3073175        
DEBUG EVAL: First branch cutoff check: z=27898505.307317, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 36 = 0
ITER 1: row=22, varin=34, theta=0.266712, up=999999999999999983222784.000000
  % 	x36 = 0,	Z0 = 27729066.6852749        
DEBUG EVAL: Second branch cutoff check: z=27729066.685275, best_z=INF, threshold=INF
  % Best branch is x9, Z0 = 27780015.7280325        , Z1 = 27958692.5046719        

DEBUG CAREFUL: Final result - returning best.var = 9
DEBUG BB: Branching variable chosen: j=9
 % @NC   69   55	x9 = 0	27780015.728032
 % @NC   70   55	x9 = 1	27958692.504672
 %      55    31 27727398.1989               27729020.5895   x15 U    41     8
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ad4c4c1bb0
% @LO 0.04  27.72739819888053958152 99.9000000000
% @LN 0.04  27.72902058954388593293 99.9000000000
% Resuming node 61 at  27.72902058954388593293
DEBUG CONSTRNT: LP rows=35, pool->nlprows=35, pool->npend=0
DEBUG CONSTRNT: Checking 35 LP rows (pool tracks 35, total LP rows 35)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=34, expected 34
 % @PAP adding 32 rows, 180 nz to LP
DEBUG BB: Processing node 61, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=5, varin=30, theta=2.189172, up=999999999999999983222784.000000
ITER 2: row=1, varin=15, theta=2.924730, up=999999999999999983222784.000000
ITER 3: row=3, varin=32, theta=0.924470, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=32)
DEBUG SOLUTION: LP solution array indices: FST[33-72], not_covered[73-92]
DEBUG SOLUTION: lp->best_solution[0] = 27729020.589544
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 32 rows, 60 cols, 240 nonzeros, 3 slack, 29 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=33, varin=35, theta=1.893460, up=1.000000
ITER 2: row=33, varin=61, theta=0.782350, up=1.000000
ITER 3: row=16, varin=35, theta=1.000000, up=1.000000
ITER 4: row=22, varin=56, theta=1.429099, up=1.000000
ITER 5: row=22, varin=62, theta=0.530543, up=1.000000
ITER 6: row=1, varin=16, theta=0.497317, up=999999999999999983222784.000000
ITER 7: row=16, varin=18, theta=0.871713, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=7)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=34)
DEBUG SOLUTION: LP solution array indices: FST[35-74], not_covered[75-94]
DEBUG SOLUTION: lp->best_solution[0] = 28005386.696859
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 34 rows, 60 cols, 248 nonzeros, 4 slack, 30 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % @PAP adding 5 rows, 20 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=33, varin=57, theta=1.425393, up=1.000000
ITER 2: row=33, varin=23, theta=0.079946, up=999999999999999983222784.000000
ITER 3: row=5, varin=58, theta=0.182556, up=1.000000
ITER 4: row=33, varin=59, theta=0.126415, up=1.000000
ITER 5: row=23, varin=3, theta=0.158065, up=999999999999999983222784.000000
ITER 6: row=6, varin=20, theta=0.131941, up=999999999999999983222784.000000
ITER 7: row=20, varin=38, theta=0.161410, up=1.000000
LP PHASE: Switching to primal (iter=7)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=35)
DEBUG SOLUTION: LP solution array indices: FST[36-75], not_covered[76-95]
DEBUG SOLUTION: lp->best_solution[0] = 28053953.320056
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 35 rows, 60 cols, 260 nonzeros, 1 slack, 34 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 4 rows, 9 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=38, varin=66, theta=1.000399, up=1.000000
ITER 2: row=38, varin=49, theta=0.000273, up=1.000000
ITER 3: row=36, varin=68, theta=1.206030, up=1.000000
ITER 4: row=36, varin=66, theta=0.249247, up=1.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=38)
DEBUG SOLUTION: LP solution array indices: FST[39-78], not_covered[79-98]
DEBUG SOLUTION: lp->best_solution[0] = 28081084.450408
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 38 rows, 60 cols, 265 nonzeros, 1 slack, 37 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 4 rows, 13 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=38, varin=71, theta=1.000000, up=1.000000
ITER 2: row=20, varin=67, theta=1.000000, up=1.000000
ITER 3: row=34, varin=63, theta=0.200000, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=41)
DEBUG SOLUTION: LP solution array indices: FST[42-81], not_covered[82-101]
DEBUG SOLUTION: lp->best_solution[0] = 28087594.438731
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 41 rows, 60 cols, 276 nonzeros, 1 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=41, varin=33, theta=1.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=41)
DEBUG SOLUTION: LP solution array indices: FST[42-81], not_covered[82-101]
DEBUG SOLUTION: lp->best_solution[0] = 28092414.141261
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 41 rows, 60 cols, 273 nonzeros, 1 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 61 LP 1 Solution, length = 28092414.141261, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.636440 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.500000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 1.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.500000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.500000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.363560 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.363560 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.500000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28092414.141261, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 61 at  28.09241414126056213263
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ad4c4a22c0
% @LO 0.04  27.72902058954388593293 99.9000000000
% @LN 0.04  27.72996078202604408602 99.9000000000
% Resuming node 36 at  27.72996078202604408602
DEBUG CONSTRNT: LP rows=40, pool->nlprows=40, pool->npend=0
DEBUG CONSTRNT: Checking 40 LP rows (pool tracks 40, total LP rows 40)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 141
DEBUG CONSTRNT: Pool row 141 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 145
DEBUG CONSTRNT: Pool row 145 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 159
DEBUG CONSTRNT: Pool row 159 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 133
DEBUG CONSTRNT: Pool row 133 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=39, expected 39
 % @PAP adding 20 rows, 138 nz to LP
DEBUG BB: Processing node 36, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=6, varin=23, theta=2.263174, up=1.000000
ITER 2: row=6, varin=6, theta=0.931917, up=999999999999999983222784.000000
ITER 3: row=1, varin=42, theta=0.592739, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=20)
DEBUG SOLUTION: LP solution array indices: FST[21-60], not_covered[61-80]
DEBUG SOLUTION: lp->best_solution[0] = 27729960.782026
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.203630
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 20 rows, 60 cols, 198 nonzeros, 1 slack, 19 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 10 rows, 56 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=22, varin=16, theta=0.091545, up=999999999999999983222784.000000
ITER 2: row=21, varin=22, theta=11.944403, up=999999999999999983222784.000000
ITER 3: row=27, varin=56, theta=2.177181, up=1.000000
ITER 4: row=27, varin=42, theta=0.227619, up=1.000000
ITER 5: row=23, varin=52, theta=1.148680, up=1.000000
ITER 6: row=23, varin=53, theta=0.158986, up=1.000000
ITER 7: row=19, varin=19, theta=0.088280, up=999999999999999983222784.000000
ITER 8: row=1, varin=56, theta=1.196440, up=1.000000
ITER 9: row=1, varin=18, theta=0.037861, up=999999999999999983222784.000000
ITER 10: row=24, varin=23, theta=0.134902, up=999999999999999983222784.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=29)
DEBUG SOLUTION: LP solution array indices: FST[30-69], not_covered[70-89]
DEBUG SOLUTION: lp->best_solution[0] = 999999999999999983222784.000000
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.203630
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 29 rows, 60 cols, 249 nonzeros, 6 slack, 23 tight.
  % Node 36 LP 1 Solution, length = 999999999999999983222784.000000, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.203630 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 1.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 1.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.592739 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.796370 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 1.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
DEBUG BB: compute_good_lower_bound returned status=1
DEBUG BB: Node 36 is INFEASIBLE
 %      36    30    infeasible               27733424.5987   x16 U    29     5
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ad4c49c780
% @LO 0.04  27.72996078202604408602 99.9000000000
% @LN 0.04  27.73342459871457421627 99.9000000000
% Resuming node 63 at  27.73342459871457421627
DEBUG CONSTRNT: LP rows=29, pool->nlprows=29, pool->npend=0
DEBUG CONSTRNT: Checking 29 LP rows (pool tracks 29, total LP rows 29)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 82
DEBUG CONSTRNT: Pool row 82 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 49
DEBUG CONSTRNT: Pool row 49 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 68
DEBUG CONSTRNT: Pool row 68 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 73
DEBUG CONSTRNT: Pool row 73 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 121
DEBUG CONSTRNT: Pool row 121 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=28, expected 28
 % @PAP adding 27 rows, 131 nz to LP
DEBUG BB: Processing node 63, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=11, varin=27, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=27)
DEBUG SOLUTION: LP solution array indices: FST[28-67], not_covered[68-87]
DEBUG SOLUTION: lp->best_solution[0] = 27733424.598715
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 0.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 2.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 27 rows, 60 cols, 191 nonzeros, 1 slack, 26 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 13 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=28, varin=23, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=29)
DEBUG SOLUTION: LP solution array indices: FST[30-69], not_covered[70-89]
DEBUG SOLUTION: lp->best_solution[0] = 27861475.292881
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 0.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 2.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 29 rows, 60 cols, 204 nonzeros, 3 slack, 26 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 4 rows, 15 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=27, varin=57, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=30)
DEBUG SOLUTION: LP solution array indices: FST[31-70], not_covered[71-90]
DEBUG SOLUTION: lp->best_solution[0] = 27933127.611818
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 0.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 2.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 30 rows, 60 cols, 204 nonzeros, 2 slack, 28 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 4 rows, 17 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=29, varin=60, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=32)
DEBUG SOLUTION: LP solution array indices: FST[33-72], not_covered[73-92]
DEBUG SOLUTION: lp->best_solution[0] = 27946159.195044
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 0.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 2.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 32 rows, 60 cols, 210 nonzeros, 0 slack, 32 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=33, varin=63, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=33)
DEBUG SOLUTION: LP solution array indices: FST[34-73], not_covered[74-93]
DEBUG SOLUTION: lp->best_solution[0] = 27953402.356167
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 0.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 2.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 33 rows, 60 cols, 212 nonzeros, 0 slack, 33 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 9 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=34, varin=49, theta=0.250000, up=1.000000
ITER 2: row=32, varin=48, theta=0.035714, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=37)
DEBUG SOLUTION: LP solution array indices: FST[38-77], not_covered[78-97]
DEBUG SOLUTION: lp->best_solution[0] = 27961096.539000
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 0.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 2.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 37 rows, 60 cols, 221 nonzeros, 0 slack, 37 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 3 rows, 12 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=38, varin=45, theta=0.250000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=40)
DEBUG SOLUTION: LP solution array indices: FST[41-80], not_covered[81-100]
DEBUG SOLUTION: lp->best_solution[0] = 27964528.209320
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 0.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 2.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 40 rows, 60 cols, 233 nonzeros, 1 slack, 39 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 3 rows, 11 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=40, varin=46, theta=0.125000, up=1.000000
ITER 2: row=42, varin=64, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 27975843.102113
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 0.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 2.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 42 rows, 60 cols, 242 nonzeros, 0 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 7 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=43, varin=40, theta=0.178571, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 27979488.539737
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 0.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 2.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 44 rows, 60 cols, 249 nonzeros, 4 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=41, varin=74, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=41)
DEBUG SOLUTION: LP solution array indices: FST[42-81], not_covered[82-101]
DEBUG SOLUTION: lp->best_solution[0] = 27982448.306187
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 0.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 2.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 41 rows, 60 cols, 232 nonzeros, 0 slack, 41 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 63 LP 1 Solution, length = 27982448.306187, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.500000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.500000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 1.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.500000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.500000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.500000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.500000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.500000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.500000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=27982448.306187, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 63 at  27.98244830618653367083
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ad4c4b0620
% @LO 0.04  27.73342459871457421627 99.9000000000
% @LN 0.04  27.73434367855188398266 99.9000000000
% Resuming node 22 at  27.73434367855188398266
DEBUG CONSTRNT: LP rows=41, pool->nlprows=41, pool->npend=0
DEBUG CONSTRNT: Checking 41 LP rows (pool tracks 41, total LP rows 41)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 142
DEBUG CONSTRNT: Pool row 142 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 133
DEBUG CONSTRNT: Pool row 133 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 143
DEBUG CONSTRNT: Pool row 143 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=40, expected 40
 % @PAP adding 22 rows, 151 nz to LP
DEBUG BB: Processing node 22, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=6, varin=8, theta=0.985603, up=999999999999999983222784.000000
ITER 2: row=22, varin=21, theta=3.082776, up=999999999999999983222784.000000
ITER 3: row=5, varin=44, theta=1.197343, up=1.000000
ITER 4: row=5, varin=49, theta=0.235276, up=1.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=22)
DEBUG SOLUTION: LP solution array indices: FST[23-62], not_covered[63-82]
DEBUG SOLUTION: lp->best_solution[0] = 27734343.678552
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 0.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 22 rows, 60 cols, 211 nonzeros, 3 slack, 19 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 6 rows, 21 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=25, varin=50, theta=1.000000, up=1.000000
ITER 2: row=23, varin=39, theta=1.895067, up=1.000000
ITER 3: row=23, varin=56, theta=0.728114, up=1.000000
ITER 4: row=24, varin=39, theta=1.000000, up=1.000000
ITER 5: row=23, varin=51, theta=0.432608, up=1.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=28)
DEBUG SOLUTION: LP solution array indices: FST[29-68], not_covered[69-88]
DEBUG SOLUTION: lp->best_solution[0] = 27806096.322097
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 0.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 28 rows, 60 cols, 232 nonzeros, 4 slack, 24 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % @PAP adding 3 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=26, varin=55, theta=0.710327, up=1.000000
ITER 2: row=27, varin=51, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=27)
DEBUG SOLUTION: LP solution array indices: FST[28-67], not_covered[68-87]
DEBUG SOLUTION: lp->best_solution[0] = 27819144.649515
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 27 rows, 60 cols, 226 nonzeros, 1 slack, 26 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 4 rows, 13 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=27, varin=60, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=30)
DEBUG SOLUTION: LP solution array indices: FST[31-70], not_covered[71-90]
DEBUG SOLUTION: lp->best_solution[0] = 27834448.970291
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 30 rows, 60 cols, 237 nonzeros, 0 slack, 30 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 5 rows, 15 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=31, varin=19, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=35, varin=61, theta=0.949855, up=1.000000
ITER 3: row=24, varin=48, theta=0.206897, up=1.000000
ITER 4: row=20, varin=25, theta=0.087563, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=35)
DEBUG SOLUTION: LP solution array indices: FST[36-75], not_covered[76-95]
DEBUG SOLUTION: lp->best_solution[0] = 27844104.004234
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 35 rows, 60 cols, 252 nonzeros, 2 slack, 33 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 2 rows, 7 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=34, varin=60, theta=0.884110, up=1.000000
ITER 2: row=28, varin=23, theta=2.469285, up=999999999999999983222784.000000
ITER 3: row=35, varin=64, theta=0.434340, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=35)
DEBUG SOLUTION: LP solution array indices: FST[36-75], not_covered[76-95]
DEBUG SOLUTION: lp->best_solution[0] = 28013797.820219
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 35 rows, 60 cols, 252 nonzeros, 1 slack, 34 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 1 rows, 5 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=35, varin=92, theta=1.414995, up=1.000000
ITER 2: row=35, varin=90, theta=0.734104, up=1.000000
ITER 3: row=27, varin=92, theta=0.500000, up=1.000000
ITER 4: row=20, varin=66, theta=1.560419, up=1.000000
ITER 5: row=20, varin=67, theta=1.150926, up=1.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=35)
DEBUG SOLUTION: LP solution array indices: FST[36-75], not_covered[76-95]
DEBUG SOLUTION: lp->best_solution[0] = 999999999999999983222784.000000
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 35 rows, 60 cols, 250 nonzeros, 1 slack, 34 tight.
  % Node 22 LP 1 Solution, length = 999999999999999983222784.000000, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.282830 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.500000 (FST 12)
  % DEBUG LP_VARS: x[13] = 1.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 1.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.500000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.500000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.282830 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.434340 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.717170 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.500000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
DEBUG BB: compute_good_lower_bound returned status=1
DEBUG BB: Node 22 is INFEASIBLE
 %      22    29    infeasible               27737733.8685   x13 U     4     3
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ad4c4b16a0
% @LO 0.04  27.73434367855188398266 99.9000000000
% @LN 0.04  27.73773386848108302161 99.9000000000
% Resuming node 24 at  27.73773386848108302161
DEBUG CONSTRNT: LP rows=35, pool->nlprows=35, pool->npend=0
DEBUG CONSTRNT: Checking 35 LP rows (pool tracks 35, total LP rows 35)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 65
DEBUG CONSTRNT: Pool row 65 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=34, expected 34
 % @PAP adding 30 rows, 185 nz to LP
DEBUG BB: Processing node 24, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=5, varin=52, theta=1.601070, up=1.000000
ITER 2: row=5, varin=57, theta=0.716607, up=1.000000
ITER 3: row=13, varin=52, theta=1.000000, up=1.000000
ITER 4: row=5, varin=58, theta=0.981465, up=1.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=30)
DEBUG SOLUTION: LP solution array indices: FST[31-70], not_covered[71-90]
DEBUG SOLUTION: lp->best_solution[0] = 27737733.868481
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 30 rows, 60 cols, 245 nonzeros, 0 slack, 30 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 11 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=33, varin=61, theta=1.000000, up=1.000000
ITER 2: row=32, varin=57, theta=1.244013, up=1.000000
ITER 3: row=32, varin=58, theta=0.271351, up=1.000000
ITER 4: row=25, varin=57, theta=1.000000, up=1.000000
ITER 5: row=32, varin=64, theta=0.729355, up=1.000000
ITER 6: row=31, varin=32, theta=0.084447, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=34)
DEBUG SOLUTION: LP solution array indices: FST[35-74], not_covered[75-94]
DEBUG SOLUTION: lp->best_solution[0] = 27820557.333640
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 34 rows, 60 cols, 256 nonzeros, 1 slack, 33 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 6 rows, 18 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=38, varin=63, theta=1.000000, up=1.000000
ITER 2: row=34, varin=64, theta=1.732654, up=1.000000
ITER 3: row=34, varin=12, theta=0.902324, up=999999999999999983222784.000000
ITER 4: row=29, varin=64, theta=1.000000, up=1.000000
ITER 5: row=12, varin=68, theta=2.168481, up=1.000000
ITER 6: row=12, varin=81, theta=0.749751, up=1.000000
ITER 7: row=39, varin=24, theta=1.735933, up=999999999999999983222784.000000
ITER 8: row=10, varin=46, theta=3.245756, up=1.000000
ITER 9: row=10, varin=17, theta=5.041729, up=999999999999999983222784.000000
ITER 10: row=1, varin=70, theta=2.802142, up=1.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=39)
DEBUG SOLUTION: LP solution array indices: FST[40-79], not_covered[80-99]
DEBUG SOLUTION: lp->best_solution[0] = 999999999999999983222784.000000
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 39 rows, 60 cols, 270 nonzeros, 2 slack, 37 tight.
  % Node 24 LP 1 Solution, length = 999999999999999983222784.000000, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.084447 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 1.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 1.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.084447 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.831107 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.915553 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
DEBUG BB: compute_good_lower_bound returned status=1
DEBUG BB: Node 24 is INFEASIBLE
 %      24    28    infeasible               27741321.0343   x19 U    14     4
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ad4c4c70b0
% @LO 0.04  27.73773386848108302161 99.9000000000
% @LN 0.04  27.74132103429895224167 99.9000000000
% Resuming node 62 at  27.74132103429895224167
DEBUG CONSTRNT: LP rows=39, pool->nlprows=39, pool->npend=0
DEBUG CONSTRNT: Checking 39 LP rows (pool tracks 39, total LP rows 39)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=38, expected 38
 % @PAP adding 32 rows, 180 nz to LP
DEBUG BB: Processing node 62, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=5, varin=87, theta=1.110039, up=1.000000
ITER 2: row=5, varin=33, theta=0.086196, up=1.000000
ITER 3: row=23, varin=87, theta=1.000000, up=1.000000
ITER 4: row=16, varin=17, theta=0.790112, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
ITER 5: row=16, varin=16, theta=0.000000, up=999999999999999983222784.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=32)
DEBUG SOLUTION: LP solution array indices: FST[33-72], not_covered[73-92]
DEBUG SOLUTION: lp->best_solution[0] = 27741321.034299
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 32 rows, 60 cols, 240 nonzeros, 2 slack, 30 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 62 LP 1 Solution, length = 27741321.034299, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.790112 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.790112 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 1.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.209888 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.209888 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.209888 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.209888 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 2 fractional variables
DEBUG CG: LP optimal, z=27741321.034299, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=27741321.034299, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 62 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 62
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=1.000000
DEBUG CAREFUL: Skipping var 2: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.790112
DEBUG CAREFUL: Adding var 9 to fractional list (xi=0.790112)
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.790112
DEBUG CAREFUL: Adding var 12 to fractional list (xi=0.790112)
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=1.000000
DEBUG CAREFUL: Skipping var 20: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 2 fractional variables

  %  Carefully choosing branching variable, nfrac = 2
DEBUG CAREFUL: Testing fvar[0] = var 12
DEBUG CAREFUL: Calling compare_branch_vars for var 12
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 12
DEBUG CAREFUL: New best var: 12
DEBUG CAREFUL: Testing fvar[1] = var 9
DEBUG CAREFUL: Calling compare_branch_vars for var 9
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 9
DEBUG CAREFUL: New best var: 9
  % Initial guess is x9, Z0 = 27741321.034299         , Z1 = 27823410.5176258        

DEBUG EVAL: Testing var 12 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=5, varin=33, theta=0.192325, up=1.000000
ITER 2: row=16, varin=15, theta=0.143608, up=999999999999999983222784.000000
ITER 3: row=15, varin=77, theta=0.059349, up=1.000000
DEBUG EVAL: Branch var 12 = 1 gives z=27750673.820348
  % 	x12 = 1,	Z1 = 27750673.8203481        
DEBUG EVAL: First branch cutoff check: z=27750673.820348, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 12 = 0
ITER 1: row=5, varin=14, theta=1.068746, up=999999999999999983222784.000000
ITER 2: row=31, varin=77, theta=0.407640, up=1.000000
  % 	x12 = 0,	Z0 = 27801369.7612537        
DEBUG EVAL: Second branch cutoff check: z=27801369.761254, best_z=INF, threshold=INF
  %   New best:  x12, Z = 27750673.8203481        
DEBUG EVAL: Testing var 9 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=23, theta=0.294875, up=999999999999999983222784.000000
ITER 2: row=21, varin=30, theta=0.230511, up=999999999999999983222784.000000
ITER 3: row=30, varin=15, theta=0.566935, up=999999999999999983222784.000000
ITER 4: row=15, varin=24, theta=0.142779, up=999999999999999983222784.000000
ITER 5: row=24, varin=21, theta=0.237690, up=999999999999999983222784.000000
ITER 6: row=23, varin=35, theta=0.391861, up=1.000000
DEBUG EVAL: Branch var 9 = 1 gives z=27823410.517626
  % 	x9 = 1,	Z1 = 27823410.5176258        
DEBUG EVAL: First branch cutoff check: z=27823410.517626, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 9 = 0
ITER 1: row=1, varin=33, theta=0.869518, up=1.000000
ITER 2: row=16, varin=77, theta=0.270123, up=1.000000
ITER 3: row=5, varin=14, theta=0.277444, up=999999999999999983222784.000000
ITER 4: row=31, varin=16, theta=0.784891, up=999999999999999983222784.000000
  % 	x9 = 0,	Z0 = 27794138.2177648        
DEBUG EVAL: Second branch cutoff check: z=27794138.217765, best_z=INF, threshold=INF
  %   New best:  x9, Z = 27794138.2177648        
  % Best branch is x9, Z0 = 27794138.2177648        , Z1 = 27823410.5176258        

DEBUG CAREFUL: Final result - returning best.var = 9
DEBUG BB: Branching variable chosen: j=9
 % @NC   71   62	x9 = 0	27794138.217765
 % @NC   72   62	x9 = 1	27823410.517626
 %      62    29 27741321.0343               27741871.1563    x7 D    53     8
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ad4c4af9e0
% @LO 0.04  27.74132103429895224167 99.9000000000
% @LN 0.04  27.74187115626175170746 99.9000000000
% Resuming node 47 at  27.74187115626175170746
DEBUG CONSTRNT: LP rows=32, pool->nlprows=32, pool->npend=0
DEBUG CONSTRNT: Checking 32 LP rows (pool tracks 32, total LP rows 32)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 141
DEBUG CONSTRNT: Pool row 141 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 145
DEBUG CONSTRNT: Pool row 145 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 159
DEBUG CONSTRNT: Pool row 159 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=31, expected 31
 % @PAP adding 37 rows, 194 nz to LP
DEBUG BB: Processing node 47, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 47 LP 2 Solution, length = 27741871.156262, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 1.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.193189 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.500000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.500000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.500000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 1.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.306811 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.806811 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.500000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.500000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.500000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.500000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=27741871.156262, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=27741871.156262, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 3 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 47 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 47
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=1.000000
DEBUG CAREFUL: Skipping var 1: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=1.000000
DEBUG CAREFUL: Skipping var 2: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.193189
DEBUG CAREFUL: Adding var 5 to fractional list (xi=0.193189)
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.500000
DEBUG CAREFUL: Adding var 8 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.500000
DEBUG CAREFUL: Adding var 12 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.500000
DEBUG CAREFUL: Adding var 14 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=1.000000
DEBUG CAREFUL: Skipping var 17: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.306811
DEBUG CAREFUL: Adding var 21 to fractional list (xi=0.306811)
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 8
DEBUG CAREFUL: Calling compare_branch_vars for var 8
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 8
DEBUG CAREFUL: New best var: 8
DEBUG CAREFUL: Testing fvar[1] = var 12
DEBUG CAREFUL: Calling compare_branch_vars for var 12
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 12
DEBUG CAREFUL: Testing fvar[2] = var 14
DEBUG CAREFUL: Calling compare_branch_vars for var 14
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 14
DEBUG CAREFUL: Testing fvar[3] = var 5
DEBUG CAREFUL: Calling compare_branch_vars for var 5
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 5
DEBUG CAREFUL: Testing fvar[4] = var 21
DEBUG CAREFUL: Calling compare_branch_vars for var 21
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 21
DEBUG CAREFUL: New best var: 21
  % Initial guess is x21, Z0 = 27741871.1562618        , Z1 = 27918744.8755473        

DEBUG EVAL: Testing var 8 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=5, varin=44, theta=1.000000, up=1.000000
ITER 2: row=17, varin=6, theta=0.953060, up=999999999999999983222784.000000
ITER 3: row=27, varin=24, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 8 = 0 gives z=27781918.330435
  % 	x8 = 0,	Z0 = 27781918.3304351        
DEBUG EVAL: First branch cutoff check: z=27781918.330435, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 8 = 1
ITER 1: row=5, varin=18, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=27, varin=7, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=25, varin=21, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=17, varin=67, theta=1.282232, up=1.000000
ITER 5: row=17, varin=72, theta=0.413818, up=1.000000
ITER 6: row=1, varin=61, theta=0.679500, up=1.000000
ITER 7: row=17, varin=36, theta=0.189257, up=999999999999999983222784.000000
ITER 8: row=13, varin=29, theta=0.199984, up=999999999999999983222784.000000
ITER 9: row=6, varin=26, theta=0.977601, up=999999999999999983222784.000000
  % 	x8 = 1,	Z1 = 28361260.7517958        
DEBUG EVAL: Second branch cutoff check: z=28361260.751796, best_z=INF, threshold=INF
  %   New best:  x8, Z = 27781918.3304351        
DEBUG EVAL: Testing var 12 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=7, varin=7, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=20, varin=44, theta=1.000000, up=1.000000
ITER 3: row=17, varin=6, theta=1.123656, up=999999999999999983222784.000000
ITER 4: row=18, varin=72, theta=1.275022, up=1.000000
ITER 5: row=18, varin=74, theta=0.205843, up=1.000000
ITER 6: row=20, varin=72, theta=4.793850, up=1.000000
ITER 7: row=20, varin=37, theta=0.529444, up=999999999999999983222784.000000
ITER 8: row=37, varin=13, theta=0.976239, up=999999999999999983222784.000000
ITER 9: row=18, varin=28, theta=0.340655, up=999999999999999983222784.000000
ITER 10: row=8, varin=15, theta=0.326574, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 12 = 0 gives z=27848701.892396
  % 	x12 = 0,	Z0 = 27848701.8923963        
DEBUG EVAL: First branch cutoff check: z=27848701.892396, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 12 = 1
ITER 1: row=7, varin=44, theta=1.000000, up=1.000000
ITER 2: row=17, varin=6, theta=0.953060, up=999999999999999983222784.000000
ITER 3: row=27, varin=21, theta=1.000000, up=999999999999999983222784.000000
  % 	x12 = 1,	Z1 = 28057616.3000076        
DEBUG EVAL: Second branch cutoff check: z=28057616.300008, best_z=INF, threshold=INF
  %   New best:  x12, Z = 27848701.8923963        
DEBUG EVAL: Testing var 14 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=14, varin=24, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=20, varin=26, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=17, varin=67, theta=0.884339, up=1.000000
DEBUG EVAL: Branch var 14 = 1 gives z=28121630.409482
  % 	x14 = 1,	Z1 = 28121630.4094816        
DEBUG EVAL: First branch cutoff check: z=28121630.409482, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 14 = 0
ITER 1: row=14, varin=44, theta=1.000000, up=1.000000
ITER 2: row=17, varin=6, theta=0.953060, up=999999999999999983222784.000000
ITER 3: row=27, varin=7, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=18, varin=72, theta=1.275022, up=1.000000
ITER 5: row=18, varin=74, theta=0.205843, up=1.000000
ITER 6: row=14, varin=72, theta=4.793850, up=1.000000
ITER 7: row=14, varin=37, theta=0.529444, up=999999999999999983222784.000000
ITER 8: row=37, varin=13, theta=0.976239, up=999999999999999983222784.000000
ITER 9: row=18, varin=28, theta=0.340655, up=999999999999999983222784.000000
ITER 10: row=8, varin=15, theta=0.326574, up=999999999999999983222784.000000
  % 	x14 = 0,	Z0 = 27867642.4921902        
DEBUG EVAL: Second branch cutoff check: z=27867642.492190, best_z=INF, threshold=INF
  %   New best:  x14, Z = 27867642.4921902        
DEBUG EVAL: Testing var 5 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=72, theta=0.484540, up=1.000000
DEBUG EVAL: Branch var 5 = 0 gives z=27744413.739316
  % 	x5 = 0,	Z0 = 27744413.7393161        
DEBUG EVAL: First branch cutoff check: z=27744413.739316, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 21 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=17, varin=37, theta=0.769243, up=999999999999999983222784.000000
ITER 2: row=37, varin=36, theta=0.436599, up=999999999999999983222784.000000
ITER 3: row=13, varin=15, theta=0.746475, up=999999999999999983222784.000000
ITER 4: row=15, varin=28, theta=1.279926, up=999999999999999983222784.000000
ITER 5: row=8, varin=33, theta=0.511156, up=999999999999999983222784.000000
ITER 6: row=33, varin=30, theta=0.493910, up=999999999999999983222784.000000
ITER 7: row=30, varin=29, theta=0.743277, up=999999999999999983222784.000000
ITER 8: row=6, varin=24, theta=1.853353, up=999999999999999983222784.000000
ITER 9: row=20, varin=26, theta=0.470643, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 21 = 1 gives z=27918744.875547
  % 	x21 = 1,	Z1 = 27918744.8755473        
DEBUG EVAL: First branch cutoff check: z=27918744.875547, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 21 = 0
ITER 1: row=17, varin=67, theta=0.348002, up=1.000000
  % 	x21 = 0,	Z0 = 27743424.2215255        
DEBUG EVAL: Second branch cutoff check: z=27743424.221526, best_z=INF, threshold=INF
  % Best branch is x14, Z0 = 27867642.4921902        , Z1 = 28121630.4094816        

DEBUG CAREFUL: Final result - returning best.var = 14
DEBUG BB: Branching variable chosen: j=14
 % @NC   73   47	x14 = 0	27867642.492190
 % @NC   74   47	x14 = 1	28121630.409482
 %      47    30 27741871.1563               27757109.4895   x15 D    37     8
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ad4c4a4590
% @LO 0.04  27.74187115626175170746 99.9000000000
% @LN 0.04  27.75710948951016376895 99.9000000000
% Resuming node 65 at  27.75710948951016376895
DEBUG CONSTRNT: LP rows=37, pool->nlprows=37, pool->npend=0
DEBUG CONSTRNT: Checking 37 LP rows (pool tracks 37, total LP rows 37)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 91
DEBUG CONSTRNT: Pool row 91 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 79
DEBUG CONSTRNT: Pool row 79 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 45
DEBUG CONSTRNT: Pool row 45 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 62
DEBUG CONSTRNT: Pool row 62 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 142
DEBUG CONSTRNT: Pool row 142 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 133
DEBUG CONSTRNT: Pool row 133 has lprow=36, expected 36
 % @PAP adding 24 rows, 162 nz to LP
DEBUG BB: Processing node 65, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=16, varin=19, theta=0.544912, up=999999999999999983222784.000000
ITER 2: row=17, varin=28, theta=0.039766, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=24)
DEBUG SOLUTION: LP solution array indices: FST[25-64], not_covered[65-84]
DEBUG SOLUTION: lp->best_solution[0] = 27757109.489510
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 24 rows, 60 cols, 222 nonzeros, 1 slack, 23 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 5 rows, 25 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=25, varin=72, theta=0.244103, up=1.000000
ITER 2: row=27, varin=30, theta=0.261183, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=29)
DEBUG SOLUTION: LP solution array indices: FST[30-69], not_covered[70-89]
DEBUG SOLUTION: lp->best_solution[0] = 27780036.441720
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 29 rows, 60 cols, 247 nonzeros, 2 slack, 27 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 6 rows, 21 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=28, varin=70, theta=0.586528, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=33)
DEBUG SOLUTION: LP solution array indices: FST[34-73], not_covered[74-93]
DEBUG SOLUTION: lp->best_solution[0] = 27810301.755991
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 33 rows, 60 cols, 247 nonzeros, 0 slack, 33 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=34, varin=70, theta=0.354464, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=35)
DEBUG SOLUTION: LP solution array indices: FST[36-75], not_covered[76-95]
DEBUG SOLUTION: lp->best_solution[0] = 27812677.646339
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 35 rows, 60 cols, 251 nonzeros, 0 slack, 35 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=36, varin=55, theta=0.065479, up=1.000000
ITER 2: row=27, varin=63, theta=0.087135, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=36)
DEBUG SOLUTION: LP solution array indices: FST[37-76], not_covered[77-96]
DEBUG SOLUTION: lp->best_solution[0] = 27814170.841081
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 36 rows, 60 cols, 253 nonzeros, 0 slack, 36 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 65 LP 1 Solution, length = 27814170.841081, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.228216 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.228216 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.228216 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 1.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 1.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.087135 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.228216 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.228216 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.771784 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.771784 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.771784 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.771784 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=27814170.841081, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 65 at  27.81417084108084480931
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ad4c4c1860
% @LO 0.04  27.75710948951016376895 99.9000000000
% @LN 0.04  27.76023900136749489320 99.9000000000
% Resuming node 46 at  27.76023900136749489320
DEBUG CONSTRNT: LP rows=36, pool->nlprows=36, pool->npend=0
DEBUG CONSTRNT: Checking 36 LP rows (pool tracks 36, total LP rows 36)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=35, expected 35
 % @PAP adding 40 rows, 164 nz to LP
DEBUG BB: Processing node 46, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=36, varin=39, theta=3.000000, up=999999999999999983222784.000000
ITER 2: row=39, varin=12, theta=3.000000, up=999999999999999983222784.000000
ITER 3: row=12, varin=37, theta=1.500000, up=999999999999999983222784.000000
ITER 4: row=20, varin=33, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=33, varin=32, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=32, varin=29, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=40)
DEBUG SOLUTION: LP solution array indices: FST[41-80], not_covered[81-100]
DEBUG SOLUTION: lp->best_solution[0] = 27760239.001367
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 40 rows, 60 cols, 224 nonzeros, 4 slack, 36 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 45 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=42, varin=25, theta=2.058805, up=999999999999999983222784.000000
ITER 2: row=18, varin=22, theta=1.363307, up=999999999999999983222784.000000
ITER 3: row=29, varin=70, theta=1.426125, up=1.000000
ITER 4: row=29, varin=72, theta=0.440522, up=1.000000
ITER 5: row=32, varin=70, theta=1.000000, up=1.000000
ITER 6: row=33, varin=4, theta=1.545937, up=999999999999999983222784.000000
ITER 7: row=40, varin=64, theta=1.223355, up=1.000000
ITER 8: row=40, varin=45, theta=0.136469, up=1.000000
ITER 9: row=12, varin=64, theta=1.000000, up=1.000000
ITER 10: row=41, varin=40, theta=1.566896, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=11)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 28064106.438324
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 42 rows, 60 cols, 269 nonzeros, 4 slack, 38 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % @PAP adding 3 rows, 7 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=40, varin=94, theta=0.218138, up=1.000000
ITER 2: row=39, varin=64, theta=1.194247, up=1.000000
ITER 3: row=39, varin=66, theta=0.205672, up=1.000000
ITER 4: row=18, varin=4, theta=0.304493, up=999999999999999983222784.000000
ITER 5: row=36, varin=37, theta=0.263775, up=999999999999999983222784.000000
ITER 6: row=20, varin=24, theta=0.432750, up=999999999999999983222784.000000
ITER 7: row=24, varin=3, theta=0.291548, up=999999999999999983222784.000000
ITER 8: row=4, varin=17, theta=0.214575, up=999999999999999983222784.000000
ITER 9: row=41, varin=13, theta=0.487239, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=9)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=41)
DEBUG SOLUTION: LP solution array indices: FST[42-81], not_covered[82-101]
DEBUG SOLUTION: lp->best_solution[0] = 28230933.192098
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.512761
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 41 rows, 60 cols, 268 nonzeros, 1 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 2 rows, 9 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=41, varin=65, theta=1.000000, up=1.000000
ITER 2: row=1, varin=11, theta=0.746867, up=999999999999999983222784.000000
ITER 3: row=11, varin=49, theta=0.666448, up=1.000000
ITER 4: row=16, varin=44, theta=1.333333, up=1.000000
ITER 5: row=16, varin=79, theta=0.250000, up=1.000000
ITER 6: row=15, varin=86, theta=2.135095, up=1.000000
ITER 7: row=15, varin=44, theta=1.509818, up=1.000000
ITER 8: row=15, varin=71, theta=0.207921, up=1.000000
ITER 9: row=16, varin=86, theta=0.828745, up=1.000000
ITER 10: row=36, varin=79, theta=0.249610, up=1.000000
LP PHASE: Switching to primal (iter=12)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 28615332.435514
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 42 rows, 60 cols, 275 nonzeros, 0 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 3 rows, 11 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=45, varin=78, theta=1.333333, up=1.000000
ITER 2: row=45, varin=102, theta=0.250000, up=1.000000
ITER 3: row=44, varin=78, theta=1.428181, up=1.000000
ITER 4: row=44, varin=4, theta=0.353561, up=999999999999999983222784.000000
ITER 5: row=13, varin=23, theta=0.459535, up=999999999999999983222784.000000
ITER 6: row=23, varin=36, theta=0.362184, up=999999999999999983222784.000000
ITER 7: row=42, varin=16, theta=0.549314, up=999999999999999983222784.000000
ITER 8: row=16, varin=19, theta=0.398967, up=999999999999999983222784.000000
ITER 9: row=39, varin=58, theta=1.174494, up=1.000000
ITER 10: row=39, varin=39, theta=0.193578, up=999999999999999983222784.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 999999999999999983222784.000000
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 45 rows, 60 cols, 286 nonzeros, 4 slack, 41 tight.
  % Node 46 LP 1 Solution, length = 999999999999999983222784.000000, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.250308 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 1.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.749692 (FST 27)
  % DEBUG LP_VARS: x[28] = 1.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.749692 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
DEBUG BB: compute_good_lower_bound returned status=1
DEBUG BB: Node 46 is INFEASIBLE
 %      46    29    infeasible               27764068.5586   x11 U    39     7
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ad4c4b6b40
% @LO 0.04  27.76023900136749489320 99.9000000000
% @LN 0.04  27.76406855858192201936 99.9000000000
% Resuming node 67 at  27.76406855858192201936
DEBUG CONSTRNT: LP rows=45, pool->nlprows=45, pool->npend=0
DEBUG CONSTRNT: Checking 45 LP rows (pool tracks 45, total LP rows 45)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 133
DEBUG CONSTRNT: Pool row 133 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=44, expected 44
 % @PAP adding 47 rows, 238 nz to LP
DEBUG BB: Processing node 67, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 67 LP 2 Solution, length = 27764068.558582, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.021825 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.021825 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.412701 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.500000 (FST 12)
  % DEBUG LP_VARS: x[13] = 1.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 1.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.500000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.412701 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.021825 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.021825 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.021825 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.021825 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.978175 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.978175 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.978175 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.978175 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.587299 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.587299 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.500000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 10 fractional variables
DEBUG CG: LP optimal, z=27764068.558582, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=27764068.558582, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 67 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 67
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.021825
DEBUG CAREFUL: Adding var 0 to fractional list (xi=0.021825)
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.021825
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.021825)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=1.000000
DEBUG CAREFUL: Skipping var 2: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.412701
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.412701)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.500000
DEBUG CAREFUL: Adding var 12 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=1.000000
DEBUG CAREFUL: Skipping var 13: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=1.000000
DEBUG CAREFUL: Skipping var 17: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.500000
DEBUG CAREFUL: Adding var 25 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.412701
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.412701)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.021825
DEBUG CAREFUL: Adding var 29 to fractional list (xi=0.021825)
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.021825
DEBUG CAREFUL: Adding var 30 to fractional list (xi=0.021825)
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.021825
DEBUG CAREFUL: Adding var 32 to fractional list (xi=0.021825)
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.021825
DEBUG CAREFUL: Adding var 33 to fractional list (xi=0.021825)
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 10 fractional variables

  %  Carefully choosing branching variable, nfrac = 10
DEBUG CAREFUL: Testing fvar[0] = var 25
DEBUG CAREFUL: Calling compare_branch_vars for var 25
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 25
DEBUG CAREFUL: New best var: 25
DEBUG CAREFUL: Testing fvar[1] = var 12
DEBUG CAREFUL: Calling compare_branch_vars for var 12
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 12
DEBUG CAREFUL: Testing fvar[2] = var 33
DEBUG CAREFUL: Calling compare_branch_vars for var 33
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 33
DEBUG CAREFUL: New best var: 33
DEBUG CAREFUL: Testing fvar[3] = var 30
DEBUG CAREFUL: Calling compare_branch_vars for var 30
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 30
DEBUG CAREFUL: Testing fvar[4] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 1
DEBUG CAREFUL: Testing fvar[5] = var 32
DEBUG CAREFUL: Calling compare_branch_vars for var 32
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 32
DEBUG CAREFUL: Testing fvar[6] = var 0
DEBUG CAREFUL: Calling compare_branch_vars for var 0
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 0
DEBUG CAREFUL: Testing fvar[7] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
DEBUG CAREFUL: Testing fvar[8] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 10
DEBUG CAREFUL: New best var: 10
DEBUG CAREFUL: Testing fvar[9] = var 29
DEBUG CAREFUL: Calling compare_branch_vars for var 29
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 29
  % Initial guess is x10, Z0 = 27764068.5585819        , Z1 = 28068478.2952541        

DEBUG EVAL: Testing var 25 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=14, varin=8, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=19, varin=79, theta=0.105745, up=1.000000
DEBUG EVAL: Branch var 25 = 0 gives z=27991659.598568
  % 	x25 = 0,	Z0 = 27991659.598568         
DEBUG EVAL: First branch cutoff check: z=27991659.598568, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 25 = 1
ITER 1: row=14, varin=19, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=19, varin=79, theta=0.564481, up=1.000000
  % 	x25 = 1,	Z1 = 28404898.3162094        
DEBUG EVAL: Second branch cutoff check: z=28404898.316209, best_z=INF, threshold=INF
  %   New best:  x25, Z = 27991659.598568         
DEBUG EVAL: Testing var 12 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=8, varin=8, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=19, varin=79, theta=0.105745, up=1.000000
DEBUG EVAL: Branch var 12 = 0 gives z=27991659.598568
  % 	x12 = 0,	Z0 = 27991659.598568         
DEBUG EVAL: First branch cutoff check: z=27991659.598568, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 12 = 1
ITER 1: row=8, varin=44, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=19, varin=79, theta=0.837074, up=1.000000
  % 	x12 = 1,	Z1 = 28009884.9061322        
DEBUG EVAL: Second branch cutoff check: z=28009884.906132, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 33 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=37, varin=47, theta=0.965738, up=999999999999999983222784.000000
ITER 2: row=31, varin=45, theta=2.113105, up=999999999999999983222784.000000
ITER 3: row=19, varin=40, theta=0.291667, up=999999999999999983222784.000000
ITER 4: row=30, varin=74, theta=7.696365, up=1.000000
ITER 5: row=30, varin=44, theta=0.643635, up=999999999999999983222784.000000
ITER 6: row=31, varin=74, theta=2.555375, up=1.000000
ITER 7: row=31, varin=27, theta=1.070527, up=999999999999999983222784.000000
ITER 8: row=27, varin=39, theta=1.643661, up=999999999999999983222784.000000
ITER 9: row=32, varin=51, theta=0.897272, up=1.000000
ITER 10: row=26, varin=43, theta=3.652256, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 33 = 1 gives z=28632839.736207
  % 	x33 = 1,	Z1 = 28632839.7362065        
DEBUG EVAL: First branch cutoff check: z=28632839.736207, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 33 = 0
ITER 1: row=37, varin=79, theta=0.037831, up=1.000000
  % 	x33 = 0,	Z0 = 27764678.0710478        
DEBUG EVAL: Second branch cutoff check: z=27764678.071048, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 30 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=30, varin=45, theta=2.173578, up=999999999999999983222784.000000
ITER 2: row=25, varin=40, theta=0.563661, up=999999999999999983222784.000000
ITER 3: row=37, varin=27, theta=0.804409, up=999999999999999983222784.000000
ITER 4: row=27, varin=51, theta=0.669945, up=1.000000
ITER 5: row=26, varin=44, theta=0.630023, up=999999999999999983222784.000000
ITER 6: row=46, varin=30, theta=2.252194, up=999999999999999983222784.000000
ITER 7: row=30, varin=43, theta=3.232353, up=999999999999999983222784.000000
ITER 8: row=26, varin=39, theta=5.723514, up=999999999999999983222784.000000
ITER 9: row=32, varin=34, theta=1.250270, up=999999999999999983222784.000000
ITER 10: row=34, varin=28, theta=0.386141, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 30 = 1 gives z=28734152.689540
  % 	x30 = 1,	Z1 = 28734152.6895398        
DEBUG EVAL: First branch cutoff check: z=28734152.689540, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 30 = 0
ITER 1: row=30, varin=47, theta=0.022109, up=999999999999999983222784.000000
ITER 2: row=31, varin=79, theta=0.037831, up=1.000000
  % 	x30 = 0,	Z0 = 27764678.071048         
DEBUG EVAL: Second branch cutoff check: z=27764678.071048, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 1 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=2, varin=79, theta=0.037831, up=1.000000
DEBUG EVAL: Branch var 1 = 0 gives z=27764678.071048
  % 	x1 = 0,	Z0 = 27764678.071048         
DEBUG EVAL: First branch cutoff check: z=27764678.071048, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 32 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=32, varin=79, theta=0.037831, up=1.000000
DEBUG EVAL: Branch var 32 = 0 gives z=27764678.071048
  % 	x32 = 0,	Z0 = 27764678.071048         
DEBUG EVAL: First branch cutoff check: z=27764678.071048, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 0 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=79, theta=0.037831, up=1.000000
DEBUG EVAL: Branch var 0 = 0 gives z=27764678.071048
  % 	x0 = 0,	Z0 = 27764678.071048         
DEBUG EVAL: First branch cutoff check: z=27764678.071048, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 26 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=19, varin=79, theta=0.449149, up=1.000000
ITER 2: row=37, varin=47, theta=0.432251, up=999999999999999983222784.000000
ITER 3: row=30, varin=2, theta=0.412472, up=999999999999999983222784.000000
ITER 4: row=31, varin=9, theta=0.960611, up=999999999999999983222784.000000
ITER 5: row=19, varin=27, theta=0.250000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 26 = 1 gives z=27898628.840997
  % 	x26 = 1,	Z1 = 27898628.8409967        
DEBUG EVAL: First branch cutoff check: z=27898628.840997, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 10 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=4, varin=79, theta=0.449149, up=1.000000
DEBUG EVAL: Branch var 10 = 1 gives z=27771304.959151
  % 	x10 = 1,	Z1 = 28068478.2952541        
DEBUG EVAL: First branch cutoff check: z=28068478.295254, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 0
ITER 1: row=4, varin=47, theta=0.392482, up=999999999999999983222784.000000
  % 	x10 = 0,	Z0 = 27765466.5423452        
DEBUG EVAL: Second branch cutoff check: z=27765466.542345, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 29 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=29, varin=79, theta=0.037831, up=1.000000
DEBUG EVAL: Branch var 29 = 0 gives z=27764678.071048
  % 	x29 = 0,	Z0 = 27764678.071048         
DEBUG EVAL: First branch cutoff check: z=27764678.071048, best_z=INF, threshold=INF
  % Best branch is x25, Z0 = 27991659.598568         , Z1 = 28404898.3162094        

DEBUG CAREFUL: Final result - returning best.var = 25
DEBUG BB: Branching variable chosen: j=25
 % @NC   75   67	x25 = 0	27991659.598568
 % @NC   76   67	x25 = 1	28404898.316209
 %      67    30 27764068.5586               27764166.9374   x21 D    10     5
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ad4c4ad660
% @LO 0.04  27.76406855858192201936 99.9000000000
% @LN 0.04  27.76416693740379670885 99.9000000000
% Resuming node 59 at  27.76416693740379670885
DEBUG CONSTRNT: LP rows=47, pool->nlprows=47, pool->npend=0
DEBUG CONSTRNT: Checking 47 LP rows (pool tracks 47, total LP rows 47)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 65
DEBUG CONSTRNT: Pool row 65 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 133
DEBUG CONSTRNT: Pool row 133 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=46, expected 46
 % @PAP adding 41 rows, 167 nz to LP
DEBUG BB: Processing node 59, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 59 LP 2 Solution, length = 27764166.937404, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.500000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.500000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.500000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.500000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.500000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.500000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.500000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.500000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.500000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.500000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=27764166.937404, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=27764166.937404, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 59 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 59
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.500000
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=1.000000
DEBUG CAREFUL: Skipping var 2: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.500000
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=1.000000
DEBUG CAREFUL: Skipping var 7: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.500000
DEBUG CAREFUL: Adding var 22 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.500000
DEBUG CAREFUL: Adding var 30 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.500000
DEBUG CAREFUL: Adding var 32 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 3
DEBUG CAREFUL: New best var: 3
DEBUG CAREFUL: Testing fvar[1] = var 22
DEBUG CAREFUL: Calling compare_branch_vars for var 22
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 22
DEBUG CAREFUL: Testing fvar[2] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 1
DEBUG CAREFUL: New best var: 1
DEBUG CAREFUL: Testing fvar[3] = var 32
DEBUG CAREFUL: Calling compare_branch_vars for var 32
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 32
DEBUG CAREFUL: Testing fvar[4] = var 30
DEBUG CAREFUL: Calling compare_branch_vars for var 30
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 30
  % Initial guess is x1, Z0 = 27764166.9374038        , Z1 = 27804342.3285327        

DEBUG EVAL: Testing var 3 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=3, varin=37, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 3 = 0 gives z=27853708.714069
  % 	x3 = 0,	Z0 = 27853708.7140694        
DEBUG EVAL: First branch cutoff check: z=27853708.714069, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 3 = 1
ITER 1: row=3, varin=35, theta=1.000000, up=999999999999999983222784.000000
  % 	x3 = 1,	Z1 = 27937250.2706298        
DEBUG EVAL: Second branch cutoff check: z=27937250.270630, best_z=INF, threshold=INF
  %   New best:  x3, Z = 27853708.7140694        
DEBUG EVAL: Testing var 22 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=20, varin=37, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 22 = 0 gives z=27853708.714069
  % 	x22 = 0,	Z0 = 27853708.7140694        
DEBUG EVAL: First branch cutoff check: z=27853708.714069, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 22 = 1
ITER 1: row=20, varin=20, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=36, varin=22, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=1, varin=70, theta=1.000000, up=1.000000
  % 	x22 = 1,	Z1 = 28762823.4768046        
DEBUG EVAL: Second branch cutoff check: z=28762823.476805, best_z=INF, threshold=INF
  %   New best:  x22, Z = 27853708.7140694        
DEBUG EVAL: Testing var 1 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=47, theta=0.500000, up=1.000000
ITER 2: row=17, varin=40, theta=0.500000, up=999999999999999983222784.000000
ITER 3: row=40, varin=38, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 1 = 1 gives z=27832146.622184
  % 	x1 = 1,	Z1 = 27832146.6221844        
DEBUG EVAL: First branch cutoff check: z=27832146.622184, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 32 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=32, varin=47, theta=0.500000, up=1.000000
ITER 2: row=17, varin=40, theta=0.500000, up=999999999999999983222784.000000
ITER 3: row=40, varin=38, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 32 = 1 gives z=27832146.622184
  % 	x32 = 1,	Z1 = 27832146.6221844        
DEBUG EVAL: First branch cutoff check: z=27832146.622184, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 30 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=35, varin=70, theta=0.500000, up=1.000000
DEBUG EVAL: Branch var 30 = 0 gives z=27773749.579243
  % 	x30 = 0,	Z0 = 27773749.5792431        
DEBUG EVAL: First branch cutoff check: z=27773749.579243, best_z=INF, threshold=INF
  % Best branch is x22, Z0 = 27853708.7140694        , Z1 = 28762823.4768046        

DEBUG CAREFUL: Final result - returning best.var = 22
DEBUG BB: Branching variable chosen: j=22
 % @NC   77   59	x22 = 0	27853708.714069
 % @NC   78   59	x22 = 1	28762823.476805
 %      59    31 27764166.9374               27773965.6826   x27 D    57    10
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ad4c4a0450
% @LO 0.05  27.76416693740379670885 99.9000000000
% @LN 0.05  27.77396568264578391450 99.9000000000
% Resuming node 52 at  27.77396568264578391450
DEBUG CONSTRNT: LP rows=41, pool->nlprows=41, pool->npend=0
DEBUG CONSTRNT: Checking 41 LP rows (pool tracks 41, total LP rows 41)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 133
DEBUG CONSTRNT: Pool row 133 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=40, expected 40
 % @PAP adding 43 rows, 171 nz to LP
DEBUG BB: Processing node 52, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=20, varin=59, theta=2.000000, up=1.000000
ITER 2: row=20, varin=40, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=10, varin=59, theta=1.000000, up=1.000000
ITER 4: row=40, varin=42, theta=2.000000, up=999999999999999983222784.000000
ITER 5: row=36, varin=39, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=39, varin=37, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=37, varin=12, theta=1.000000, up=999999999999999983222784.000000
ITER 8: row=12, varin=33, theta=1.000000, up=999999999999999983222784.000000
ITER 9: row=33, varin=32, theta=1.000000, up=999999999999999983222784.000000
ITER 10: row=32, varin=29, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=10)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 27773965.682646
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 43 rows, 60 cols, 231 nonzeros, 5 slack, 38 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 45 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=45, varin=25, theta=2.123720, up=999999999999999983222784.000000
ITER 2: row=18, varin=20, theta=1.446890, up=999999999999999983222784.000000
ITER 3: row=29, varin=73, theta=1.513559, up=1.000000
ITER 4: row=29, varin=75, theta=0.530910, up=1.000000
ITER 5: row=32, varin=73, theta=1.000000, up=1.000000
ITER 6: row=33, varin=4, theta=1.640717, up=999999999999999983222784.000000
ITER 7: row=38, varin=67, theta=1.298357, up=1.000000
ITER 8: row=38, varin=48, theta=0.182295, up=1.000000
ITER 9: row=12, varin=67, theta=1.000000, up=1.000000
ITER 10: row=44, varin=38, theta=1.282557, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=12)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 28088375.357701
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 45 rows, 60 cols, 276 nonzeros, 4 slack, 41 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % @PAP adding 3 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=42, varin=67, theta=1.254710, up=1.000000
ITER 2: row=42, varin=69, theta=0.269691, up=1.000000
ITER 3: row=39, varin=67, theta=1.000000, up=1.000000
ITER 4: row=37, varin=77, theta=1.816037, up=1.000000
ITER 5: row=37, varin=59, theta=0.627474, up=1.000000
ITER 6: row=34, varin=77, theta=1.000000, up=1.000000
ITER 7: row=10, varin=75, theta=1.731810, up=1.000000
ITER 8: row=10, varin=51, theta=0.557303, up=1.000000
ITER 9: row=35, varin=75, theta=1.000000, up=1.000000
ITER 10: row=17, varin=73, theta=1.401334, up=1.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 999999999999999983222784.000000
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 44 rows, 60 cols, 276 nonzeros, 4 slack, 40 tight.
  % Node 52 LP 1 Solution, length = 999999999999999983222784.000000, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.178553 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 1.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.178553 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.178553 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.821447 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.821447 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.821447 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.821447 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.821447 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
DEBUG BB: compute_good_lower_bound returned status=1
DEBUG BB: Node 52 is INFEASIBLE
 %      52    30    infeasible               27778327.5046    x4 U    45     8
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ad4c4c78e0
% @LO 0.05  27.77396568264578391450 99.9000000000
% @LN 0.05  27.77832750459954880284 99.9000000000
% Resuming node 66 at  27.77832750459954880284
DEBUG CONSTRNT: LP rows=44, pool->nlprows=44, pool->npend=0
DEBUG CONSTRNT: Checking 44 LP rows (pool tracks 44, total LP rows 44)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 133
DEBUG CONSTRNT: Pool row 133 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=43, expected 43
 % @PAP adding 24 rows, 162 nz to LP
DEBUG BB: Processing node 66, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=16, varin=24, theta=2.516816, up=999999999999999983222784.000000
ITER 2: row=6, varin=6, theta=1.500000, up=999999999999999983222784.000000
ITER 3: row=1, varin=8, theta=2.000000, up=999999999999999983222784.000000
ITER 4: row=8, varin=17, theta=2.000000, up=999999999999999983222784.000000
ITER 5: row=21, varin=18, theta=2.000000, up=999999999999999983222784.000000
ITER 6: row=19, varin=9, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=16, varin=13, theta=0.000702, up=999999999999999983222784.000000
ITER 8: row=13, varin=30, theta=0.000913, up=1.000000
LP PHASE: Switching to primal (iter=8)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=24)
DEBUG SOLUTION: LP solution array indices: FST[25-64], not_covered[65-84]
DEBUG SOLUTION: lp->best_solution[0] = 27778327.504600
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.500456
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 24 rows, 60 cols, 222 nonzeros, 4 slack, 20 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 9 rows, 46 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=30, varin=21, theta=0.115420, up=999999999999999983222784.000000
ITER 2: row=27, varin=20, theta=0.149954, up=999999999999999983222784.000000
ITER 3: row=31, varin=22, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=29, varin=30, theta=11.499544, up=999999999999999983222784.000000
ITER 5: row=1, varin=80, theta=1.149954, up=1.000000
ITER 6: row=1, varin=82, theta=0.149954, up=1.000000
ITER 7: row=8, varin=80, theta=1.000000, up=1.000000
ITER 8: row=25, varin=27, theta=8.491327, up=999999999999999983222784.000000
ITER 9: row=1, varin=85, theta=0.999087, up=1.000000
ITER 10: row=17, varin=44, theta=0.277275, up=1.000000
LP PHASE: Switching to primal (iter=24)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=33)
DEBUG SOLUTION: LP solution array indices: FST[34-73], not_covered[74-93]
DEBUG SOLUTION: lp->best_solution[0] = 27803758.704582
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 33 rows, 60 cols, 268 nonzeros, 8 slack, 25 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 8 slack rows
  % @PAP adding 2 rows, 11 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=26, varin=17, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=14, varin=83, theta=1.000000, up=1.000000
ITER 3: row=12, varin=87, theta=1.000000, up=1.000000
ITER 4: row=15, varin=37, theta=0.333333, up=1.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=27)
DEBUG SOLUTION: LP solution array indices: FST[28-67], not_covered[68-87]
DEBUG SOLUTION: lp->best_solution[0] = 27807567.971815
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.666667
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 27 rows, 60 cols, 237 nonzeros, 4 slack, 23 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=24, varin=12, theta=1.345895, up=999999999999999983222784.000000
ITER 2: row=12, varin=17, theta=0.122520, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=24)
DEBUG SOLUTION: LP solution array indices: FST[25-64], not_covered[65-84]
DEBUG SOLUTION: lp->best_solution[0] = 27812769.436264
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.561260
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 24 rows, 60 cols, 218 nonzeros, 2 slack, 22 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 2 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=24, varin=35, theta=0.156527, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=24)
DEBUG SOLUTION: LP solution array indices: FST[25-64], not_covered[65-84]
DEBUG SOLUTION: lp->best_solution[0] = 27812790.139751
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 24 rows, 60 cols, 208 nonzeros, 0 slack, 24 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 66 LP 1 Solution, length = 27812790.139751, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.500000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.500000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.343473 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.156527 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 1.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 1.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.500000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.500000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.656527 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.843473 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=27812790.139751, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 66 at  27.81279013975059655195
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ad4c4a5090
% @LO 0.05  27.77832750459954880284 99.9000000000
% @LN 0.05  27.78001572803248464538 99.9000000000
% Resuming node 69 at  27.78001572803248464538
DEBUG CONSTRNT: LP rows=24, pool->nlprows=24, pool->npend=0
DEBUG CONSTRNT: Checking 24 LP rows (pool tracks 24, total LP rows 24)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 45
DEBUG CONSTRNT: Pool row 45 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 79
DEBUG CONSTRNT: Pool row 79 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=23, expected 23
 % @PAP adding 35 rows, 191 nz to LP
DEBUG BB: Processing node 69, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=5, varin=24, theta=0.497179, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
ITER 2: row=27, varin=54, theta=0.000000, up=1.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=35)
DEBUG SOLUTION: LP solution array indices: FST[36-75], not_covered[76-95]
DEBUG SOLUTION: lp->best_solution[0] = 27780015.728032
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 35 rows, 60 cols, 251 nonzeros, 1 slack, 34 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=36, varin=63, theta=0.003592, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=36)
DEBUG SOLUTION: LP solution array indices: FST[37-76], not_covered[77-96]
DEBUG SOLUTION: lp->best_solution[0] = 27780185.721100
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 36 rows, 60 cols, 253 nonzeros, 1 slack, 35 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 2 rows, 5 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=36, varin=65, theta=0.003705, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=37)
DEBUG SOLUTION: LP solution array indices: FST[38-77], not_covered[78-97]
DEBUG SOLUTION: lp->best_solution[0] = 27780254.435458
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 37 rows, 60 cols, 256 nonzeros, 0 slack, 37 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=38, varin=68, theta=0.003790, up=1.000000
ITER 2: row=32, varin=60, theta=0.003328, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=38)
DEBUG SOLUTION: LP solution array indices: FST[39-78], not_covered[79-98]
DEBUG SOLUTION: lp->best_solution[0] = 27780354.908690
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 38 rows, 60 cols, 258 nonzeros, 0 slack, 38 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=39, varin=42, theta=0.002287, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=39)
DEBUG SOLUTION: LP solution array indices: FST[40-79], not_covered[80-99]
DEBUG SOLUTION: lp->best_solution[0] = 27780387.221818
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 39 rows, 60 cols, 262 nonzeros, 0 slack, 39 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=40, varin=64, theta=0.003443, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=40)
DEBUG SOLUTION: LP solution array indices: FST[41-80], not_covered[81-100]
DEBUG SOLUTION: lp->best_solution[0] = 27780512.067169
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 40 rows, 60 cols, 264 nonzeros, 0 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 5 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=41, varin=88, theta=0.001012, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 27780572.563307
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.998988
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 42 rows, 60 cols, 269 nonzeros, 2 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 3 rows, 7 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=42, varin=68, theta=0.003548, up=1.000000
ITER 2: row=27, varin=76, theta=0.004666, up=1.000000
ITER 3: row=29, varin=85, theta=0.002823, up=1.000000
ITER 4: row=40, varin=66, theta=0.003782, up=1.000000
ITER 5: row=23, varin=48, theta=0.004150, up=1.000000
ITER 6: row=24, varin=88, theta=0.001900, up=1.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 27781542.342747
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 0.998100
DEBUG SOLUTION: lp->best_solution[3] = 0.000000
DEBUG SOLUTION: lp->best_solution[4] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 43 rows, 60 cols, 272 nonzeros, 2 slack, 41 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=42, varin=71, theta=0.003720, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 27781681.298109
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 0.000000
DEBUG SOLUTION: lp->best_solution[3] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 42 rows, 60 cols, 270 nonzeros, 0 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=43, varin=76, theta=0.004547, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 27782253.116829
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 0.000000
DEBUG SOLUTION: lp->best_solution[3] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 44 rows, 60 cols, 278 nonzeros, 0 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=45, varin=6, theta=0.003066, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 27782566.755642
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 0.000000
DEBUG SOLUTION: lp->best_solution[3] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.996934
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 45 rows, 60 cols, 280 nonzeros, 1 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 69 LP 1 Solution, length = 27782566.755642, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.996934 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.498467 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 1.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 1.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.003066 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.003066 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.498467 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.498467 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.501533 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.501533 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.003066 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=27782566.755642, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
 % @LO 0.05  27.78001572803248464538 99.9000000000
 % @LN 0.05  27.78256675564177413662 99.9000000000
DEBUG CG: Second cutoff check: z=27782566.755642, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 69 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 69
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.996934
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.996934)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.498467
DEBUG CAREFUL: Adding var 5 to fractional list (xi=0.498467)
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=1.000000
DEBUG CAREFUL: Skipping var 15: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=1.000000
DEBUG CAREFUL: Skipping var 17: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.003066
DEBUG CAREFUL: Adding var 27 to fractional list (xi=0.003066)
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.003066
DEBUG CAREFUL: Adding var 31 to fractional list (xi=0.003066)
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.498467
DEBUG CAREFUL: Adding var 34 to fractional list (xi=0.498467)
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.498467
DEBUG CAREFUL: Adding var 36 to fractional list (xi=0.498467)
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 6 fractional variables

  %  Carefully choosing branching variable, nfrac = 6
DEBUG CAREFUL: Testing fvar[0] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 2
DEBUG CAREFUL: New best var: 2
DEBUG CAREFUL: Testing fvar[1] = var 34
DEBUG CAREFUL: Calling compare_branch_vars for var 34
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 34
DEBUG CAREFUL: Testing fvar[2] = var 5
DEBUG CAREFUL: Calling compare_branch_vars for var 5
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 5
DEBUG CAREFUL: Testing fvar[3] = var 27
DEBUG CAREFUL: Calling compare_branch_vars for var 27
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 27
DEBUG CAREFUL: Testing fvar[4] = var 31
DEBUG CAREFUL: Calling compare_branch_vars for var 31
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 31
DEBUG CAREFUL: New best var: 31
DEBUG CAREFUL: Testing fvar[5] = var 36
DEBUG CAREFUL: Calling compare_branch_vars for var 36
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 36
  % Initial guess is x31, Z0 = 27782566.7556418        , Z1 = 28279015.2255093        

DEBUG EVAL: Testing var 2 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=3, varin=101, theta=0.004460, up=1.000000
DEBUG EVAL: Branch var 2 = 1 gives z=27782633.759548
  % 	x2 = 1,	Z1 = 27782633.7595481        
DEBUG EVAL: First branch cutoff check: z=27782633.759548, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 0
ITER 1: row=3, varin=44, theta=1.478552, up=999999999999999983222784.000000
ITER 2: row=24, varin=42, theta=0.391570, up=999999999999999983222784.000000
ITER 3: row=42, varin=41, theta=0.600061, up=999999999999999983222784.000000
ITER 4: row=26, varin=22, theta=0.436821, up=999999999999999983222784.000000
ITER 5: row=22, varin=48, theta=0.398092, up=1.000000
ITER 6: row=21, varin=37, theta=0.433331, up=999999999999999983222784.000000
ITER 7: row=37, varin=39, theta=0.532408, up=999999999999999983222784.000000
ITER 8: row=39, varin=36, theta=0.362418, up=999999999999999983222784.000000
ITER 9: row=36, varin=34, theta=0.350300, up=999999999999999983222784.000000
ITER 10: row=34, varin=33, theta=0.389946, up=999999999999999983222784.000000
  % 	x2 = 0,	Z0 = 28094915.1860231        
DEBUG EVAL: Second branch cutoff check: z=28094915.186023, best_z=INF, threshold=INF
  %   New best:  x2, Z = 27782633.7595481        
DEBUG EVAL: Testing var 34 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=30, varin=44, theta=3.079380, up=999999999999999983222784.000000
ITER 2: row=3, varin=59, theta=1.473150, up=1.000000
ITER 3: row=3, varin=22, theta=0.185170, up=999999999999999983222784.000000
ITER 4: row=4, varin=59, theta=1.000000, up=1.000000
ITER 5: row=22, varin=48, theta=0.653536, up=1.000000
ITER 6: row=21, varin=16, theta=0.400795, up=999999999999999983222784.000000
ITER 7: row=24, varin=41, theta=0.288086, up=999999999999999983222784.000000
ITER 8: row=26, varin=47, theta=0.267169, up=1.000000
DEBUG EVAL: Branch var 34 = 1 gives z=28117990.815524
  % 	x34 = 1,	Z1 = 28117990.8155243        
DEBUG EVAL: First branch cutoff check: z=28117990.815524, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 34 = 0
ITER 1: row=30, varin=101, theta=1.399060, up=1.000000
ITER 2: row=30, varin=19, theta=0.313335, up=999999999999999983222784.000000
ITER 3: row=15, varin=101, theta=1.160236, up=1.000000
ITER 4: row=15, varin=44, theta=0.153674, up=999999999999999983222784.000000
ITER 5: row=10, varin=30, theta=0.073421, up=999999999999999983222784.000000
ITER 6: row=24, varin=42, theta=0.065379, up=999999999999999983222784.000000
ITER 7: row=42, varin=41, theta=0.082693, up=999999999999999983222784.000000
ITER 8: row=26, varin=55, theta=0.140591, up=1.000000
  % 	x34 = 0,	Z0 = 27879925.8914962        
DEBUG EVAL: Second branch cutoff check: z=27879925.891496, best_z=INF, threshold=INF
  %   New best:  x34, Z = 27879925.8914962        
DEBUG EVAL: Testing var 5 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=7, varin=101, theta=1.399060, up=1.000000
ITER 2: row=7, varin=19, theta=0.313335, up=999999999999999983222784.000000
ITER 3: row=15, varin=101, theta=1.160236, up=1.000000
ITER 4: row=15, varin=44, theta=0.153674, up=999999999999999983222784.000000
ITER 5: row=10, varin=101, theta=0.348503, up=1.000000
ITER 6: row=24, varin=25, theta=0.359482, up=999999999999999983222784.000000
ITER 7: row=36, varin=42, theta=0.093639, up=999999999999999983222784.000000
ITER 8: row=42, varin=41, theta=0.133745, up=999999999999999983222784.000000
ITER 9: row=26, varin=37, theta=0.068840, up=999999999999999983222784.000000
ITER 10: row=37, varin=21, theta=0.066515, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 5 = 0 gives z=27849592.159164
  % 	x5 = 0,	Z0 = 27849592.1591641        
DEBUG EVAL: First branch cutoff check: z=27849592.159164, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 27 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=15, varin=44, theta=1.478552, up=999999999999999983222784.000000
ITER 2: row=24, varin=42, theta=0.391570, up=999999999999999983222784.000000
ITER 3: row=42, varin=41, theta=0.600061, up=999999999999999983222784.000000
ITER 4: row=26, varin=22, theta=0.436821, up=999999999999999983222784.000000
ITER 5: row=22, varin=48, theta=0.398092, up=1.000000
ITER 6: row=21, varin=37, theta=0.433331, up=999999999999999983222784.000000
ITER 7: row=37, varin=39, theta=0.532408, up=999999999999999983222784.000000
ITER 8: row=39, varin=36, theta=0.362418, up=999999999999999983222784.000000
ITER 9: row=36, varin=34, theta=0.350300, up=999999999999999983222784.000000
ITER 10: row=34, varin=31, theta=0.378051, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 27 = 1 gives z=28120038.889811
  % 	x27 = 1,	Z1 = 28120038.8898113        
DEBUG EVAL: First branch cutoff check: z=28120038.889811, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 27 = 0
ITER 1: row=15, varin=101, theta=0.004460, up=1.000000
  % 	x27 = 0,	Z0 = 27782633.7595481        
DEBUG EVAL: Second branch cutoff check: z=27782633.759548, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 31 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=24, varin=42, theta=1.209809, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 31 = 1 gives z=28070500.580514
  % 	x31 = 1,	Z1 = 28279015.2255093        
DEBUG EVAL: First branch cutoff check: z=28279015.225509, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 31 = 0
ITER 1: row=24, varin=101, theta=0.004460, up=1.000000
  % 	x31 = 0,	Z0 = 27782633.7595481        
DEBUG EVAL: Second branch cutoff check: z=27782633.759548, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 36 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=28, varin=44, theta=3.079380, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 36 = 1 gives z=27994979.847096
  % 	x36 = 1,	Z1 = 27994979.8470958        
DEBUG EVAL: First branch cutoff check: z=27994979.847096, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 36 = 0
ITER 1: row=28, varin=101, theta=1.399060, up=1.000000
  % 	x36 = 0,	Z0 = 27797590.7110841        
DEBUG EVAL: Second branch cutoff check: z=27797590.711084, best_z=INF, threshold=INF
  % Best branch is x34, Z0 = 27879925.8914962        , Z1 = 28117990.8155243        

DEBUG CAREFUL: Final result - returning best.var = 34
DEBUG BB: Branching variable chosen: j=34
 % @NC   79   69	x34 = 0	27879925.891496
 % @NC   80   69	x34 = 1	28117990.815524
 %      69    31 27782566.7556               27791481.5914    x9 D    55     9
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ad4c4c0ef0
% @LO 0.05  27.78256675564177413662 99.9000000000
% @LN 0.05  27.79148159138904716770 99.9000000000
% Resuming node 48 at  27.79148159138904716770
DEBUG CONSTRNT: LP rows=44, pool->nlprows=44, pool->npend=0
DEBUG CONSTRNT: Checking 44 LP rows (pool tracks 44, total LP rows 44)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 133
DEBUG CONSTRNT: Pool row 133 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 58
DEBUG CONSTRNT: Pool row 58 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 134
DEBUG CONSTRNT: Pool row 134 has lprow=43, expected 43
 % @PAP adding 26 rows, 161 nz to LP
DEBUG BB: Processing node 48, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=19, varin=37, theta=2.222222, up=1.000000
ITER 2: row=19, varin=23, theta=1.100000, up=999999999999999983222784.000000
ITER 3: row=16, varin=37, theta=1.000000, up=1.000000
ITER 4: row=24, varin=36, theta=1.111111, up=1.000000
ITER 5: row=24, varin=25, theta=0.200000, up=999999999999999983222784.000000
ITER 6: row=1, varin=36, theta=1.306182, up=1.000000
ITER 7: row=1, varin=29, theta=0.339420, up=1.000000
ITER 8: row=7, varin=36, theta=1.111111, up=1.000000
ITER 9: row=7, varin=30, theta=0.100000, up=1.000000
ITER 10: row=8, varin=36, theta=0.487160, up=1.000000
LP PHASE: Switching to primal (iter=10)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=26)
DEBUG SOLUTION: LP solution array indices: FST[27-66], not_covered[67-86]
DEBUG SOLUTION: lp->best_solution[0] = 27791481.591389
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.897432
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.897432
  % @PL 26 rows, 60 cols, 221 nonzeros, 3 slack, 23 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 9 rows, 41 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=29, varin=82, theta=0.217994, up=1.000000
ITER 2: row=28, varin=29, theta=5.518820, up=999999999999999983222784.000000
ITER 3: row=33, varin=36, theta=1.614232, up=1.000000
ITER 4: row=33, varin=62, theta=0.629774, up=1.000000
ITER 5: row=17, varin=57, theta=0.552993, up=1.000000
ITER 6: row=5, varin=36, theta=0.502858, up=1.000000
ITER 7: row=17, varin=63, theta=0.008250, up=1.000000
LP PHASE: Switching to primal (iter=7)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=35)
DEBUG SOLUTION: LP solution array indices: FST[36-75], not_covered[76-95]
DEBUG SOLUTION: lp->best_solution[0] = 27941659.563003
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 35 rows, 60 cols, 262 nonzeros, 3 slack, 32 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 5 rows, 15 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=37, varin=59, theta=1.000000, up=1.000000
ITER 2: row=35, varin=67, theta=1.590462, up=1.000000
ITER 3: row=35, varin=61, theta=0.415321, up=1.000000
ITER 4: row=33, varin=47, theta=0.170006, up=1.000000
ITER 5: row=27, varin=72, theta=0.462112, up=1.000000
ITER 6: row=28, varin=92, theta=0.229539, up=1.000000
ITER 7: row=14, varin=25, theta=0.043677, up=999999999999999983222784.000000
ITER 8: row=29, varin=15, theta=0.112661, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=8)
ITER 9: row=32, varin=56, theta=0.000000, up=1.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=37)
DEBUG SOLUTION: LP solution array indices: FST[38-77], not_covered[78-97]
DEBUG SOLUTION: lp->best_solution[0] = 28067858.862751
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.962446
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 37 rows, 60 cols, 263 nonzeros, 3 slack, 34 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 6 rows, 17 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=40, varin=70, theta=1.000000, up=1.000000
ITER 2: row=35, varin=65, theta=1.577642, up=1.000000
ITER 3: row=35, varin=24, theta=0.615604, up=999999999999999983222784.000000
ITER 4: row=37, varin=77, theta=2.825340, up=1.000000
ITER 5: row=37, varin=46, theta=1.194221, up=1.000000
ITER 6: row=37, varin=73, theta=0.110285, up=1.000000
ITER 7: row=39, varin=46, theta=2.000000, up=1.000000
ITER 8: row=39, varin=65, theta=1.000000, up=1.000000
ITER 9: row=37, varin=55, theta=1.477123, up=1.000000
ITER 10: row=37, varin=14, theta=0.368370, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=18)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=40)
DEBUG SOLUTION: LP solution array indices: FST[41-80], not_covered[81-100]
DEBUG SOLUTION: lp->best_solution[0] = 28542731.016030
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.619625
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.500000
  % @PL 40 rows, 60 cols, 270 nonzeros, 2 slack, 38 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 5 rows, 16 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=43, varin=70, theta=1.000000, up=1.000000
ITER 2: row=39, varin=74, theta=1.000000, up=1.000000
ITER 3: row=31, varin=80, theta=0.800000, up=1.000000
ITER 4: row=42, varin=100, theta=1.154399, up=1.000000
ITER 5: row=42, varin=75, theta=0.171783, up=1.000000
ITER 6: row=29, varin=100, theta=1.000000, up=1.000000
ITER 7: row=41, varin=42, theta=1.000000, up=999999999999999983222784.000000
ITER 8: row=42, varin=67, theta=1.798021, up=1.000000
ITER 9: row=42, varin=66, theta=0.577117, up=1.000000
ITER 10: row=31, varin=76, theta=2.055487, up=1.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 999999999999999983222784.000000
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.619625
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.500000
  % @PL 43 rows, 60 cols, 282 nonzeros, 4 slack, 39 tight.
  % Node 48 LP 1 Solution, length = 999999999999999983222784.000000, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 1.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.619625 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 1.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 1.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 1.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.380375 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.500000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 1.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.380375 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.500000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
DEBUG BB: compute_good_lower_bound returned status=1
DEBUG BB: Node 48 is INFEASIBLE
 %      48    30    infeasible               27794138.2178   x15 U    37     8
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ad4c4b16a0
% @LO 0.05  27.79148159138904716770 99.9000000000
% @LN 0.05  27.79413821776481796633 99.9000000000
% Resuming node 71 at  27.79413821776481796633
DEBUG CONSTRNT: LP rows=43, pool->nlprows=43, pool->npend=0
DEBUG CONSTRNT: Checking 43 LP rows (pool tracks 43, total LP rows 43)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 85
DEBUG CONSTRNT: Pool row 85 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 133
DEBUG CONSTRNT: Pool row 133 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 142
DEBUG CONSTRNT: Pool row 142 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 143
DEBUG CONSTRNT: Pool row 143 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 58
DEBUG CONSTRNT: Pool row 58 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=42, expected 42
 % @PAP adding 32 rows, 180 nz to LP
DEBUG BB: Processing node 71, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=33, theta=0.869518, up=1.000000
ITER 2: row=16, varin=77, theta=0.270123, up=1.000000
ITER 3: row=5, varin=14, theta=0.277444, up=999999999999999983222784.000000
ITER 4: row=31, varin=16, theta=0.784891, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=32)
DEBUG SOLUTION: LP solution array indices: FST[33-72], not_covered[73-92]
DEBUG SOLUTION: lp->best_solution[0] = 27794138.217765
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 32 rows, 60 cols, 240 nonzeros, 1 slack, 31 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 5 rows, 13 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=33, varin=74, theta=1.340811, up=1.000000
ITER 2: row=33, varin=72, theta=0.356629, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=37)
DEBUG SOLUTION: LP solution array indices: FST[38-77], not_covered[78-97]
DEBUG SOLUTION: lp->best_solution[0] = 27853205.450122
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 37 rows, 60 cols, 253 nonzeros, 4 slack, 33 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % @PAP adding 5 rows, 21 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=38, varin=31, theta=0.180318, up=999999999999999983222784.000000
ITER 2: row=34, varin=38, theta=6.166911, up=999999999999999983222784.000000
ITER 3: row=5, varin=75, theta=0.743279, up=1.000000
ITER 4: row=36, varin=80, theta=0.939817, up=1.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=38)
DEBUG SOLUTION: LP solution array indices: FST[39-78], not_covered[79-98]
DEBUG SOLUTION: lp->best_solution[0] = 27890294.350036
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.939817
  % @PL 38 rows, 60 cols, 262 nonzeros, 6 slack, 32 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 6 slack rows
  % @PAP adding 4 rows, 15 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=33, varin=49, theta=0.510079, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=36)
DEBUG SOLUTION: LP solution array indices: FST[37-76], not_covered[77-96]
DEBUG SOLUTION: lp->best_solution[0] = 27891392.537303
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 36 rows, 60 cols, 252 nonzeros, 0 slack, 36 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 71 LP 1 Solution, length = 27891392.537303, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.489921 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.489921 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 1.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.489921 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.489921 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.510079 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.510079 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.510079 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.510079 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.510079 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.510079 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=27891392.537303, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 71 at  27.89139253730306933221
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ad4c4c3fd0
% @LO 0.05  27.79413821776481796633 99.9000000000
% @LN 0.05  27.79676937249551826881 99.9000000000
% Resuming node 68 at  27.79676937249551826881
DEBUG CONSTRNT: LP rows=36, pool->nlprows=36, pool->npend=0
DEBUG CONSTRNT: Checking 36 LP rows (pool tracks 36, total LP rows 36)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 141
DEBUG CONSTRNT: Pool row 141 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 145
DEBUG CONSTRNT: Pool row 145 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 159
DEBUG CONSTRNT: Pool row 159 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=35, expected 35
 % @PAP adding 43 rows, 234 nz to LP
DEBUG BB: Processing node 68, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=9, varin=41, theta=0.215248, up=999999999999999983222784.000000
ITER 2: row=15, varin=47, theta=2.098337, up=1.000000
ITER 3: row=15, varin=34, theta=1.217188, up=999999999999999983222784.000000
ITER 4: row=34, varin=28, theta=0.840962, up=999999999999999983222784.000000
ITER 5: row=28, varin=24, theta=1.205260, up=999999999999999983222784.000000
ITER 6: row=10, varin=39, theta=1.885277, up=999999999999999983222784.000000
ITER 7: row=39, varin=42, theta=2.826970, up=999999999999999983222784.000000
ITER 8: row=32, varin=8, theta=1.950835, up=999999999999999983222784.000000
ITER 9: row=29, varin=47, theta=1.000000, up=1.000000
ITER 10: row=21, varin=33, theta=0.767582, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=10)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 27796769.372496
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.000000
DEBUG SOLUTION: lp->best_solution[4] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 43 rows, 60 cols, 294 nonzeros, 6 slack, 37 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 6 slack rows
  % @PAP adding 5 rows, 18 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=39, varin=22, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=41, varin=59, theta=1.000000, up=1.000000
ITER 3: row=10, varin=68, theta=1.368291, up=1.000000
ITER 4: row=10, varin=72, theta=0.533693, up=1.000000
ITER 5: row=5, varin=57, theta=1.000000, up=1.000000
ITER 6: row=6, varin=20, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 28421432.563335
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.000000
DEBUG SOLUTION: lp->best_solution[4] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 42 rows, 60 cols, 293 nonzeros, 5 slack, 37 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % @PAP adding 3 rows, 7 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=39, varin=64, theta=0.666580, up=1.000000
ITER 2: row=34, varin=43, theta=0.426145, up=1.000000
ITER 3: row=21, varin=63, theta=0.650911, up=1.000000
ITER 4: row=25, varin=65, theta=0.716747, up=1.000000
ITER 5: row=24, varin=22, theta=0.004430, up=999999999999999983222784.000000
ITER 6: row=22, varin=73, theta=0.052920, up=1.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=40)
DEBUG SOLUTION: LP solution array indices: FST[41-80], not_covered[81-100]
DEBUG SOLUTION: lp->best_solution[0] = 28438199.354613
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.000000
DEBUG SOLUTION: lp->best_solution[4] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 40 rows, 60 cols, 282 nonzeros, 1 slack, 39 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 7 rows, 18 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=45, varin=56, theta=0.105876, up=1.000000
ITER 2: row=43, varin=26, theta=0.191146, up=999999999999999983222784.000000
ITER 3: row=46, varin=91, theta=0.556132, up=1.000000
ITER 4: row=42, varin=45, theta=2.812009, up=999999999999999983222784.000000
ITER 5: row=4, varin=9, theta=0.672431, up=999999999999999983222784.000000
ITER 6: row=26, varin=51, theta=0.500000, up=1.000000
ITER 7: row=43, varin=78, theta=1.000000, up=1.000000
ITER 8: row=4, varin=71, theta=0.170453, up=1.000000
ITER 9: row=42, varin=43, theta=0.185042, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=9)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=46)
DEBUG SOLUTION: LP solution array indices: FST[47-86], not_covered[87-106]
DEBUG SOLUTION: lp->best_solution[0] = 28729677.987885
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.000000
DEBUG SOLUTION: lp->best_solution[4] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 46 rows, 60 cols, 298 nonzeros, 3 slack, 43 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 3 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=46, varin=9, theta=0.433523, up=999999999999999983222784.000000
ITER 2: row=45, varin=77, theta=0.558883, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=46)
DEBUG SOLUTION: LP solution array indices: FST[47-86], not_covered[87-106]
DEBUG SOLUTION: lp->best_solution[0] = 28740681.711620
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.000000
DEBUG SOLUTION: lp->best_solution[4] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.745177
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 46 rows, 60 cols, 295 nonzeros, 1 slack, 45 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 3 rows, 9 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=46, varin=37, theta=0.146449, up=999999999999999983222784.000000
ITER 2: row=43, varin=28, theta=0.509356, up=999999999999999983222784.000000
ITER 3: row=47, varin=82, theta=0.143306, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 28799225.377462
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.000000
DEBUG SOLUTION: lp->best_solution[4] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 48 rows, 60 cols, 302 nonzeros, 2 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % Node 68 LP 1 Solution, length = 28799225.377462, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.143306 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.143306 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.573223 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 1.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 1.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 1.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 1.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.426777 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.143306 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.143306 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.426777 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.143306 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.143306 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.856694 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.856694 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.856694 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.856694 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.426777 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 9 fractional variables
DEBUG CG: LP optimal, z=28799225.377462, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 68 at  28.79922537746197264141
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ad4c48c600
% @LO 0.05  27.79676937249551826881 99.9000000000
% @LN 0.05  27.79809053952812902821 99.9000000000
% Resuming node 49 at  27.79809053952812902821
DEBUG CONSTRNT: LP rows=46, pool->nlprows=46, pool->npend=0
DEBUG CONSTRNT: Checking 46 LP rows (pool tracks 46, total LP rows 46)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 65
DEBUG CONSTRNT: Pool row 65 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 133
DEBUG CONSTRNT: Pool row 133 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 134
DEBUG CONSTRNT: Pool row 134 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=45, expected 45
 % @PAP adding 32 rows, 183 nz to LP
DEBUG BB: Processing node 49, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 49 LP 2 Solution, length = 27798090.539528, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.250000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.067660 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.500000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.500000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 1.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.500000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.500000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.932340 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.932340 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.500000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=27798090.539528, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=27798090.539528, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 49 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 49
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=1.000000
DEBUG CAREFUL: Skipping var 2: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.250000
DEBUG CAREFUL: Adding var 6 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=1.000000
DEBUG CAREFUL: Skipping var 7: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.067660
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.067660)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.500000
DEBUG CAREFUL: Adding var 12 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.500000
DEBUG CAREFUL: Adding var 14 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=1.000000
DEBUG CAREFUL: Skipping var 17: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 4 fractional variables

  %  Carefully choosing branching variable, nfrac = 4
DEBUG CAREFUL: Testing fvar[0] = var 12
DEBUG CAREFUL: Calling compare_branch_vars for var 12
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 12
DEBUG CAREFUL: New best var: 12
DEBUG CAREFUL: Testing fvar[1] = var 14
DEBUG CAREFUL: Calling compare_branch_vars for var 14
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 14
DEBUG CAREFUL: Testing fvar[2] = var 6
DEBUG CAREFUL: Calling compare_branch_vars for var 6
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 6
DEBUG CAREFUL: New best var: 6
DEBUG CAREFUL: Testing fvar[3] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 10
DEBUG CAREFUL: New best var: 10
  % Initial guess is x10, Z0 = 27798090.5395281        , Z1 = 28250613.6812525        

DEBUG EVAL: Testing var 12 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=7, varin=26, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=6, varin=29, theta=0.874672, up=999999999999999983222784.000000
ITER 3: row=21, varin=59, theta=2.340656, up=1.000000
ITER 4: row=21, varin=4, theta=0.444940, up=999999999999999983222784.000000
ITER 5: row=30, varin=20, theta=0.268622, up=999999999999999983222784.000000
ITER 6: row=20, varin=60, theta=1.578171, up=1.000000
ITER 7: row=20, varin=54, theta=0.353127, up=1.000000
ITER 8: row=1, varin=7, theta=0.397197, up=999999999999999983222784.000000
ITER 9: row=20, varin=60, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 12 = 0 gives z=27930676.236139
  % 	x12 = 0,	Z0 = 27930676.2361391        
DEBUG EVAL: First branch cutoff check: z=27930676.236139, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 12 = 1
ITER 1: row=7, varin=27, theta=1.000000, up=999999999999999983222784.000000
  % 	x12 = 1,	Z1 = 27967151.1018277        
DEBUG EVAL: Second branch cutoff check: z=27967151.101828, best_z=INF, threshold=INF
  %   New best:  x12, Z = 27930676.2361391        
DEBUG EVAL: Testing var 14 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=13, varin=26, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=6, varin=29, theta=0.874672, up=999999999999999983222784.000000
ITER 3: row=21, varin=59, theta=2.340656, up=1.000000
ITER 4: row=21, varin=4, theta=0.444940, up=999999999999999983222784.000000
ITER 5: row=30, varin=20, theta=0.268622, up=999999999999999983222784.000000
ITER 6: row=20, varin=60, theta=1.578171, up=1.000000
ITER 7: row=20, varin=54, theta=0.353127, up=1.000000
ITER 8: row=1, varin=60, theta=3.476373, up=1.000000
ITER 9: row=1, varin=21, theta=0.295944, up=999999999999999983222784.000000
ITER 10: row=29, varin=3, theta=0.385657, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 14 = 1 gives z=28065755.549498
  % 	x14 = 1,	Z1 = 28065755.5494978        
DEBUG EVAL: First branch cutoff check: z=28065755.549498, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 14 = 0
ITER 1: row=13, varin=27, theta=1.000000, up=999999999999999983222784.000000
  % 	x14 = 0,	Z0 = 27967151.1018277        
DEBUG EVAL: Second branch cutoff check: z=27967151.101828, best_z=INF, threshold=INF
  %   New best:  x14, Z = 27967151.1018277        
DEBUG EVAL: Testing var 6 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=29, theta=1.500000, up=999999999999999983222784.000000
ITER 2: row=21, varin=26, theta=3.000000, up=999999999999999983222784.000000
ITER 3: row=6, varin=20, theta=0.365851, up=999999999999999983222784.000000
ITER 4: row=20, varin=21, theta=0.674261, up=999999999999999983222784.000000
ITER 5: row=29, varin=18, theta=0.690100, up=999999999999999983222784.000000
ITER 6: row=18, varin=28, theta=0.599501, up=999999999999999983222784.000000
ITER 7: row=28, varin=78, theta=22.982054, up=1.000000
ITER 8: row=28, varin=3, theta=2.178416, up=999999999999999983222784.000000
ITER 9: row=21, varin=78, theta=1.863043, up=1.000000
ITER 10: row=21, varin=4, theta=0.863043, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 6 = 1 gives z=28192148.554659
  % 	x6 = 1,	Z1 = 28192148.5546589        
DEBUG EVAL: First branch cutoff check: z=28192148.554659, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 6 = 0
ITER 1: row=1, varin=18, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=18, varin=59, theta=0.500000, up=1.000000
  % 	x6 = 0,	Z0 = 27813356.3382172        
DEBUG EVAL: Second branch cutoff check: z=27813356.338217, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 10 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=6, varin=29, theta=1.532757, up=999999999999999983222784.000000
ITER 2: row=21, varin=59, theta=4.101719, up=1.000000
ITER 3: row=21, varin=4, theta=1.029406, up=999999999999999983222784.000000
ITER 4: row=30, varin=20, theta=0.621479, up=999999999999999983222784.000000
ITER 5: row=20, varin=60, theta=3.651230, up=1.000000
ITER 6: row=20, varin=54, theta=1.619278, up=1.000000
ITER 7: row=20, varin=62, theta=1.159667, up=1.000000
ITER 8: row=20, varin=56, theta=0.097781, up=1.000000
ITER 9: row=1, varin=21, theta=1.045401, up=999999999999999983222784.000000
ITER 10: row=20, varin=62, theta=1.818893, up=1.000000
DEBUG EVAL: Branch var 10 = 1 gives z=28329424.935629
  % 	x10 = 1,	Z1 = 28329424.9356293        
DEBUG EVAL: First branch cutoff check: z=28329424.935629, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 0
ITER 1: row=6, varin=26, theta=0.112822, up=999999999999999983222784.000000
  % 	x10 = 0,	Z0 = 27799300.1493656        
DEBUG EVAL: Second branch cutoff check: z=27799300.149366, best_z=INF, threshold=INF
  % Best branch is x14, Z0 = 27967151.1018277        , Z1 = 28065755.5494978        

DEBUG CAREFUL: Final result - returning best.var = 14
DEBUG BB: Branching variable chosen: j=14
 % @NC   81   49	x14 = 0	27967151.101828
 % @NC   82   49	x14 = 1	28065755.549498
 %      49    31 27798090.5395               27800175.2677   x15 D    23     5
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ad4c4bad70
% @LO 0.05  27.79809053952812902821 99.9000000000
% @LN 0.05  27.80017526770294367111 99.9000000000
% Resuming node 64 at  27.80017526770294367111
DEBUG CONSTRNT: LP rows=32, pool->nlprows=32, pool->npend=0
DEBUG CONSTRNT: Checking 32 LP rows (pool tracks 32, total LP rows 32)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=31, expected 31
 % @PAP adding 27 rows, 131 nz to LP
DEBUG BB: Processing node 64, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=11, varin=26, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=27)
DEBUG SOLUTION: LP solution array indices: FST[28-67], not_covered[68-87]
DEBUG SOLUTION: lp->best_solution[0] = 27800175.267703
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 0.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 2.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 27 rows, 60 cols, 191 nonzeros, 1 slack, 26 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 15 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=28, varin=11, theta=0.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=31)
DEBUG SOLUTION: LP solution array indices: FST[32-71], not_covered[72-91]
DEBUG SOLUTION: lp->best_solution[0] = 27800981.106502
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 0.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.500000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 31 rows, 60 cols, 206 nonzeros, 4 slack, 27 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % Node 64 LP 1 Solution, length = 27800981.106502, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.500000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.500000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.500000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.500000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.500000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.500000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.500000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.500000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.500000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.500000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=27800981.106502, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
 % @LO 0.05  27.80017526770294367111 99.9000000000
 % @LN 0.05  27.80098110650234843888 99.9000000000
DEBUG CG: Second cutoff check: z=27800981.106502, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 3 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 64 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 64
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.500000
DEBUG CAREFUL: Adding var 0 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.500000
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=1.000000
DEBUG CAREFUL: Skipping var 2: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=1.000000
DEBUG CAREFUL: Skipping var 7: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.500000
DEBUG CAREFUL: Adding var 12 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.500000
DEBUG CAREFUL: Adding var 15 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 4 fractional variables

  %  Carefully choosing branching variable, nfrac = 4
DEBUG CAREFUL: Testing fvar[0] = var 12
DEBUG CAREFUL: Calling compare_branch_vars for var 12
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 12
DEBUG CAREFUL: New best var: 12
DEBUG CAREFUL: Testing fvar[1] = var 0
DEBUG CAREFUL: Calling compare_branch_vars for var 0
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 0
DEBUG CAREFUL: Testing fvar[2] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 1
DEBUG CAREFUL: Testing fvar[3] = var 15
DEBUG CAREFUL: Calling compare_branch_vars for var 15
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 15
  % Initial guess is x12, Z0 = 27800981.1065023        , Z1 = 27800981.1065023        

DEBUG EVAL: Testing var 12 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=6, varin=34, theta=0.500000, up=1.000000
DEBUG EVAL: Branch var 12 = 0 gives z=27829912.164464
  % 	x12 = 0,	Z0 = 27829912.1644637        
DEBUG EVAL: First branch cutoff check: z=27829912.164464, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 12 = 1
ITER 1: row=6, varin=26, theta=1.000000, up=999999999999999983222784.000000
  % 	x12 = 1,	Z1 = 27801786.9453017        
DEBUG EVAL: Second branch cutoff check: z=27801786.945302, best_z=INF, threshold=INF
  %   New best:  x12, Z = 27801786.9453017        
DEBUG EVAL: Testing var 0 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=26, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 0 = 0 gives z=27801786.945302
  % 	x0 = 0,	Z0 = 27801786.9453017        
DEBUG EVAL: First branch cutoff check: z=27801786.945302, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 0 = 1
ITER 1: row=1, varin=3, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=27, varin=4, theta=1.000000, up=999999999999999983222784.000000
  % 	x0 = 1,	Z1 = 28057888.3336347        
DEBUG EVAL: Second branch cutoff check: z=28057888.333635, best_z=INF, threshold=INF
  %   New best:  x0, Z = 27801786.9453017        
DEBUG EVAL: Testing var 1 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=3, varin=21, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 1 = 0 gives z=27815040.700266
  % 	x1 = 0,	Z0 = 27815040.7002658        
DEBUG EVAL: First branch cutoff check: z=27815040.700266, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 1 = 1
ITER 1: row=3, varin=26, theta=1.000000, up=999999999999999983222784.000000
  % 	x1 = 1,	Z1 = 27801786.9453017        
DEBUG EVAL: Second branch cutoff check: z=27801786.945302, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 15 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=17, varin=26, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 15 = 0 gives z=27801786.945302
  % 	x15 = 0,	Z0 = 27801786.9453017        
DEBUG EVAL: First branch cutoff check: z=27801786.945302, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 15 = 1
ITER 1: row=17, varin=34, theta=0.500000, up=1.000000
  % 	x15 = 1,	Z1 = 27829912.1644637        
DEBUG EVAL: Second branch cutoff check: z=27829912.164464, best_z=INF, threshold=INF
  % Best branch is x0, Z0 = 27801786.9453017        , Z1 = 28057888.3336347        

DEBUG CAREFUL: Final result - returning best.var = 0
DEBUG BB: Branching variable chosen: j=0
 % @NC   83   64	x0 = 0	27801786.945302
 % @NC   84   64	x0 = 1	28057888.333635
 %      64    32 27800981.1065               27801786.9453   x14 D    34     6
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ad4c48c600
% @LO 0.05  27.80098110650234843888 99.9000000000
% @LN 0.05  27.80178694530174965394 99.9000000000
% Resuming node 83 at  27.80178694530174965394
DEBUG CONSTRNT: LP rows=27, pool->nlprows=27, pool->npend=0
DEBUG CONSTRNT: Checking 27 LP rows (pool tracks 27, total LP rows 27)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 142
DEBUG CONSTRNT: Pool row 142 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=26, expected 26
 % @PAP adding 27 rows, 121 nz to LP
DEBUG BB: Processing node 83, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=26, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=27)
DEBUG SOLUTION: LP solution array indices: FST[28-67], not_covered[68-87]
DEBUG SOLUTION: lp->best_solution[0] = 27801786.945302
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 0.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 27 rows, 60 cols, 181 nonzeros, 2 slack, 25 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 16 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=28, varin=21, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=31)
DEBUG SOLUTION: LP solution array indices: FST[32-71], not_covered[72-91]
DEBUG SOLUTION: lp->best_solution[0] = 27815040.700266
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 0.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 31 rows, 60 cols, 197 nonzeros, 3 slack, 28 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % Node 83 LP 1 Solution, length = 27815040.700266, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.500000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.500000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.500000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.500000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 2 fractional variables
DEBUG CG: LP optimal, z=27815040.700266, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 83 at  27.81504070026580777153
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ad4c4c78e0
% @LO 0.05  27.80178694530174965394 99.9000000000
% @LN 0.05  27.81279013975059655195 99.9000000000
% Resuming node 66 at  27.81279013975059655195
DEBUG CONSTRNT: LP rows=28, pool->nlprows=28, pool->npend=0
DEBUG CONSTRNT: Checking 28 LP rows (pool tracks 28, total LP rows 28)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=27, expected 27
 % @PAP adding 24 rows, 148 nz to LP
DEBUG BB: Processing node 66, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 66 LP 2 Solution, length = 27812790.139751, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.500000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.500000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.343473 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.156527 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 1.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 1.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.500000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.500000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.656527 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.843473 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=27812790.139751, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=27812790.139751, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 66 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 66
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=1.000000
DEBUG CAREFUL: Skipping var 2: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.500000
DEBUG CAREFUL: Adding var 5 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.500000
DEBUG CAREFUL: Adding var 8 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.343473
DEBUG CAREFUL: Adding var 9 to fractional list (xi=0.343473)
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.156527
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.156527)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=1.000000
DEBUG CAREFUL: Skipping var 12: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=1.000000
DEBUG CAREFUL: Skipping var 17: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 4 fractional variables

  %  Carefully choosing branching variable, nfrac = 4
DEBUG CAREFUL: Testing fvar[0] = var 8
DEBUG CAREFUL: Calling compare_branch_vars for var 8
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 8
DEBUG CAREFUL: New best var: 8
DEBUG CAREFUL: Testing fvar[1] = var 5
DEBUG CAREFUL: Calling compare_branch_vars for var 5
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 5
DEBUG CAREFUL: Testing fvar[2] = var 9
DEBUG CAREFUL: Calling compare_branch_vars for var 9
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 9
DEBUG CAREFUL: New best var: 9
DEBUG CAREFUL: Testing fvar[3] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
  % Initial guess is x9, Z0 = 27812790.1397506        , Z1 = 27846141.019627         

DEBUG EVAL: Testing var 8 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=5, varin=21, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=23, varin=20, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=12, varin=17, theta=0.148995, up=999999999999999983222784.000000
ITER 4: row=14, varin=35, theta=0.182548, up=1.000000
DEBUG EVAL: Branch var 8 = 0 gives z=27883469.360729
  % 	x8 = 0,	Z0 = 27883469.3607292        
DEBUG EVAL: First branch cutoff check: z=27883469.360729, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 8 = 1
ITER 1: row=5, varin=24, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=12, varin=28, theta=0.111390, up=1.000000
ITER 3: row=22, varin=6, theta=0.285374, up=999999999999999983222784.000000
ITER 4: row=12, varin=35, theta=0.175770, up=1.000000
  % 	x8 = 1,	Z1 = 27832665.5494742        
DEBUG EVAL: Second branch cutoff check: z=27832665.549474, best_z=INF, threshold=INF
  %   New best:  x8, Z = 27832665.5494742        
DEBUG EVAL: Testing var 5 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=24, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=22, varin=20, theta=0.193385, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 5 = 0 gives z=27826221.039639
  % 	x5 = 0,	Z0 = 27826221.0396387        
DEBUG EVAL: First branch cutoff check: z=27826221.039639, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 9 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=14, varin=6, theta=0.265837, up=999999999999999983222784.000000
ITER 2: row=12, varin=20, theta=0.699991, up=999999999999999983222784.000000
ITER 3: row=14, varin=24, theta=0.361123, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 9 = 1 gives z=27856771.965284
  % 	x9 = 1,	Z1 = 27856771.9652835        
DEBUG EVAL: First branch cutoff check: z=27856771.965284, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 9 = 0
ITER 1: row=14, varin=24, theta=0.441729, up=999999999999999983222784.000000
  % 	x9 = 0,	Z0 = 27812864.7832647        
DEBUG EVAL: Second branch cutoff check: z=27812864.783265, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 10 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=12, varin=24, theta=0.660219, up=999999999999999983222784.000000
ITER 2: row=22, varin=22, theta=0.194246, up=999999999999999983222784.000000
ITER 3: row=14, varin=20, theta=0.193385, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 1 gives z=27826221.039639
  % 	x10 = 1,	Z1 = 27826221.0396387        
DEBUG EVAL: First branch cutoff check: z=27826221.039639, best_z=INF, threshold=INF
  % Best branch is x8, Z0 = 27883469.3607292        , Z1 = 27832665.5494742        

DEBUG CAREFUL: Final result - returning best.var = 8
DEBUG BB: Branching variable chosen: j=8
 % @NC   85   66	x8 = 1	27832665.549474
 % @NC   86   66	x8 = 0	27883469.360729
 %      66    33 27812790.1398               27814170.8411   x14 D    56     9
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ad4c4a4590
% @LO 0.05  27.81279013975059655195 99.9000000000
% @LN 0.05  27.81417084108084480931 99.9000000000
% Resuming node 65 at  27.81417084108084480931
DEBUG CONSTRNT: LP rows=24, pool->nlprows=24, pool->npend=0
DEBUG CONSTRNT: Checking 24 LP rows (pool tracks 24, total LP rows 24)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 45
DEBUG CONSTRNT: Pool row 45 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 79
DEBUG CONSTRNT: Pool row 79 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=23, expected 23
 % @PAP adding 36 rows, 193 nz to LP
DEBUG BB: Processing node 65, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 65 LP 2 Solution, length = 27814170.841081, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.228216 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.228216 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.228216 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 1.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 1.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.087135 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.228216 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.228216 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.771784 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.771784 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.771784 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.771784 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=27814170.841081, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=27814170.841081, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 65 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 65
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=1.000000
DEBUG CAREFUL: Skipping var 2: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.228216
DEBUG CAREFUL: Adding var 5 to fractional list (xi=0.228216)
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.228216
DEBUG CAREFUL: Adding var 9 to fractional list (xi=0.228216)
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.228216
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.228216)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=1.000000
DEBUG CAREFUL: Skipping var 14: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=1.000000
DEBUG CAREFUL: Skipping var 17: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.087135
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.087135)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.228216
DEBUG CAREFUL: Adding var 34 to fractional list (xi=0.228216)
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.228216
DEBUG CAREFUL: Adding var 36 to fractional list (xi=0.228216)
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 6 fractional variables

  %  Carefully choosing branching variable, nfrac = 6
DEBUG CAREFUL: Testing fvar[0] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 26
DEBUG CAREFUL: New best var: 26
DEBUG CAREFUL: Testing fvar[1] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[2] = var 9
DEBUG CAREFUL: Calling compare_branch_vars for var 9
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 9
DEBUG CAREFUL: Testing fvar[3] = var 34
DEBUG CAREFUL: Calling compare_branch_vars for var 34
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 34
DEBUG CAREFUL: Testing fvar[4] = var 5
DEBUG CAREFUL: Calling compare_branch_vars for var 5
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 5
DEBUG CAREFUL: Testing fvar[5] = var 36
DEBUG CAREFUL: Calling compare_branch_vars for var 36
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 36
  % Initial guess is x26, Z0 = 27814170.8410808        , Z1 = 27911220.381184         

DEBUG EVAL: Testing var 26 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=16, varin=27, theta=0.685986, up=999999999999999983222784.000000
ITER 2: row=27, varin=36, theta=1.459211, up=999999999999999983222784.000000
ITER 3: row=23, varin=34, theta=1.172608, up=999999999999999983222784.000000
ITER 4: row=34, varin=28, theta=0.348110, up=999999999999999983222784.000000
ITER 5: row=28, varin=25, theta=0.341066, up=999999999999999983222784.000000
ITER 6: row=25, varin=24, theta=0.726272, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 26 = 1 gives z=27911220.381184
  % 	x26 = 1,	Z1 = 27911220.381184         
DEBUG EVAL: First branch cutoff check: z=27911220.381184, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 26 = 0
ITER 1: row=16, varin=64, theta=0.089964, up=1.000000
  % 	x26 = 0,	Z0 = 27815986.0035887        
DEBUG EVAL: Second branch cutoff check: z=27815986.003589, best_z=INF, threshold=INF
  %   New best:  x26, Z = 27815986.0035887        
DEBUG EVAL: Testing var 10 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=13, varin=13, theta=0.278679, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 0 gives z=27837907.087697
  % 	x10 = 0,	Z0 = 27837907.087697         
DEBUG EVAL: First branch cutoff check: z=27837907.087697, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 1
ITER 1: row=13, varin=27, theta=1.849395, up=999999999999999983222784.000000
ITER 2: row=27, varin=36, theta=8.245283, up=999999999999999983222784.000000
ITER 3: row=23, varin=34, theta=6.308100, up=999999999999999983222784.000000
ITER 4: row=34, varin=23, theta=1.002702, up=999999999999999983222784.000000
ITER 5: row=16, varin=39, theta=0.009931, up=1.000000
  % 	x10 = 1,	Z1 = 27973321.4975168        
DEBUG EVAL: Second branch cutoff check: z=27973321.497517, best_z=INF, threshold=INF
  %   New best:  x10, Z = 27837907.087697         
DEBUG EVAL: Testing var 9 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=5, varin=64, theta=29.035991, up=1.000000
ITER 2: row=5, varin=24, theta=0.427592, up=999999999999999983222784.000000
ITER 3: row=16, varin=64, theta=0.882091, up=1.000000
DEBUG EVAL: Branch var 9 = 0 gives z=27863690.436144
  % 	x9 = 0,	Z0 = 27863690.4361441        
DEBUG EVAL: First branch cutoff check: z=27863690.436144, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 9 = 1
ITER 1: row=5, varin=27, theta=1.849395, up=999999999999999983222784.000000
ITER 2: row=27, varin=36, theta=8.245283, up=999999999999999983222784.000000
ITER 3: row=23, varin=34, theta=6.308100, up=999999999999999983222784.000000
ITER 4: row=34, varin=39, theta=3.684722, up=1.000000
ITER 5: row=34, varin=17, theta=1.565776, up=999999999999999983222784.000000
ITER 6: row=23, varin=13, theta=0.829719, up=999999999999999983222784.000000
  % 	x9 = 1,	Z1 = 28059347.0576496        
DEBUG EVAL: Second branch cutoff check: z=28059347.057650, best_z=INF, threshold=INF
  %   New best:  x9, Z = 27863690.4361441        
DEBUG EVAL: Testing var 34 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=23, varin=27, theta=1.849395, up=999999999999999983222784.000000
ITER 2: row=27, varin=34, theta=7.178749, up=999999999999999983222784.000000
ITER 3: row=34, varin=24, theta=1.370605, up=999999999999999983222784.000000
ITER 4: row=13, varin=39, theta=1.159752, up=1.000000
ITER 5: row=13, varin=17, theta=0.093170, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 34 = 1 gives z=27984792.671728
  % 	x34 = 1,	Z1 = 27984792.6717278        
DEBUG EVAL: First branch cutoff check: z=27984792.671728, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 34 = 0
ITER 1: row=23, varin=36, theta=0.251784, up=999999999999999983222784.000000
  % 	x34 = 0,	Z0 = 27816870.0592518        
DEBUG EVAL: Second branch cutoff check: z=27816870.059252, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 5 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=64, theta=29.035991, up=1.000000
ITER 2: row=1, varin=17, theta=0.351481, up=999999999999999983222784.000000
ITER 3: row=16, varin=64, theta=0.721040, up=1.000000
DEBUG EVAL: Branch var 5 = 0 gives z=27865350.673531
  % 	x5 = 0,	Z0 = 27865350.6735306        
DEBUG EVAL: First branch cutoff check: z=27865350.673531, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 5 = 1
ITER 1: row=1, varin=27, theta=1.849395, up=999999999999999983222784.000000
ITER 2: row=27, varin=36, theta=8.245283, up=999999999999999983222784.000000
ITER 3: row=23, varin=34, theta=6.308100, up=999999999999999983222784.000000
ITER 4: row=34, varin=24, theta=1.177473, up=999999999999999983222784.000000
ITER 5: row=16, varin=39, theta=0.555374, up=1.000000
  % 	x5 = 1,	Z1 = 27968588.8868633        
DEBUG EVAL: Second branch cutoff check: z=27968588.886863, best_z=INF, threshold=INF
  %   New best:  x5, Z = 27865350.6735306        
DEBUG EVAL: Testing var 36 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=34, varin=27, theta=1.849395, up=999999999999999983222784.000000
ITER 2: row=27, varin=36, theta=8.245283, up=999999999999999983222784.000000
ITER 3: row=23, varin=24, theta=1.399298, up=999999999999999983222784.000000
ITER 4: row=13, varin=39, theta=1.249543, up=1.000000
ITER 5: row=13, varin=16, theta=0.145538, up=999999999999999983222784.000000
ITER 6: row=35, varin=23, theta=0.151618, up=999999999999999983222784.000000
ITER 7: row=5, varin=28, theta=0.269697, up=999999999999999983222784.000000
ITER 8: row=28, varin=25, theta=0.297841, up=999999999999999983222784.000000
ITER 9: row=25, varin=17, theta=0.178203, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 36 = 1 gives z=28032344.751309
  % 	x36 = 1,	Z1 = 28032344.7513089        
DEBUG EVAL: First branch cutoff check: z=28032344.751309, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 36 = 0
ITER 1: row=34, varin=34, theta=0.255707, up=999999999999999983222784.000000
  % 	x36 = 0,	Z0 = 27818268.0142693        
DEBUG EVAL: Second branch cutoff check: z=27818268.014269, best_z=INF, threshold=INF
  % Best branch is x5, Z0 = 27865350.6735306        , Z1 = 27968588.8868633        

DEBUG CAREFUL: Final result - returning best.var = 5
DEBUG BB: Branching variable chosen: j=5
 % @NC   87   65	x5 = 0	27865350.673531
 % @NC   88   65	x5 = 1	27968588.886863
 %      65    34 27814170.8411               27815040.7003   x14 U    56     9
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ad4c48c600
% @LO 0.05  27.81417084108084480931 99.9000000000
% @LN 0.05  27.81504070026580777153 99.9000000000
% Resuming node 83 at  27.81504070026580777153
DEBUG CONSTRNT: LP rows=36, pool->nlprows=36, pool->npend=0
DEBUG CONSTRNT: Checking 36 LP rows (pool tracks 36, total LP rows 36)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=35, expected 35
 % @PAP adding 28 rows, 122 nz to LP
DEBUG BB: Processing node 83, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 83 LP 2 Solution, length = 27815040.700266, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.500000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.500000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.500000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.500000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 2 fractional variables
DEBUG CG: LP optimal, z=27815040.700266, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=27815040.700266, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 83 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 83
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=1.000000
DEBUG CAREFUL: Skipping var 2: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=1.000000
DEBUG CAREFUL: Skipping var 7: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.500000
DEBUG CAREFUL: Adding var 12 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.500000
DEBUG CAREFUL: Adding var 15 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 2 fractional variables

  %  Carefully choosing branching variable, nfrac = 2
DEBUG CAREFUL: Testing fvar[0] = var 12
DEBUG CAREFUL: Calling compare_branch_vars for var 12
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 12
DEBUG CAREFUL: New best var: 12
DEBUG CAREFUL: Testing fvar[1] = var 15
DEBUG CAREFUL: Calling compare_branch_vars for var 15
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 15
  % Initial guess is x12, Z0 = 27829912.1644637        , Z1 = 27815040.7002658        

DEBUG EVAL: Testing var 12 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=3, varin=22, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=28, varin=24, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=1, varin=35, theta=0.500000, up=1.000000
DEBUG EVAL: Branch var 12 = 1 gives z=28101684.824159
  % 	x12 = 1,	Z1 = 28101684.8241589        
DEBUG EVAL: First branch cutoff check: z=28101684.824159, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 12 = 0
ITER 1: row=3, varin=27, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=1, varin=35, theta=0.500000, up=1.000000
  % 	x12 = 0,	Z0 = 27843971.7582272        
DEBUG EVAL: Second branch cutoff check: z=27843971.758227, best_z=INF, threshold=INF
  %   New best:  x12, Z = 27843971.7582272        
DEBUG EVAL: Testing var 15 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=6, varin=27, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=1, varin=35, theta=0.500000, up=1.000000
DEBUG EVAL: Branch var 15 = 1 gives z=27843971.758227
  % 	x15 = 1,	Z1 = 27843971.7582272        
DEBUG EVAL: First branch cutoff check: z=27843971.758227, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 15 = 0
ITER 1: row=6, varin=22, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=28, varin=24, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=1, varin=35, theta=0.500000, up=1.000000
  % 	x15 = 0,	Z0 = 28101684.8241589        
DEBUG EVAL: Second branch cutoff check: z=28101684.824159, best_z=INF, threshold=INF
  % Best branch is x12, Z0 = 27843971.7582272        , Z1 = 28101684.8241589        

DEBUG CAREFUL: Final result - returning best.var = 12
DEBUG BB: Branching variable chosen: j=12
 % @NC   89   83	x12 = 0	27843971.758227
 % @NC   90   83	x12 = 1	28101684.824159
 %      83    35 27815040.7003               27817239.8664    x0 D    64     7
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ad4c4b74e0
% @LO 0.05  27.81504070026580777153 99.9000000000
% @LN 0.05  27.81723986637267742594 99.9000000000
% Resuming node 32 at  27.81723986637267742594
DEBUG CONSTRNT: LP rows=28, pool->nlprows=28, pool->npend=0
DEBUG CONSTRNT: Checking 28 LP rows (pool tracks 28, total LP rows 28)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=27, expected 27
 % @PAP adding 47 rows, 228 nz to LP
DEBUG BB: Processing node 32, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=18, varin=104, theta=0.683974, up=1.000000
ITER 2: row=30, varin=78, theta=1.107573, up=1.000000
ITER 3: row=30, varin=81, theta=0.129462, up=1.000000
ITER 4: row=27, varin=18, theta=0.349851, up=999999999999999983222784.000000
ITER 5: row=30, varin=78, theta=0.374874, up=1.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 27817239.866373
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 0.843718
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 47 rows, 60 cols, 288 nonzeros, 4 slack, 43 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=50, varin=85, theta=0.779418, up=1.000000
ITER 2: row=22, varin=79, theta=0.498169, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 27856680.385821
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 51 rows, 60 cols, 296 nonzeros, 1 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 2 rows, 18 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=51, varin=30, theta=0.001316, up=999999999999999983222784.000000
ITER 2: row=48, varin=49, theta=0.000728, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 27856903.039111
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 0.998544
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 52 rows, 60 cols, 312 nonzeros, 5 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % @PAP adding 3 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=48, varin=89, theta=0.004849, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 27857005.424347
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 0.000000
DEBUG SOLUTION: lp->best_solution[8] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 50 rows, 60 cols, 304 nonzeros, 0 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 5 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=51, varin=76, theta=0.001718, up=1.000000
ITER 2: row=45, varin=27, theta=0.008830, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 27857238.461834
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 0.000000
DEBUG SOLUTION: lp->best_solution[8] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 51 rows, 60 cols, 309 nonzeros, 2 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 2 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=50, varin=89, theta=0.004868, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 27857305.628087
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 0.000000
DEBUG SOLUTION: lp->best_solution[8] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 51 rows, 60 cols, 310 nonzeros, 0 slack, 51 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 32 LP 1 Solution, length = 27857305.628087, 0.01 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.504868 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.500000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 1.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.495132 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.495132 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.500000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.004868 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.500000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.495132 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=27857305.628087, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 32 at  27.85730562808717536427
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ad4c4a44d0
% @LO 0.06  27.81723986637267742594 99.9000000000
% @LN 0.06  27.82171671436230298013 99.9000000000
% Resuming node 28 at  27.82171671436230298013
DEBUG CONSTRNT: LP rows=51, pool->nlprows=51, pool->npend=0
DEBUG CONSTRNT: Checking 51 LP rows (pool tracks 51, total LP rows 51)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 133
DEBUG CONSTRNT: Pool row 133 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 134
DEBUG CONSTRNT: Pool row 134 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 159
DEBUG CONSTRNT: Pool row 159 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=50, expected 50
 % @PAP adding 32 rows, 182 nz to LP
DEBUG BB: Processing node 28, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=21, varin=30, theta=4.416637, up=999999999999999983222784.000000
ITER 2: row=3, varin=32, theta=2.625237, up=999999999999999983222784.000000
ITER 3: row=1, varin=23, theta=2.770060, up=999999999999999983222784.000000
ITER 4: row=10, varin=27, theta=1.891042, up=999999999999999983222784.000000
ITER 5: row=19, varin=29, theta=1.172984, up=999999999999999983222784.000000
ITER 6: row=25, varin=35, theta=1.321845, up=1.000000
ITER 7: row=25, varin=18, theta=0.142044, up=999999999999999983222784.000000
ITER 8: row=18, varin=45, theta=0.303048, up=1.000000
ITER 9: row=12, varin=24, theta=0.078583, up=999999999999999983222784.000000
ITER 10: row=24, varin=11, theta=0.090760, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=11)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=32)
DEBUG SOLUTION: LP solution array indices: FST[33-72], not_covered[73-92]
DEBUG SOLUTION: lp->best_solution[0] = 27821716.714362
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.818051
DEBUG SOLUTION: lp->best_solution[12] = 0.818051
DEBUG SOLUTION: lp->best_solution[13] = 0.818051
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 32 rows, 60 cols, 242 nonzeros, 7 slack, 25 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 20 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=33, varin=14, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=35, varin=19, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=11, varin=50, theta=0.238564, up=1.000000
ITER 4: row=24, varin=52, theta=0.613332, up=1.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=36)
DEBUG SOLUTION: LP solution array indices: FST[37-76], not_covered[77-96]
DEBUG SOLUTION: lp->best_solution[0] = 27971668.826712
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 36 rows, 60 cols, 262 nonzeros, 8 slack, 28 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 8 slack rows
  % @PAP adding 3 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=29, varin=34, theta=0.301331, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=31)
DEBUG SOLUTION: LP solution array indices: FST[32-71], not_covered[72-91]
DEBUG SOLUTION: lp->best_solution[0] = 28001926.624797
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 31 rows, 60 cols, 229 nonzeros, 0 slack, 31 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=32, varin=48, theta=0.108882, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=33)
DEBUG SOLUTION: LP solution array indices: FST[34-73], not_covered[74-93]
DEBUG SOLUTION: lp->best_solution[0] = 28004677.270080
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.891118
DEBUG SOLUTION: lp->best_solution[13] = 0.891118
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 33 rows, 60 cols, 233 nonzeros, 2 slack, 31 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % Node 28 LP 1 Solution, length = 28004677.270080, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.188157 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.297039 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.108882 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.297039 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 1.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.297039 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.702961 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.702961 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.811843 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.702961 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.702961 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28004677.270080, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 28 at  28.00467727007990248467
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ad4c4b0620
% @LO 0.06  27.82171671436230298013 99.9000000000
% @LN 0.06  27.82341051762582040396 99.9000000000
% Resuming node 72 at  27.82341051762582040396
DEBUG CONSTRNT: LP rows=31, pool->nlprows=31, pool->npend=0
DEBUG CONSTRNT: Checking 31 LP rows (pool tracks 31, total LP rows 31)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=30, expected 30
 % @PAP adding 32 rows, 180 nz to LP
DEBUG BB: Processing node 72, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=23, theta=0.294875, up=999999999999999983222784.000000
ITER 2: row=21, varin=30, theta=0.230511, up=999999999999999983222784.000000
ITER 3: row=30, varin=15, theta=0.566935, up=999999999999999983222784.000000
ITER 4: row=15, varin=24, theta=0.142779, up=999999999999999983222784.000000
ITER 5: row=24, varin=21, theta=0.237690, up=999999999999999983222784.000000
ITER 6: row=23, varin=35, theta=0.391861, up=1.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=32)
DEBUG SOLUTION: LP solution array indices: FST[33-72], not_covered[73-92]
DEBUG SOLUTION: lp->best_solution[0] = 27823410.517626
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 32 rows, 60 cols, 240 nonzeros, 2 slack, 30 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=33, varin=18, theta=1.225664, up=999999999999999983222784.000000
ITER 2: row=18, varin=55, theta=0.129729, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=33)
DEBUG SOLUTION: LP solution array indices: FST[34-73], not_covered[74-93]
DEBUG SOLUTION: lp->best_solution[0] = 27920713.969792
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 33 rows, 60 cols, 242 nonzeros, 3 slack, 30 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 4 rows, 16 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=31, varin=61, theta=0.154666, up=1.000000
ITER 2: row=20, varin=62, theta=0.167028, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=34)
DEBUG SOLUTION: LP solution array indices: FST[35-74], not_covered[75-94]
DEBUG SOLUTION: lp->best_solution[0] = 27928534.037099
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 34 rows, 60 cols, 252 nonzeros, 0 slack, 34 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 72 LP 1 Solution, length = 27928534.037099, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.832972 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 1.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 1.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.167028 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.167028 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 2 fractional variables
DEBUG CG: LP optimal, z=27928534.037099, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 72 at  27.92853403709865389715
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ad4c4bad70
% @LO 0.06  27.82341051762582040396 99.9000000000
% @LN 0.06  27.83266554947421411725 99.9000000000
% Resuming node 85 at  27.83266554947421411725
DEBUG CONSTRNT: LP rows=34, pool->nlprows=34, pool->npend=0
DEBUG CONSTRNT: Checking 34 LP rows (pool tracks 34, total LP rows 34)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 141
DEBUG CONSTRNT: Pool row 141 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 145
DEBUG CONSTRNT: Pool row 145 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 159
DEBUG CONSTRNT: Pool row 159 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 63
DEBUG CONSTRNT: Pool row 63 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 121
DEBUG CONSTRNT: Pool row 121 has lprow=33, expected 33
 % @PAP adding 24 rows, 148 nz to LP
DEBUG BB: Processing node 85, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=5, varin=24, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=12, varin=28, theta=0.111390, up=1.000000
ITER 3: row=22, varin=6, theta=0.285374, up=999999999999999983222784.000000
ITER 4: row=12, varin=35, theta=0.175770, up=1.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=24)
DEBUG SOLUTION: LP solution array indices: FST[25-64], not_covered[65-84]
DEBUG SOLUTION: lp->best_solution[0] = 27832665.549474
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.824230
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 24 rows, 60 cols, 208 nonzeros, 3 slack, 21 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 3 rows, 10 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=26, varin=31, theta=0.669095, up=1.000000
ITER 2: row=18, varin=80, theta=0.177571, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=27)
DEBUG SOLUTION: LP solution array indices: FST[28-67], not_covered[68-87]
DEBUG SOLUTION: lp->best_solution[0] = 27842893.571161
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 27 rows, 60 cols, 218 nonzeros, 3 slack, 24 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 5 rows, 32 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=25, varin=87, theta=0.314545, up=1.000000
ITER 2: row=28, varin=30, theta=0.645637, up=1.000000
ITER 3: row=6, varin=22, theta=0.244823, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=29)
DEBUG SOLUTION: LP solution array indices: FST[30-69], not_covered[70-89]
DEBUG SOLUTION: lp->best_solution[0] = 27886983.219784
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 29 rows, 60 cols, 240 nonzeros, 1 slack, 28 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 6 rows, 21 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=29, varin=53, theta=0.333333, up=1.000000
ITER 2: row=26, varin=71, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=34)
DEBUG SOLUTION: LP solution array indices: FST[35-74], not_covered[75-94]
DEBUG SOLUTION: lp->best_solution[0] = 27923751.512936
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 34 rows, 60 cols, 259 nonzeros, 0 slack, 34 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=35, varin=6, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=22, varin=78, theta=1.000000, up=1.000000
ITER 3: row=31, varin=43, theta=0.500000, up=1.000000
ITER 4: row=28, varin=24, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=24, varin=63, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=36)
DEBUG SOLUTION: LP solution array indices: FST[37-76], not_covered[77-96]
DEBUG SOLUTION: lp->best_solution[0] = 28014072.263600
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 36 rows, 60 cols, 267 nonzeros, 0 slack, 36 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 3 rows, 7 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=39, varin=67, theta=0.538268, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=39)
DEBUG SOLUTION: LP solution array indices: FST[40-79], not_covered[80-99]
DEBUG SOLUTION: lp->best_solution[0] = 28022008.940970
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 39 rows, 60 cols, 274 nonzeros, 2 slack, 37 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=38, varin=68, theta=0.525928, up=1.000000
ITER 2: row=34, varin=43, theta=0.170114, up=1.000000
ITER 3: row=25, varin=60, theta=0.610965, up=1.000000
LP PHASE: Switching to primal (iter=3)
ITER 4: row=5, varin=5, theta=212050.000000, up=999999999999999983222784.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=38)
DEBUG SOLUTION: LP solution array indices: FST[39-78], not_covered[79-98]
DEBUG SOLUTION: lp->best_solution[0] = 28041951.849998
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1587950.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 38 rows, 60 cols, 271 nonzeros, 1 slack, 37 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 2 rows, 5 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=38, varin=61, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=39)
DEBUG SOLUTION: LP solution array indices: FST[40-79], not_covered[80-99]
DEBUG SOLUTION: lp->best_solution[0] = 28049489.090279
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 39 rows, 60 cols, 236 nonzeros, 0 slack, 39 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=40, varin=86, theta=0.125000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=40)
DEBUG SOLUTION: LP solution array indices: FST[41-80], not_covered[81-100]
DEBUG SOLUTION: lp->best_solution[0] = 28054545.564015
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.875000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 40 rows, 60 cols, 240 nonzeros, 2 slack, 38 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 4 rows, 47 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=42, varin=23, theta=0.006222, up=999999999999999983222784.000000
ITER 2: row=40, varin=68, theta=0.402586, up=1.000000
ITER 3: row=4, varin=66, theta=0.381868, up=1.000000
ITER 4: row=33, varin=65, theta=0.368291, up=1.000000
ITER 5: row=22, varin=75, theta=0.691647, up=1.000000
ITER 6: row=30, varin=45, theta=0.204860, up=1.000000
ITER 7: row=42, varin=67, theta=0.601725, up=1.000000
ITER 8: row=28, varin=12, theta=0.123652, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=8)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 28079302.761270
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.876348
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 42 rows, 60 cols, 283 nonzeros, 1 slack, 41 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 4 rows, 9 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=44, varin=90, theta=0.076736, up=1.000000
ITER 2: row=45, varin=15, theta=0.437441, up=999999999999999983222784.000000
ITER 3: row=1, varin=44, theta=0.148073, up=999999999999999983222784.000000
ITER 4: row=10, varin=27, theta=0.131694, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 28095312.170702
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 0.934153
DEBUG SOLUTION: lp->best_solution[3] = 0.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 45 rows, 60 cols, 290 nonzeros, 4 slack, 41 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % @PAP adding 2 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=42, varin=37, theta=61472.750000, up=999999999999999983222784.000000
ITER 2: row=43, varin=46, theta=-0.374883, up=1.000000
ITER 3: row=43, varin=67, theta=1.190577, up=1.000000
ITER 4: row=43, varin=25, theta=0.013792, up=999999999999999983222784.000000
ITER 5: row=40, varin=67, theta=1.000000, up=1.000000
ITER 6: row=25, varin=27, theta=0.263177, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=6)
ITER 7: row=28, varin=40, theta=0.000000, up=999999999999999983222784.000000
ITER 8: row=25, varin=42, theta=0.000000, up=999999999999999983222784.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 28100529.309509
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 0.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 43 rows, 60 cols, 284 nonzeros, 1 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 85 LP 1 Solution, length = 28100529.309509, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 1.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.500000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.750000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 1.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.250000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.250000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.500000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.500000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.500000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.250000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.250000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28100529.309509, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 85 at  28.10052930950887528638
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ad4c4a4590
% @LO 0.06  27.83266554947421411725 99.9000000000
% @LN 0.06  27.84397175822718750737 99.9000000000
% Resuming node 89 at  27.84397175822718750737
DEBUG CONSTRNT: LP rows=42, pool->nlprows=42, pool->npend=0
DEBUG CONSTRNT: Checking 42 LP rows (pool tracks 42, total LP rows 42)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 45
DEBUG CONSTRNT: Pool row 45 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 79
DEBUG CONSTRNT: Pool row 79 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 62
DEBUG CONSTRNT: Pool row 62 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 158
DEBUG CONSTRNT: Pool row 158 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 133
DEBUG CONSTRNT: Pool row 133 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=41, expected 41
 % @PAP adding 28 rows, 122 nz to LP
DEBUG BB: Processing node 89, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=3, varin=27, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=1, varin=35, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=28)
DEBUG SOLUTION: LP solution array indices: FST[29-68], not_covered[69-88]
DEBUG SOLUTION: lp->best_solution[0] = 27843971.758227
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 0.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 28 rows, 60 cols, 182 nonzeros, 2 slack, 26 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 28 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=29, varin=59, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=32)
DEBUG SOLUTION: LP solution array indices: FST[33-72], not_covered[73-92]
DEBUG SOLUTION: lp->best_solution[0] = 27885887.180404
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 0.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 32 rows, 60 cols, 210 nonzeros, 2 slack, 30 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 4 rows, 17 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=31, varin=62, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=34)
DEBUG SOLUTION: LP solution array indices: FST[35-74], not_covered[75-94]
DEBUG SOLUTION: lp->best_solution[0] = 27898918.763629
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 0.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 34 rows, 60 cols, 223 nonzeros, 0 slack, 34 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=35, varin=65, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=35)
DEBUG SOLUTION: LP solution array indices: FST[36-75], not_covered[76-95]
DEBUG SOLUTION: lp->best_solution[0] = 27906161.924753
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 0.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 35 rows, 60 cols, 225 nonzeros, 0 slack, 35 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 13 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=36, varin=51, theta=0.500000, up=1.000000
ITER 2: row=34, varin=50, theta=0.071429, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=39)
DEBUG SOLUTION: LP solution array indices: FST[40-79], not_covered[80-99]
DEBUG SOLUTION: lp->best_solution[0] = 27921550.290418
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 0.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 39 rows, 60 cols, 238 nonzeros, 0 slack, 39 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 3 rows, 12 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=40, varin=47, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 27928413.631057
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 0.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 42 rows, 60 cols, 250 nonzeros, 1 slack, 41 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 3 rows, 11 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=42, varin=48, theta=0.250000, up=1.000000
ITER 2: row=44, varin=66, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 27951043.416643
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 0.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 44 rows, 60 cols, 259 nonzeros, 0 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=45, varin=42, theta=0.357143, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 27958334.291892
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 0.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 45 rows, 60 cols, 263 nonzeros, 4 slack, 41 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=42, varin=75, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 27964253.824791
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 0.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 42 rows, 60 cols, 246 nonzeros, 0 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 7 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=43, varin=33, theta=1.250000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 27972585.431561
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 0.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 44 rows, 60 cols, 253 nonzeros, 1 slack, 43 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 89 LP 1 Solution, length = 27972585.431561, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.250000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.250000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.250000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.250000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 1.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.250000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.750000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.750000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.750000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.750000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.750000 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=27972585.431561, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 89 at  27.97258543156093324455
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ad4c4b6b40
% @LO 0.06  27.84397175822718750737 99.9000000000
% @LN 0.06  27.85370871406938064752 99.9000000000
% Resuming node 77 at  27.85370871406938064752
DEBUG CONSTRNT: LP rows=43, pool->nlprows=43, pool->npend=0
DEBUG CONSTRNT: Checking 43 LP rows (pool tracks 43, total LP rows 43)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 133
DEBUG CONSTRNT: Pool row 133 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=42, expected 42
 % @PAP adding 41 rows, 167 nz to LP
DEBUG BB: Processing node 77, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=20, varin=37, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=41)
DEBUG SOLUTION: LP solution array indices: FST[42-81], not_covered[82-101]
DEBUG SOLUTION: lp->best_solution[0] = 27853708.714069
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 41 rows, 60 cols, 227 nonzeros, 1 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 43 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=43, varin=72, theta=0.020997, up=1.000000
ITER 2: row=42, varin=43, theta=244211.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 27863291.355909
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 43 rows, 60 cols, 270 nonzeros, 2 slack, 41 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 1 rows, 5 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=42, varin=74, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 27873775.080475
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 42 rows, 60 cols, 231 nonzeros, 0 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=43, varin=100, theta=0.500000, up=1.000000
ITER 2: row=40, varin=83, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 27889652.201464
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 43 rows, 60 cols, 233 nonzeros, 0 slack, 43 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 9 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=44, varin=84, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 27913674.825360
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 45 rows, 60 cols, 242 nonzeros, 0 slack, 45 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 22 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=46, varin=35, theta=0.250000, up=999999999999999983222784.000000
ITER 2: row=48, varin=46, theta=0.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 27931422.979744
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 49 rows, 60 cols, 264 nonzeros, 5 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % @PAP adding 1 rows, 40 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=45, varin=83, theta=0.153385, up=1.000000
ITER 2: row=44, varin=30, theta=0.075842, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 27936195.776743
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 45 rows, 60 cols, 283 nonzeros, 1 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 77 LP 1 Solution, length = 27936195.776743, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.500000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.924158 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.424158 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.500000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.075842 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.500000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.424158 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.575842 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.500000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.500000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.075842 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.500000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.075842 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.575842 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 7 fractional variables
DEBUG CG: LP optimal, z=27936195.776743, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 77 at  27.93619577674266807321
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ad4c4b74e0
% @LO 0.06  27.85370871406938064752 99.9000000000
% @LN 0.06  27.85730562808717536427 99.9000000000
% Resuming node 32 at  27.85730562808717536427
DEBUG CONSTRNT: LP rows=44, pool->nlprows=44, pool->npend=0
DEBUG CONSTRNT: Checking 44 LP rows (pool tracks 44, total LP rows 44)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 142
DEBUG CONSTRNT: Pool row 142 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 134
DEBUG CONSTRNT: Pool row 134 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 20
DEBUG CONSTRNT: Pool row 20 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 130
DEBUG CONSTRNT: Pool row 130 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=43, expected 43
 % @PAP adding 51 rows, 250 nz to LP
DEBUG BB: Processing node 32, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 32 LP 2 Solution, length = 27857305.628087, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.504868 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.500000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 1.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.495132 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.495132 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.500000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.004868 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.500000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.495132 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=27857305.628087, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=27857305.628087, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 32 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 32
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.504868
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.504868)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.500000
DEBUG CAREFUL: Adding var 9 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=1.000000
DEBUG CAREFUL: Skipping var 17: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.495132
DEBUG CAREFUL: Adding var 27 to fractional list (xi=0.495132)
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.495132
DEBUG CAREFUL: Adding var 31 to fractional list (xi=0.495132)
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.500000
DEBUG CAREFUL: Adding var 34 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.004868
DEBUG CAREFUL: Adding var 37 to fractional list (xi=0.004868)
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 6 fractional variables

  %  Carefully choosing branching variable, nfrac = 6
DEBUG CAREFUL: Testing fvar[0] = var 9
DEBUG CAREFUL: Calling compare_branch_vars for var 9
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 9
DEBUG CAREFUL: New best var: 9
DEBUG CAREFUL: Testing fvar[1] = var 34
DEBUG CAREFUL: Calling compare_branch_vars for var 34
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 34
DEBUG CAREFUL: Testing fvar[2] = var 37
DEBUG CAREFUL: Calling compare_branch_vars for var 37
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 37
DEBUG CAREFUL: New best var: 37
DEBUG CAREFUL: Testing fvar[3] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[4] = var 27
DEBUG CAREFUL: Calling compare_branch_vars for var 27
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 27
DEBUG CAREFUL: Testing fvar[5] = var 31
DEBUG CAREFUL: Calling compare_branch_vars for var 31
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 31
DEBUG CAREFUL: New best var: 31
  % Initial guess is x31, Z0 = 27857305.6280872        , Z1 = 28166647.1851951        

DEBUG EVAL: Testing var 9 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=14, varin=45, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=42, varin=18, theta=0.075479, up=999999999999999983222784.000000
ITER 3: row=25, varin=89, theta=0.703522, up=1.000000
DEBUG EVAL: Branch var 9 = 0 gives z=28047205.688546
  % 	x9 = 0,	Z0 = 28047205.6885458        
DEBUG EVAL: First branch cutoff check: z=28047205.688546, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 9 = 1
ITER 1: row=14, varin=29, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=8, varin=44, theta=0.325737, up=999999999999999983222784.000000
ITER 3: row=51, varin=50, theta=1.057922, up=999999999999999983222784.000000
ITER 4: row=26, varin=47, theta=2.141970, up=999999999999999983222784.000000
ITER 5: row=37, varin=23, theta=8.831897, up=999999999999999983222784.000000
  % 	x9 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: Second branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=14, varin=45, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=42, varin=18, theta=0.075479, up=999999999999999983222784.000000
ITER 3: row=25, varin=89, theta=0.703522, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 28047205.688546
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 0.000000
DEBUG SOLUTION: lp->best_solution[8] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 51 rows, 60 cols, 310 nonzeros, 5 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 5 slack rows
   % @PAP adding 4 rows, 19 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=49, varin=78, theta=0.095425, up=1.000000
ITER 2: row=47, varin=25, theta=0.423383, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28057412.548583
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 0.000000
DEBUG SOLUTION: lp->best_solution[8] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 50 rows, 60 cols, 297 nonzeros, 1 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 32 at  28.05741254858318001197
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ad4c4c78e0
% @LO 0.06  27.85730562808717536427 99.9000000000
% @LN 0.06  27.86535067353057470996 99.9000000000
% Resuming node 87 at  27.86535067353057470996
DEBUG CONSTRNT: LP rows=49, pool->nlprows=49, pool->npend=0
DEBUG CONSTRNT: Checking 49 LP rows (pool tracks 49, total LP rows 49)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 133
DEBUG CONSTRNT: Pool row 133 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 134
DEBUG CONSTRNT: Pool row 134 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 159
DEBUG CONSTRNT: Pool row 159 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 85
DEBUG CONSTRNT: Pool row 85 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 90
DEBUG CONSTRNT: Pool row 90 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 91
DEBUG CONSTRNT: Pool row 91 has lprow=48, expected 48
 % @PAP adding 36 rows, 193 nz to LP
DEBUG BB: Processing node 87, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=64, theta=29.035991, up=1.000000
ITER 2: row=1, varin=17, theta=0.351481, up=999999999999999983222784.000000
ITER 3: row=16, varin=64, theta=0.721040, up=1.000000
LP PHASE: Switching to primal (iter=3)
ITER 4: row=13, varin=63, theta=0.271965, up=1.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=36)
DEBUG SOLUTION: LP solution array indices: FST[37-76], not_covered[77-96]
DEBUG SOLUTION: lp->best_solution[0] = 27860164.089378
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 36 rows, 60 cols, 253 nonzeros, 2 slack, 34 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 87 LP 1 Solution, length = 27860164.089378, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.364017 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.364017 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 1.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 1.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.271965 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.364017 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.635983 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.635983 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.635983 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=27860164.089378, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=27860164.089378, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 87 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 87
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=1.000000
DEBUG CAREFUL: Skipping var 2: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.364017
DEBUG CAREFUL: Adding var 9 to fractional list (xi=0.364017)
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.364017
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.364017)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=1.000000
DEBUG CAREFUL: Skipping var 14: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=1.000000
DEBUG CAREFUL: Skipping var 17: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.271965
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.271965)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.364017
DEBUG CAREFUL: Adding var 34 to fractional list (xi=0.364017)
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 4 fractional variables

  %  Carefully choosing branching variable, nfrac = 4
DEBUG CAREFUL: Testing fvar[0] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 26
DEBUG CAREFUL: New best var: 26
DEBUG CAREFUL: Testing fvar[1] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 10
DEBUG CAREFUL: New best var: 10
DEBUG CAREFUL: Testing fvar[2] = var 9
DEBUG CAREFUL: Calling compare_branch_vars for var 9
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 9
DEBUG CAREFUL: New best var: 9
DEBUG CAREFUL: Testing fvar[3] = var 34
DEBUG CAREFUL: Calling compare_branch_vars for var 34
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 34
  % Initial guess is x9, Z0 = 27863690.4361441        , Z1 = 28059347.0576496        

DEBUG EVAL: Testing var 26 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=13, varin=36, theta=1.037980, up=999999999999999983222784.000000
ITER 2: row=23, varin=27, theta=0.192964, up=999999999999999983222784.000000
ITER 3: row=27, varin=34, theta=0.535939, up=999999999999999983222784.000000
ITER 4: row=34, varin=28, theta=0.247156, up=999999999999999983222784.000000
ITER 5: row=28, varin=25, theta=0.243584, up=999999999999999983222784.000000
ITER 6: row=25, varin=13, theta=0.647868, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 26 = 1 gives z=27958155.485032
  % 	x26 = 1,	Z1 = 27958155.485032         
DEBUG EVAL: First branch cutoff check: z=27958155.485032, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 26 = 0
ITER 1: row=13, varin=64, theta=0.278960, up=1.000000
  % 	x26 = 0,	Z0 = 27865350.6735306        
DEBUG EVAL: Second branch cutoff check: z=27865350.673531, best_z=INF, threshold=INF
  %   New best:  x26, Z = 27865350.6735306        
DEBUG EVAL: Testing var 10 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=5, varin=27, theta=0.955441, up=999999999999999983222784.000000
ITER 2: row=27, varin=23, theta=1.003872, up=999999999999999983222784.000000
ITER 3: row=13, varin=64, theta=0.008064, up=1.000000
ITER 4: row=23, varin=39, theta=0.009931, up=1.000000
DEBUG EVAL: Branch var 10 = 1 gives z=27973321.497517
  % 	x10 = 1,	Z1 = 27973321.4975168        
DEBUG EVAL: First branch cutoff check: z=27973321.497517, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 0
ITER 1: row=5, varin=64, theta=29.035991, up=1.000000
ITER 2: row=5, varin=66, theta=16.401948, up=1.000000
ITER 3: row=5, varin=13, theta=0.464095, up=999999999999999983222784.000000
ITER 4: row=13, varin=66, theta=1.509582, up=1.000000
ITER 5: row=13, varin=64, theta=0.503096, up=1.000000
  % 	x10 = 0,	Z0 = 27930613.2863742        
DEBUG EVAL: Second branch cutoff check: z=27930613.286374, best_z=INF, threshold=INF
  %   New best:  x10, Z = 27930613.2863742        
DEBUG EVAL: Testing var 9 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=64, theta=29.035991, up=1.000000
ITER 2: row=1, varin=66, theta=16.401948, up=1.000000
ITER 3: row=1, varin=78, theta=1.077838, up=1.000000
ITER 4: row=1, varin=58, theta=-0.732035, up=1.000000
ITER 5: row=33, varin=78, theta=2.000000, up=1.000000
ITER 6: row=33, varin=28, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=1, varin=66, theta=2.696787, up=1.000000
ITER 8: row=1, varin=82, theta=0.287978, up=1.000000
ITER 9: row=13, varin=64, theta=2.855809, up=1.000000
ITER 10: row=13, varin=23, theta=0.623256, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 9 = 0 gives z=27971886.799545
  % 	x9 = 0,	Z0 = 27971886.7995446        
DEBUG EVAL: First branch cutoff check: z=27971886.799545, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 9 = 1
ITER 1: row=1, varin=27, theta=0.955441, up=999999999999999983222784.000000
ITER 2: row=27, varin=36, theta=4.259704, up=999999999999999983222784.000000
ITER 3: row=23, varin=34, theta=2.838059, up=999999999999999983222784.000000
ITER 4: row=34, varin=39, theta=1.970094, up=1.000000
ITER 5: row=34, varin=13, theta=0.829719, up=999999999999999983222784.000000
  % 	x9 = 1,	Z1 = 28059347.0576496        
DEBUG EVAL: Second branch cutoff check: z=28059347.057650, best_z=INF, threshold=INF
  %   New best:  x9, Z = 27971886.7995446        
DEBUG EVAL: Testing var 34 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=23, varin=27, theta=0.955441, up=999999999999999983222784.000000
ITER 2: row=27, varin=34, theta=3.708708, up=999999999999999983222784.000000
ITER 3: row=34, varin=24, theta=0.822687, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 34 = 1 gives z=28028451.711831
  % 	x34 = 1,	Z1 = 28028451.711831         
DEBUG EVAL: First branch cutoff check: z=28028451.711831, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 34 = 0
ITER 1: row=23, varin=36, theta=0.427904, up=999999999999999983222784.000000
  % 	x34 = 0,	Z0 = 27872823.4476076        
DEBUG EVAL: Second branch cutoff check: z=27872823.447608, best_z=INF, threshold=INF
  % Best branch is x9, Z0 = 27971886.7995446        , Z1 = 28059347.0576496        

DEBUG CAREFUL: Final result - returning best.var = 9
DEBUG BB: Branching variable chosen: j=9
 % @NC   91   87	x9 = 0	27971886.799545
 % @NC   92   87	x9 = 1	28059347.057650
 %      87    36 27860164.0894               27867642.4922    x5 D    65    10
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ad4c4c70b0
% @LO 0.06  27.86535067353057470996 99.9000000000
% @LN 0.06  27.86764249219023525939 99.9000000000
% Resuming node 73 at  27.86764249219023525939
DEBUG CONSTRNT: LP rows=36, pool->nlprows=36, pool->npend=0
DEBUG CONSTRNT: Checking 36 LP rows (pool tracks 36, total LP rows 36)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=35, expected 35
 % @PAP adding 37 rows, 194 nz to LP
DEBUG BB: Processing node 73, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=14, varin=44, theta=1.000000, up=1.000000
ITER 2: row=17, varin=6, theta=0.953060, up=999999999999999983222784.000000
ITER 3: row=27, varin=7, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=18, varin=72, theta=1.275022, up=1.000000
ITER 5: row=18, varin=74, theta=0.205843, up=1.000000
ITER 6: row=14, varin=72, theta=4.793850, up=1.000000
ITER 7: row=14, varin=37, theta=0.529444, up=999999999999999983222784.000000
ITER 8: row=37, varin=13, theta=0.976239, up=999999999999999983222784.000000
ITER 9: row=18, varin=28, theta=0.340655, up=999999999999999983222784.000000
ITER 10: row=8, varin=15, theta=0.326574, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=12)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=37)
DEBUG SOLUTION: LP solution array indices: FST[38-77], not_covered[78-97]
DEBUG SOLUTION: lp->best_solution[0] = 27867642.492190
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 0.145025
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 4.782462
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 37 rows, 60 cols, 254 nonzeros, 7 slack, 30 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 7 slack rows
  % @PAP adding 5 rows, 26 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=35, varin=14, theta=0.145367, up=999999999999999983222784.000000
ITER 2: row=31, varin=35, theta=6.305428, up=999999999999999983222784.000000
ITER 3: row=11, varin=36, theta=0.651004, up=1.000000
ITER 4: row=5, varin=78, theta=0.473942, up=1.000000
ITER 5: row=26, varin=46, theta=0.372600, up=1.000000
ITER 6: row=34, varin=72, theta=0.099988, up=1.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=35)
DEBUG SOLUTION: LP solution array indices: FST[36-75], not_covered[76-95]
DEBUG SOLUTION: lp->best_solution[0] = 27922294.396841
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.699996
  % @PL 35 rows, 60 cols, 252 nonzeros, 3 slack, 32 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 3 rows, 18 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=35, varin=48, theta=0.047425, up=1.000000
ITER 2: row=34, varin=32, theta=0.400620, up=999999999999999983222784.000000
ITER 3: row=33, varin=35, theta=2.262707, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=35)
DEBUG SOLUTION: LP solution array indices: FST[36-75], not_covered[76-95]
DEBUG SOLUTION: lp->best_solution[0] = 27955061.662995
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 35 rows, 60 cols, 248 nonzeros, 1 slack, 34 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 2 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=35, varin=71, theta=0.307421, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=36)
DEBUG SOLUTION: LP solution array indices: FST[37-76], not_covered[77-96]
DEBUG SOLUTION: lp->best_solution[0] = 27956776.735856
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 36 rows, 60 cols, 238 nonzeros, 0 slack, 36 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=37, varin=65, theta=0.055293, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=38)
DEBUG SOLUTION: LP solution array indices: FST[39-78], not_covered[79-98]
DEBUG SOLUTION: lp->best_solution[0] = 27957383.356604
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 38 rows, 60 cols, 242 nonzeros, 0 slack, 38 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 73 LP 1 Solution, length = 27957383.356604, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 1.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.236177 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.236177 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.236177 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.236177 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.236177 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 1.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.055293 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.236177 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.236177 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.763823 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.763823 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.763823 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.763823 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.763823 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.763823 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.763823 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.763823 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 8 fractional variables
DEBUG CG: LP optimal, z=27957383.356604, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 73 at  27.95738335660372797520
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ad4c4a0510
% @LO 0.06  27.86764249219023525939 99.9000000000
% @LN 0.06  27.87407560969392150696 99.9000000000
% Resuming node 42 at  27.87407560969392150696
DEBUG CONSTRNT: LP rows=38, pool->nlprows=38, pool->npend=0
DEBUG CONSTRNT: Checking 38 LP rows (pool tracks 38, total LP rows 38)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 79
DEBUG CONSTRNT: Pool row 79 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 45
DEBUG CONSTRNT: Pool row 45 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 142
DEBUG CONSTRNT: Pool row 142 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 133
DEBUG CONSTRNT: Pool row 133 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 62
DEBUG CONSTRNT: Pool row 62 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 63
DEBUG CONSTRNT: Pool row 63 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 71
DEBUG CONSTRNT: Pool row 71 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=37, expected 37
 % @PAP adding 43 rows, 226 nz to LP
DEBUG BB: Processing node 42, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 42 LP 2 Solution, length = 27874075.609694, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.098711 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.549356 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 1.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 1.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.450644 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.450644 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.098711 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.901289 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.901289 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.450644 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.450644 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=27874075.609694, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=27874075.609694, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 42 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 42
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=1.000000
DEBUG CAREFUL: Skipping var 2: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.098711
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.098711)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.549356
DEBUG CAREFUL: Adding var 12 to fractional list (xi=0.549356)
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=1.000000
DEBUG CAREFUL: Skipping var 16: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=1.000000
DEBUG CAREFUL: Skipping var 17: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.450644
DEBUG CAREFUL: Adding var 21 to fractional list (xi=0.450644)
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.450644
DEBUG CAREFUL: Adding var 25 to fractional list (xi=0.450644)
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.098711
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.098711)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 10
DEBUG CAREFUL: New best var: 10
DEBUG CAREFUL: Testing fvar[1] = var 12
DEBUG CAREFUL: Calling compare_branch_vars for var 12
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 12
DEBUG CAREFUL: Testing fvar[2] = var 21
DEBUG CAREFUL: Calling compare_branch_vars for var 21
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 21
DEBUG CAREFUL: Testing fvar[3] = var 25
DEBUG CAREFUL: Calling compare_branch_vars for var 25
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 25
DEBUG CAREFUL: Testing fvar[4] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
  % Initial guess is x10, Z0 = 27874075.6096939        , Z1 = 28298651.5188827        

DEBUG EVAL: Testing var 10 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=5, varin=47, theta=0.682641, up=1.000000
ITER 2: row=26, varin=35, theta=2.330928, up=999999999999999983222784.000000
ITER 3: row=32, varin=39, theta=1.517796, up=999999999999999983222784.000000
ITER 4: row=39, varin=49, theta=1.293260, up=1.000000
ITER 5: row=39, varin=42, theta=0.921028, up=999999999999999983222784.000000
ITER 6: row=19, varin=49, theta=1.000000, up=1.000000
ITER 7: row=42, varin=28, theta=0.445896, up=999999999999999983222784.000000
ITER 8: row=28, varin=40, theta=5.554200, up=999999999999999983222784.000000
ITER 9: row=31, varin=38, theta=3.050951, up=999999999999999983222784.000000
ITER 10: row=38, varin=32, theta=0.545692, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 1 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x10 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=5, varin=58, theta=0.487822, up=1.000000
ITER 2: row=6, varin=48, theta=0.070590, up=1.000000
ITER 3: row=27, varin=33, theta=0.413198, up=999999999999999983222784.000000
ITER 4: row=34, varin=25, theta=0.277320, up=999999999999999983222784.000000
ITER 5: row=9, varin=88, theta=0.048710, up=1.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 27891668.027491
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 0.951290
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 43 rows, 60 cols, 286 nonzeros, 3 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 3 slack rows
   % @PAP adding 2 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=41, varin=4, theta=45474.500000, up=999999999999999983222784.000000
ITER 2: row=42, varin=96, theta=-0.277320, up=1.000000
ITER 3: row=6, varin=32, theta=0.063738, up=999999999999999983222784.000000
ITER 4: row=32, varin=34, theta=0.194685, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
ITER 5: row=32, varin=41, theta=0.000000, up=999999999999999983222784.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 27895527.408740
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.000000
DEBUG SOLUTION: lp->best_solution[4] = 1754525.500000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 42 rows, 60 cols, 282 nonzeros, 1 slack, 41 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 42 at  27.89552740873996938831
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ad4c4a0450
% @LO 0.06  27.87407560969392150696 99.9000000000
% @LN 0.06  27.87992589149622091327 99.9000000000
% Resuming node 79 at  27.87992589149622091327
DEBUG CONSTRNT: LP rows=41, pool->nlprows=41, pool->npend=0
DEBUG CONSTRNT: Checking 41 LP rows (pool tracks 41, total LP rows 41)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 82
DEBUG CONSTRNT: Pool row 82 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 137
DEBUG CONSTRNT: Pool row 137 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 49
DEBUG CONSTRNT: Pool row 49 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 68
DEBUG CONSTRNT: Pool row 68 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 133
DEBUG CONSTRNT: Pool row 133 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=40, expected 40
 % @PAP adding 44 rows, 218 nz to LP
DEBUG BB: Processing node 79, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=30, varin=101, theta=1.399060, up=1.000000
ITER 2: row=30, varin=19, theta=0.313335, up=999999999999999983222784.000000
ITER 3: row=15, varin=101, theta=1.160236, up=1.000000
ITER 4: row=15, varin=44, theta=0.153674, up=999999999999999983222784.000000
ITER 5: row=10, varin=30, theta=0.073421, up=999999999999999983222784.000000
ITER 6: row=24, varin=42, theta=0.065379, up=999999999999999983222784.000000
ITER 7: row=42, varin=41, theta=0.082693, up=999999999999999983222784.000000
ITER 8: row=26, varin=55, theta=0.140591, up=1.000000
LP PHASE: Switching to primal (iter=8)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 27879925.891496
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 0.000000
DEBUG SOLUTION: lp->best_solution[3] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 44 rows, 60 cols, 278 nonzeros, 2 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=45, varin=78, theta=0.281862, up=1.000000
ITER 2: row=41, varin=74, theta=0.167136, up=1.000000
ITER 3: row=42, varin=77, theta=0.187694, up=1.000000
ITER 4: row=44, varin=102, theta=0.157816, up=1.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 27930785.182378
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 0.000000
DEBUG SOLUTION: lp->best_solution[3] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 45 rows, 60 cols, 280 nonzeros, 3 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 3 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=43, varin=24, theta=0.141667, up=999999999999999983222784.000000
ITER 2: row=45, varin=79, theta=0.193452, up=1.000000
ITER 3: row=43, varin=76, theta=0.143372, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 27956442.489142
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 0.000000
DEBUG SOLUTION: lp->best_solution[3] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 45 rows, 60 cols, 280 nonzeros, 1 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 2 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=46, varin=74, theta=0.148082, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=46)
DEBUG SOLUTION: LP solution array indices: FST[47-86], not_covered[87-106]
DEBUG SOLUTION: lp->best_solution[0] = 27961361.881176
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 0.000000
DEBUG SOLUTION: lp->best_solution[3] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 46 rows, 60 cols, 282 nonzeros, 0 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 79 LP 1 Solution, length = 27961361.881176, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.851918 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.351918 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.500000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 1.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 1.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.500000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.148082 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.148082 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.351918 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.648082 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.648082 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.500000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.148082 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.500000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 7 fractional variables
DEBUG CG: LP optimal, z=27961361.881176, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 79 at  27.96136188117632315198
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ad4c4c2b50
% @LO 0.06  27.87992589149622091327 99.9000000000
% @LN 0.06  27.88346936072915127625 99.9000000000
% Resuming node 86 at  27.88346936072915127625
DEBUG CONSTRNT: LP rows=46, pool->nlprows=46, pool->npend=0
DEBUG CONSTRNT: Checking 46 LP rows (pool tracks 46, total LP rows 46)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 133
DEBUG CONSTRNT: Pool row 133 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 58
DEBUG CONSTRNT: Pool row 58 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 134
DEBUG CONSTRNT: Pool row 134 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 158
DEBUG CONSTRNT: Pool row 158 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=45, expected 45
 % @PAP adding 24 rows, 148 nz to LP
DEBUG BB: Processing node 86, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=5, varin=21, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=23, varin=20, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=12, varin=17, theta=0.148995, up=999999999999999983222784.000000
ITER 4: row=14, varin=35, theta=0.182548, up=1.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=24)
DEBUG SOLUTION: LP solution array indices: FST[25-64], not_covered[65-84]
DEBUG SOLUTION: lp->best_solution[0] = 27883469.360729
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 24 rows, 60 cols, 208 nonzeros, 3 slack, 21 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=22, varin=32, theta=0.667202, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=22)
DEBUG SOLUTION: LP solution array indices: FST[23-62], not_covered[63-82]
DEBUG SOLUTION: lp->best_solution[0] = 27885059.783209
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 22 rows, 60 cols, 202 nonzeros, 0 slack, 22 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=23, varin=27, theta=0.284074, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=23)
DEBUG SOLUTION: LP solution array indices: FST[24-63], not_covered[64-83]
DEBUG SOLUTION: lp->best_solution[0] = 27912481.898477
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 23 rows, 60 cols, 204 nonzeros, 0 slack, 23 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 3 rows, 14 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=24, varin=27, theta=0.286553, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=26)
DEBUG SOLUTION: LP solution array indices: FST[27-66], not_covered[67-86]
DEBUG SOLUTION: lp->best_solution[0] = 27922902.096926
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 26 rows, 60 cols, 218 nonzeros, 0 slack, 26 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 6 rows, 21 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=27, varin=21, theta=1.415146, up=999999999999999983222784.000000
ITER 2: row=5, varin=6, theta=0.199224, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=32)
DEBUG SOLUTION: LP solution array indices: FST[33-72], not_covered[73-92]
DEBUG SOLUTION: lp->best_solution[0] = 27935704.291874
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.800776
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 32 rows, 60 cols, 239 nonzeros, 2 slack, 30 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % Node 86 LP 1 Solution, length = 27935704.291874, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.800776 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.800776 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.800776 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 1.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.199224 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.199224 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.199224 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.199224 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.199224 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.199224 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 3 fractional variables
DEBUG CG: LP optimal, z=27935704.291874, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 86 at  27.93570429187353809652
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ad4c4b16a0
% @LO 0.06  27.88346936072915127625 99.9000000000
% @LN 0.06  27.89139253730306933221 99.9000000000
% Resuming node 71 at  27.89139253730306933221
DEBUG CONSTRNT: LP rows=30, pool->nlprows=30, pool->npend=0
DEBUG CONSTRNT: Checking 30 LP rows (pool tracks 30, total LP rows 30)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=29, expected 29
 % @PAP adding 36 rows, 192 nz to LP
DEBUG BB: Processing node 71, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 71 LP 2 Solution, length = 27891392.537303, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.489921 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.489921 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 1.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.489921 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.489921 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.510079 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.510079 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.510079 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.510079 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.510079 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.510079 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=27891392.537303, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=27891392.537303, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 71 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 71
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=1.000000
DEBUG CAREFUL: Skipping var 2: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.489921
DEBUG CAREFUL: Adding var 5 to fractional list (xi=0.489921)
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.489921
DEBUG CAREFUL: Adding var 12 to fractional list (xi=0.489921)
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=1.000000
DEBUG CAREFUL: Skipping var 20: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.489921
DEBUG CAREFUL: Adding var 34 to fractional list (xi=0.489921)
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.489921
DEBUG CAREFUL: Adding var 36 to fractional list (xi=0.489921)
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 4 fractional variables

  %  Carefully choosing branching variable, nfrac = 4
DEBUG CAREFUL: Testing fvar[0] = var 5
DEBUG CAREFUL: Calling compare_branch_vars for var 5
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 5
DEBUG CAREFUL: New best var: 5
DEBUG CAREFUL: Testing fvar[1] = var 12
DEBUG CAREFUL: Calling compare_branch_vars for var 12
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 12
DEBUG CAREFUL: Testing fvar[2] = var 34
DEBUG CAREFUL: Calling compare_branch_vars for var 34
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 34
DEBUG CAREFUL: Testing fvar[3] = var 36
DEBUG CAREFUL: Calling compare_branch_vars for var 36
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 36
  % Initial guess is x5, Z0 = 27891392.5373031        , Z1 = 28100527.5770825        

DEBUG EVAL: Testing var 5 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=33, theta=1.115520, up=999999999999999983222784.000000
ITER 2: row=29, varin=31, theta=1.625780, up=999999999999999983222784.000000
ITER 3: row=12, varin=30, theta=0.587774, up=999999999999999983222784.000000
ITER 4: row=15, varin=14, theta=0.855276, up=999999999999999983222784.000000
ITER 5: row=36, varin=63, theta=1.251835, up=1.000000
ITER 6: row=36, varin=64, theta=0.271698, up=1.000000
ITER 7: row=19, varin=63, theta=1.000000, up=1.000000
ITER 8: row=36, varin=71, theta=2.512101, up=1.000000
ITER 9: row=36, varin=43, theta=0.190177, up=1.000000
ITER 10: row=17, varin=71, theta=1.844257, up=1.000000
DEBUG EVAL: Branch var 5 = 1 gives z=28100527.577083
  % 	x5 = 1,	Z1 = 28100527.5770825        
DEBUG EVAL: First branch cutoff check: z=28100527.577083, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 5 = 0
ITER 1: row=1, varin=55, theta=0.700868, up=1.000000
ITER 2: row=19, varin=43, theta=0.966772, up=1.000000
ITER 3: row=5, varin=81, theta=0.407385, up=1.000000
  % 	x5 = 0,	Z0 = 27927220.1641378        
DEBUG EVAL: Second branch cutoff check: z=27927220.164138, best_z=INF, threshold=INF
  %   New best:  x5, Z = 27927220.1641378        
DEBUG EVAL: Testing var 12 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=5, varin=55, theta=0.392073, up=1.000000
ITER 2: row=19, varin=43, theta=0.341592, up=1.000000
DEBUG EVAL: Branch var 12 = 1 gives z=27900665.402645
  % 	x12 = 1,	Z1 = 27900665.4026454        
DEBUG EVAL: First branch cutoff check: z=27900665.402645, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 34 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=12, varin=55, theta=0.700868, up=1.000000
ITER 2: row=18, varin=31, theta=0.713904, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 34 = 0 gives z=27914037.703623
  % 	x34 = 0,	Z0 = 27914037.7036229        
DEBUG EVAL: First branch cutoff check: z=27914037.703623, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 36 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=17, varin=55, theta=0.700868, up=1.000000
ITER 2: row=18, varin=43, theta=0.966772, up=1.000000
ITER 3: row=15, varin=30, theta=0.355183, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 36 = 0 gives z=27921578.665537
  % 	x36 = 0,	Z0 = 27921578.6655372        
DEBUG EVAL: First branch cutoff check: z=27921578.665537, best_z=INF, threshold=INF
  % Best branch is x5, Z0 = 27927220.1641378        , Z1 = 28100527.5770825        

DEBUG CAREFUL: Final result - returning best.var = 5
DEBUG BB: Branching variable chosen: j=5
 % @NC   93   71	x5 = 0	27927220.164138
 % @NC   94   71	x5 = 1	28100527.577083
 %      71    37 27891392.5373               27895527.4087    x9 D    62     9
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ad4c4a0510
% @LO 0.06  27.89139253730306933221 99.9000000000
% @LN 0.06  27.89552740873996938831 99.9000000000
% Resuming node 42 at  27.89552740873996938831
DEBUG CONSTRNT: LP rows=36, pool->nlprows=36, pool->npend=0
DEBUG CONSTRNT: Checking 36 LP rows (pool tracks 36, total LP rows 36)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 141
DEBUG CONSTRNT: Pool row 141 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 145
DEBUG CONSTRNT: Pool row 145 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 159
DEBUG CONSTRNT: Pool row 159 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=35, expected 35
 % @PAP adding 41 rows, 182 nz to LP
DEBUG BB: Processing node 42, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 42 LP 3 Solution, length = 27895527.408740, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.500000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 1.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 1.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.500000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.500000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.500000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 3 fractional variables
DEBUG CG: LP optimal, z=27895527.408740, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=27895527.408740, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 42 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 42
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=1.000000
DEBUG CAREFUL: Skipping var 2: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.500000
DEBUG CAREFUL: Adding var 12 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=1.000000
DEBUG CAREFUL: Skipping var 16: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=1.000000
DEBUG CAREFUL: Skipping var 17: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.500000
DEBUG CAREFUL: Adding var 21 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.500000
DEBUG CAREFUL: Adding var 25 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 3 fractional variables

  %  Carefully choosing branching variable, nfrac = 3
DEBUG CAREFUL: Testing fvar[0] = var 12
DEBUG CAREFUL: Calling compare_branch_vars for var 12
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 12
DEBUG CAREFUL: New best var: 12
DEBUG CAREFUL: Testing fvar[1] = var 21
DEBUG CAREFUL: Calling compare_branch_vars for var 21
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 21
DEBUG CAREFUL: Testing fvar[2] = var 25
DEBUG CAREFUL: Calling compare_branch_vars for var 25
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 25
DEBUG CAREFUL: New best var: 25
  % Initial guess is x25, Z0 = 27895527.40874          , Z1 = 27903399.8706598        

DEBUG EVAL: Testing var 12 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=57, theta=1.000000, up=1.000000
ITER 2: row=4, varin=30, theta=0.333333, up=999999999999999983222784.000000
ITER 3: row=33, varin=36, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=36, varin=24, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=24, varin=35, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=35, varin=37, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 12 = 0 gives z=27973771.250885
  % 	x12 = 0,	Z0 = 27973771.2508849        
DEBUG EVAL: First branch cutoff check: z=27973771.250885, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 12 = 1
ITER 1: row=1, varin=31, theta=0.333333, up=999999999999999983222784.000000
ITER 2: row=40, varin=88, theta=1.000000, up=1.000000
ITER 3: row=23, varin=75, theta=1.000000, up=1.000000
ITER 4: row=33, varin=83, theta=0.250000, up=1.000000
ITER 5: row=1, varin=72, theta=0.500000, up=1.000000
  % 	x12 = 1,	Z1 = 28081496.1157048        
DEBUG EVAL: Second branch cutoff check: z=28081496.115705, best_z=INF, threshold=INF
  %   New best:  x12, Z = 27973771.2508849        
DEBUG EVAL: Testing var 21 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=15, varin=31, theta=0.333333, up=999999999999999983222784.000000
ITER 2: row=40, varin=88, theta=1.000000, up=1.000000
ITER 3: row=23, varin=57, theta=1.000000, up=1.000000
ITER 4: row=4, varin=29, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 21 = 0 gives z=27997607.847201
  % 	x21 = 0,	Z0 = 27997607.8472005        
DEBUG EVAL: First branch cutoff check: z=27997607.847201, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 21 = 1
ITER 1: row=15, varin=30, theta=0.333333, up=999999999999999983222784.000000
ITER 2: row=33, varin=36, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=36, varin=24, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=24, varin=35, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=35, varin=37, theta=1.000000, up=999999999999999983222784.000000
  % 	x21 = 1,	Z1 = 27973771.2508849        
DEBUG EVAL: Second branch cutoff check: z=27973771.250885, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 25 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=29, varin=57, theta=1.000000, up=1.000000
ITER 2: row=4, varin=30, theta=0.333333, up=999999999999999983222784.000000
ITER 3: row=33, varin=36, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=36, varin=24, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=24, varin=35, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=35, varin=32, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=32, varin=29, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 25 = 1 gives z=27997607.847201
  % 	x25 = 1,	Z1 = 27997607.8472005        
DEBUG EVAL: First branch cutoff check: z=27997607.847201, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 25 = 0
ITER 1: row=29, varin=31, theta=0.333333, up=999999999999999983222784.000000
ITER 2: row=40, varin=88, theta=1.000000, up=1.000000
ITER 3: row=23, varin=37, theta=1.000000, up=999999999999999983222784.000000
  % 	x25 = 0,	Z0 = 27973771.2508849        
DEBUG EVAL: Second branch cutoff check: z=27973771.250885, best_z=INF, threshold=INF
  % Best branch is x12, Z0 = 27973771.2508849        , Z1 = 28081496.1157048        

DEBUG CAREFUL: Final result - returning best.var = 12
DEBUG BB: Branching variable chosen: j=12
 % @NC   95   42	x12 = 0	27973771.250885
 % @NC   96   42	x12 = 1	28081496.115705
 %      42    38 27895527.4087               27902927.2292   x16 U    18     7
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ad4c4c23d0
% @LO 0.06  27.89552740873996938831 99.9000000000
% @LN 0.06  27.90292722917613232880 99.9000000000
% Resuming node 50 at  27.90292722917613232880
DEBUG CONSTRNT: LP rows=41, pool->nlprows=41, pool->npend=0
DEBUG CONSTRNT: Checking 41 LP rows (pool tracks 41, total LP rows 41)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 82
DEBUG CONSTRNT: Pool row 82 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 137
DEBUG CONSTRNT: Pool row 137 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 49
DEBUG CONSTRNT: Pool row 49 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 68
DEBUG CONSTRNT: Pool row 68 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 133
DEBUG CONSTRNT: Pool row 133 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=40, expected 40
 % @PAP adding 27 rows, 166 nz to LP
DEBUG BB: Processing node 50, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=7, varin=33, theta=0.500000, up=1.000000
ITER 2: row=6, varin=54, theta=1.382571, up=1.000000
ITER 3: row=6, varin=49, theta=0.321962, up=1.000000
ITER 4: row=7, varin=4, theta=0.321357, up=999999999999999983222784.000000
ITER 5: row=8, varin=54, theta=2.032266, up=1.000000
ITER 6: row=8, varin=81, theta=0.166430, up=1.000000
ITER 7: row=6, varin=54, theta=0.198421, up=1.000000
LP PHASE: Switching to primal (iter=7)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=27)
DEBUG SOLUTION: LP solution array indices: FST[28-67], not_covered[68-87]
DEBUG SOLUTION: lp->best_solution[0] = 27902927.229176
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 0.000000
DEBUG SOLUTION: lp->best_solution[6] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 27 rows, 60 cols, 226 nonzeros, 0 slack, 27 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 3 rows, 9 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=30, varin=52, theta=1.000000, up=1.000000
ITER 2: row=28, varin=58, theta=1.501788, up=1.000000
ITER 3: row=28, varin=53, theta=0.400816, up=1.000000
ITER 4: row=18, varin=54, theta=0.420626, up=1.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=30)
DEBUG SOLUTION: LP solution array indices: FST[31-70], not_covered[71-90]
DEBUG SOLUTION: lp->best_solution[0] = 27977925.266234
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 0.000000
DEBUG SOLUTION: lp->best_solution[6] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 30 rows, 60 cols, 235 nonzeros, 0 slack, 30 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 9 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=34, varin=62, theta=0.691166, up=1.000000
ITER 2: row=32, varin=64, theta=1.000000, up=1.000000
ITER 3: row=31, varin=34, theta=0.131917, up=999999999999999983222784.000000
ITER 4: row=32, varin=59, theta=0.095465, up=1.000000
ITER 5: row=22, varin=63, theta=0.119478, up=1.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=34)
DEBUG SOLUTION: LP solution array indices: FST[35-74], not_covered[75-94]
DEBUG SOLUTION: lp->best_solution[0] = 28047619.095273
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 0.000000
DEBUG SOLUTION: lp->best_solution[6] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 34 rows, 60 cols, 244 nonzeros, 1 slack, 33 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 6 rows, 21 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=34, varin=69, theta=1.000000, up=1.000000
ITER 2: row=36, varin=81, theta=0.657803, up=1.000000
ITER 3: row=33, varin=46, theta=5.135011, up=1.000000
ITER 4: row=33, varin=17, theta=2.574052, up=999999999999999983222784.000000
ITER 5: row=1, varin=70, theta=2.644791, up=1.000000
ITER 6: row=1, varin=71, theta=2.271587, up=1.000000
ITER 7: row=1, varin=72, theta=3.603803, up=1.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=39)
DEBUG SOLUTION: LP solution array indices: FST[40-79], not_covered[80-99]
DEBUG SOLUTION: lp->best_solution[0] = 999999999999999983222784.000000
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 0.000000
DEBUG SOLUTION: lp->best_solution[6] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 39 rows, 60 cols, 263 nonzeros, 2 slack, 37 tight.
  % Node 50 LP 1 Solution, length = 999999999999999983222784.000000, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.440261 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 1.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 1.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.440261 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.119478 (FST 28)
  % DEBUG LP_VARS: x[29] = 1.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.559739 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
DEBUG BB: compute_good_lower_bound returned status=1
DEBUG BB: Node 50 is INFEASIBLE
 %      50    37    infeasible               27927220.1641   x15 U    23     5
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ad4c4c78e0
% @LO 0.06  27.90292722917613232880 99.9000000000
% @LN 0.06  27.92722016413777197386 99.9000000000
% Resuming node 93 at  27.92722016413777197386
DEBUG CONSTRNT: LP rows=39, pool->nlprows=39, pool->npend=0
DEBUG CONSTRNT: Checking 39 LP rows (pool tracks 39, total LP rows 39)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 58
DEBUG CONSTRNT: Pool row 58 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=38, expected 38
 % @PAP adding 36 rows, 192 nz to LP
DEBUG BB: Processing node 93, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=55, theta=0.700868, up=1.000000
ITER 2: row=19, varin=43, theta=0.966772, up=1.000000
ITER 3: row=5, varin=81, theta=0.407385, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=36)
DEBUG SOLUTION: LP solution array indices: FST[37-76], not_covered[77-96]
DEBUG SOLUTION: lp->best_solution[0] = 27927220.164138
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 36 rows, 60 cols, 252 nonzeros, 2 slack, 34 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 4 rows, 21 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=35, varin=51, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=38)
DEBUG SOLUTION: LP solution array indices: FST[39-78], not_covered[79-98]
DEBUG SOLUTION: lp->best_solution[0] = 27937486.029517
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 38 rows, 60 cols, 262 nonzeros, 0 slack, 38 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 3 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=39, varin=18, theta=0.154510, up=999999999999999983222784.000000
ITER 2: row=24, varin=5, theta=226848.000000, up=999999999999999983222784.000000
ITER 3: row=19, varin=67, theta=1.058015, up=1.000000
ITER 4: row=19, varin=66, theta=0.014214, up=1.000000
ITER 5: row=15, varin=67, theta=0.008099, up=1.000000
LP PHASE: Switching to primal (iter=5)
ITER 6: row=1, varin=24, theta=0.000000, up=999999999999999983222784.000000
ITER 7: row=18, varin=89, theta=0.000000, up=1.000000
ITER 8: row=12, varin=67, theta=1.000000, up=1.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=39)
DEBUG SOLUTION: LP solution array indices: FST[40-79], not_covered[80-99]
DEBUG SOLUTION: lp->best_solution[0] = 27947152.607459
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1573152.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 39 rows, 60 cols, 265 nonzeros, 1 slack, 38 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 93 LP 1 Solution, length = 27947152.607459, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.500000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.500000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 1.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.500000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.500000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.500000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 1.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.500000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 2 fractional variables
DEBUG CG: LP optimal, z=27947152.607459, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 93 at  27.94715260745892848604
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ad4c4b0620
% @LO 0.06  27.92722016413777197386 99.9000000000
% @LN 0.06  27.92853403709865389715 99.9000000000
% Resuming node 72 at  27.92853403709865389715
DEBUG CONSTRNT: LP rows=38, pool->nlprows=38, pool->npend=0
DEBUG CONSTRNT: Checking 38 LP rows (pool tracks 38, total LP rows 38)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 141
DEBUG CONSTRNT: Pool row 141 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 145
DEBUG CONSTRNT: Pool row 145 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 159
DEBUG CONSTRNT: Pool row 159 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 142
DEBUG CONSTRNT: Pool row 142 has lprow=37, expected 37
 % @PAP adding 34 rows, 192 nz to LP
DEBUG BB: Processing node 72, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 72 LP 2 Solution, length = 27928534.037099, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.832972 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 1.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 1.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.167028 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.167028 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 2 fractional variables
DEBUG CG: LP optimal, z=27928534.037099, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=27928534.037099, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 72 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 72
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.832972
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.832972)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=1.000000
DEBUG CAREFUL: Skipping var 9: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=1.000000
DEBUG CAREFUL: Skipping var 20: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.167028
DEBUG CAREFUL: Adding var 27 to fractional list (xi=0.167028)
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 2 fractional variables

  %  Carefully choosing branching variable, nfrac = 2
DEBUG CAREFUL: Testing fvar[0] = var 27
DEBUG CAREFUL: Calling compare_branch_vars for var 27
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 27
DEBUG CAREFUL: New best var: 27
DEBUG CAREFUL: Testing fvar[1] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
  % Initial guess is x27, Z0 = 27928534.0370987        , Z1 = 28059495.5363871        

DEBUG EVAL: Testing var 27 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=5, varin=20, theta=0.771324, up=999999999999999983222784.000000
ITER 2: row=20, varin=31, theta=0.646965, up=999999999999999983222784.000000
ITER 3: row=31, varin=92, theta=1.125395, up=1.000000
ITER 4: row=31, varin=2, theta=0.058931, up=999999999999999983222784.000000
ITER 5: row=2, varin=3, theta=0.058931, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 27 = 1 gives z=28063366.790566
  % 	x27 = 1,	Z1 = 28063366.7905663        
DEBUG EVAL: First branch cutoff check: z=28063366.790566, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 27 = 0
ITER 1: row=5, varin=57, theta=0.133418, up=1.000000
ITER 2: row=22, varin=58, theta=0.140012, up=1.000000
  % 	x27 = 0,	Z0 = 27930508.6525487        
DEBUG EVAL: Second branch cutoff check: z=27930508.652549, best_z=INF, threshold=INF
  %   New best:  x27, Z = 27930508.6525487        
DEBUG EVAL: Testing var 2 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=57, theta=0.663031, up=1.000000
ITER 2: row=22, varin=58, theta=0.865635, up=1.000000
ITER 3: row=5, varin=20, theta=1.477751, up=999999999999999983222784.000000
ITER 4: row=20, varin=12, theta=0.466301, up=999999999999999983222784.000000
ITER 5: row=34, varin=17, theta=3.489045, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 1 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x2 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=45, theta=0.657722, up=1.000000
ITER 2: row=19, varin=52, theta=0.345836, up=1.000000
ITER 3: row=22, varin=92, theta=1.840203, up=1.000000
ITER 4: row=22, varin=35, theta=0.293145, up=1.000000
ITER 5: row=5, varin=31, theta=0.406240, up=999999999999999983222784.000000
ITER 6: row=16, varin=62, theta=1.322816, up=1.000000
ITER 7: row=16, varin=79, theta=0.011934, up=1.000000
ITER 8: row=31, varin=62, theta=0.112706, up=1.000000
LP PHASE: Switching to primal (iter=8)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=34)
DEBUG SOLUTION: LP solution array indices: FST[35-74], not_covered[75-94]
DEBUG SOLUTION: lp->best_solution[0] = 28057234.915990
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 34 rows, 60 cols, 252 nonzeros, 5 slack, 29 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 5 slack rows
   % @PAP adding 7 rows, 22 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=35, varin=58, theta=0.657677, up=1.000000
ITER 2: row=30, varin=91, theta=0.168542, up=1.000000
ITER 3: row=20, varin=43, theta=0.257443, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=36)
DEBUG SOLUTION: LP solution array indices: FST[37-76], not_covered[77-96]
DEBUG SOLUTION: lp->best_solution[0] = 28070864.868577
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 36 rows, 60 cols, 256 nonzeros, 0 slack, 36 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @PAP adding 5 rows, 25 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=41, varin=71, theta=0.908429, up=1.000000
ITER 2: row=34, varin=99, theta=0.242309, up=1.000000
ITER 3: row=37, varin=76, theta=0.589854, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=41)
DEBUG SOLUTION: LP solution array indices: FST[42-81], not_covered[82-101]
DEBUG SOLUTION: lp->best_solution[0] = 28105006.453294
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 41 rows, 60 cols, 281 nonzeros, 0 slack, 41 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @PAP adding 1 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=42, varin=48, theta=0.169622, up=1.000000
ITER 2: row=27, varin=79, theta=0.548985, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 28109103.516583
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 42 rows, 60 cols, 287 nonzeros, 0 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @PAP adding 2 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=43, varin=68, theta=1.342352, up=1.000000
ITER 2: row=43, varin=70, theta=0.311623, up=1.000000
ITER 3: row=44, varin=68, theta=1.000000, up=1.000000
ITER 4: row=5, varin=44, theta=2.471759, up=999999999999999983222784.000000
ITER 5: row=44, varin=46, theta=0.085285, up=1.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28120424.033455
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 44 rows, 60 cols, 295 nonzeros, 2 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 2 slack rows
   % @PAP adding 5 rows, 14 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=47, varin=71, theta=0.602254, up=1.000000
ITER 2: row=42, varin=69, theta=0.197639, up=1.000000
ITER 3: row=44, varin=14, theta=0.083297, up=999999999999999983222784.000000
ITER 4: row=37, varin=72, theta=1.449855, up=1.000000
ITER 5: row=37, varin=35, theta=0.034774, up=999999999999999983222784.000000
ITER 6: row=31, varin=72, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 28157802.816635
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.887925
   % @PL 47 rows, 60 cols, 305 nonzeros, 3 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 3 slack rows
   % @PAP adding 3 rows, 7 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=46, varin=66, theta=0.228933, up=1.000000
ITER 2: row=18, varin=39, theta=0.415645, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 28168080.920718
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 4.000000
   % @PL 47 rows, 60 cols, 297 nonzeros, 2 slack, 45 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 2 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 72 at  28.16808092071806157719
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ad4c4c2b50
% @LO 0.06  27.92853403709865389715 99.9000000000
% @LN 0.06  27.93570429187353809652 99.9000000000
% Resuming node 86 at  27.93570429187353809652
DEBUG CONSTRNT: LP rows=45, pool->nlprows=45, pool->npend=0
DEBUG CONSTRNT: Checking 45 LP rows (pool tracks 45, total LP rows 45)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 141
DEBUG CONSTRNT: Pool row 141 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 145
DEBUG CONSTRNT: Pool row 145 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 159
DEBUG CONSTRNT: Pool row 159 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 63
DEBUG CONSTRNT: Pool row 63 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=44, expected 44
 % @PAP adding 30 rows, 172 nz to LP
DEBUG BB: Processing node 86, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 86 LP 2 Solution, length = 27935704.291874, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.800776 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.800776 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.800776 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 1.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.199224 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.199224 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.199224 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.199224 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.199224 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.199224 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 3 fractional variables
DEBUG CG: LP optimal, z=27935704.291874, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=27935704.291874, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 86 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 86
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=1.000000
DEBUG CAREFUL: Skipping var 2: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.800776
DEBUG CAREFUL: Adding var 9 to fractional list (xi=0.800776)
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.800776
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.800776)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.800776
DEBUG CAREFUL: Adding var 12 to fractional list (xi=0.800776)
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=1.000000
DEBUG CAREFUL: Skipping var 17: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 3 fractional variables

  %  Carefully choosing branching variable, nfrac = 3
DEBUG CAREFUL: Testing fvar[0] = var 12
DEBUG CAREFUL: Calling compare_branch_vars for var 12
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 12
DEBUG CAREFUL: New best var: 12
DEBUG CAREFUL: Testing fvar[1] = var 9
DEBUG CAREFUL: Calling compare_branch_vars for var 9
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 9
DEBUG CAREFUL: Testing fvar[2] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
  % Initial guess is x12, Z0 = 27935704.2918735        , Z1 = 27935704.2918735        

DEBUG EVAL: Testing var 12 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=11, varin=67, theta=0.306350, up=1.000000
DEBUG EVAL: Branch var 12 = 1 gives z=27941970.490342
  % 	x12 = 1,	Z1 = 27941970.4903417        
DEBUG EVAL: First branch cutoff check: z=27941970.490342, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 12 = 0
ITER 1: row=11, varin=25, theta=0.567863, up=999999999999999983222784.000000
ITER 2: row=25, varin=22, theta=0.559656, up=999999999999999983222784.000000
ITER 3: row=22, varin=21, theta=1.488533, up=999999999999999983222784.000000
ITER 4: row=1, varin=36, theta=0.547654, up=1.000000
  % 	x12 = 0,	Z0 = 28017429.8984105        
DEBUG EVAL: Second branch cutoff check: z=28017429.898410, best_z=INF, threshold=INF
  %   New best:  x12, Z = 27941970.4903417        
DEBUG EVAL: Testing var 9 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=25, theta=0.337758, up=999999999999999983222784.000000
ITER 2: row=25, varin=22, theta=0.350029, up=999999999999999983222784.000000
ITER 3: row=22, varin=21, theta=0.431186, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 9 = 1 gives z=27969629.973929
  % 	x9 = 1,	Z1 = 27969629.9739292        
DEBUG EVAL: First branch cutoff check: z=27969629.973929, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 9 = 0
ITER 1: row=1, varin=67, theta=2.289996, up=1.000000
ITER 2: row=1, varin=49, theta=0.377858, up=1.000000
ITER 3: row=11, varin=36, theta=0.939993, up=1.000000
  % 	x9 = 0,	Z0 = 27961386.3825477        
DEBUG EVAL: Second branch cutoff check: z=27961386.382548, best_z=INF, threshold=INF
  %   New best:  x9, Z = 27961386.3825477        
DEBUG EVAL: Testing var 10 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=5, varin=25, theta=0.337758, up=999999999999999983222784.000000
ITER 2: row=25, varin=18, theta=0.306913, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 1 gives z=27955697.087478
  % 	x10 = 1,	Z1 = 27955697.0874779        
DEBUG EVAL: First branch cutoff check: z=27955697.087478, best_z=INF, threshold=INF
  % Best branch is x9, Z0 = 27961386.3825477        , Z1 = 27969629.9739292        

DEBUG CAREFUL: Final result - returning best.var = 9
DEBUG BB: Branching variable chosen: j=9
 % @NC   97   86	x9 = 0	27961386.382548
 % @NC   98   86	x9 = 1	27969629.973929
 %      86    38 27935704.2919               27936195.7767    x8 D    66    10
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ad4c4b6b40
% @LO 0.06  27.93570429187353809652 99.9000000000
% @LN 0.06  27.93619577674266807321 99.9000000000
% Resuming node 77 at  27.93619577674266807321
DEBUG CONSTRNT: LP rows=30, pool->nlprows=30, pool->npend=0
DEBUG CONSTRNT: Checking 30 LP rows (pool tracks 30, total LP rows 30)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=29, expected 29
 % @PAP adding 44 rows, 221 nz to LP
DEBUG BB: Processing node 77, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 77 LP 2 Solution, length = 27936195.776743, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.500000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.924158 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.424158 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.500000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.075842 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.500000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.424158 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.575842 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.500000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.500000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.075842 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.500000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.075842 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.575842 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 7 fractional variables
DEBUG CG: LP optimal, z=27936195.776743, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=27936195.776743, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 77 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 77
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.500000
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.924158
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.924158)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.424158
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.424158)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=1.000000
DEBUG CAREFUL: Skipping var 7: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.500000
DEBUG CAREFUL: Adding var 30 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.075842
DEBUG CAREFUL: Adding var 31 to fractional list (xi=0.075842)
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.500000
DEBUG CAREFUL: Adding var 32 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.424158
DEBUG CAREFUL: Adding var 39 to fractional list (xi=0.424158)
DEBUG CAREFUL: Found 7 fractional variables

  %  Carefully choosing branching variable, nfrac = 7
DEBUG CAREFUL: Testing fvar[0] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 1
DEBUG CAREFUL: New best var: 1
DEBUG CAREFUL: Testing fvar[1] = var 32
DEBUG CAREFUL: Calling compare_branch_vars for var 32
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 32
DEBUG CAREFUL: Testing fvar[2] = var 30
DEBUG CAREFUL: Calling compare_branch_vars for var 30
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 30
DEBUG CAREFUL: Testing fvar[3] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[4] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 3
DEBUG CAREFUL: New best var: 3
DEBUG CAREFUL: Testing fvar[5] = var 39
DEBUG CAREFUL: Calling compare_branch_vars for var 39
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 39
DEBUG CAREFUL: Testing fvar[6] = var 31
DEBUG CAREFUL: Calling compare_branch_vars for var 31
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 31
  % Initial guess is x3, Z0 = 27936195.7767427        , Z1 = 27937250.2706298        

DEBUG EVAL: Testing var 1 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=3, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=35, varin=38, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 1 = 0 gives z=28017830.155974
  % 	x1 = 0,	Z0 = 28017830.1559735        
DEBUG EVAL: First branch cutoff check: z=28017830.155974, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 1 = 1
ITER 1: row=1, varin=34, theta=1.000000, up=999999999999999983222784.000000
  % 	x1 = 1,	Z1 = 28188833.4210929        
DEBUG EVAL: Second branch cutoff check: z=28188833.421093, best_z=INF, threshold=INF
  %   New best:  x1, Z = 28017830.1559735        
DEBUG EVAL: Testing var 32 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=31, varin=38, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 32 = 0 gives z=28017830.155974
  % 	x32 = 0,	Z0 = 28017830.1559735        
DEBUG EVAL: First branch cutoff check: z=28017830.155974, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 32 = 1
ITER 1: row=31, varin=3, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=35, varin=34, theta=0.500000, up=999999999999999983222784.000000
  % 	x32 = 1,	Z1 = 28082362.2809365        
DEBUG EVAL: Second branch cutoff check: z=28082362.280936, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 30 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=32, varin=38, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 30 = 0 gives z=28017830.155974
  % 	x30 = 0,	Z0 = 28017830.1559735        
DEBUG EVAL: First branch cutoff check: z=28017830.155974, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 30 = 1
ITER 1: row=32, varin=3, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=35, varin=4, theta=1.000000, up=999999999999999983222784.000000
  % 	x30 = 1,	Z1 = 28763659.8511125        
DEBUG EVAL: Second branch cutoff check: z=28763659.851112, best_z=INF, threshold=INF
  %   New best:  x30, Z = 28017830.1559735        
DEBUG EVAL: Testing var 2 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=3, varin=30, theta=0.026376, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 1 gives z=27938760.929185
  % 	x2 = 1,	Z1 = 27938760.9291854        
DEBUG EVAL: First branch cutoff check: z=27938760.929185, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 3 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=13, varin=43, theta=1.139048, up=999999999999999983222784.000000
ITER 2: row=43, varin=42, theta=1.135761, up=999999999999999983222784.000000
ITER 3: row=42, varin=38, theta=1.315584, up=999999999999999983222784.000000
ITER 4: row=1, varin=41, theta=0.263913, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 3 = 1 gives z=28047793.241838
  % 	x3 = 1,	Z1 = 28047793.2418381        
DEBUG EVAL: First branch cutoff check: z=28047793.241838, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 3 = 0
ITER 1: row=13, varin=30, theta=0.102837, up=999999999999999983222784.000000
ITER 2: row=3, varin=44, theta=102350.500000, up=999999999999999983222784.000000
  % 	x3 = 0,	Z0 = 28024974.3370937        
DEBUG EVAL: Second branch cutoff check: z=28024974.337094, best_z=INF, threshold=INF
  %   New best:  x3, Z = 28024974.3370937        
DEBUG EVAL: Testing var 39 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=40, varin=43, theta=1.139048, up=999999999999999983222784.000000
ITER 2: row=43, varin=42, theta=1.135761, up=999999999999999983222784.000000
ITER 3: row=42, varin=38, theta=1.315584, up=999999999999999983222784.000000
ITER 4: row=1, varin=40, theta=0.425025, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 39 = 1 gives z=28084888.190532
  % 	x39 = 1,	Z1 = 28084888.1905318        
DEBUG EVAL: First branch cutoff check: z=28084888.190532, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 39 = 0
ITER 1: row=40, varin=30, theta=0.102837, up=999999999999999983222784.000000
ITER 2: row=3, varin=44, theta=102350.500000, up=999999999999999983222784.000000
  % 	x39 = 0,	Z0 = 28024974.3370937        
DEBUG EVAL: Second branch cutoff check: z=28024974.337094, best_z=INF, threshold=INF
  %   New best:  x39, Z = 28024974.3370937        
DEBUG EVAL: Testing var 31 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=34, varin=30, theta=0.026376, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 31 = 0 gives z=27938760.929185
  % 	x31 = 0,	Z0 = 27938760.9291854        
DEBUG EVAL: First branch cutoff check: z=27938760.929185, best_z=INF, threshold=INF
  % Best branch is x39, Z0 = 28024974.3370937        , Z1 = 28084888.1905318        

DEBUG CAREFUL: Final result - returning best.var = 39
DEBUG BB: Branching variable chosen: j=39
 % @NC   99   77	x39 = 0	28024974.337094
 % @NC  100   77	x39 = 1	28084888.190532
 %      77    39 27936195.7767               27947152.6075   x22 D    59    11
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ad4c4c78e0
% @LO 0.06  27.93619577674266807321 99.9000000000
% @LN 0.06  27.94715260745892848604 99.9000000000
% Resuming node 93 at  27.94715260745892848604
DEBUG CONSTRNT: LP rows=44, pool->nlprows=44, pool->npend=0
DEBUG CONSTRNT: Checking 44 LP rows (pool tracks 44, total LP rows 44)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 142
DEBUG CONSTRNT: Pool row 142 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 134
DEBUG CONSTRNT: Pool row 134 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 20
DEBUG CONSTRNT: Pool row 20 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 130
DEBUG CONSTRNT: Pool row 130 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=43, expected 43
 % @PAP adding 38 rows, 165 nz to LP
DEBUG BB: Processing node 93, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 93 LP 2 Solution, length = 27947152.607459, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.500000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.500000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 1.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.500000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.500000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.500000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 1.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.500000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 2 fractional variables
DEBUG CG: LP optimal, z=27947152.607459, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=27947152.607459, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 93 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 93
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.500000
DEBUG CAREFUL: Adding var 0 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.500000
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=1.000000
DEBUG CAREFUL: Skipping var 2: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=1.000000
DEBUG CAREFUL: Skipping var 20: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 2 fractional variables

  %  Carefully choosing branching variable, nfrac = 2
DEBUG CAREFUL: Testing fvar[0] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 1
DEBUG CAREFUL: New best var: 1
DEBUG CAREFUL: Testing fvar[1] = var 0
DEBUG CAREFUL: Calling compare_branch_vars for var 0
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 0
  % Initial guess is x1, Z0 = 27947152.6074589        , Z1 = 27947152.6074589        

DEBUG EVAL: Testing var 1 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=13, varin=38, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 1 = 0 gives z=27961212.201222
  % 	x1 = 0,	Z0 = 27961212.2012224        
DEBUG EVAL: First branch cutoff check: z=27961212.201222, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 1 = 1
ITER 1: row=13, varin=32, theta=1.000000, up=999999999999999983222784.000000
  % 	x1 = 1,	Z1 = 28031836.5096217        
DEBUG EVAL: Second branch cutoff check: z=28031836.509622, best_z=INF, threshold=INF
  %   New best:  x1, Z = 27961212.2012224        
DEBUG EVAL: Testing var 0 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=32, varin=38, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 0 = 0 gives z=27961212.201222
  % 	x0 = 0,	Z0 = 27961212.2012224        
DEBUG EVAL: First branch cutoff check: z=27961212.201222, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 0 = 1
ITER 1: row=32, varin=13, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=33, varin=3, theta=1.000000, up=999999999999999983222784.000000
  % 	x0 = 1,	Z1 = 28287937.8979546        
DEBUG EVAL: Second branch cutoff check: z=28287937.897955, best_z=INF, threshold=INF
  %   New best:  x0, Z = 27961212.2012224        
  % Best branch is x0, Z0 = 27961212.2012224        , Z1 = 28287937.8979546        

DEBUG CAREFUL: Final result - returning best.var = 0
DEBUG BB: Branching variable chosen: j=0
 % @NC  101   93	x0 = 0	27961212.201222
 % @NC  102   93	x0 = 1	28287937.897955
 %      93    40 27947152.6075               27947758.7584    x5 D    71    10
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ad4c4b75a0
% @LO 0.07  27.94715260745892848604 99.9000000000
% @LN 0.07  27.94775875838207213064 99.9000000000
% Resuming node 30 at  27.94775875838207213064
DEBUG CONSTRNT: LP rows=38, pool->nlprows=38, pool->npend=0
DEBUG CONSTRNT: Checking 38 LP rows (pool tracks 38, total LP rows 38)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 141
DEBUG CONSTRNT: Pool row 141 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 145
DEBUG CONSTRNT: Pool row 145 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 159
DEBUG CONSTRNT: Pool row 159 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 142
DEBUG CONSTRNT: Pool row 142 has lprow=37, expected 37
 % @PAP adding 52 rows, 244 nz to LP
DEBUG BB: Processing node 30, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 30 LP 2 Solution, length = 27947758.758382, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.500000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.097900 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.097900 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.097900 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 1.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 1.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.500000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.412598 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.097900 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.097900 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.902100 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.902100 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.500000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 8 fractional variables
DEBUG CG: LP optimal, z=27947758.758382, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=27947758.758382, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 30 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 30
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.500000
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.097900
DEBUG CAREFUL: Adding var 5 to fractional list (xi=0.097900)
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.097900
DEBUG CAREFUL: Adding var 7 to fractional list (xi=0.097900)
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.097900
DEBUG CAREFUL: Adding var 9 to fractional list (xi=0.097900)
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=1.000000
DEBUG CAREFUL: Skipping var 15: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=1.000000
DEBUG CAREFUL: Skipping var 20: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.500000
DEBUG CAREFUL: Adding var 27 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.412598
DEBUG CAREFUL: Adding var 31 to fractional list (xi=0.412598)
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.097900
DEBUG CAREFUL: Adding var 34 to fractional list (xi=0.097900)
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.097900
DEBUG CAREFUL: Adding var 36 to fractional list (xi=0.097900)
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 8 fractional variables

  %  Carefully choosing branching variable, nfrac = 8
DEBUG CAREFUL: Testing fvar[0] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 2
DEBUG CAREFUL: New best var: 2
DEBUG CAREFUL: Testing fvar[1] = var 27
DEBUG CAREFUL: Calling compare_branch_vars for var 27
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 27
DEBUG CAREFUL: Testing fvar[2] = var 31
DEBUG CAREFUL: Calling compare_branch_vars for var 31
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 31
DEBUG CAREFUL: New best var: 31
DEBUG CAREFUL: Testing fvar[3] = var 9
DEBUG CAREFUL: Calling compare_branch_vars for var 9
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 9
DEBUG CAREFUL: Testing fvar[4] = var 7
DEBUG CAREFUL: Calling compare_branch_vars for var 7
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 7
DEBUG CAREFUL: Testing fvar[5] = var 5
DEBUG CAREFUL: Calling compare_branch_vars for var 5
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 5
DEBUG CAREFUL: New best var: 5
DEBUG CAREFUL: Testing fvar[6] = var 34
DEBUG CAREFUL: Calling compare_branch_vars for var 34
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 34
DEBUG CAREFUL: Testing fvar[7] = var 36
DEBUG CAREFUL: Calling compare_branch_vars for var 36
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 36
  % Initial guess is x5, Z0 = 27947758.7583821        , Z1 = 28167025.8857567        

DEBUG EVAL: Testing var 2 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=5, varin=24, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=43, varin=17, theta=0.208145, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 0 gives z=28533205.045953
  % 	x2 = 0,	Z0 = 28533205.0459532        
DEBUG EVAL: First branch cutoff check: z=28533205.045953, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 1
ITER 1: row=5, varin=45, theta=1.000000, up=999999999999999983222784.000000
  % 	x2 = 1,	Z1 = 28053195.110666         
DEBUG EVAL: Second branch cutoff check: z=28053195.110666, best_z=INF, threshold=INF
  %   New best:  x2, Z = 28053195.110666         
DEBUG EVAL: Testing var 27 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=24, varin=45, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 27 = 0 gives z=28053195.110666
  % 	x27 = 0,	Z0 = 28053195.110666         
DEBUG EVAL: First branch cutoff check: z=28053195.110666, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 27 = 1
ITER 1: row=24, varin=12, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=43, varin=17, theta=0.491446, up=999999999999999983222784.000000
ITER 3: row=34, varin=109, theta=0.614896, up=1.000000
ITER 4: row=35, varin=83, theta=0.507774, up=1.000000
ITER 5: row=38, varin=54, theta=0.212228, up=1.000000
ITER 6: row=12, varin=31, theta=0.453793, up=999999999999999983222784.000000
ITER 7: row=35, varin=35, theta=0.167454, up=999999999999999983222784.000000
ITER 8: row=1, varin=8, theta=0.277712, up=999999999999999983222784.000000
ITER 9: row=6, varin=75, theta=0.212437, up=1.000000
ITER 10: row=25, varin=44, theta=0.258651, up=999999999999999983222784.000000
  % 	x27 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: Second branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=24, varin=45, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 28053195.110666
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 52 rows, 60 cols, 304 nonzeros, 1 slack, 51 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
   % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=52, varin=17, theta=0.469138, up=999999999999999983222784.000000
ITER 2: row=34, varin=109, theta=0.558083, up=1.000000
ITER 3: row=35, varin=83, theta=0.460858, up=1.000000
ITER 4: row=38, varin=54, theta=0.192620, up=1.000000
ITER 5: row=40, varin=31, theta=0.398943, up=999999999999999983222784.000000
ITER 6: row=35, varin=50, theta=0.093094, up=999999999999999983222784.000000
ITER 7: row=5, varin=35, theta=0.139519, up=999999999999999983222784.000000
ITER 8: row=1, varin=24, theta=0.426890, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=8)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 28372092.270903
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 52 rows, 60 cols, 304 nonzeros, 4 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 4 slack rows
   % @PAP adding 5 rows, 14 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=52, varin=86, theta=1.000000, up=1.000000
ITER 2: row=50, varin=54, theta=0.500000, up=1.000000
ITER 3: row=53, varin=8, theta=0.834346, up=999999999999999983222784.000000
ITER 4: row=6, varin=84, theta=1.861930, up=1.000000
ITER 5: row=6, varin=52, theta=0.518436, up=999999999999999983222784.000000
ITER 6: row=52, varin=65, theta=2.160970, up=1.000000
ITER 7: row=52, varin=60, theta=1.848245, up=1.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=53)
DEBUG SOLUTION: LP solution array indices: FST[54-93], not_covered[94-113]
DEBUG SOLUTION: lp->best_solution[0] = 999999999999999983222784.000000
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 53 rows, 60 cols, 310 nonzeros, 1 slack, 52 tight.
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 30 at 1000000000000000000.00000000000000000000
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ad4c4bac90
% @LO 0.07  27.94775875838207213064 99.9000000000
% @LN 0.07  27.95588344175039097195 99.9000000000
% Resuming node 40 at  27.95588344175039097195
DEBUG CONSTRNT: LP rows=53, pool->nlprows=53, pool->npend=0
DEBUG CONSTRNT: Checking 53 LP rows (pool tracks 53, total LP rows 53)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 141
DEBUG CONSTRNT: Pool row 141 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 145
DEBUG CONSTRNT: Pool row 145 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 159
DEBUG CONSTRNT: Pool row 159 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 58
DEBUG CONSTRNT: Pool row 58 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 134
DEBUG CONSTRNT: Pool row 134 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=52, expected 52
 % @PAP adding 41 rows, 172 nz to LP
DEBUG BB: Processing node 40, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=27, varin=4, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=28, varin=3, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=36, varin=35, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=1, varin=33, theta=1.250000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=41)
DEBUG SOLUTION: LP solution array indices: FST[42-81], not_covered[82-101]
DEBUG SOLUTION: lp->best_solution[0] = 27955883.441750
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 41 rows, 60 cols, 232 nonzeros, 5 slack, 36 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 40 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=42, varin=66, theta=1.098583, up=1.000000
ITER 2: row=42, varin=65, theta=0.096583, up=1.000000
ITER 3: row=33, varin=41, theta=0.035983, up=999999999999999983222784.000000
ITER 4: row=1, varin=66, theta=4.759700, up=1.000000
ITER 5: row=1, varin=75, theta=0.285918, up=1.000000
ITER 6: row=42, varin=40, theta=0.087538, up=999999999999999983222784.000000
ITER 7: row=1, varin=66, theta=0.123041, up=1.000000
ITER 8: row=20, varin=25, theta=0.068034, up=999999999999999983222784.000000
ITER 9: row=19, varin=75, theta=0.309451, up=1.000000
LP PHASE: Switching to primal (iter=9)
ITER 10: row=1, varin=65, theta=0.638034, up=1.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 27984640.791108
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 42 rows, 60 cols, 272 nonzeros, 4 slack, 38 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % @PAP adding 6 rows, 24 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=43, varin=68, theta=1.000000, up=1.000000
ITER 2: row=39, varin=47, theta=0.475139, up=1.000000
ITER 3: row=38, varin=69, theta=0.753127, up=1.000000
ITER 4: row=44, varin=23, theta=0.021468, up=999999999999999983222784.000000
ITER 5: row=42, varin=39, theta=0.251618, up=999999999999999983222784.000000
ITER 6: row=1, varin=49, theta=0.188208, up=1.000000
ITER 7: row=40, varin=48, theta=0.016746, up=1.000000
ITER 8: row=35, varin=42, theta=0.147759, up=999999999999999983222784.000000
ITER 9: row=36, varin=9, theta=0.698135, up=999999999999999983222784.000000
ITER 10: row=9, varin=97, theta=0.199505, up=1.000000
LP PHASE: Switching to primal (iter=13)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28030519.403572
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 0.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 44 rows, 60 cols, 288 nonzeros, 3 slack, 41 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 3 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=44, varin=51, theta=0.604010, up=1.000000
ITER 2: row=15, varin=78, theta=1.099938, up=1.000000
ITER 3: row=15, varin=73, theta=0.058618, up=1.000000
ITER 4: row=43, varin=77, theta=0.500000, up=1.000000
ITER 5: row=11, varin=34, theta=0.034800, up=999999999999999983222784.000000
ITER 6: row=16, varin=28, theta=0.048517, up=999999999999999983222784.000000
ITER 7: row=18, varin=78, theta=0.337280, up=1.000000
LP PHASE: Switching to primal (iter=7)
ITER 8: row=28, varin=49, theta=0.000000, up=1.000000
ITER 9: row=34, varin=55, theta=0.000000, up=1.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28237881.942667
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 0.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 44 rows, 60 cols, 271 nonzeros, 0 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 7 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=45, varin=50, theta=0.054802, up=1.000000
ITER 2: row=46, varin=103, theta=0.830204, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=46)
DEBUG SOLUTION: LP solution array indices: FST[47-86], not_covered[87-106]
DEBUG SOLUTION: lp->best_solution[0] = 28288263.432188
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 0.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 46 rows, 60 cols, 278 nonzeros, 0 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 40 LP 1 Solution, length = 28288263.432188, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 1.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.500000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.033959 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.033959 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.033959 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.033959 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.033959 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.830204 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.830204 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.033959 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.500000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.500000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.966041 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.500000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.966041 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.500000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.966041 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.966041 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 0.169796 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.966041 (terminal 19)
 % 11 fractional variables
DEBUG CG: LP optimal, z=28288263.432188, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 40 at  28.28826343218806727009
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ad4c4c70b0
% @LO 0.07  27.95588344175039097195 99.9000000000
% @LN 0.07  27.95738335660372797520 99.9000000000
% Resuming node 73 at  27.95738335660372797520
DEBUG CONSTRNT: LP rows=46, pool->nlprows=46, pool->npend=0
DEBUG CONSTRNT: Checking 46 LP rows (pool tracks 46, total LP rows 46)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 142
DEBUG CONSTRNT: Pool row 142 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 133
DEBUG CONSTRNT: Pool row 133 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 135
DEBUG CONSTRNT: Pool row 135 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=45, expected 45
 % @PAP adding 38 rows, 182 nz to LP
DEBUG BB: Processing node 73, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 73 LP 2 Solution, length = 27957383.356604, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 1.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.236177 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.236177 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.236177 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.236177 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.236177 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 1.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.055293 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.236177 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.236177 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.763823 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.763823 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.763823 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.763823 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.763823 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.763823 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.763823 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.763823 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 8 fractional variables
DEBUG CG: LP optimal, z=27957383.356604, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=27957383.356604, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 73 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 73
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=1.000000
DEBUG CAREFUL: Skipping var 1: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=1.000000
DEBUG CAREFUL: Skipping var 2: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.236177
DEBUG CAREFUL: Adding var 5 to fractional list (xi=0.236177)
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.236177
DEBUG CAREFUL: Adding var 8 to fractional list (xi=0.236177)
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.236177
DEBUG CAREFUL: Adding var 9 to fractional list (xi=0.236177)
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.236177
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.236177)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.236177
DEBUG CAREFUL: Adding var 12 to fractional list (xi=0.236177)
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=1.000000
DEBUG CAREFUL: Skipping var 17: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.055293
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.055293)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.236177
DEBUG CAREFUL: Adding var 34 to fractional list (xi=0.236177)
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.236177
DEBUG CAREFUL: Adding var 36 to fractional list (xi=0.236177)
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 8 fractional variables

  %  Carefully choosing branching variable, nfrac = 8
DEBUG CAREFUL: Testing fvar[0] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 26
DEBUG CAREFUL: New best var: 26
DEBUG CAREFUL: Testing fvar[1] = var 9
DEBUG CAREFUL: Calling compare_branch_vars for var 9
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 9
DEBUG CAREFUL: Testing fvar[2] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[3] = var 34
DEBUG CAREFUL: Calling compare_branch_vars for var 34
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 34
DEBUG CAREFUL: Testing fvar[4] = var 12
DEBUG CAREFUL: Calling compare_branch_vars for var 12
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 12
DEBUG CAREFUL: New best var: 12
DEBUG CAREFUL: Testing fvar[5] = var 8
DEBUG CAREFUL: Calling compare_branch_vars for var 8
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 8
DEBUG CAREFUL: New best var: 8
DEBUG CAREFUL: Testing fvar[6] = var 36
DEBUG CAREFUL: Calling compare_branch_vars for var 36
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 36
DEBUG CAREFUL: Testing fvar[7] = var 5
DEBUG CAREFUL: Calling compare_branch_vars for var 5
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 5
  % Initial guess is x8, Z0 = 27957383.3566037        , Z1 = 28361260.7517958        

DEBUG EVAL: Testing var 26 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=16, varin=37, theta=1.308099, up=999999999999999983222784.000000
ITER 2: row=21, varin=35, theta=1.025007, up=999999999999999983222784.000000
ITER 3: row=35, varin=34, theta=0.480834, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 26 = 1 gives z=28011782.230807
  % 	x26 = 1,	Z1 = 28011782.2308071        
DEBUG EVAL: First branch cutoff check: z=28011782.230807, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 26 = 0
ITER 1: row=16, varin=57, theta=0.031390, up=1.000000
ITER 2: row=24, varin=45, theta=0.032718, up=1.000000
  % 	x26 = 0,	Z0 = 27957849.2674718        
DEBUG EVAL: Second branch cutoff check: z=27957849.267472, best_z=INF, threshold=INF
  %   New best:  x26, Z = 27957849.2674718        
DEBUG EVAL: Testing var 9 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=13, varin=57, theta=0.762758, up=1.000000
ITER 2: row=16, varin=34, theta=0.306388, up=999999999999999983222784.000000
ITER 3: row=24, varin=45, theta=0.149268, up=1.000000
DEBUG EVAL: Branch var 9 = 0 gives z=27991916.945974
  % 	x9 = 0,	Z0 = 27991916.9459739        
DEBUG EVAL: First branch cutoff check: z=27991916.945974, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 9 = 1
ITER 1: row=13, varin=33, theta=1.588557, up=999999999999999983222784.000000
ITER 2: row=38, varin=37, theta=1.388066, up=999999999999999983222784.000000
ITER 3: row=32, varin=38, theta=10.998118, up=999999999999999983222784.000000
ITER 4: row=21, varin=35, theta=8.704854, up=999999999999999983222784.000000
ITER 5: row=35, varin=41, theta=5.348475, up=1.000000
ITER 6: row=35, varin=30, theta=2.536105, up=999999999999999983222784.000000
ITER 7: row=1, varin=28, theta=2.252722, up=999999999999999983222784.000000
ITER 8: row=11, varin=15, theta=1.002356, up=999999999999999983222784.000000
ITER 9: row=16, varin=66, theta=1.038421, up=1.000000
ITER 10: row=16, varin=60, theta=0.034018, up=1.000000
  % 	x9 = 1,	Z1 = 28670461.2115338        
DEBUG EVAL: Second branch cutoff check: z=28670461.211534, best_z=INF, threshold=INF
  %   New best:  x9, Z = 27991916.9459739        
DEBUG EVAL: Testing var 10 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=11, varin=57, theta=0.762758, up=1.000000
ITER 2: row=16, varin=28, theta=0.239141, up=999999999999999983222784.000000
ITER 3: row=24, varin=65, theta=0.181502, up=1.000000
DEBUG EVAL: Branch var 10 = 0 gives z=27979145.374635
  % 	x10 = 0,	Z0 = 27979145.3746351        
DEBUG EVAL: First branch cutoff check: z=27979145.374635, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 34 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=21, varin=33, theta=1.588557, up=999999999999999983222784.000000
ITER 2: row=38, varin=35, theta=9.575503, up=999999999999999983222784.000000
ITER 3: row=35, varin=34, theta=1.902266, up=999999999999999983222784.000000
ITER 4: row=28, varin=41, theta=2.823506, up=1.000000
ITER 5: row=28, varin=30, theta=1.063500, up=999999999999999983222784.000000
ITER 6: row=20, varin=41, theta=1.000000, up=1.000000
ITER 7: row=1, varin=28, theta=0.948420, up=999999999999999983222784.000000
ITER 8: row=11, varin=15, theta=0.758871, up=999999999999999983222784.000000
ITER 9: row=16, varin=66, theta=0.786176, up=1.000000
ITER 10: row=29, varin=60, theta=0.696083, up=1.000000
DEBUG EVAL: Branch var 34 = 1 gives z=28310673.706386
  % 	x34 = 1,	Z1 = 28310673.7063859        
DEBUG EVAL: First branch cutoff check: z=28310673.706386, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 34 = 0
ITER 1: row=21, varin=37, theta=0.253804, up=999999999999999983222784.000000
  % 	x34 = 0,	Z0 = 27959394.3094251        
DEBUG EVAL: Second branch cutoff check: z=27959394.309425, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 12 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=15, varin=33, theta=1.588557, up=999999999999999983222784.000000
ITER 2: row=38, varin=37, theta=1.388066, up=999999999999999983222784.000000
ITER 3: row=32, varin=38, theta=10.998118, up=999999999999999983222784.000000
ITER 4: row=21, varin=34, theta=0.826213, up=999999999999999983222784.000000
ITER 5: row=16, varin=73, theta=0.455377, up=1.000000
ITER 6: row=32, varin=45, theta=0.125397, up=1.000000
DEBUG EVAL: Branch var 12 = 1 gives z=28072602.056590
  % 	x12 = 1,	Z1 = 28072602.0565903        
DEBUG EVAL: First branch cutoff check: z=28072602.056590, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 12 = 0
ITER 1: row=15, varin=57, theta=0.762758, up=1.000000
ITER 2: row=16, varin=18, theta=0.249396, up=999999999999999983222784.000000
ITER 3: row=24, varin=65, theta=0.001362, up=1.000000
  % 	x12 = 0,	Z0 = 27985340.7622063        
DEBUG EVAL: Second branch cutoff check: z=27985340.762206, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 8 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=5, varin=37, theta=10.998118, up=999999999999999983222784.000000
ITER 2: row=21, varin=35, theta=8.704854, up=999999999999999983222784.000000
ITER 3: row=35, varin=34, theta=1.709134, up=999999999999999983222784.000000
ITER 4: row=16, varin=41, theta=2.219127, up=1.000000
ITER 5: row=16, varin=75, theta=1.400484, up=1.000000
ITER 6: row=16, varin=73, theta=0.363037, up=1.000000
DEBUG EVAL: Branch var 8 = 1 gives z=28150611.961111
  % 	x8 = 1,	Z1 = 28361260.7517958        
DEBUG EVAL: First branch cutoff check: z=28361260.751796, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 8 = 0
ITER 1: row=5, varin=57, theta=0.762758, up=1.000000
  % 	x8 = 0,	Z0 = 27960985.1457279        
DEBUG EVAL: Second branch cutoff check: z=27960985.145728, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 36 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=35, varin=35, theta=0.256649, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 36 = 0 gives z=27960671.096546
  % 	x36 = 0,	Z0 = 27960671.0965458        
DEBUG EVAL: First branch cutoff check: z=27960671.096546, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 5 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=57, theta=0.762758, up=1.000000
DEBUG EVAL: Branch var 5 = 0 gives z=27960985.145728
  % 	x5 = 0,	Z0 = 27960985.1457279        
DEBUG EVAL: First branch cutoff check: z=27960985.145728, best_z=INF, threshold=INF
  % Best branch is x9, Z0 = 27991916.9459739        , Z1 = 28670461.2115338        

DEBUG CAREFUL: Final result - returning best.var = 9
DEBUG BB: Branching variable chosen: j=9
 % @NC  103   73	x9 = 0	27991916.945974
 % @NC  104   73	x9 = 1	28670461.211534
 %      73    41 27957383.3566               27958692.5047   x14 D    47     9
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ad4c4c9450
% @LO 0.07  27.95738335660372797520 99.9000000000
% @LN 0.07  27.95869250467187328013 99.9000000000
% Resuming node 70 at  27.95869250467187328013
DEBUG CONSTRNT: LP rows=38, pool->nlprows=38, pool->npend=0
DEBUG CONSTRNT: Checking 38 LP rows (pool tracks 38, total LP rows 38)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 79
DEBUG CONSTRNT: Pool row 79 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 45
DEBUG CONSTRNT: Pool row 45 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 142
DEBUG CONSTRNT: Pool row 142 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 133
DEBUG CONSTRNT: Pool row 133 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 62
DEBUG CONSTRNT: Pool row 62 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 63
DEBUG CONSTRNT: Pool row 63 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 71
DEBUG CONSTRNT: Pool row 71 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=37, expected 37
 % @PAP adding 35 rows, 191 nz to LP
DEBUG BB: Processing node 70, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=5, varin=34, theta=33.254034, up=999999999999999983222784.000000
ITER 2: row=22, varin=62, theta=4.791923, up=1.000000
ITER 3: row=22, varin=38, theta=2.291756, up=1.000000
ITER 4: row=22, varin=63, theta=2.333251, up=1.000000
ITER 5: row=22, varin=57, theta=1.002640, up=1.000000
ITER 6: row=22, varin=65, theta=0.003754, up=1.000000
ITER 7: row=18, varin=19, theta=1.273110, up=999999999999999983222784.000000
ITER 8: row=22, varin=57, theta=2.404124, up=1.000000
ITER 9: row=22, varin=63, theta=1.558179, up=1.000000
ITER 10: row=22, varin=62, theta=0.541659, up=1.000000
LP PHASE: Switching to primal (iter=11)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=35)
DEBUG SOLUTION: LP solution array indices: FST[36-75], not_covered[76-95]
DEBUG SOLUTION: lp->best_solution[0] = 27958692.504672
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.327835
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 35 rows, 60 cols, 251 nonzeros, 3 slack, 32 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 4 rows, 17 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=33, varin=39, theta=1.000000, up=1.000000
ITER 2: row=35, varin=64, theta=2.250273, up=1.000000
ITER 3: row=35, varin=58, theta=0.931675, up=1.000000
ITER 4: row=13, varin=64, theta=3.656171, up=1.000000
ITER 5: row=13, varin=26, theta=0.407858, up=999999999999999983222784.000000
ITER 6: row=35, varin=64, theta=1.177253, up=1.000000
ITER 7: row=35, varin=66, theta=0.194227, up=1.000000
ITER 8: row=26, varin=17, theta=0.365899, up=999999999999999983222784.000000
ITER 9: row=17, varin=60, theta=2.831925, up=1.000000
ITER 10: row=17, varin=59, theta=0.337539, up=1.000000
LP PHASE: Switching to primal (iter=15)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=36)
DEBUG SOLUTION: LP solution array indices: FST[37-76], not_covered[77-96]
DEBUG SOLUTION: lp->best_solution[0] = 28226075.615663
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.236330
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 36 rows, 60 cols, 262 nonzeros, 2 slack, 34 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 3 rows, 10 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=37, varin=59, theta=1.000000, up=1.000000
ITER 2: row=36, varin=60, theta=1.226564, up=1.000000
ITER 3: row=36, varin=12, theta=0.255062, up=999999999999999983222784.000000
ITER 4: row=22, varin=60, theta=1.000000, up=1.000000
ITER 5: row=5, varin=61, theta=1.078341, up=1.000000
ITER 6: row=5, varin=52, theta=0.225805, up=1.000000
ITER 7: row=35, varin=65, theta=1.000000, up=1.000000
ITER 8: row=6, varin=36, theta=2.420506, up=999999999999999983222784.000000
ITER 9: row=12, varin=67, theta=0.808070, up=1.000000
ITER 10: row=30, varin=62, theta=0.584779, up=1.000000
LP PHASE: Switching to primal (iter=14)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=37)
DEBUG SOLUTION: LP solution array indices: FST[38-77], not_covered[78-97]
DEBUG SOLUTION: lp->best_solution[0] = 28532489.792164
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.839213
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 37 rows, 60 cols, 260 nonzeros, 2 slack, 35 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 9 rows, 28 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=36, varin=68, theta=1.000000, up=1.000000
ITER 2: row=39, varin=33, theta=1.348523, up=999999999999999983222784.000000
ITER 3: row=41, varin=86, theta=1.671387, up=1.000000
ITER 4: row=41, varin=8, theta=3.142860, up=999999999999999983222784.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 999999999999999983222784.000000
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.839213
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 44 rows, 60 cols, 284 nonzeros, 2 slack, 42 tight.
  % Node 70 LP 1 Solution, length = 999999999999999983222784.000000, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 1.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 1.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 1.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 1.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.356854 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.803933 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.839213 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
DEBUG BB: compute_good_lower_bound returned status=1
DEBUG BB: Node 70 is INFEASIBLE
 %      70    40    infeasible               27961212.2012    x9 U    55     9
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ad4c4b6b40
% @LO 0.07  27.95869250467187328013 99.9000000000
% @LN 0.07  27.96121220122238781869 99.9000000000
% Resuming node 101 at  27.96121220122238781869
DEBUG CONSTRNT: LP rows=44, pool->nlprows=44, pool->npend=0
DEBUG CONSTRNT: Checking 44 LP rows (pool tracks 44, total LP rows 44)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 58
DEBUG CONSTRNT: Pool row 58 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=43, expected 43
 % @PAP adding 38 rows, 165 nz to LP
DEBUG BB: Processing node 101, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=32, varin=38, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=38)
DEBUG SOLUTION: LP solution array indices: FST[39-78], not_covered[79-98]
DEBUG SOLUTION: lp->best_solution[0] = 27961212.201222
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 38 rows, 60 cols, 225 nonzeros, 1 slack, 37 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 101 LP 1 Solution, length = 27961212.201222, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 1.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 1.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 0 fractional variables
DEBUG CG: LP optimal, z=27961212.201222, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG IFS: Budget mode - accepting integer solution with 2 edges covering 7 vertices
DEBUG CG: integer_feasible_solution returned: TRUE
DEBUG CG: Solution is integer feasible, returning LB_INTEGRAL
DEBUG BB: compute_good_lower_bound returned status=3
DEBUG BB: Node 101 is INTEGRAL (integer solution found)
 %  	=== 39 nodes cut off ===
 % @UO 0.07   8.46121220122238604233 -230.4634316722
 % @UN 0.07   8.46121220122238604233 -230.4634316722
DEBUG BB: Calling heuristic UB for integer solution, current best_z=8461212.201222
DEBUG BB: Heuristic did not improve integer solution
 % *   101     0  8461212.2012  8461212.2012                  x0 D    93    11
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=(nil)
DEBUG BB: No more nodes to process, exiting

 % Certificate of solution:
 % @C	.4767008182741058	.2081993675729823
 % @C	.9346545514704401	.5030260596239182
 % @C	.8743159763680044	.2782542139644725
 % @C	.9603074535474138	.1921833678795793
%%Page: 1 1
BeginPlot
	Plot_Terminals
 % fs2: 13 0 6
	13 T	.4767008182741058	.2081993675729823	S
	.4767008182741058	.2081993675729823	0 T	S
	.4767008182741058	.2081993675729823	6 T	S
 % fs20: 19 15 3 6 12
	19 T	.9346545514704401	.5030260596239182	S
	.9346545514704401	.5030260596239182	.8743159763680044	.2782542139644725	S
	.8743159763680044	.2782542139644725	.9603074535474138	.1921833678795793	S
	.9603074535474138	.1921833678795793	15 T	S
	.9603074535474138	.1921833678795793	3 T	S
	.8743159763680044	.2782542139644725	6 T	S
	.9346545514704401	.5030260596239182	12 T	S
  (Euclidean SMT:  20 points,  length = 8.461212201222386,  0.07 seconds)
EndPlot

% @0 Euclidean SMT
% N M Nodes LPs P1CPU P2CPU TotCPU
% @1 20 40 78 122 0.00 0.07 0.07
% Z RootZ %Gap RootLPs RootCPU RedMST
% @2 8.461212201222386 27071883.767022 -219.95278 2 0.00 -170.6050
% InitPRows InitPNZ InitLPRows InitLPNZ
% @3 163 594 135 555
% RootPRows RootPNZ RootLPRows RootLPNZ
% @4 164 606 28 238
% FinalPRows FinalPNZ FinalLPRows FinalLPNZ
% @5 164 606 38 225
% SMTFSTs SMTAvgFSTSz SMTMaxFSTSz #2FSTs #3FSTs ... #10FSTS #>10FSTs
% @6 2 4.000000 5 0 1 0 1 0 0 0 0 0 0
