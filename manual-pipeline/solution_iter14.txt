 % ./bb
 % Args:
DEBUG P1READ: Terminal 0 battery=100.00
DEBUG P1READ: Terminal 1 battery=82.00
DEBUG P1READ: Terminal 2 battery=98.00
DEBUG P1READ: Terminal 3 battery=98.00
DEBUG P1READ: Terminal 4 battery=96.00
DEBUG P1READ: Terminal 5 battery=87.50
DEBUG P1READ: Terminal 6 battery=98.00
DEBUG P1READ: Terminal 7 battery=100.00
DEBUG P1READ: Terminal 8 battery=100.00
DEBUG P1READ: Terminal 9 battery=100.00
DEBUG P1READ: Terminal 10 battery=90.20
DEBUG P1READ: Terminal 11 battery=46.70
DEBUG P1READ: Terminal 12 battery=98.00
DEBUG P1READ: Terminal 13 battery=89.90
DEBUG P1READ: Terminal 14 battery=60.30
DEBUG P1READ: Terminal 15 battery=98.00
DEBUG P1READ: Terminal 16 battery=68.00
DEBUG P1READ: Terminal 17 battery=100.00
DEBUG P1READ: Terminal 18 battery=100.00
DEBUG P1READ: Terminal 19 battery=98.00
DEBUG HG: num_verts=20, num_edges=40
 % Phase 1: 0.00 seconds

%%BeginSetup

0 1 0 1 SetAxes

20 DefineTerminals
	.4588350000000000	.2373240000000000	DT
	.1270640000000000	.3509960000000000	DT
	.1544540000000000	.4808220000000000	DT
	.9474030000000000	.1441120000000000	DT
	.2867390000000000	.0565890000000000	DT
	.1326890000000000	.1166050000000000	DT
	.6273950000000000	.2122140000000000	DT
	.0794880000000000	.7970990000000000	DT
	.0327480000000000	.8803250000000000	DT
	.3110550000000000	.8689670000000000	DT
	.0916180000000000	.0221720000000000	DT
	.3600710000000000	.6382240000000000	DT
	.7197120000000000	.7181670000000000	DT
	.4424420000000000	.1450340000000000	DT
	.9983770000000000	.5729870000000000	DT
	.9654920000000000	.1935700000000000	DT
	.1600100000000000	.4187950000000000	DT
	.2909450000000000	.9620800000000000	DT
	.3330000000000000	.9414120000000000	DT
	.9512590000000000	.5074670000000000	DT

%%EndSetup

DEBUG ALGO: num_verts=20 <= 8? NO, num_edges=40 <= 12? NO
DEBUG ALGO: Forcing BRANCH-AND-CUT for multi-objective optimization (vertices=20 > 1)
DEBUG SPANNING: Adding modified spanning constraint for budget mode
DEBUG SPANNING: Added modified spanning constraint: Σ(|FST|-1)*x + Σnot_covered = 19
DEBUG CONSTRAINT: Adding soft cutset constraints with not_covered variables
DEBUG CONSTRAINT: Added constraint x[2] + not_covered[0] ≤ 1 for terminal 0
DEBUG CONSTRAINT: Added constraint x[27] + not_covered[0] ≤ 1 for terminal 0
DEBUG CONSTRAINT: Added constraint x[31] + not_covered[0] ≤ 1 for terminal 0
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 3·not_covered[0] ≤ 3 for terminal 0
DEBUG CONSTRAINT: Added constraint x[0] + not_covered[1] ≤ 1 for terminal 1
DEBUG CONSTRAINT: Added constraint x[24] + not_covered[1] ≤ 1 for terminal 1
DEBUG CONSTRAINT: Added constraint x[33] + not_covered[1] ≤ 1 for terminal 1
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 3·not_covered[1] ≤ 3 for terminal 1
DEBUG CONSTRAINT: Added constraint x[5] + not_covered[2] ≤ 1 for terminal 2
DEBUG CONSTRAINT: Added constraint x[7] + not_covered[2] ≤ 1 for terminal 2
DEBUG CONSTRAINT: Added constraint x[16] + not_covered[2] ≤ 1 for terminal 2
DEBUG CONSTRAINT: Added constraint x[23] + not_covered[2] ≤ 1 for terminal 2
DEBUG CONSTRAINT: Added constraint x[36] + not_covered[2] ≤ 1 for terminal 2
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 5·not_covered[2] ≤ 5 for terminal 2
DEBUG CONSTRAINT: Added constraint x[3] + not_covered[3] ≤ 1 for terminal 3
DEBUG CONSTRAINT: Added constraint x[4] + not_covered[3] ≤ 1 for terminal 3
DEBUG CONSTRAINT: Added constraint x[17] + not_covered[3] ≤ 1 for terminal 3
DEBUG CONSTRAINT: Added constraint x[20] + not_covered[3] ≤ 1 for terminal 3
DEBUG CONSTRAINT: Added constraint x[22] + not_covered[3] ≤ 1 for terminal 3
DEBUG CONSTRAINT: Added constraint x[39] + not_covered[3] ≤ 1 for terminal 3
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 6·not_covered[3] ≤ 6 for terminal 3
DEBUG CONSTRAINT: Added constraint x[0] + not_covered[4] ≤ 1 for terminal 4
DEBUG CONSTRAINT: Added constraint x[1] + not_covered[4] ≤ 1 for terminal 4
DEBUG CONSTRAINT: Added constraint x[30] + not_covered[4] ≤ 1 for terminal 4
DEBUG CONSTRAINT: Added constraint x[32] + not_covered[4] ≤ 1 for terminal 4
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 4·not_covered[4] ≤ 4 for terminal 4
DEBUG CONSTRAINT: Added constraint x[0] + not_covered[5] ≤ 1 for terminal 5
DEBUG CONSTRAINT: Added constraint x[1] + not_covered[5] ≤ 1 for terminal 5
DEBUG CONSTRAINT: Added constraint x[29] + not_covered[5] ≤ 1 for terminal 5
DEBUG CONSTRAINT: Added constraint x[30] + not_covered[5] ≤ 1 for terminal 5
DEBUG CONSTRAINT: Added constraint x[33] + not_covered[5] ≤ 1 for terminal 5
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 5·not_covered[5] ≤ 5 for terminal 5
DEBUG CONSTRAINT: Added constraint x[2] + not_covered[6] ≤ 1 for terminal 6
DEBUG CONSTRAINT: Added constraint x[3] + not_covered[6] ≤ 1 for terminal 6
DEBUG CONSTRAINT: Added constraint x[4] + not_covered[6] ≤ 1 for terminal 6
DEBUG CONSTRAINT: Added constraint x[11] + not_covered[6] ≤ 1 for terminal 6
DEBUG CONSTRAINT: Added constraint x[17] + not_covered[6] ≤ 1 for terminal 6
DEBUG CONSTRAINT: Added constraint x[18] + not_covered[6] ≤ 1 for terminal 6
DEBUG CONSTRAINT: Added constraint x[20] + not_covered[6] ≤ 1 for terminal 6
DEBUG CONSTRAINT: Added constraint x[31] + not_covered[6] ≤ 1 for terminal 6
DEBUG CONSTRAINT: Added constraint x[39] + not_covered[6] ≤ 1 for terminal 6
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 9·not_covered[6] ≤ 9 for terminal 6
DEBUG CONSTRAINT: Added constraint x[5] + not_covered[7] ≤ 1 for terminal 7
DEBUG CONSTRAINT: Added constraint x[6] + not_covered[7] ≤ 1 for terminal 7
DEBUG CONSTRAINT: Added constraint x[8] + not_covered[7] ≤ 1 for terminal 7
DEBUG CONSTRAINT: Added constraint x[13] + not_covered[7] ≤ 1 for terminal 7
DEBUG CONSTRAINT: Added constraint x[14] + not_covered[7] ≤ 1 for terminal 7
DEBUG CONSTRAINT: Added constraint x[15] + not_covered[7] ≤ 1 for terminal 7
DEBUG CONSTRAINT: Added constraint x[16] + not_covered[7] ≤ 1 for terminal 7
DEBUG CONSTRAINT: Added constraint x[19] + not_covered[7] ≤ 1 for terminal 7
DEBUG CONSTRAINT: Added constraint x[28] + not_covered[7] ≤ 1 for terminal 7
DEBUG CONSTRAINT: Added constraint x[35] + not_covered[7] ≤ 1 for terminal 7
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 10·not_covered[7] ≤ 10 for terminal 7
DEBUG CONSTRAINT: Added constraint x[6] + not_covered[8] ≤ 1 for terminal 8
DEBUG CONSTRAINT: Added constraint x[13] + not_covered[8] ≤ 1 for terminal 8
DEBUG CONSTRAINT: Added constraint x[14] + not_covered[8] ≤ 1 for terminal 8
DEBUG CONSTRAINT: Added constraint x[19] + not_covered[8] ≤ 1 for terminal 8
DEBUG CONSTRAINT: Added constraint x[28] + not_covered[8] ≤ 1 for terminal 8
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 5·not_covered[8] ≤ 5 for terminal 8
DEBUG CONSTRAINT: Added constraint x[6] + not_covered[9] ≤ 1 for terminal 9
DEBUG CONSTRAINT: Added constraint x[7] + not_covered[9] ≤ 1 for terminal 9
DEBUG CONSTRAINT: Added constraint x[8] + not_covered[9] ≤ 1 for terminal 9
DEBUG CONSTRAINT: Added constraint x[9] + not_covered[9] ≤ 1 for terminal 9
DEBUG CONSTRAINT: Added constraint x[12] + not_covered[9] ≤ 1 for terminal 9
DEBUG CONSTRAINT: Added constraint x[13] + not_covered[9] ≤ 1 for terminal 9
DEBUG CONSTRAINT: Added constraint x[14] + not_covered[9] ≤ 1 for terminal 9
DEBUG CONSTRAINT: Added constraint x[15] + not_covered[9] ≤ 1 for terminal 9
DEBUG CONSTRAINT: Added constraint x[16] + not_covered[9] ≤ 1 for terminal 9
DEBUG CONSTRAINT: Added constraint x[19] + not_covered[9] ≤ 1 for terminal 9
DEBUG CONSTRAINT: Added constraint x[25] + not_covered[9] ≤ 1 for terminal 9
DEBUG CONSTRAINT: Added constraint x[34] + not_covered[9] ≤ 1 for terminal 9
DEBUG CONSTRAINT: Added constraint x[35] + not_covered[9] ≤ 1 for terminal 9
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 13·not_covered[9] ≤ 13 for terminal 9
DEBUG CONSTRAINT: Added constraint x[1] + not_covered[10] ≤ 1 for terminal 10
DEBUG CONSTRAINT: Added constraint x[29] + not_covered[10] ≤ 1 for terminal 10
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 2·not_covered[10] ≤ 2 for terminal 10
DEBUG CONSTRAINT: Added constraint x[5] + not_covered[11] ≤ 1 for terminal 11
DEBUG CONSTRAINT: Added constraint x[7] + not_covered[11] ≤ 1 for terminal 11
DEBUG CONSTRAINT: Added constraint x[8] + not_covered[11] ≤ 1 for terminal 11
DEBUG CONSTRAINT: Added constraint x[9] + not_covered[11] ≤ 1 for terminal 11
DEBUG CONSTRAINT: Added constraint x[13] + not_covered[11] ≤ 1 for terminal 11
DEBUG CONSTRAINT: Added constraint x[16] + not_covered[11] ≤ 1 for terminal 11
DEBUG CONSTRAINT: Added constraint x[34] + not_covered[11] ≤ 1 for terminal 11
DEBUG CONSTRAINT: Added constraint x[36] + not_covered[11] ≤ 1 for terminal 11
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 8·not_covered[11] ≤ 8 for terminal 11
DEBUG CONSTRAINT: Added constraint x[9] + not_covered[12] ≤ 1 for terminal 12
DEBUG CONSTRAINT: Added constraint x[10] + not_covered[12] ≤ 1 for terminal 12
DEBUG CONSTRAINT: Added constraint x[18] + not_covered[12] ≤ 1 for terminal 12
DEBUG CONSTRAINT: Added constraint x[20] + not_covered[12] ≤ 1 for terminal 12
DEBUG CONSTRAINT: Added constraint x[37] + not_covered[12] ≤ 1 for terminal 12
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 5·not_covered[12] ≤ 5 for terminal 12
DEBUG CONSTRAINT: Added constraint x[2] + not_covered[13] ≤ 1 for terminal 13
DEBUG CONSTRAINT: Added constraint x[27] + not_covered[13] ≤ 1 for terminal 13
DEBUG CONSTRAINT: Added constraint x[32] + not_covered[13] ≤ 1 for terminal 13
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 3·not_covered[13] ≤ 3 for terminal 13
DEBUG CONSTRAINT: Added constraint x[10] + not_covered[14] ≤ 1 for terminal 14
DEBUG CONSTRAINT: Added constraint x[26] + not_covered[14] ≤ 1 for terminal 14
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 2·not_covered[14] ≤ 2 for terminal 14
DEBUG CONSTRAINT: Added constraint x[3] + not_covered[15] ≤ 1 for terminal 15
DEBUG CONSTRAINT: Added constraint x[11] + not_covered[15] ≤ 1 for terminal 15
DEBUG CONSTRAINT: Added constraint x[17] + not_covered[15] ≤ 1 for terminal 15
DEBUG CONSTRAINT: Added constraint x[18] + not_covered[15] ≤ 1 for terminal 15
DEBUG CONSTRAINT: Added constraint x[20] + not_covered[15] ≤ 1 for terminal 15
DEBUG CONSTRAINT: Added constraint x[22] + not_covered[15] ≤ 1 for terminal 15
DEBUG CONSTRAINT: Added constraint x[38] + not_covered[15] ≤ 1 for terminal 15
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 7·not_covered[15] ≤ 7 for terminal 15
DEBUG CONSTRAINT: Added constraint x[23] + not_covered[16] ≤ 1 for terminal 16
DEBUG CONSTRAINT: Added constraint x[24] + not_covered[16] ≤ 1 for terminal 16
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 2·not_covered[16] ≤ 2 for terminal 16
DEBUG CONSTRAINT: Added constraint x[12] + not_covered[17] ≤ 1 for terminal 17
DEBUG CONSTRAINT: Added constraint x[15] + not_covered[17] ≤ 1 for terminal 17
DEBUG CONSTRAINT: Added constraint x[19] + not_covered[17] ≤ 1 for terminal 17
DEBUG CONSTRAINT: Added constraint x[21] + not_covered[17] ≤ 1 for terminal 17
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 4·not_covered[17] ≤ 4 for terminal 17
DEBUG CONSTRAINT: Added constraint x[12] + not_covered[18] ≤ 1 for terminal 18
DEBUG CONSTRAINT: Added constraint x[14] + not_covered[18] ≤ 1 for terminal 18
DEBUG CONSTRAINT: Added constraint x[15] + not_covered[18] ≤ 1 for terminal 18
DEBUG CONSTRAINT: Added constraint x[19] + not_covered[18] ≤ 1 for terminal 18
DEBUG CONSTRAINT: Added constraint x[21] + not_covered[18] ≤ 1 for terminal 18
DEBUG CONSTRAINT: Added constraint x[25] + not_covered[18] ≤ 1 for terminal 18
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 6·not_covered[18] ≤ 6 for terminal 18
DEBUG CONSTRAINT: Added constraint x[4] + not_covered[19] ≤ 1 for terminal 19
DEBUG CONSTRAINT: Added constraint x[10] + not_covered[19] ≤ 1 for terminal 19
DEBUG CONSTRAINT: Added constraint x[11] + not_covered[19] ≤ 1 for terminal 19
DEBUG CONSTRAINT: Added constraint x[17] + not_covered[19] ≤ 1 for terminal 19
DEBUG CONSTRAINT: Added constraint x[18] + not_covered[19] ≤ 1 for terminal 19
DEBUG CONSTRAINT: Added constraint x[20] + not_covered[19] ≤ 1 for terminal 19
DEBUG CONSTRAINT: Added constraint x[26] + not_covered[19] ≤ 1 for terminal 19
DEBUG CONSTRAINT: Added constraint x[37] + not_covered[19] ≤ 1 for terminal 19
DEBUG CONSTRAINT: Added constraint x[38] + not_covered[19] ≤ 1 for terminal 19
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 9·not_covered[19] ≤ 9 for terminal 19
DEBUG CONSTRAINT: Added source terminal constraint: not_covered[0] = 0
DEBUG BUDGET: Adding budget constraint ≤ 1800000.000 to constraint pool
DEBUG BUDGET: Using raw tree costs directly
DEBUG BUDGET: Budget limit: 1800000.000
DEBUG BUDGET: Building raw cost constraint coefficients:
DEBUG BUDGET:   x[0] coefficient = 398991 (raw=398991.100)
DEBUG BUDGET:   x[1] coefficient = 260889 (raw=260889.712)
DEBUG BUDGET:   x[2] coefficient = 256773 (raw=256773.057)
DEBUG BUDGET:   x[3] coefficient = 376541 (raw=376541.557)
DEBUG BUDGET:   x[4] coefficient = 646084 (raw=646084.462)
DEBUG BUDGET:   x[5] coefficient = 520973 (raw=520973.020)
DEBUG BUDGET:   x[6] coefficient = 334575 (raw=334575.182)
DEBUG BUDGET:   x[7] coefficient = 494448 (raw=494448.457)
DEBUG BUDGET:   x[8] coefficient = 455905 (raw=455905.519)
DEBUG BUDGET:   x[9] coefficient = 584020 (raw=584020.499)
DEBUG BUDGET:   x[10] coefficient = 380918 (raw=380918.244)
DEBUG BUDGET:   x[11] coefficient = 621357 (raw=621357.781)
DEBUG BUDGET:   x[12] coefficient = 120675 (raw=120675.719)
DEBUG BUDGET:   x[13] coefficient = 551354 (raw=551354.477)
DEBUG BUDGET:   x[14] coefficient = 410262 (raw=410262.679)
DEBUG BUDGET:   x[15] coefficient = 362962 (raw=362962.653)
DEBUG BUDGET:   x[16] coefficient = 702244 (raw=702244.403)
DEBUG BUDGET:   x[17] coefficient = 673894 (raw=673894.542)
DEBUG BUDGET:   x[18] coefficient = 933994 (raw=933994.022)
DEBUG BUDGET:   x[19] coefficient = 454199 (raw=454199.906)
DEBUG BUDGET:   x[20] coefficient = 986439 (raw=986439.144)
DEBUG BUDGET:   x[21] coefficient = 46859 (raw=46859.249)
DEBUG BUDGET:   x[22] coefficient = 52662 (raw=52662.185)
DEBUG BUDGET:   x[23] coefficient = 62275 (raw=62275.339)
DEBUG BUDGET:   x[24] coefficient = 75379 (raw=75379.993)
DEBUG BUDGET:   x[25] coefficient = 75695 (raw=75695.846)
DEBUG BUDGET:   x[26] coefficient = 80703 (raw=80703.013)
DEBUG BUDGET:   x[27] coefficient = 93734 (raw=93734.596)
DEBUG BUDGET:   x[28] coefficient = 95452 (raw=95452.578)
DEBUG BUDGET:   x[29] coefficient = 102977 (raw=102977.757)
DEBUG BUDGET:   x[30] coefficient = 165327 (raw=165327.925)
DEBUG BUDGET:   x[31] coefficient = 170420 (raw=170420.027)
DEBUG BUDGET:   x[32] coefficient = 179069 (raw=179069.657)
DEBUG BUDGET:   x[33] coefficient = 234458 (raw=234458.486)
DEBUG BUDGET:   x[34] coefficient = 235891 (raw=235891.713)
DEBUG BUDGET:   x[35] coefficient = 242462 (raw=242462.956)
DEBUG BUDGET:   x[36] coefficient = 258947 (raw=258947.370)
DEBUG BUDGET:   x[37] coefficient = 313063 (raw=313063.098)
DEBUG BUDGET:   x[38] coefficient = 314219 (raw=314219.517)
DEBUG BUDGET:   x[39] coefficient = 327174 (raw=327174.269)
DEBUG BUDGET: Constraint: Σ tree_cost[i] * x[i] ≤ 1800000
DEBUG BUDGET: Budget constraint added to pool with 40 FSTs
DEBUG CONSTRAINT: Adding 'at least one FST' constraint: Σ x[i] ≥ 1
DEBUG CONSTRAINT: Added 'at least one FST' constraint: Σ x[i] ≥ 1
 % _gst_initialize_constraint_pool: 0.00 seconds.
 % Constraint pool initialized with:
 % 	1	Total degree rows	40	coeffs.
 % 	20	Cutset rows		111	coeffs.
 % 	0	Incompatibility rows	0	coeffs.
 % 	29	2-terminal SEC rows	102	coeffs.
 % 	1	At least one FST rows	40	coeffs.
 % 	163	Total rows in pool	135	in LP
 % @PMEM 163 rows, 1 blocks, 415 nzfree, 0 nzwasted, 1172 nztotal
DEBUG SOFT: Found 20 terminals, 40 FSTs
DEBUG SOFT: Adding space for 20 not_covered variables in soft constraints, total ncoeff=514
DEBUG LP_SETUP: Created LP with 0 rows, 60 columns (nedges=40 + nterms=20)
DEBUG SOFT: Set bounds for 40 FST vars [1-40] and 20 coverage vars [41-60]
DEBUG OBJ: Using raw costs - alpha=10000.0 (battery weight), beta=1500000 (coverage penalty)
DEBUG OBJ: Allocated rowvec[0-60] for ncols=60 LP variables
DEBUG OBJ: Full_trees battery_score=0.000 for FST 0
DEBUG OBJ: Recalculating for FST 0 with 3 terminals
DEBUG OBJ: Terminal 0 (idx 5): battery=87.50, running_total=87.50
DEBUG OBJ: Terminal 1 (idx 1): battery=82.00, running_total=169.50
DEBUG OBJ: Terminal 2 (idx 4): battery=96.00, running_total=265.50
DEBUG OBJ: Recalculated battery_score=265.500 for FST 0
DEBUG OBJ: FST 0: tree_cost=398991.100, battery_cost=265.500 (weighted=2655000.0), combined=3053991.1
DEBUG OBJ: Full_trees battery_score=0.000 for FST 1
DEBUG OBJ: Recalculating for FST 1 with 3 terminals
DEBUG OBJ: Terminal 0 (idx 10): battery=90.20, running_total=90.20
DEBUG OBJ: Terminal 1 (idx 5): battery=87.50, running_total=177.70
DEBUG OBJ: Terminal 2 (idx 4): battery=96.00, running_total=273.70
DEBUG OBJ: Recalculated battery_score=273.700 for FST 1
DEBUG OBJ: FST 1: tree_cost=260889.712, battery_cost=273.700 (weighted=2737000.0), combined=2997889.7
DEBUG OBJ: Full_trees battery_score=0.000 for FST 2
DEBUG OBJ: Recalculating for FST 2 with 3 terminals
DEBUG OBJ: Terminal 0 (idx 13): battery=89.90, running_total=89.90
DEBUG OBJ: Terminal 1 (idx 0): battery=100.00, running_total=189.90
DEBUG OBJ: Terminal 2 (idx 6): battery=98.00, running_total=287.90
DEBUG OBJ: Recalculated battery_score=287.900 for FST 2
DEBUG OBJ: FST 2: tree_cost=256773.057, battery_cost=287.900 (weighted=2879000.0), combined=3135773.1
DEBUG OBJ: Full_trees battery_score=0.000 for FST 3
DEBUG OBJ: Recalculating for FST 3 with 3 terminals
DEBUG OBJ: Terminal 0 (idx 15): battery=98.00, running_total=98.00
DEBUG OBJ: Terminal 1 (idx 3): battery=98.00, running_total=196.00
DEBUG OBJ: Terminal 2 (idx 6): battery=98.00, running_total=294.00
DEBUG OBJ: Recalculated battery_score=294.000 for FST 3
DEBUG OBJ: FST 3: tree_cost=376541.557, battery_cost=294.000 (weighted=2940000.0), combined=3316541.6
DEBUG OBJ: Full_trees battery_score=0.000 for FST 4
DEBUG OBJ: Recalculating for FST 4 with 3 terminals
DEBUG OBJ: Terminal 0 (idx 19): battery=98.00, running_total=98.00
DEBUG OBJ: Terminal 1 (idx 3): battery=98.00, running_total=196.00
DEBUG OBJ: Terminal 2 (idx 6): battery=98.00, running_total=294.00
DEBUG OBJ: Recalculated battery_score=294.000 for FST 4
DEBUG OBJ: FST 4: tree_cost=646084.462, battery_cost=294.000 (weighted=2940000.0), combined=3586084.5
DEBUG OBJ: Full_trees battery_score=0.000 for FST 5
DEBUG OBJ: Recalculating for FST 5 with 3 terminals
DEBUG OBJ: Terminal 0 (idx 11): battery=46.70, running_total=46.70
DEBUG OBJ: Terminal 1 (idx 2): battery=98.00, running_total=144.70
DEBUG OBJ: Terminal 2 (idx 7): battery=100.00, running_total=244.70
DEBUG OBJ: Recalculated battery_score=244.700 for FST 5
DEBUG OBJ: FST 5: tree_cost=520973.020, battery_cost=244.700 (weighted=2447000.0), combined=2967973.0
DEBUG OBJ: Full_trees battery_score=0.000 for FST 6
DEBUG OBJ: Recalculating for FST 6 with 3 terminals
DEBUG OBJ: Terminal 0 (idx 9): battery=100.00, running_total=100.00
DEBUG OBJ: Terminal 1 (idx 7): battery=100.00, running_total=200.00
DEBUG OBJ: Terminal 2 (idx 8): battery=100.00, running_total=300.00
DEBUG OBJ: Recalculated battery_score=300.000 for FST 6
DEBUG OBJ: FST 6: tree_cost=334575.182, battery_cost=300.000 (weighted=3000000.0), combined=3334575.2
DEBUG OBJ: Full_trees battery_score=0.000 for FST 7
DEBUG OBJ: Recalculating for FST 7 with 3 terminals
DEBUG OBJ: Terminal 0 (idx 11): battery=46.70, running_total=46.70
DEBUG OBJ: Terminal 1 (idx 2): battery=98.00, running_total=144.70
DEBUG OBJ: Terminal 2 (idx 9): battery=100.00, running_total=244.70
DEBUG OBJ: Recalculated battery_score=244.700 for FST 7
DEBUG OBJ: FST 7: tree_cost=494448.457, battery_cost=244.700 (weighted=2447000.0), combined=2941448.5
DEBUG OBJ: Full_trees battery_score=0.000 for FST 8
DEBUG OBJ: Recalculating for FST 8 with 3 terminals
DEBUG OBJ: Terminal 0 (idx 11): battery=46.70, running_total=46.70
DEBUG OBJ: Terminal 1 (idx 7): battery=100.00, running_total=146.70
DEBUG OBJ: Terminal 2 (idx 9): battery=100.00, running_total=246.70
DEBUG OBJ: Recalculated battery_score=246.700 for FST 8
DEBUG OBJ: FST 8: tree_cost=455905.519, battery_cost=246.700 (weighted=2467000.0), combined=2922905.5
DEBUG OBJ: Full_trees battery_score=0.000 for FST 9
DEBUG OBJ: Recalculating for FST 9 with 3 terminals
DEBUG OBJ: Terminal 0 (idx 12): battery=98.00, running_total=98.00
DEBUG OBJ: Terminal 1 (idx 11): battery=46.70, running_total=144.70
DEBUG OBJ: Terminal 2 (idx 9): battery=100.00, running_total=244.70
DEBUG OBJ: Recalculated battery_score=244.700 for FST 9
DEBUG OBJ: FST 9: tree_cost=584020.499, battery_cost=244.700 (weighted=2447000.0), combined=3031020.5
DEBUG OBJ: Full_trees battery_score=0.000 for FST 10
DEBUG OBJ: Recalculating for FST 10 with 3 terminals
DEBUG OBJ: Terminal 0 (idx 19): battery=98.00, running_total=98.00
DEBUG OBJ: Terminal 1 (idx 12): battery=98.00, running_total=196.00
DEBUG OBJ: Terminal 2 (idx 14): battery=60.30, running_total=256.30
DEBUG OBJ: Recalculated battery_score=256.300 for FST 10
DEBUG OBJ: FST 10: tree_cost=380918.244, battery_cost=256.300 (weighted=2563000.0), combined=2943918.2
DEBUG OBJ: Full_trees battery_score=0.000 for FST 11
DEBUG OBJ: Recalculating for FST 11 with 3 terminals
DEBUG OBJ: Terminal 0 (idx 19): battery=98.00, running_total=98.00
DEBUG OBJ: Terminal 1 (idx 15): battery=98.00, running_total=196.00
DEBUG OBJ: Terminal 2 (idx 6): battery=98.00, running_total=294.00
DEBUG OBJ: Recalculated battery_score=294.000 for FST 11
DEBUG OBJ: FST 11: tree_cost=621357.781, battery_cost=294.000 (weighted=2940000.0), combined=3561357.8
DEBUG OBJ: Full_trees battery_score=0.000 for FST 12
DEBUG OBJ: Recalculating for FST 12 with 3 terminals
DEBUG OBJ: Terminal 0 (idx 18): battery=100.00, running_total=100.00
DEBUG OBJ: Terminal 1 (idx 9): battery=100.00, running_total=200.00
DEBUG OBJ: Terminal 2 (idx 17): battery=100.00, running_total=300.00
DEBUG OBJ: Recalculated battery_score=300.000 for FST 12
DEBUG OBJ: FST 12: tree_cost=120675.719, battery_cost=300.000 (weighted=3000000.0), combined=3120675.7
DEBUG OBJ: Full_trees battery_score=0.000 for FST 13
DEBUG OBJ: Recalculating for FST 13 with 4 terminals
DEBUG OBJ: Terminal 0 (idx 11): battery=46.70, running_total=46.70
DEBUG OBJ: Terminal 1 (idx 7): battery=100.00, running_total=146.70
DEBUG OBJ: Terminal 2 (idx 8): battery=100.00, running_total=246.70
DEBUG OBJ: Terminal 3 (idx 9): battery=100.00, running_total=346.70
DEBUG OBJ: Recalculated battery_score=346.700 for FST 13
DEBUG OBJ: FST 13: tree_cost=551354.477, battery_cost=346.700 (weighted=3467000.0), combined=4018354.5
DEBUG OBJ: Full_trees battery_score=0.000 for FST 14
DEBUG OBJ: Recalculating for FST 14 with 4 terminals
DEBUG OBJ: Terminal 0 (idx 18): battery=100.00, running_total=100.00
DEBUG OBJ: Terminal 1 (idx 9): battery=100.00, running_total=200.00
DEBUG OBJ: Terminal 2 (idx 7): battery=100.00, running_total=300.00
DEBUG OBJ: Terminal 3 (idx 8): battery=100.00, running_total=400.00
DEBUG OBJ: Recalculated battery_score=400.000 for FST 14
DEBUG OBJ: FST 14: tree_cost=410262.679, battery_cost=400.000 (weighted=4000000.0), combined=4410262.7
DEBUG OBJ: Full_trees battery_score=0.000 for FST 15
DEBUG OBJ: Recalculating for FST 15 with 4 terminals
DEBUG OBJ: Terminal 0 (idx 18): battery=100.00, running_total=100.00
DEBUG OBJ: Terminal 1 (idx 9): battery=100.00, running_total=200.00
DEBUG OBJ: Terminal 2 (idx 7): battery=100.00, running_total=300.00
DEBUG OBJ: Terminal 3 (idx 17): battery=100.00, running_total=400.00
DEBUG OBJ: Recalculated battery_score=400.000 for FST 15
DEBUG OBJ: FST 15: tree_cost=362962.653, battery_cost=400.000 (weighted=4000000.0), combined=4362962.7
DEBUG OBJ: Full_trees battery_score=0.000 for FST 16
DEBUG OBJ: Recalculating for FST 16 with 4 terminals
DEBUG OBJ: Terminal 0 (idx 11): battery=46.70, running_total=46.70
DEBUG OBJ: Terminal 1 (idx 2): battery=98.00, running_total=144.70
DEBUG OBJ: Terminal 2 (idx 7): battery=100.00, running_total=244.70
DEBUG OBJ: Terminal 3 (idx 9): battery=100.00, running_total=344.70
DEBUG OBJ: Recalculated battery_score=344.700 for FST 16
DEBUG OBJ: FST 16: tree_cost=702244.403, battery_cost=344.700 (weighted=3447000.0), combined=4149244.4
DEBUG OBJ: Full_trees battery_score=0.000 for FST 17
DEBUG OBJ: Recalculating for FST 17 with 4 terminals
DEBUG OBJ: Terminal 0 (idx 19): battery=98.00, running_total=98.00
DEBUG OBJ: Terminal 1 (idx 15): battery=98.00, running_total=196.00
DEBUG OBJ: Terminal 2 (idx 3): battery=98.00, running_total=294.00
DEBUG OBJ: Terminal 3 (idx 6): battery=98.00, running_total=392.00
DEBUG OBJ: Recalculated battery_score=392.000 for FST 17
DEBUG OBJ: FST 17: tree_cost=673894.542, battery_cost=392.000 (weighted=3920000.0), combined=4593894.5
DEBUG OBJ: Full_trees battery_score=0.000 for FST 18
DEBUG OBJ: Recalculating for FST 18 with 4 terminals
DEBUG OBJ: Terminal 0 (idx 19): battery=98.00, running_total=98.00
DEBUG OBJ: Terminal 1 (idx 15): battery=98.00, running_total=196.00
DEBUG OBJ: Terminal 2 (idx 6): battery=98.00, running_total=294.00
DEBUG OBJ: Terminal 3 (idx 12): battery=98.00, running_total=392.00
DEBUG OBJ: Recalculated battery_score=392.000 for FST 18
DEBUG OBJ: FST 18: tree_cost=933994.022, battery_cost=392.000 (weighted=3920000.0), combined=4853994.0
DEBUG OBJ: Full_trees battery_score=0.000 for FST 19
DEBUG OBJ: Recalculating for FST 19 with 5 terminals
DEBUG OBJ: Terminal 0 (idx 18): battery=100.00, running_total=100.00
DEBUG OBJ: Terminal 1 (idx 9): battery=100.00, running_total=200.00
DEBUG OBJ: Terminal 2 (idx 7): battery=100.00, running_total=300.00
DEBUG OBJ: Terminal 3 (idx 8): battery=100.00, running_total=400.00
DEBUG OBJ: Terminal 4 (idx 17): battery=100.00, running_total=500.00
DEBUG OBJ: Recalculated battery_score=500.000 for FST 19
DEBUG OBJ: FST 19: tree_cost=454199.906, battery_cost=500.000 (weighted=5000000.0), combined=5454199.9
DEBUG OBJ: Full_trees battery_score=0.000 for FST 20
DEBUG OBJ: Recalculating for FST 20 with 5 terminals
DEBUG OBJ: Terminal 0 (idx 19): battery=98.00, running_total=98.00
DEBUG OBJ: Terminal 1 (idx 15): battery=98.00, running_total=196.00
DEBUG OBJ: Terminal 2 (idx 3): battery=98.00, running_total=294.00
DEBUG OBJ: Terminal 3 (idx 6): battery=98.00, running_total=392.00
DEBUG OBJ: Terminal 4 (idx 12): battery=98.00, running_total=490.00
DEBUG OBJ: Recalculated battery_score=490.000 for FST 20
DEBUG OBJ: FST 20: tree_cost=986439.144, battery_cost=490.000 (weighted=4900000.0), combined=5886439.1
DEBUG OBJ: Full_trees battery_score=0.000 for FST 21
DEBUG OBJ: Recalculating for FST 21 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 18): battery=100.00, running_total=100.00
DEBUG OBJ: Terminal 1 (idx 17): battery=100.00, running_total=200.00
DEBUG OBJ: Recalculated battery_score=200.000 for FST 21
DEBUG OBJ: FST 21: tree_cost=46859.249, battery_cost=200.000 (weighted=2000000.0), combined=2046859.2
DEBUG OBJ: Full_trees battery_score=0.000 for FST 22
DEBUG OBJ: Recalculating for FST 22 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 15): battery=98.00, running_total=98.00
DEBUG OBJ: Terminal 1 (idx 3): battery=98.00, running_total=196.00
DEBUG OBJ: Recalculated battery_score=196.000 for FST 22
DEBUG OBJ: FST 22: tree_cost=52662.185, battery_cost=196.000 (weighted=1960000.0), combined=2012662.2
DEBUG OBJ: Full_trees battery_score=0.000 for FST 23
DEBUG OBJ: Recalculating for FST 23 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 16): battery=68.00, running_total=68.00
DEBUG OBJ: Terminal 1 (idx 2): battery=98.00, running_total=166.00
DEBUG OBJ: Recalculated battery_score=166.000 for FST 23
DEBUG OBJ: FST 23: tree_cost=62275.339, battery_cost=166.000 (weighted=1660000.0), combined=1722275.3
DEBUG OBJ: Full_trees battery_score=0.000 for FST 24
DEBUG OBJ: Recalculating for FST 24 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 16): battery=68.00, running_total=68.00
DEBUG OBJ: Terminal 1 (idx 1): battery=82.00, running_total=150.00
DEBUG OBJ: Recalculated battery_score=150.000 for FST 24
DEBUG OBJ: FST 24: tree_cost=75379.993, battery_cost=150.000 (weighted=1500000.0), combined=1575380.0
DEBUG OBJ: Full_trees battery_score=0.000 for FST 25
DEBUG OBJ: Recalculating for FST 25 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 18): battery=100.00, running_total=100.00
DEBUG OBJ: Terminal 1 (idx 9): battery=100.00, running_total=200.00
DEBUG OBJ: Recalculated battery_score=200.000 for FST 25
DEBUG OBJ: FST 25: tree_cost=75695.846, battery_cost=200.000 (weighted=2000000.0), combined=2075695.8
DEBUG OBJ: Full_trees battery_score=0.000 for FST 26
DEBUG OBJ: Recalculating for FST 26 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 14): battery=60.30, running_total=60.30
DEBUG OBJ: Terminal 1 (idx 19): battery=98.00, running_total=158.30
DEBUG OBJ: Recalculated battery_score=158.300 for FST 26
DEBUG OBJ: FST 26: tree_cost=80703.013, battery_cost=158.300 (weighted=1583000.0), combined=1663703.0
DEBUG OBJ: Full_trees battery_score=0.000 for FST 27
DEBUG OBJ: Recalculating for FST 27 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 0): battery=100.00, running_total=100.00
DEBUG OBJ: Terminal 1 (idx 13): battery=89.90, running_total=189.90
DEBUG OBJ: Recalculated battery_score=189.900 for FST 27
DEBUG OBJ: FST 27: tree_cost=93734.596, battery_cost=189.900 (weighted=1899000.0), combined=1992734.6
DEBUG OBJ: Full_trees battery_score=0.000 for FST 28
DEBUG OBJ: Recalculating for FST 28 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 8): battery=100.00, running_total=100.00
DEBUG OBJ: Terminal 1 (idx 7): battery=100.00, running_total=200.00
DEBUG OBJ: Recalculated battery_score=200.000 for FST 28
DEBUG OBJ: FST 28: tree_cost=95452.578, battery_cost=200.000 (weighted=2000000.0), combined=2095452.6
DEBUG OBJ: Full_trees battery_score=0.000 for FST 29
DEBUG OBJ: Recalculating for FST 29 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 5): battery=87.50, running_total=87.50
DEBUG OBJ: Terminal 1 (idx 10): battery=90.20, running_total=177.70
DEBUG OBJ: Recalculated battery_score=177.700 for FST 29
DEBUG OBJ: FST 29: tree_cost=102977.757, battery_cost=177.700 (weighted=1777000.0), combined=1879977.8
DEBUG OBJ: Full_trees battery_score=0.000 for FST 30
DEBUG OBJ: Recalculating for FST 30 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 4): battery=96.00, running_total=96.00
DEBUG OBJ: Terminal 1 (idx 5): battery=87.50, running_total=183.50
DEBUG OBJ: Recalculated battery_score=183.500 for FST 30
DEBUG OBJ: FST 30: tree_cost=165327.925, battery_cost=183.500 (weighted=1835000.0), combined=2000327.9
DEBUG OBJ: Full_trees battery_score=0.000 for FST 31
DEBUG OBJ: Recalculating for FST 31 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 6): battery=98.00, running_total=98.00
DEBUG OBJ: Terminal 1 (idx 0): battery=100.00, running_total=198.00
DEBUG OBJ: Recalculated battery_score=198.000 for FST 31
DEBUG OBJ: FST 31: tree_cost=170420.027, battery_cost=198.000 (weighted=1980000.0), combined=2150420.0
DEBUG OBJ: Full_trees battery_score=0.000 for FST 32
DEBUG OBJ: Recalculating for FST 32 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 13): battery=89.90, running_total=89.90
DEBUG OBJ: Terminal 1 (idx 4): battery=96.00, running_total=185.90
DEBUG OBJ: Recalculated battery_score=185.900 for FST 32
DEBUG OBJ: FST 32: tree_cost=179069.657, battery_cost=185.900 (weighted=1859000.0), combined=2038069.7
DEBUG OBJ: Full_trees battery_score=0.000 for FST 33
DEBUG OBJ: Recalculating for FST 33 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 5): battery=87.50, running_total=87.50
DEBUG OBJ: Terminal 1 (idx 1): battery=82.00, running_total=169.50
DEBUG OBJ: Recalculated battery_score=169.500 for FST 33
DEBUG OBJ: FST 33: tree_cost=234458.486, battery_cost=169.500 (weighted=1695000.0), combined=1929458.5
DEBUG OBJ: Full_trees battery_score=0.000 for FST 34
DEBUG OBJ: Recalculating for FST 34 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 11): battery=46.70, running_total=46.70
DEBUG OBJ: Terminal 1 (idx 9): battery=100.00, running_total=146.70
DEBUG OBJ: Recalculated battery_score=146.700 for FST 34
DEBUG OBJ: FST 34: tree_cost=235891.713, battery_cost=146.700 (weighted=1467000.0), combined=1702891.7
DEBUG OBJ: Full_trees battery_score=0.000 for FST 35
DEBUG OBJ: Recalculating for FST 35 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 9): battery=100.00, running_total=100.00
DEBUG OBJ: Terminal 1 (idx 7): battery=100.00, running_total=200.00
DEBUG OBJ: Recalculated battery_score=200.000 for FST 35
DEBUG OBJ: FST 35: tree_cost=242462.956, battery_cost=200.000 (weighted=2000000.0), combined=2242463.0
DEBUG OBJ: Full_trees battery_score=0.000 for FST 36
DEBUG OBJ: Recalculating for FST 36 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 2): battery=98.00, running_total=98.00
DEBUG OBJ: Terminal 1 (idx 11): battery=46.70, running_total=144.70
DEBUG OBJ: Recalculated battery_score=144.700 for FST 36
DEBUG OBJ: FST 36: tree_cost=258947.370, battery_cost=144.700 (weighted=1447000.0), combined=1705947.4
DEBUG OBJ: Full_trees battery_score=0.000 for FST 37
DEBUG OBJ: Recalculating for FST 37 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 19): battery=98.00, running_total=98.00
DEBUG OBJ: Terminal 1 (idx 12): battery=98.00, running_total=196.00
DEBUG OBJ: Recalculated battery_score=196.000 for FST 37
DEBUG OBJ: FST 37: tree_cost=313063.098, battery_cost=196.000 (weighted=1960000.0), combined=2273063.1
DEBUG OBJ: Full_trees battery_score=0.000 for FST 38
DEBUG OBJ: Recalculating for FST 38 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 15): battery=98.00, running_total=98.00
DEBUG OBJ: Terminal 1 (idx 19): battery=98.00, running_total=196.00
DEBUG OBJ: Recalculated battery_score=196.000 for FST 38
DEBUG OBJ: FST 38: tree_cost=314219.517, battery_cost=196.000 (weighted=1960000.0), combined=2274219.5
DEBUG OBJ: Full_trees battery_score=0.000 for FST 39
DEBUG OBJ: Recalculating for FST 39 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 3): battery=98.00, running_total=98.00
DEBUG OBJ: Terminal 1 (idx 6): battery=98.00, running_total=196.00
DEBUG OBJ: Recalculated battery_score=196.000 for FST 39
DEBUG OBJ: FST 39: tree_cost=327174.269, battery_cost=196.000 (weighted=1960000.0), combined=2287174.3
DEBUG OBJ: Added penalty terms beta=1500000 for 20 not_covered variables [41-60]
DEBUG LP_MATRIX: LP has 0 rows, 60 columns after setup
DEBUG EXTRA_COEFF: Calculated extra_coeff=1 for 135 rows
DEBUG SOFT: Added not_covered_0 (RC_var 43 -> matrix_idx 40) to soft constraint 134
DEBUG MATRIX_CHECK: nzi=495, ncoeff=514, extra_coeff=1, expected=515
ERROR: Matrix coefficient count mismatch! nzi=495 != ncoeff=514 + extra_coeff=1
WARNING: Allowing discrepancy in budget mode (nzi=495 vs expected=515)
DEBUG MATRIX: Total matrix has 495 entries (nzi=495)
DEBUG MATRIX: matbeg[135] = 495 (should equal nzi)
DEBUG LP: Calling add_rows with 135 rows
DEBUG LP: Before add_rows: LP has 0 rows, 60 cols, 60 nonzeros
DEBUG LP: After add_rows: LP has 135 rows, 60 cols, 555 nonzeros
DEBUG NLPROWS: nrows=135, extra_rows=0, setting nlprows=135
 % _gst_build_initial_formulation: 0.00 seconds.
DEBUG BB: Expected nlprows=135, total rows=163
DEBUG BB: Row 0 (uid=0) has lprow=0 (included, j=0)
DEBUG BB: Row 1 (uid=1) has lprow=1 (included, j=1)
DEBUG BB: Row 2 (uid=2) has lprow=2 (included, j=2)
DEBUG BB: Row 3 (uid=3) has lprow=3 (included, j=3)
DEBUG BB: Row 4 (uid=4) has lprow=4 (included, j=4)
DEBUG BB: Row 5 (uid=5) has lprow=5 (included, j=5)
DEBUG BB: Row 6 (uid=6) has lprow=6 (included, j=6)
DEBUG BB: Row 7 (uid=7) has lprow=7 (included, j=7)
DEBUG BB: Row 8 (uid=8) has lprow=8 (included, j=8)
DEBUG BB: Row 9 (uid=9) has lprow=9 (included, j=9)
DEBUG BB: Row 10 (uid=10) has lprow=10 (included, j=10)
DEBUG BB: Row 11 (uid=11) has lprow=11 (included, j=11)
DEBUG BB: Row 12 (uid=12) has lprow=12 (included, j=12)
DEBUG BB: Row 13 (uid=13) has lprow=13 (included, j=13)
DEBUG BB: Row 14 (uid=14) has lprow=14 (included, j=14)
DEBUG BB: Row 15 (uid=15) has lprow=15 (included, j=15)
DEBUG BB: Row 16 (uid=16) has lprow=16 (included, j=16)
DEBUG BB: Row 17 (uid=17) has lprow=17 (included, j=17)
DEBUG BB: Row 18 (uid=18) has lprow=18 (included, j=18)
DEBUG BB: Row 19 (uid=19) has lprow=19 (included, j=19)
DEBUG BB: Row 20 (uid=20) has lprow=20 (included, j=20)
DEBUG BB: Row 21 (uid=21) has lprow=21 (included, j=21)
DEBUG BB: Row 22 (uid=22) has lprow=22 (included, j=22)
DEBUG BB: Row 23 (uid=23) has lprow=23 (included, j=23)
DEBUG BB: Row 24 (uid=24) has lprow=24 (included, j=24)
DEBUG BB: Row 25 (uid=25) has lprow=25 (included, j=25)
DEBUG BB: Row 26 (uid=26) has lprow=26 (included, j=26)
DEBUG BB: Row 27 (uid=27) has lprow=27 (included, j=27)
DEBUG BB: Row 28 (uid=28) has lprow=28 (included, j=28)
DEBUG BB: Row 29 (uid=29) has lprow=29 (included, j=29)
DEBUG BB: Row 30 (uid=30) has lprow=30 (included, j=30)
DEBUG BB: Row 31 (uid=31) has lprow=31 (included, j=31)
DEBUG BB: Row 32 (uid=32) has lprow=32 (included, j=32)
DEBUG BB: Row 33 (uid=33) has lprow=33 (included, j=33)
DEBUG BB: Row 34 (uid=34) has lprow=34 (included, j=34)
DEBUG BB: Row 35 (uid=35) has lprow=35 (included, j=35)
DEBUG BB: Row 36 (uid=36) has lprow=36 (included, j=36)
DEBUG BB: Row 37 (uid=37) has lprow=37 (included, j=37)
DEBUG BB: Row 38 (uid=38) has lprow=38 (included, j=38)
DEBUG BB: Row 39 (uid=39) has lprow=39 (included, j=39)
DEBUG BB: Row 40 (uid=40) has lprow=40 (included, j=40)
DEBUG BB: Row 41 (uid=41) has lprow=41 (included, j=41)
DEBUG BB: Row 42 (uid=42) has lprow=42 (included, j=42)
DEBUG BB: Row 43 (uid=43) has lprow=43 (included, j=43)
DEBUG BB: Row 44 (uid=44) has lprow=44 (included, j=44)
DEBUG BB: Row 45 (uid=45) has lprow=45 (included, j=45)
DEBUG BB: Row 46 (uid=46) has lprow=46 (included, j=46)
DEBUG BB: Row 47 (uid=47) has lprow=47 (included, j=47)
DEBUG BB: Row 48 (uid=48) has lprow=48 (included, j=48)
DEBUG BB: Row 49 (uid=49) has lprow=49 (included, j=49)
DEBUG BB: Row 50 (uid=50) has lprow=50 (included, j=50)
DEBUG BB: Row 51 (uid=51) has lprow=51 (included, j=51)
DEBUG BB: Row 52 (uid=52) has lprow=52 (included, j=52)
DEBUG BB: Row 53 (uid=53) has lprow=53 (included, j=53)
DEBUG BB: Row 54 (uid=54) has lprow=54 (included, j=54)
DEBUG BB: Row 55 (uid=55) has lprow=55 (included, j=55)
DEBUG BB: Row 56 (uid=56) has lprow=56 (included, j=56)
DEBUG BB: Row 57 (uid=57) has lprow=57 (included, j=57)
DEBUG BB: Row 58 (uid=58) has lprow=58 (included, j=58)
DEBUG BB: Row 59 (uid=59) has lprow=59 (included, j=59)
DEBUG BB: Row 60 (uid=60) has lprow=60 (included, j=60)
DEBUG BB: Row 61 (uid=61) has lprow=61 (included, j=61)
DEBUG BB: Row 62 (uid=62) has lprow=62 (included, j=62)
DEBUG BB: Row 63 (uid=63) has lprow=63 (included, j=63)
DEBUG BB: Row 64 (uid=64) has lprow=64 (included, j=64)
DEBUG BB: Row 65 (uid=65) has lprow=65 (included, j=65)
DEBUG BB: Row 66 (uid=66) has lprow=66 (included, j=66)
DEBUG BB: Row 67 (uid=67) has lprow=67 (included, j=67)
DEBUG BB: Row 68 (uid=68) has lprow=68 (included, j=68)
DEBUG BB: Row 69 (uid=69) has lprow=69 (included, j=69)
DEBUG BB: Row 70 (uid=70) has lprow=70 (included, j=70)
DEBUG BB: Row 71 (uid=71) has lprow=71 (included, j=71)
DEBUG BB: Row 72 (uid=72) has lprow=72 (included, j=72)
DEBUG BB: Row 73 (uid=73) has lprow=73 (included, j=73)
DEBUG BB: Row 74 (uid=74) has lprow=74 (included, j=74)
DEBUG BB: Row 75 (uid=75) has lprow=75 (included, j=75)
DEBUG BB: Row 76 (uid=76) has lprow=76 (included, j=76)
DEBUG BB: Row 77 (uid=77) has lprow=77 (included, j=77)
DEBUG BB: Row 78 (uid=78) has lprow=78 (included, j=78)
DEBUG BB: Row 79 (uid=79) has lprow=79 (included, j=79)
DEBUG BB: Row 80 (uid=80) has lprow=80 (included, j=80)
DEBUG BB: Row 81 (uid=81) has lprow=81 (included, j=81)
DEBUG BB: Row 82 (uid=82) has lprow=82 (included, j=82)
DEBUG BB: Row 83 (uid=83) has lprow=83 (included, j=83)
DEBUG BB: Row 84 (uid=84) has lprow=84 (included, j=84)
DEBUG BB: Row 85 (uid=85) has lprow=85 (included, j=85)
DEBUG BB: Row 86 (uid=86) has lprow=86 (included, j=86)
DEBUG BB: Row 87 (uid=87) has lprow=87 (included, j=87)
DEBUG BB: Row 88 (uid=88) has lprow=88 (included, j=88)
DEBUG BB: Row 89 (uid=89) has lprow=89 (included, j=89)
DEBUG BB: Row 90 (uid=90) has lprow=90 (included, j=90)
DEBUG BB: Row 91 (uid=91) has lprow=91 (included, j=91)
DEBUG BB: Row 92 (uid=92) has lprow=92 (included, j=92)
DEBUG BB: Row 93 (uid=93) has lprow=93 (included, j=93)
DEBUG BB: Row 94 (uid=94) has lprow=94 (included, j=94)
DEBUG BB: Row 95 (uid=95) has lprow=95 (included, j=95)
DEBUG BB: Row 96 (uid=96) has lprow=96 (included, j=96)
DEBUG BB: Row 97 (uid=97) has lprow=97 (included, j=97)
DEBUG BB: Row 98 (uid=98) has lprow=98 (included, j=98)
DEBUG BB: Row 99 (uid=99) has lprow=99 (included, j=99)
DEBUG BB: Row 100 (uid=100) has lprow=100 (included, j=100)
DEBUG BB: Row 101 (uid=101) has lprow=101 (included, j=101)
DEBUG BB: Row 102 (uid=102) has lprow=102 (included, j=102)
DEBUG BB: Row 103 (uid=103) has lprow=103 (included, j=103)
DEBUG BB: Row 104 (uid=104) has lprow=104 (included, j=104)
DEBUG BB: Row 105 (uid=105) has lprow=105 (included, j=105)
DEBUG BB: Row 106 (uid=106) has lprow=106 (included, j=106)
DEBUG BB: Row 107 (uid=107) has lprow=107 (included, j=107)
DEBUG BB: Row 108 (uid=108) has lprow=108 (included, j=108)
DEBUG BB: Row 109 (uid=109) has lprow=109 (included, j=109)
DEBUG BB: Row 110 (uid=110) has lprow=110 (included, j=110)
DEBUG BB: Row 111 (uid=111) has lprow=111 (included, j=111)
DEBUG BB: Row 112 (uid=112) has lprow=112 (included, j=112)
DEBUG BB: Row 113 (uid=113) has lprow=113 (included, j=113)
DEBUG BB: Row 114 (uid=114) has lprow=114 (included, j=114)
DEBUG BB: Row 115 (uid=115) has lprow=115 (included, j=115)
DEBUG BB: Row 116 (uid=116) has lprow=116 (included, j=116)
DEBUG BB: Row 117 (uid=117) has lprow=117 (included, j=117)
DEBUG BB: Row 118 (uid=118) has lprow=118 (included, j=118)
DEBUG BB: Row 119 (uid=119) has lprow=119 (included, j=119)
DEBUG BB: Row 120 (uid=120) has lprow=120 (included, j=120)
DEBUG BB: Row 121 (uid=121) has lprow=121 (included, j=121)
DEBUG BB: Row 122 (uid=122) has lprow=122 (included, j=122)
DEBUG BB: Row 123 (uid=123) has lprow=123 (included, j=123)
DEBUG BB: Row 124 (uid=124) has lprow=124 (included, j=124)
DEBUG BB: Row 125 (uid=125) has lprow=125 (included, j=125)
DEBUG BB: Row 126 (uid=126) has lprow=126 (included, j=126)
DEBUG BB: Row 127 (uid=127) has lprow=127 (included, j=127)
DEBUG BB: Row 128 (uid=128) has lprow=128 (included, j=128)
DEBUG BB: Row 129 (uid=129) has lprow=129 (included, j=129)
DEBUG BB: Row 130 (uid=130) has lprow=130 (included, j=130)
DEBUG BB: Row 131 (uid=131) has lprow=131 (included, j=131)
DEBUG BB: Row 132 (uid=132) has lprow=132 (included, j=132)
DEBUG BB: Row 133 (uid=133) has lprow=-1 (skipped)
DEBUG BB: Row 134 (uid=134) has lprow=-1 (skipped)
DEBUG BB: Row 135 (uid=135) has lprow=-1 (skipped)
DEBUG BB: Row 136 (uid=136) has lprow=-1 (skipped)
DEBUG BB: Row 137 (uid=137) has lprow=-1 (skipped)
DEBUG BB: Row 138 (uid=138) has lprow=-1 (skipped)
DEBUG BB: Row 139 (uid=139) has lprow=-1 (skipped)
DEBUG BB: Row 140 (uid=140) has lprow=-1 (skipped)
DEBUG BB: Row 141 (uid=141) has lprow=-1 (skipped)
DEBUG BB: Row 142 (uid=142) has lprow=-1 (skipped)
DEBUG BB: Row 143 (uid=143) has lprow=-1 (skipped)
DEBUG BB: Row 144 (uid=144) has lprow=-1 (skipped)
DEBUG BB: Row 145 (uid=145) has lprow=-1 (skipped)
DEBUG BB: Row 146 (uid=146) has lprow=-1 (skipped)
DEBUG BB: Row 147 (uid=147) has lprow=-1 (skipped)
DEBUG BB: Row 148 (uid=148) has lprow=-1 (skipped)
DEBUG BB: Row 149 (uid=149) has lprow=-1 (skipped)
DEBUG BB: Row 150 (uid=150) has lprow=-1 (skipped)
DEBUG BB: Row 151 (uid=151) has lprow=-1 (skipped)
DEBUG BB: Row 152 (uid=152) has lprow=-1 (skipped)
DEBUG BB: Row 153 (uid=153) has lprow=-1 (skipped)
DEBUG BB: Row 154 (uid=154) has lprow=-1 (skipped)
DEBUG BB: Row 155 (uid=155) has lprow=-1 (skipped)
DEBUG BB: Row 156 (uid=156) has lprow=-1 (skipped)
DEBUG BB: Row 157 (uid=157) has lprow=-1 (skipped)
DEBUG BB: Row 158 (uid=158) has lprow=-1 (skipped)
DEBUG BB: Row 159 (uid=159) has lprow=-1 (skipped)
DEBUG BB: Row 160 (uid=160) has lprow=-1 (skipped)
DEBUG BB: Row 161 (uid=161) has lprow=133 (included, j=133)
DEBUG BB: Row 162 (uid=162) has lprow=134 (included, j=134)
DEBUG BB: Found 135 actual LP rows, expected 135
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde8386600
% Resuming node 0
DEBUG CONSTRNT: LP rows=135, pool->nlprows=135, pool->npend=0
DEBUG CONSTRNT: Checking 135 LP rows (pool tracks 135, total LP rows 135)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 1
DEBUG CONSTRNT: Pool row 1 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 2
DEBUG CONSTRNT: Pool row 2 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 3
DEBUG CONSTRNT: Pool row 3 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 4
DEBUG CONSTRNT: Pool row 4 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 20
DEBUG CONSTRNT: Pool row 20 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 41
DEBUG CONSTRNT: Pool row 41 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 45
DEBUG CONSTRNT: Pool row 45 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 49
DEBUG CONSTRNT: Pool row 49 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 51
DEBUG CONSTRNT: Pool row 51 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 52
DEBUG CONSTRNT: Pool row 52 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=54, expected 54
DEBUG CONSTRNT: Checking LP row 55 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=55, expected 55
DEBUG CONSTRNT: Checking LP row 56 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=56, expected 56
DEBUG CONSTRNT: Checking LP row 57 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=57, expected 57
DEBUG CONSTRNT: Checking LP row 58 -> pool row 58
DEBUG CONSTRNT: Pool row 58 has lprow=58, expected 58
DEBUG CONSTRNT: Checking LP row 59 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=59, expected 59
DEBUG CONSTRNT: Checking LP row 60 -> pool row 60
DEBUG CONSTRNT: Pool row 60 has lprow=60, expected 60
DEBUG CONSTRNT: Checking LP row 61 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=61, expected 61
DEBUG CONSTRNT: Checking LP row 62 -> pool row 62
DEBUG CONSTRNT: Pool row 62 has lprow=62, expected 62
DEBUG CONSTRNT: Checking LP row 63 -> pool row 63
DEBUG CONSTRNT: Pool row 63 has lprow=63, expected 63
DEBUG CONSTRNT: Checking LP row 64 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=64, expected 64
DEBUG CONSTRNT: Checking LP row 65 -> pool row 65
DEBUG CONSTRNT: Pool row 65 has lprow=65, expected 65
DEBUG CONSTRNT: Checking LP row 66 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=66, expected 66
DEBUG CONSTRNT: Checking LP row 67 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=67, expected 67
DEBUG CONSTRNT: Checking LP row 68 -> pool row 68
DEBUG CONSTRNT: Pool row 68 has lprow=68, expected 68
DEBUG CONSTRNT: Checking LP row 69 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=69, expected 69
DEBUG CONSTRNT: Checking LP row 70 -> pool row 70
DEBUG CONSTRNT: Pool row 70 has lprow=70, expected 70
DEBUG CONSTRNT: Checking LP row 71 -> pool row 71
DEBUG CONSTRNT: Pool row 71 has lprow=71, expected 71
DEBUG CONSTRNT: Checking LP row 72 -> pool row 72
DEBUG CONSTRNT: Pool row 72 has lprow=72, expected 72
DEBUG CONSTRNT: Checking LP row 73 -> pool row 73
DEBUG CONSTRNT: Pool row 73 has lprow=73, expected 73
DEBUG CONSTRNT: Checking LP row 74 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=74, expected 74
DEBUG CONSTRNT: Checking LP row 75 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=75, expected 75
DEBUG CONSTRNT: Checking LP row 76 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=76, expected 76
DEBUG CONSTRNT: Checking LP row 77 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=77, expected 77
DEBUG CONSTRNT: Checking LP row 78 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=78, expected 78
DEBUG CONSTRNT: Checking LP row 79 -> pool row 79
DEBUG CONSTRNT: Pool row 79 has lprow=79, expected 79
DEBUG CONSTRNT: Checking LP row 80 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=80, expected 80
DEBUG CONSTRNT: Checking LP row 81 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=81, expected 81
DEBUG CONSTRNT: Checking LP row 82 -> pool row 82
DEBUG CONSTRNT: Pool row 82 has lprow=82, expected 82
DEBUG CONSTRNT: Checking LP row 83 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=83, expected 83
DEBUG CONSTRNT: Checking LP row 84 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=84, expected 84
DEBUG CONSTRNT: Checking LP row 85 -> pool row 85
DEBUG CONSTRNT: Pool row 85 has lprow=85, expected 85
DEBUG CONSTRNT: Checking LP row 86 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=86, expected 86
DEBUG CONSTRNT: Checking LP row 87 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=87, expected 87
DEBUG CONSTRNT: Checking LP row 88 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=88, expected 88
DEBUG CONSTRNT: Checking LP row 89 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=89, expected 89
DEBUG CONSTRNT: Checking LP row 90 -> pool row 90
DEBUG CONSTRNT: Pool row 90 has lprow=90, expected 90
DEBUG CONSTRNT: Checking LP row 91 -> pool row 91
DEBUG CONSTRNT: Pool row 91 has lprow=91, expected 91
DEBUG CONSTRNT: Checking LP row 92 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=92, expected 92
DEBUG CONSTRNT: Checking LP row 93 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=93, expected 93
DEBUG CONSTRNT: Checking LP row 94 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=94, expected 94
DEBUG CONSTRNT: Checking LP row 95 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=95, expected 95
DEBUG CONSTRNT: Checking LP row 96 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=96, expected 96
DEBUG CONSTRNT: Checking LP row 97 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=97, expected 97
DEBUG CONSTRNT: Checking LP row 98 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=98, expected 98
DEBUG CONSTRNT: Checking LP row 99 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=99, expected 99
DEBUG CONSTRNT: Checking LP row 100 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=100, expected 100
DEBUG CONSTRNT: Checking LP row 101 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=101, expected 101
DEBUG CONSTRNT: Checking LP row 102 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=102, expected 102
DEBUG CONSTRNT: Checking LP row 103 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=103, expected 103
DEBUG CONSTRNT: Checking LP row 104 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=104, expected 104
DEBUG CONSTRNT: Checking LP row 105 -> pool row 105
DEBUG CONSTRNT: Pool row 105 has lprow=105, expected 105
DEBUG CONSTRNT: Checking LP row 106 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=106, expected 106
DEBUG CONSTRNT: Checking LP row 107 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=107, expected 107
DEBUG CONSTRNT: Checking LP row 108 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=108, expected 108
DEBUG CONSTRNT: Checking LP row 109 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=109, expected 109
DEBUG CONSTRNT: Checking LP row 110 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=110, expected 110
DEBUG CONSTRNT: Checking LP row 111 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=111, expected 111
DEBUG CONSTRNT: Checking LP row 112 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=112, expected 112
DEBUG CONSTRNT: Checking LP row 113 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=113, expected 113
DEBUG CONSTRNT: Checking LP row 114 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=114, expected 114
DEBUG CONSTRNT: Checking LP row 115 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=115, expected 115
DEBUG CONSTRNT: Checking LP row 116 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=116, expected 116
DEBUG CONSTRNT: Checking LP row 117 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=117, expected 117
DEBUG CONSTRNT: Checking LP row 118 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=118, expected 118
DEBUG CONSTRNT: Checking LP row 119 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=119, expected 119
DEBUG CONSTRNT: Checking LP row 120 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=120, expected 120
DEBUG CONSTRNT: Checking LP row 121 -> pool row 121
DEBUG CONSTRNT: Pool row 121 has lprow=121, expected 121
DEBUG CONSTRNT: Checking LP row 122 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=122, expected 122
DEBUG CONSTRNT: Checking LP row 123 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=123, expected 123
DEBUG CONSTRNT: Checking LP row 124 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=124, expected 124
DEBUG CONSTRNT: Checking LP row 125 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=125, expected 125
DEBUG CONSTRNT: Checking LP row 126 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=126, expected 126
DEBUG CONSTRNT: Checking LP row 127 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=127, expected 127
DEBUG CONSTRNT: Checking LP row 128 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=128, expected 128
DEBUG CONSTRNT: Checking LP row 129 -> pool row 129
DEBUG CONSTRNT: Pool row 129 has lprow=129, expected 129
DEBUG CONSTRNT: Checking LP row 130 -> pool row 130
DEBUG CONSTRNT: Pool row 130 has lprow=130, expected 130
DEBUG CONSTRNT: Checking LP row 131 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=131, expected 131
DEBUG CONSTRNT: Checking LP row 132 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=132, expected 132
DEBUG CONSTRNT: Checking LP row 133 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=133, expected 133
DEBUG CONSTRNT: Checking LP row 134 -> pool row 162
DEBUG CONSTRNT: Pool row 162 has lprow=134, expected 134
 % @PAP adding 135 rows, 494 nz to LP
DEBUG BB: Processing node 0, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=149, theta=6.333333, up=1.000000
ITER 2: row=1, varin=155, theta=4.000000, up=1.000000
ITER 3: row=1, varin=152, theta=4.000000, up=1.000000
ITER 4: row=1, varin=151, theta=3.000000, up=1.000000
ITER 5: row=1, varin=144, theta=3.000000, up=1.000000
ITER 6: row=1, varin=150, theta=1.333333, up=1.000000
ITER 7: row=1, varin=143, theta=0.500000, up=1.000000
ITER 8: row=134, varin=146, theta=12.191932, up=1.000000
ITER 9: row=134, varin=176, theta=5.139550, up=1.000000
ITER 10: row=134, varin=177, theta=4.139550, up=1.000000
LP PHASE: Switching to primal (iter=35)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=135)
DEBUG SOLUTION: LP solution array indices: FST[136-175], not_covered[176-195]
DEBUG SOLUTION: lp->best_solution[0] = 27086987.278019
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 0.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 0.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 3.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 135 rows, 60 cols, 554 nonzeros, 74 slack, 61 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 74 slack rows
  % @PAP adding 10 rows, 44 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=63, varin=82, theta=2.147777, up=1.000000
ITER 2: row=63, varin=79, theta=0.884237, up=1.000000
ITER 3: row=1, varin=127, theta=2.431527, up=1.000000
ITER 4: row=1, varin=128, theta=1.431527, up=1.000000
ITER 5: row=1, varin=129, theta=0.431527, up=1.000000
ITER 6: row=61, varin=88, theta=2.000000, up=1.000000
ITER 7: row=61, varin=85, theta=1.000000, up=1.000000
ITER 8: row=1, varin=6, theta=6.702869, up=999999999999999983222784.000000
ITER 9: row=6, varin=35, theta=5.702869, up=999999999999999983222784.000000
ITER 10: row=35, varin=38, theta=4.702869, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=20)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=71)
DEBUG SOLUTION: LP solution array indices: FST[72-111], not_covered[112-131]
DEBUG SOLUTION: lp->best_solution[0] = 27785409.176889
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.046195
DEBUG SOLUTION: lp->best_solution[7] = 0.523098
DEBUG SOLUTION: lp->best_solution[8] = 0.523098
DEBUG SOLUTION: lp->best_solution[9] = 0.523098
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.523098
DEBUG SOLUTION: lp->best_solution[12] = 0.523098
DEBUG SOLUTION: lp->best_solution[13] = 3.615489
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 71 rows, 60 cols, 350 nonzeros, 29 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 29 slack rows
  % @PAP adding 6 rows, 21 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=44, varin=103, theta=1.000000, up=1.000000
ITER 2: row=43, varin=96, theta=1.046195, up=1.000000
ITER 3: row=43, varin=97, theta=0.046195, up=1.000000
ITER 4: row=19, varin=96, theta=1.000000, up=1.000000
ITER 5: row=20, varin=98, theta=1.046195, up=1.000000
ITER 6: row=20, varin=100, theta=0.046195, up=1.000000
ITER 7: row=21, varin=98, theta=1.000000, up=1.000000
ITER 8: row=46, varin=104, theta=0.476902, up=1.000000
ITER 9: row=20, varin=106, theta=0.523098, up=1.000000
ITER 10: row=30, varin=107, theta=0.523098, up=1.000000
LP PHASE: Switching to primal (iter=12)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 27794910.549729
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 48 rows, 60 cols, 294 nonzeros, 2 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 3 rows, 13 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=47, varin=101, theta=1.000000, up=1.000000
ITER 2: row=49, varin=25, theta=0.553819, up=999999999999999983222784.000000
ITER 3: row=1, varin=55, theta=0.271611, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 27799643.757964
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 49 rows, 60 cols, 296 nonzeros, 2 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 4 rows, 18 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=50, varin=111, theta=0.111111, up=1.000000
ITER 2: row=49, varin=50, theta=2.758489, up=999999999999999983222784.000000
ITER 3: row=51, varin=59, theta=0.744305, up=1.000000
LP PHASE: Switching to primal (iter=3)
ITER 4: row=8, varin=53, theta=0.000000, up=1.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 27816526.990082
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 51 rows, 60 cols, 303 nonzeros, 3 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 2 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=49, varin=70, theta=0.118034, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 27818092.772149
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 50 rows, 60 cols, 289 nonzeros, 5 slack, 45 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % Node 0 LP 1 Solution, length = 27818092.772149, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.500000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.500000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.263932 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.118034 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.881966 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.736068 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.500000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.263932 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.263932 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.118034 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.118034 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.118034 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.263932 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.736068 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.263932 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.118034 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.118034 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.263932 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=27818092.772149, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
 % @LO 0.00  27.81809277214888709295 99.9000000000
 % @LN 0.00  27.81809277214888709295 99.9000000000
DEBUG CG: Second cutoff check: z=27818092.772149, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 % initially 3 congested vertices:
 % _gst_find_congested_components found 1 components:
 % 	component 0:	3 verts,	4 edges
 % @PAP adding 1 rows, 12 nz to LP
 % @PMEM 164 rows, 1 blocks, 402 nzfree, 0 nzwasted, 1172 nztotal
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=46, varin=91, theta=0.439023, up=1.000000
ITER 2: row=13, varin=32, theta=154412.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=46)
DEBUG SOLUTION: LP solution array indices: FST[47-86], not_covered[87-106]
DEBUG SOLUTION: lp->best_solution[0] = 27824089.338381
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 46 rows, 60 cols, 284 nonzeros, 1 slack, 45 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 0 LP 2 Solution, length = 27824089.338381, 0.00/0.00/0.00/0.00/0.00/0.00/0.00 1
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.500000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.500000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.500000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.500000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.500000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.500000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.500000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.500000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.500000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.500000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.500000 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=27824089.338381, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
 % @LO 0.00  27.81809277214888709295 99.9000000000
 % @LN 0.00  27.82408933838106790404 99.9000000000
DEBUG CG: Second cutoff check: z=27824089.338381, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 0 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 0
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.500000
DEBUG CAREFUL: Adding var 5 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.500000
DEBUG CAREFUL: Adding var 7 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.500000
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.500000
DEBUG CAREFUL: Adding var 20 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 4 fractional variables

  %  Carefully choosing branching variable, nfrac = 4
DEBUG CAREFUL: Testing fvar[0] = var 5
DEBUG CAREFUL: Calling compare_branch_vars for var 5
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 5
DEBUG CAREFUL: New best var: 5
DEBUG CAREFUL: Testing fvar[1] = var 7
DEBUG CAREFUL: Calling compare_branch_vars for var 7
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 7
DEBUG CAREFUL: Testing fvar[2] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[3] = var 20
DEBUG CAREFUL: Calling compare_branch_vars for var 20
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 20
  % Initial guess is x5, Z0 = 27824089.3383811        , Z1 = 27824089.3383811        

DEBUG EVAL: Testing var 5 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=8, varin=43, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 5 = 0 gives z=27839566.606964
  % 	x5 = 0,	Z0 = 27839566.6069642        
DEBUG EVAL: First branch cutoff check: z=27839566.606964, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 5 = 1
ITER 1: row=8, varin=35, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=44, varin=39, theta=1.000000, up=999999999999999983222784.000000
  % 	x5 = 1,	Z1 = 27866091.1698504        
DEBUG EVAL: Second branch cutoff check: z=27866091.169850, best_z=INF, threshold=INF
  %   New best:  x5, Z = 27839566.6069642        
DEBUG EVAL: Testing var 7 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=35, varin=35, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=44, varin=42, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=6, varin=39, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 7 = 0 gives z=27856702.845484
  % 	x7 = 0,	Z0 = 27856702.8454843        
DEBUG EVAL: First branch cutoff check: z=27856702.845484, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 7 = 1
ITER 1: row=35, varin=43, theta=1.000000, up=999999999999999983222784.000000
  % 	x7 = 1,	Z1 = 27839566.6069642        
DEBUG EVAL: Second branch cutoff check: z=27839566.606964, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 10 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=36, varin=63, theta=0.333333, up=1.000000
DEBUG EVAL: Branch var 10 = 0 gives z=27826647.968860
  % 	x10 = 0,	Z0 = 27826647.9688599        
DEBUG EVAL: First branch cutoff check: z=27826647.968860, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 20 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=6, varin=55, theta=0.500000, up=1.000000
ITER 2: row=19, varin=45, theta=0.500000, up=999999999999999983222784.000000
ITER 3: row=6, varin=43, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 20 = 0 gives z=27839566.606964
  % 	x20 = 0,	Z0 = 27839566.6069642        
DEBUG EVAL: First branch cutoff check: z=27839566.606964, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 20 = 1
ITER 1: row=6, varin=63, theta=0.333333, up=1.000000
  % 	x20 = 1,	Z1 = 27826647.9688599        
DEBUG EVAL: Second branch cutoff check: z=27826647.968860, best_z=INF, threshold=INF
  % Best branch is x5, Z0 = 27839566.6069642        , Z1 = 27866091.1698504        

DEBUG CAREFUL: Final result - returning best.var = 5
DEBUG BB: Branching variable chosen: j=5
 % @NC    1    0	x5 = 0	27839566.606964
 % @NC    2    0	x5 = 1	27866091.169850
 %       0     2 27824089.3384               27839566.6070
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde8397490
% @LO 0.00  27.82408933838106790404 99.9000000000
% @LN 0.00  27.83956660696425089441 99.9000000000
% Resuming node 1 at  27.83956660696425089441
DEBUG CONSTRNT: LP rows=45, pool->nlprows=45, pool->npend=0
DEBUG CONSTRNT: Checking 45 LP rows (pool tracks 45, total LP rows 45)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=44, expected 44
 % @PAP adding 45 rows, 184 nz to LP
DEBUG BB: Processing node 1, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=8, varin=43, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 27839566.606964
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 45 rows, 60 cols, 244 nonzeros, 2 slack, 43 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 20 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=46, varin=42, theta=0.250000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 27841503.585503
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 49 rows, 60 cols, 264 nonzeros, 5 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % Node 1 LP 1 Solution, length = 27841503.585503, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.750000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.500000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.250000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.750000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.500000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.250000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.500000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.500000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.250000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.250000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.250000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.250000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.500000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.500000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.500000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.250000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.250000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.500000 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=27841503.585503, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
 % @LO 0.00  27.83956660696425089441 99.9000000000
 % @LN 0.00  27.84150358550274262370 99.9000000000
DEBUG CG: Second cutoff check: z=27841503.585503, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 1 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 1
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.750000
DEBUG CAREFUL: Adding var 7 to fractional list (xi=0.750000)
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.500000
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.250000
DEBUG CAREFUL: Adding var 13 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.750000
DEBUG CAREFUL: Adding var 19 to fractional list (xi=0.750000)
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.500000
DEBUG CAREFUL: Adding var 20 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 20
DEBUG CAREFUL: Calling compare_branch_vars for var 20
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 20
DEBUG CAREFUL: New best var: 20
DEBUG CAREFUL: Testing fvar[1] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[2] = var 13
DEBUG CAREFUL: Calling compare_branch_vars for var 13
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 13
DEBUG CAREFUL: Testing fvar[3] = var 19
DEBUG CAREFUL: Calling compare_branch_vars for var 19
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 19
DEBUG CAREFUL: New best var: 19
DEBUG CAREFUL: Testing fvar[4] = var 7
DEBUG CAREFUL: Calling compare_branch_vars for var 7
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 7
  % Initial guess is x19, Z0 = 27868287.5623161        , Z1 = 27841503.5855027        

DEBUG EVAL: Testing var 20 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=6, varin=40, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=44, varin=41, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 20 = 0 gives z=27900919.664094
  % 	x20 = 0,	Z0 = 27900919.6640938        
DEBUG EVAL: First branch cutoff check: z=27900919.664094, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 20 = 1
ITER 1: row=6, varin=43, theta=1.000000, up=999999999999999983222784.000000
  % 	x20 = 1,	Z1 = 27843440.5640412        
DEBUG EVAL: Second branch cutoff check: z=27843440.564041, best_z=INF, threshold=INF
  %   New best:  x20, Z = 27843440.5640412        
DEBUG EVAL: Testing var 10 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=35, varin=43, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 0 gives z=27843440.564041
  % 	x10 = 0,	Z0 = 27843440.5640412        
DEBUG EVAL: First branch cutoff check: z=27843440.564041, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 1
ITER 1: row=35, varin=40, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=44, varin=41, theta=1.000000, up=999999999999999983222784.000000
  % 	x10 = 1,	Z1 = 27900919.6640938        
DEBUG EVAL: Second branch cutoff check: z=27900919.664094, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 13 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=32, varin=62, theta=0.333333, up=1.000000
DEBUG EVAL: Branch var 13 = 0 gives z=27842125.237443
  % 	x13 = 0,	Z0 = 27842125.2374431        
DEBUG EVAL: First branch cutoff check: z=27842125.237443, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 19 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=19, varin=62, theta=0.333333, up=1.000000
DEBUG EVAL: Branch var 19 = 1 gives z=27842125.237443
  % 	x19 = 1,	Z1 = 27842125.2374431        
DEBUG EVAL: First branch cutoff check: z=27842125.237443, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 7 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=8, varin=62, theta=0.333333, up=1.000000
DEBUG EVAL: Branch var 7 = 1 gives z=27842125.237443
  % 	x7 = 1,	Z1 = 27842125.2374431        
DEBUG EVAL: First branch cutoff check: z=27842125.237443, best_z=INF, threshold=INF
  % Best branch is x20, Z0 = 27900919.6640938        , Z1 = 27843440.5640412        

DEBUG CAREFUL: Final result - returning best.var = 20
DEBUG BB: Branching variable chosen: j=20
 % @NC    3    1	x20 = 1	27843440.564041
 % @NC    4    1	x20 = 0	27900919.664094
 %       1     3 27841503.5855               27843440.5640    x5 D     0     1
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde8386600
% @LO 0.00  27.84150358550274262370 99.9000000000
% @LN 0.00  27.84344056404123435300 99.9000000000
% Resuming node 3 at  27.84344056404123435300
DEBUG CONSTRNT: LP rows=44, pool->nlprows=44, pool->npend=0
DEBUG CONSTRNT: Checking 44 LP rows (pool tracks 44, total LP rows 44)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=43, expected 43
 % @PAP adding 44 rows, 180 nz to LP
DEBUG BB: Processing node 3, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=6, varin=43, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 27843440.564041
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 44 rows, 60 cols, 240 nonzeros, 2 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 3 LP 1 Solution, length = 27843440.564041, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.500000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.500000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.500000 (FST 19)
  % DEBUG LP_VARS: x[20] = 1.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.500000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.500000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.500000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.500000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.500000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 3 fractional variables
DEBUG CG: LP optimal, z=27843440.564041, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=27843440.564041, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 3 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 3
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.500000
DEBUG CAREFUL: Adding var 7 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.500000
DEBUG CAREFUL: Adding var 13 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.500000
DEBUG CAREFUL: Adding var 19 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=1.000000
DEBUG CAREFUL: Skipping var 20: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 3 fractional variables

  %  Carefully choosing branching variable, nfrac = 3
DEBUG CAREFUL: Testing fvar[0] = var 19
DEBUG CAREFUL: Calling compare_branch_vars for var 19
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 19
DEBUG CAREFUL: New best var: 19
DEBUG CAREFUL: Testing fvar[1] = var 13
DEBUG CAREFUL: Calling compare_branch_vars for var 13
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 13
DEBUG CAREFUL: Testing fvar[2] = var 7
DEBUG CAREFUL: Calling compare_branch_vars for var 7
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 7
  % Initial guess is x19, Z0 = 27868287.5623161        , Z1 = 27843440.5640412        

DEBUG EVAL: Testing var 19 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=19, varin=62, theta=0.666667, up=1.000000
DEBUG EVAL: Branch var 19 = 1 gives z=27844683.867922
  % 	x19 = 1,	Z1 = 27844683.867922         
DEBUG EVAL: First branch cutoff check: z=27844683.867922, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 19 = 0
ITER 1: row=19, varin=17, theta=16.000000, up=999999999999999983222784.000000
ITER 2: row=1, varin=5, theta=4.500000, up=999999999999999983222784.000000
ITER 3: row=5, varin=6, theta=0.500000, up=999999999999999983222784.000000
ITER 4: row=6, varin=8, theta=0.500000, up=999999999999999983222784.000000
ITER 5: row=13, varin=13, theta=0.500000, up=999999999999999983222784.000000
ITER 6: row=17, varin=18, theta=0.500000, up=999999999999999983222784.000000
ITER 7: row=18, varin=19, theta=0.500000, up=999999999999999983222784.000000
ITER 8: row=22, varin=24, theta=1.000000, up=999999999999999983222784.000000
  % 	x19 = 0,	Z0 = 27902683.3332409        
DEBUG EVAL: Second branch cutoff check: z=27902683.333241, best_z=INF, threshold=INF
  %   New best:  x19, Z = 27844683.867922         
DEBUG EVAL: Testing var 13 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=32, varin=62, theta=0.666667, up=1.000000
DEBUG EVAL: Branch var 13 = 0 gives z=27844683.867922
  % 	x13 = 0,	Z0 = 27844683.867922         
DEBUG EVAL: First branch cutoff check: z=27844683.867922, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 13 = 1
ITER 1: row=32, varin=17, theta=16.000000, up=999999999999999983222784.000000
ITER 2: row=1, varin=5, theta=4.500000, up=999999999999999983222784.000000
ITER 3: row=5, varin=6, theta=0.500000, up=999999999999999983222784.000000
ITER 4: row=6, varin=8, theta=0.500000, up=999999999999999983222784.000000
ITER 5: row=13, varin=13, theta=0.500000, up=999999999999999983222784.000000
ITER 6: row=17, varin=18, theta=0.500000, up=999999999999999983222784.000000
ITER 7: row=18, varin=19, theta=0.500000, up=999999999999999983222784.000000
ITER 8: row=22, varin=24, theta=1.000000, up=999999999999999983222784.000000
  % 	x13 = 1,	Z1 = 27902683.3332409        
DEBUG EVAL: Second branch cutoff check: z=27902683.333241, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 7 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=8, varin=62, theta=0.666667, up=1.000000
DEBUG EVAL: Branch var 7 = 1 gives z=27844683.867922
  % 	x7 = 1,	Z1 = 27844683.867922         
DEBUG EVAL: First branch cutoff check: z=27844683.867922, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 7 = 0
ITER 1: row=8, varin=54, theta=1.000000, up=1.000000
  % 	x7 = 0,	Z0 = 27871659.5491666        
DEBUG EVAL: Second branch cutoff check: z=27871659.549167, best_z=INF, threshold=INF
  % Best branch is x19, Z0 = 27902683.3332409        , Z1 = 27844683.867922         

DEBUG CAREFUL: Final result - returning best.var = 19
DEBUG BB: Branching variable chosen: j=19
 % @NC    5    3	x19 = 1	27844683.867922
 % @NC    6    3	x19 = 0	27902683.333241
 %       3     4 27843440.5640               27844683.8679   x20 U     1     2
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde8397490
% @LO 0.00  27.84344056404123435300 99.9000000000
% @LN 0.00  27.84468386792197591717 99.9000000000
% Resuming node 5 at  27.84468386792197591717
DEBUG CONSTRNT: LP rows=44, pool->nlprows=44, pool->npend=0
DEBUG CONSTRNT: Checking 44 LP rows (pool tracks 44, total LP rows 44)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=43, expected 43
 % @PAP adding 44 rows, 180 nz to LP
DEBUG BB: Processing node 5, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=19, varin=62, theta=0.666667, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 27844683.867922
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 44 rows, 60 cols, 240 nonzeros, 2 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 7 rows, 67 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=51, varin=13, theta=2.415917, up=999999999999999983222784.000000
ITER 2: row=11, varin=61, theta=1.624587, up=1.000000
ITER 3: row=11, varin=42, theta=0.454361, up=999999999999999983222784.000000
ITER 4: row=42, varin=64, theta=0.683708, up=1.000000
ITER 5: row=1, varin=61, theta=0.484861, up=1.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 27915129.884386
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 51 rows, 60 cols, 307 nonzeros, 3 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 5 rows, 23 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=49, varin=71, theta=0.484269, up=1.000000
ITER 2: row=42, varin=61, theta=0.249205, up=1.000000
ITER 3: row=51, varin=54, theta=2.003941, up=1.000000
ITER 4: row=51, varin=56, theta=0.561196, up=1.000000
ITER 5: row=50, varin=54, theta=0.790527, up=1.000000
ITER 6: row=25, varin=78, theta=1.986188, up=1.000000
ITER 7: row=25, varin=39, theta=0.497266, up=999999999999999983222784.000000
ITER 8: row=12, varin=80, theta=0.918267, up=1.000000
ITER 9: row=3, varin=78, theta=1.000000, up=1.000000
ITER 10: row=12, varin=77, theta=0.511956, up=1.000000
LP PHASE: Switching to primal (iter=11)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=53)
DEBUG SOLUTION: LP solution array indices: FST[54-93], not_covered[94-113]
DEBUG SOLUTION: lp->best_solution[0] = 28119531.749847
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 53 rows, 60 cols, 314 nonzeros, 1 slack, 52 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 5 rows, 12 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=54, varin=84, theta=1.000000, up=1.000000
ITER 2: row=57, varin=28, theta=5.091719, up=999999999999999983222784.000000
ITER 3: row=8, varin=92, theta=1.439443, up=1.000000
ITER 4: row=8, varin=94, theta=0.475591, up=1.000000
ITER 5: row=35, varin=3, theta=0.893867, up=999999999999999983222784.000000
ITER 6: row=3, varin=39, theta=0.566036, up=999999999999999983222784.000000
ITER 7: row=25, varin=79, theta=0.628522, up=1.000000
ITER 8: row=52, varin=85, theta=0.806849, up=1.000000
ITER 9: row=8, varin=92, theta=0.937710, up=1.000000
LP PHASE: Switching to primal (iter=9)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=57)
DEBUG SOLUTION: LP solution array indices: FST[58-97], not_covered[98-117]
DEBUG SOLUTION: lp->best_solution[0] = 28451092.307599
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 57 rows, 60 cols, 317 nonzeros, 3 slack, 54 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 3 rows, 13 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=57, varin=114, theta=1.197241, up=1.000000
ITER 2: row=57, varin=60, theta=0.134698, up=1.000000
ITER 3: row=50, varin=114, theta=1.000000, up=1.000000
ITER 4: row=55, varin=94, theta=1.000000, up=1.000000
ITER 5: row=56, varin=86, theta=1.000000, up=1.000000
ITER 6: row=30, varin=67, theta=0.125000, up=1.000000
ITER 7: row=8, varin=89, theta=0.246051, up=1.000000
LP PHASE: Switching to primal (iter=7)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=57)
DEBUG SOLUTION: LP solution array indices: FST[58-97], not_covered[98-117]
DEBUG SOLUTION: lp->best_solution[0] = 28631910.313374
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 57 rows, 60 cols, 322 nonzeros, 1 slack, 56 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 5 rows, 16 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=60, varin=89, theta=0.500000, up=1.000000
ITER 2: row=57, varin=69, theta=0.024919, up=1.000000
ITER 3: row=59, varin=94, theta=0.139004, up=1.000000
ITER 4: row=10, varin=57, theta=0.026412, up=999999999999999983222784.000000
ITER 5: row=52, varin=55, theta=0.120583, up=999999999999999983222784.000000
ITER 6: row=10, varin=73, theta=0.048797, up=1.000000
ITER 7: row=41, varin=86, theta=0.014949, up=1.000000
ITER 8: row=3, varin=92, theta=0.030755, up=1.000000
ITER 9: row=15, varin=49, theta=0.015352, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=9)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=61)
DEBUG SOLUTION: LP solution array indices: FST[62-101], not_covered[102-121]
DEBUG SOLUTION: lp->best_solution[0] = 28771225.110323
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 61 rows, 60 cols, 336 nonzeros, 4 slack, 57 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=58, varin=11, theta=0.647874, up=999999999999999983222784.000000
ITER 2: row=13, varin=63, theta=0.695493, up=1.000000
ITER 3: row=39, varin=17, theta=0.644164, up=999999999999999983222784.000000
ITER 4: row=22, varin=88, theta=0.246119, up=1.000000
ITER 5: row=2, varin=92, theta=0.200639, up=1.000000
ITER 6: row=54, varin=22, theta=0.545357, up=999999999999999983222784.000000
ITER 7: row=14, varin=39, theta=0.902462, up=999999999999999983222784.000000
ITER 8: row=13, varin=75, theta=0.990047, up=1.000000
ITER 9: row=29, varin=41, theta=1.656074, up=999999999999999983222784.000000
ITER 10: row=41, varin=81, theta=1.663094, up=1.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=58)
DEBUG SOLUTION: LP solution array indices: FST[59-98], not_covered[99-118]
DEBUG SOLUTION: lp->best_solution[0] = 999999999999999983222784.000000
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 58 rows, 60 cols, 317 nonzeros, 5 slack, 53 tight.
  % Node 5 LP 1 Solution, length = 999999999999999983222784.000000, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.500000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.015352 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.015352 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 1.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.500000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.938591 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.015352 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.015352 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.984648 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.984648 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.500000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
DEBUG BB: compute_good_lower_bound returned status=1
DEBUG BB: Node 5 is INFEASIBLE
 %       5     3    infeasible               27866091.1699   x19 U     3     3
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde8397010
% @LO 0.00  27.84468386792197591717 99.9000000000
% @LN 0.00  27.86609116985043499426 99.9000000000
% Resuming node 2 at  27.86609116985043499426
DEBUG CONSTRNT: LP rows=58, pool->nlprows=58, pool->npend=0
DEBUG CONSTRNT: Checking 58 LP rows (pool tracks 58, total LP rows 58)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 141
DEBUG CONSTRNT: Pool row 141 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 145
DEBUG CONSTRNT: Pool row 145 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 159
DEBUG CONSTRNT: Pool row 159 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 133
DEBUG CONSTRNT: Pool row 133 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=54, expected 54
DEBUG CONSTRNT: Checking LP row 55 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=55, expected 55
DEBUG CONSTRNT: Checking LP row 56 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=56, expected 56
DEBUG CONSTRNT: Checking LP row 57 -> pool row 134
DEBUG CONSTRNT: Pool row 134 has lprow=57, expected 57
 % @PAP adding 45 rows, 184 nz to LP
DEBUG BB: Processing node 2, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=8, varin=35, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=44, varin=39, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 27866091.169850
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 45 rows, 60 cols, 244 nonzeros, 2 slack, 43 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 20 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=46, varin=67, theta=0.333333, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 27868649.800329
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 49 rows, 60 cols, 264 nonzeros, 4 slack, 45 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % @PAP adding 1 rows, 40 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=46, varin=13, theta=0.345145, up=999999999999999983222784.000000
ITER 2: row=11, varin=40, theta=0.098614, up=999999999999999983222784.000000
ITER 3: row=40, varin=38, theta=0.275736, up=999999999999999983222784.000000
ITER 4: row=45, varin=37, theta=0.122107, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=46)
DEBUG SOLUTION: LP solution array indices: FST[47-86], not_covered[87-106]
DEBUG SOLUTION: lp->best_solution[0] = 27879007.063438
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 46 rows, 60 cols, 284 nonzeros, 1 slack, 45 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 2 LP 1 Solution, length = 27879007.063438, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.438947 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.333333 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.438947 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.561053 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.561053 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.561053 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.561053 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.561053 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.561053 (terminal 19)
 % 3 fractional variables
DEBUG CG: LP optimal, z=27879007.063438, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
 % @LO 0.00  27.86609116985043499426 99.9000000000
 % @LN 0.00  27.87900706343750556471 99.9000000000
DEBUG CG: Second cutoff check: z=27879007.063438, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 2 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 2
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=1.000000
DEBUG CAREFUL: Skipping var 5: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.438947
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.438947)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.333333
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.438947
DEBUG CAREFUL: Adding var 20 to fractional list (xi=0.438947)
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 3 fractional variables

  %  Carefully choosing branching variable, nfrac = 3
DEBUG CAREFUL: Testing fvar[0] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 17
DEBUG CAREFUL: New best var: 17
DEBUG CAREFUL: Testing fvar[1] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[2] = var 20
DEBUG CAREFUL: Calling compare_branch_vars for var 20
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 20
  % Initial guess is x17, Z0 = 27879007.0634375        , Z1 = 27956883.7606697        

DEBUG EVAL: Testing var 17 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=35, varin=53, theta=1.000000, up=1.000000
ITER 2: row=19, varin=8, theta=1.428571, up=999999999999999983222784.000000
ITER 3: row=1, varin=38, theta=2.000000, up=999999999999999983222784.000000
ITER 4: row=43, varin=44, theta=0.766854, up=999999999999999983222784.000000
ITER 5: row=45, varin=20, theta=0.766854, up=999999999999999983222784.000000
ITER 6: row=21, varin=19, theta=0.766854, up=999999999999999983222784.000000
ITER 7: row=20, varin=21, theta=0.766854, up=999999999999999983222784.000000
ITER 8: row=29, varin=29, theta=0.766854, up=999999999999999983222784.000000
ITER 9: row=30, varin=35, theta=0.766854, up=999999999999999983222784.000000
ITER 10: row=44, varin=36, theta=0.766854, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 17 = 1 gives z=27993845.771793
  % 	x17 = 1,	Z1 = 27993845.7717932        
DEBUG EVAL: First branch cutoff check: z=27993845.771793, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 17 = 0
ITER 1: row=35, varin=58, theta=0.500000, up=1.000000
  % 	x17 = 0,	Z0 = 27887663.4521466        
DEBUG EVAL: Second branch cutoff check: z=27887663.452147, best_z=INF, threshold=INF
  %   New best:  x17, Z = 27887663.4521466        
DEBUG EVAL: Testing var 10 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=8, varin=44, theta=0.608448, up=999999999999999983222784.000000
ITER 2: row=37, varin=53, theta=0.708987, up=1.000000
ITER 3: row=20, varin=43, theta=0.495592, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 0 gives z=27912702.389220
  % 	x10 = 0,	Z0 = 27912702.3892197        
DEBUG EVAL: First branch cutoff check: z=27912702.389220, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 1
  % 	x10 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: Second branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=8, varin=44, theta=0.608448, up=999999999999999983222784.000000
ITER 2: row=37, varin=53, theta=0.708987, up=1.000000
ITER 3: row=20, varin=43, theta=0.495592, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 27912702.389220
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 45 rows, 60 cols, 280 nonzeros, 2 slack, 43 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 2 slack rows
   % @PAP adding 4 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=44, varin=95, theta=0.002594, up=1.000000
ITER 2: row=42, varin=11, theta=-1.352769, up=999999999999999983222784.000000
ITER 3: row=42, varin=48, theta=0.006553, up=1.000000
ITER 4: row=12, varin=11, theta=0.076143, up=999999999999999983222784.000000
ITER 5: row=13, varin=60, theta=0.003467, up=1.000000
LP PHASE: Switching to primal (iter=5)
ITER 6: row=1, varin=13, theta=0.000000, up=999999999999999983222784.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 27912826.380348
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 47 rows, 60 cols, 284 nonzeros, 0 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @PAP adding 3 rows, 12 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=48, varin=51, theta=0.006922, up=1.000000
ITER 2: row=13, varin=6, theta=0.005412, up=999999999999999983222784.000000
ITER 3: row=45, varin=32, theta=0.000704, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 27913001.033628
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 50 rows, 60 cols, 296 nonzeros, 3 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 3 slack rows
   % @PAP adding 2 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=48, varin=52, theta=0.004738, up=1.000000
ITER 2: row=25, varin=19, theta=0.001801, up=999999999999999983222784.000000
ITER 3: row=49, varin=65, theta=0.002068, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 27913246.004536
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 49 rows, 60 cols, 285 nonzeros, 1 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 2 at  27.91324600453609861006
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde8397250
% @LO 0.00  27.87900706343750556471 99.9000000000
% @LN 0.00  27.90091966409378798630 99.9000000000
% Resuming node 4 at  27.90091966409378798630
DEBUG CONSTRNT: LP rows=48, pool->nlprows=48, pool->npend=0
DEBUG CONSTRNT: Checking 48 LP rows (pool tracks 48, total LP rows 48)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=47, expected 47
 % @PAP adding 44 rows, 180 nz to LP
DEBUG BB: Processing node 4, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=6, varin=40, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=44, varin=41, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 27900919.664094
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 44 rows, 60 cols, 240 nonzeros, 2 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 4 LP 1 Solution, length = 27900919.664094, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.500000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 1.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.500000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.500000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.500000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.500000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.500000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.500000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.500000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 3 fractional variables
DEBUG CG: LP optimal, z=27900919.664094, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=27900919.664094, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 4 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 4
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.500000
DEBUG CAREFUL: Adding var 7 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=1.000000
DEBUG CAREFUL: Skipping var 10: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.500000
DEBUG CAREFUL: Adding var 13 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.500000
DEBUG CAREFUL: Adding var 19 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 3 fractional variables

  %  Carefully choosing branching variable, nfrac = 3
DEBUG CAREFUL: Testing fvar[0] = var 19
DEBUG CAREFUL: Calling compare_branch_vars for var 19
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 19
DEBUG CAREFUL: New best var: 19
DEBUG CAREFUL: Testing fvar[1] = var 13
DEBUG CAREFUL: Calling compare_branch_vars for var 13
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 13
DEBUG CAREFUL: Testing fvar[2] = var 7
DEBUG CAREFUL: Calling compare_branch_vars for var 7
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 7
  % Initial guess is x19, Z0 = 27900919.6640938        , Z1 = 27900919.6640938        

DEBUG EVAL: Testing var 19 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=19, varin=17, theta=16.000000, up=999999999999999983222784.000000
ITER 2: row=1, varin=5, theta=4.500000, up=999999999999999983222784.000000
ITER 3: row=5, varin=6, theta=0.500000, up=999999999999999983222784.000000
ITER 4: row=22, varin=24, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 19 = 0 gives z=27960162.433293
  % 	x19 = 0,	Z0 = 27960162.4332934        
DEBUG EVAL: First branch cutoff check: z=27960162.433293, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 19 = 1
ITER 1: row=19, varin=62, theta=0.666667, up=1.000000
  % 	x19 = 1,	Z1 = 27902162.9679745        
DEBUG EVAL: Second branch cutoff check: z=27902162.967975, best_z=INF, threshold=INF
  %   New best:  x19, Z = 27902162.9679745        
DEBUG EVAL: Testing var 13 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=32, varin=62, theta=0.666667, up=1.000000
DEBUG EVAL: Branch var 13 = 0 gives z=27902162.967975
  % 	x13 = 0,	Z0 = 27902162.9679745        
DEBUG EVAL: First branch cutoff check: z=27902162.967975, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 13 = 1
ITER 1: row=32, varin=17, theta=16.000000, up=999999999999999983222784.000000
ITER 2: row=1, varin=5, theta=4.500000, up=999999999999999983222784.000000
ITER 3: row=5, varin=6, theta=0.500000, up=999999999999999983222784.000000
ITER 4: row=22, varin=24, theta=1.000000, up=999999999999999983222784.000000
  % 	x13 = 1,	Z1 = 27960162.4332934        
DEBUG EVAL: Second branch cutoff check: z=27960162.433293, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 7 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=8, varin=54, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 7 = 0 gives z=27929138.649219
  % 	x7 = 0,	Z0 = 27929138.6492192        
DEBUG EVAL: First branch cutoff check: z=27929138.649219, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 7 = 1
ITER 1: row=8, varin=62, theta=0.666667, up=1.000000
  % 	x7 = 1,	Z1 = 27902162.9679745        
DEBUG EVAL: Second branch cutoff check: z=27902162.967975, best_z=INF, threshold=INF
  % Best branch is x19, Z0 = 27960162.4332934        , Z1 = 27902162.9679745        

DEBUG CAREFUL: Final result - returning best.var = 19
DEBUG BB: Branching variable chosen: j=19
 % @NC    7    4	x19 = 1	27902162.967975
 % @NC    8    4	x19 = 0	27960162.433293
 %       4     4 27900919.6641               27902162.9680   x20 D     1     2
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde8397490
% @LO 0.00  27.90091966409378798630 99.9000000000
% @LN 0.00  27.90216296797452955047 99.9000000000
% Resuming node 7 at  27.90216296797452955047
DEBUG CONSTRNT: LP rows=44, pool->nlprows=44, pool->npend=0
DEBUG CONSTRNT: Checking 44 LP rows (pool tracks 44, total LP rows 44)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=43, expected 43
 % @PAP adding 44 rows, 180 nz to LP
DEBUG BB: Processing node 7, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=19, varin=62, theta=0.666667, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 27902162.967975
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 44 rows, 60 cols, 240 nonzeros, 2 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 6 rows, 31 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=45, varin=51, theta=1.297297, up=1.000000
ITER 2: row=45, varin=60, theta=0.229167, up=1.000000
ITER 3: row=7, varin=17, theta=3.000000, up=999999999999999983222784.000000
ITER 4: row=2, varin=51, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 27929138.649219
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 50 rows, 60 cols, 271 nonzeros, 2 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 2 rows, 11 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=49, varin=6, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=45, varin=38, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 27940434.383770
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 50 rows, 60 cols, 278 nonzeros, 2 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 2 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=49, varin=63, theta=0.250000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 27942562.435779
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 50 rows, 60 cols, 273 nonzeros, 1 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 3 rows, 12 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=50, varin=77, theta=0.400000, up=1.000000
ITER 2: row=3, varin=55, theta=0.300000, up=1.000000
ITER 3: row=45, varin=18, theta=0.034884, up=999999999999999983222784.000000
ITER 4: row=25, varin=5, theta=0.333333, up=999999999999999983222784.000000
ITER 5: row=22, varin=45, theta=4.000000, up=999999999999999983222784.000000
ITER 6: row=46, varin=71, theta=0.166667, up=1.000000
ITER 7: row=22, varin=37, theta=0.020833, up=999999999999999983222784.000000
ITER 8: row=47, varin=45, theta=0.055556, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=8)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 27974000.691268
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.972222
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 52 rows, 60 cols, 279 nonzeros, 5 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % @PAP adding 2 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=48, varin=22, theta=0.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 27976023.908575
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.500000
DEBUG SOLUTION: lp->best_solution[5] = 2.500000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.500000
DEBUG SOLUTION: lp->best_solution[9] = 0.500000
DEBUG SOLUTION: lp->best_solution[10] = 3.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.500000
DEBUG SOLUTION: lp->best_solution[14] = 0.500000
  % @PL 49 rows, 60 cols, 260 nonzeros, 11 slack, 38 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 11 slack rows
  % @PAP adding 2 rows, 5 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=39, varin=15, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=40)
DEBUG SOLUTION: LP solution array indices: FST[41-80], not_covered[81-100]
DEBUG SOLUTION: lp->best_solution[0] = 27980280.034407
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.500000
DEBUG SOLUTION: lp->best_solution[14] = 0.500000
  % @PL 40 rows, 60 cols, 233 nonzeros, 3 slack, 37 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 2 rows, 12 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=38, varin=28, theta=0.625000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=39)
DEBUG SOLUTION: LP solution array indices: FST[40-79], not_covered[80-99]
DEBUG SOLUTION: lp->best_solution[0] = 27985351.208461
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 39 rows, 60 cols, 237 nonzeros, 2 slack, 37 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % Node 7 LP 1 Solution, length = 27985351.208461, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.125000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.500000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.500000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.500000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.125000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.125000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.500000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.875000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.875000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.500000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.875000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.500000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.875000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.500000 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=27985351.208461, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 7 at  27.98535120846072743461
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde8398c10
% @LO 0.00  27.90216296797452955047 99.9000000000
% @LN 0.00  27.90268333324085858749 99.9000000000
% Resuming node 6 at  27.90268333324085858749
DEBUG CONSTRNT: LP rows=37, pool->nlprows=37, pool->npend=0
DEBUG CONSTRNT: Checking 37 LP rows (pool tracks 37, total LP rows 37)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=36, expected 36
 % @PAP adding 44 rows, 180 nz to LP
DEBUG BB: Processing node 6, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=19, varin=17, theta=16.000000, up=999999999999999983222784.000000
ITER 2: row=1, varin=5, theta=4.500000, up=999999999999999983222784.000000
ITER 3: row=5, varin=6, theta=0.500000, up=999999999999999983222784.000000
ITER 4: row=6, varin=8, theta=0.500000, up=999999999999999983222784.000000
ITER 5: row=13, varin=13, theta=0.500000, up=999999999999999983222784.000000
ITER 6: row=17, varin=18, theta=0.500000, up=999999999999999983222784.000000
ITER 7: row=18, varin=19, theta=0.500000, up=999999999999999983222784.000000
ITER 8: row=22, varin=24, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=8)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 27902683.333241
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 0.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 0.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 0.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 44 rows, 60 cols, 240 nonzeros, 17 slack, 27 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 8 rows, 48 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=45, varin=94, theta=1.000000, up=1.000000
ITER 2: row=47, varin=20, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=5, varin=96, theta=1.000000, up=1.000000
ITER 4: row=6, varin=97, theta=1.000000, up=1.000000
ITER 5: row=8, varin=98, theta=1.000000, up=1.000000
ITER 6: row=13, varin=99, theta=1.000000, up=1.000000
ITER 7: row=18, varin=54, theta=1.000000, up=1.000000
ITER 8: row=49, varin=21, theta=1.000000, up=999999999999999983222784.000000
ITER 9: row=17, varin=13, theta=4.000000, up=999999999999999983222784.000000
ITER 10: row=11, varin=70, theta=0.333333, up=1.000000
LP PHASE: Switching to primal (iter=11)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 27967389.982181
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 52 rows, 60 cols, 288 nonzeros, 10 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 10 slack rows
  % @PAP adding 7 rows, 67 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=49, varin=66, theta=0.250196, up=1.000000
ITER 2: row=43, varin=49, theta=186762.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 27970238.584257
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 49 rows, 60 cols, 303 nonzeros, 3 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 2 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=47, varin=49, theta=1.428571, up=1.000000
ITER 2: row=47, varin=30, theta=0.200000, up=999999999999999983222784.000000
ITER 3: row=12, varin=49, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 27992053.571952
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 48 rows, 60 cols, 262 nonzeros, 2 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 3 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=47, varin=65, theta=0.111111, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 27994750.992075
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 49 rows, 60 cols, 260 nonzeros, 0 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 16 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=50, varin=68, theta=0.111111, up=1.000000
ITER 2: row=53, varin=27, theta=0.019231, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=53)
DEBUG SOLUTION: LP solution array indices: FST[54-93], not_covered[94-113]
DEBUG SOLUTION: lp->best_solution[0] = 28001151.472203
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 53 rows, 60 cols, 276 nonzeros, 2 slack, 51 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=52, varin=65, theta=0.185185, up=1.000000
ITER 2: row=50, varin=26, theta=0.040650, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 28002635.664947
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 52 rows, 60 cols, 274 nonzeros, 1 slack, 51 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 3 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=53, varin=49, theta=0.282051, up=999999999999999983222784.000000
ITER 2: row=54, varin=50, theta=0.166667, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=54)
DEBUG SOLUTION: LP solution array indices: FST[55-94], not_covered[95-114]
DEBUG SOLUTION: lp->best_solution[0] = 28004082.977884
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 54 rows, 60 cols, 278 nonzeros, 2 slack, 52 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % Node 6 LP 1 Solution, length = 28004082.977884, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.111111 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.055556 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.444444 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.055556 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.055556 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.444444 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 1.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.555556 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.555556 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.555556 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.555556 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.555556 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.944444 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.944444 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28004082.977884, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 6 at  28.00408297788409583973
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde8397010
% @LO 0.00  27.90268333324085858749 99.9000000000
% @LN 0.00  27.91324600453609861006 99.9000000000
% Resuming node 2 at  27.91324600453609861006
DEBUG CONSTRNT: LP rows=52, pool->nlprows=52, pool->npend=0
DEBUG CONSTRNT: Checking 52 LP rows (pool tracks 52, total LP rows 52)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 65
DEBUG CONSTRNT: Pool row 65 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 141
DEBUG CONSTRNT: Pool row 141 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 145
DEBUG CONSTRNT: Pool row 145 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 159
DEBUG CONSTRNT: Pool row 159 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 49
DEBUG CONSTRNT: Pool row 49 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 68
DEBUG CONSTRNT: Pool row 68 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 82
DEBUG CONSTRNT: Pool row 82 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=51, expected 51
 % @PAP adding 48 rows, 223 nz to LP
DEBUG BB: Processing node 2, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 2 LP 2 Solution, length = 27913246.004536, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.002068 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.496898 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.997932 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.496898 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.503102 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.503102 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.002068 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.002068 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.503102 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.503102 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.002068 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.002068 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.503102 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=27913246.004536, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=27913246.004536, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 2 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 2
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=1.000000
DEBUG CAREFUL: Skipping var 5: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.002068
DEBUG CAREFUL: Adding var 15 to fractional list (xi=0.002068)
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.496898
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.496898)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.997932
DEBUG CAREFUL: Adding var 19 to fractional list (xi=0.997932)
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.496898
DEBUG CAREFUL: Adding var 20 to fractional list (xi=0.496898)
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 4 fractional variables

  %  Carefully choosing branching variable, nfrac = 4
DEBUG CAREFUL: Testing fvar[0] = var 19
DEBUG CAREFUL: Calling compare_branch_vars for var 19
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 19
DEBUG CAREFUL: New best var: 19
DEBUG CAREFUL: Testing fvar[1] = var 15
DEBUG CAREFUL: Calling compare_branch_vars for var 15
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 15
DEBUG CAREFUL: New best var: 15
DEBUG CAREFUL: Testing fvar[2] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[3] = var 20
DEBUG CAREFUL: Calling compare_branch_vars for var 20
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 20
  % Initial guess is x15, Z0 = 27913246.0045361        , Z1 = 28159895.71745          

DEBUG EVAL: Testing var 19 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=19, varin=73, theta=0.011167, up=1.000000
ITER 2: row=3, varin=17, theta=0.029242, up=999999999999999983222784.000000
ITER 3: row=21, varin=67, theta=0.003430, up=1.000000
DEBUG EVAL: Branch var 19 = 1 gives z=27913655.073772
  % 	x19 = 1,	Z1 = 27913655.0737718        
DEBUG EVAL: First branch cutoff check: z=27913655.073772, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 19 = 0
ITER 1: row=19, varin=24, theta=1.524264, up=999999999999999983222784.000000
ITER 2: row=8, varin=41, theta=2.611817, up=999999999999999983222784.000000
ITER 3: row=6, varin=13, theta=10.021901, up=999999999999999983222784.000000
ITER 4: row=11, varin=44, theta=1.673357, up=999999999999999983222784.000000
ITER 5: row=24, varin=12, theta=2.319255, up=999999999999999983222784.000000
ITER 6: row=1, varin=40, theta=1.418248, up=999999999999999983222784.000000
ITER 7: row=39, varin=8, theta=0.611275, up=999999999999999983222784.000000
ITER 8: row=5, varin=31, theta=1.071341, up=999999999999999983222784.000000
ITER 9: row=31, varin=32, theta=0.071341, up=999999999999999983222784.000000
  % 	x19 = 0,	Z0 = 28225476.4149264        
DEBUG EVAL: Second branch cutoff check: z=28225476.414926, best_z=INF, threshold=INF
  %   New best:  x19, Z = 27913655.0737718        
DEBUG EVAL: Testing var 15 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=38, varin=48, theta=0.434699, up=999999999999999983222784.000000
ITER 2: row=24, varin=24, theta=1.524264, up=999999999999999983222784.000000
ITER 3: row=8, varin=41, theta=2.611817, up=999999999999999983222784.000000
ITER 4: row=6, varin=13, theta=10.021901, up=999999999999999983222784.000000
ITER 5: row=11, varin=12, theta=2.319255, up=999999999999999983222784.000000
ITER 6: row=1, varin=40, theta=1.418248, up=999999999999999983222784.000000
ITER 7: row=39, varin=8, theta=0.611275, up=999999999999999983222784.000000
ITER 8: row=5, varin=31, theta=1.071341, up=999999999999999983222784.000000
ITER 9: row=31, varin=19, theta=0.071341, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 15 = 1 gives z=28225476.414926
  % 	x15 = 1,	Z1 = 28225476.4149264        
DEBUG EVAL: First branch cutoff check: z=28225476.414926, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 15 = 0
ITER 1: row=38, varin=73, theta=0.011167, up=1.000000
ITER 2: row=3, varin=17, theta=0.029242, up=999999999999999983222784.000000
ITER 3: row=21, varin=63, theta=0.002106, up=1.000000
  % 	x15 = 0,	Z0 = 27913362.549635         
DEBUG EVAL: Second branch cutoff check: z=27913362.549635, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 17 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=39, varin=13, theta=1.704957, up=999999999999999983222784.000000
ITER 2: row=11, varin=18, theta=0.851567, up=999999999999999983222784.000000
ITER 3: row=42, varin=12, theta=1.190041, up=999999999999999983222784.000000
ITER 4: row=1, varin=24, theta=1.877570, up=999999999999999983222784.000000
ITER 5: row=8, varin=32, theta=0.826838, up=999999999999999983222784.000000
ITER 6: row=43, varin=34, theta=0.803504, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 17 = 1 gives z=28185941.639583
  % 	x17 = 1,	Z1 = 28185941.6395827        
DEBUG EVAL: First branch cutoff check: z=28185941.639583, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 17 = 0
ITER 1: row=39, varin=73, theta=8.940989, up=1.000000
ITER 2: row=39, varin=17, theta=3.277088, up=999999999999999983222784.000000
ITER 3: row=21, varin=41, theta=0.770029, up=999999999999999983222784.000000
ITER 4: row=6, varin=13, theta=1.811706, up=999999999999999983222784.000000
ITER 5: row=7, varin=23, theta=1.116785, up=999999999999999983222784.000000
ITER 6: row=2, varin=67, theta=0.409185, up=1.000000
ITER 7: row=3, varin=73, theta=1.000000, up=1.000000
ITER 8: row=19, varin=7, theta=1.968257, up=999999999999999983222784.000000
ITER 9: row=39, varin=39, theta=513496.666667, up=999999999999999983222784.000000
  % 	x17 = 0,	Z0 = 28040170.9327857        
DEBUG EVAL: Second branch cutoff check: z=28040170.932786, best_z=INF, threshold=INF
  %   New best:  x17, Z = 28040170.9327857        
DEBUG EVAL: Testing var 20 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=18, varin=73, theta=8.940989, up=1.000000
ITER 2: row=18, varin=17, theta=3.277088, up=999999999999999983222784.000000
ITER 3: row=21, varin=13, theta=1.811706, up=999999999999999983222784.000000
ITER 4: row=7, varin=18, theta=1.078489, up=999999999999999983222784.000000
ITER 5: row=42, varin=23, theta=1.116785, up=999999999999999983222784.000000
ITER 6: row=2, varin=67, theta=0.409185, up=1.000000
ITER 7: row=3, varin=73, theta=1.000000, up=1.000000
ITER 8: row=19, varin=7, theta=1.968257, up=999999999999999983222784.000000
ITER 9: row=21, varin=39, theta=513496.666667, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 20 = 0 gives z=28040170.932786
  % 	x20 = 0,	Z0 = 28040170.9327857        
DEBUG EVAL: First branch cutoff check: z=28040170.932786, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 20 = 1
ITER 1: row=18, varin=13, theta=1.704957, up=999999999999999983222784.000000
ITER 2: row=11, varin=41, theta=1.178570, up=999999999999999983222784.000000
ITER 3: row=6, varin=24, theta=1.877570, up=999999999999999983222784.000000
ITER 4: row=8, varin=12, theta=1.190041, up=999999999999999983222784.000000
  % 	x20 = 1,	Z1 = 28026185.4957774        
DEBUG EVAL: Second branch cutoff check: z=28026185.495777, best_z=INF, threshold=INF
  % Best branch is x17, Z0 = 28040170.9327857        , Z1 = 28185941.6395827        

DEBUG CAREFUL: Final result - returning best.var = 17
DEBUG BB: Branching variable chosen: j=17
 % @NC    9    2	x17 = 0	28040170.932786
 % @NC   10    2	x17 = 1	28185941.639583
 %       2     5 27913246.0045               27960162.4333    x5 U     0     1
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde8386600
% @LO 0.01  27.91324600453609861006 99.9000000000
% @LN 0.01  27.96016243329341577351 99.9000000000
% Resuming node 8 at  27.96016243329341577351
DEBUG CONSTRNT: LP rows=48, pool->nlprows=48, pool->npend=0
DEBUG CONSTRNT: Checking 48 LP rows (pool tracks 48, total LP rows 48)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=47, expected 47
 % @PAP adding 44 rows, 180 nz to LP
DEBUG BB: Processing node 8, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=19, varin=17, theta=16.000000, up=999999999999999983222784.000000
ITER 2: row=1, varin=5, theta=4.500000, up=999999999999999983222784.000000
ITER 3: row=5, varin=6, theta=0.500000, up=999999999999999983222784.000000
ITER 4: row=22, varin=24, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 27960162.433293
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 0.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 0.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 0.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 44 rows, 60 cols, 240 nonzeros, 17 slack, 27 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 8 rows, 48 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=45, varin=19, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=1, varin=94, theta=1.000000, up=1.000000
ITER 3: row=47, varin=20, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=5, varin=54, theta=1.000000, up=1.000000
ITER 5: row=49, varin=21, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=17, varin=13, theta=4.000000, up=999999999999999983222784.000000
ITER 7: row=11, varin=70, theta=0.333333, up=1.000000
ITER 8: row=51, varin=39, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=8)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 28024869.082234
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 52 rows, 60 cols, 288 nonzeros, 10 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 10 slack rows
  % @PAP adding 6 rows, 31 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=43, varin=65, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 28027717.684309
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 48 rows, 60 cols, 267 nonzeros, 2 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 2 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=47, varin=49, theta=1.428571, up=1.000000
ITER 2: row=47, varin=30, theta=0.200000, up=999999999999999983222784.000000
ITER 3: row=12, varin=49, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 28049532.672005
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 48 rows, 60 cols, 266 nonzeros, 2 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 3 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=47, varin=93, theta=0.250000, up=1.000000
ITER 2: row=42, varin=65, theta=0.111111, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 28052230.092127
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 49 rows, 60 cols, 264 nonzeros, 0 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 16 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=50, varin=32, theta=0.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=53)
DEBUG SOLUTION: LP solution array indices: FST[54-93], not_covered[94-113]
DEBUG SOLUTION: lp->best_solution[0] = 28055758.562148
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 53 rows, 60 cols, 280 nonzeros, 1 slack, 52 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 8 LP 1 Solution, length = 28055758.562148, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.500000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.500000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.500000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.500000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.500000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.500000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.500000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.500000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.500000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.500000 (terminal 19)
 % 3 fractional variables
DEBUG CG: LP optimal, z=28055758.562148, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 8 at  28.05575856214834473690
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde8397490
% @LO 0.01  27.96016243329341577351 99.9000000000
% @LN 0.01  27.98535120846072743461 99.9000000000
% Resuming node 7 at  27.98535120846072743461
DEBUG CONSTRNT: LP rows=52, pool->nlprows=52, pool->npend=0
DEBUG CONSTRNT: Checking 52 LP rows (pool tracks 52, total LP rows 52)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 65
DEBUG CONSTRNT: Pool row 65 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 49
DEBUG CONSTRNT: Pool row 49 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 68
DEBUG CONSTRNT: Pool row 68 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 82
DEBUG CONSTRNT: Pool row 82 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 121
DEBUG CONSTRNT: Pool row 121 has lprow=51, expected 51
 % @PAP adding 37 rows, 159 nz to LP
DEBUG BB: Processing node 7, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 7 LP 2 Solution, length = 27985351.208461, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.125000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.500000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.500000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.500000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.125000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.125000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.500000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.875000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.875000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.500000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.875000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.500000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.875000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.500000 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=27985351.208461, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=27985351.208461, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 7 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 7
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.125000
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.125000)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.500000
DEBUG CAREFUL: Adding var 7 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.500000
DEBUG CAREFUL: Adding var 9 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.500000
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.125000
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.125000)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.125000
DEBUG CAREFUL: Adding var 18 to fractional list (xi=0.125000)
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 6 fractional variables

  %  Carefully choosing branching variable, nfrac = 6
DEBUG CAREFUL: Testing fvar[0] = var 9
DEBUG CAREFUL: Calling compare_branch_vars for var 9
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 9
DEBUG CAREFUL: New best var: 9
DEBUG CAREFUL: Testing fvar[1] = var 7
DEBUG CAREFUL: Calling compare_branch_vars for var 7
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 7
DEBUG CAREFUL: Testing fvar[2] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[3] = var 18
DEBUG CAREFUL: Calling compare_branch_vars for var 18
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 18
DEBUG CAREFUL: New best var: 18
DEBUG CAREFUL: Testing fvar[4] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[5] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
  % Initial guess is x18, Z0 = 27985351.2084607        , Z1 = 28257487.0839494        

DEBUG EVAL: Testing var 9 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=19, varin=28, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 9 = 0 gives z=28041563.767702
  % 	x9 = 0,	Z0 = 28041563.7677023        
DEBUG EVAL: First branch cutoff check: z=28041563.767702, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 9 = 1
ITER 1: row=19, varin=21, theta=1.000000, up=999999999999999983222784.000000
  % 	x9 = 1,	Z1 = 28075054.0542792        
DEBUG EVAL: Second branch cutoff check: z=28075054.054279, best_z=INF, threshold=INF
  %   New best:  x9, Z = 28041563.7677023        
DEBUG EVAL: Testing var 7 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=12, varin=21, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 7 = 0 gives z=28075054.054279
  % 	x7 = 0,	Z0 = 28075054.0542792        
DEBUG EVAL: First branch cutoff check: z=28075054.054279, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 7 = 1
ITER 1: row=12, varin=28, theta=1.000000, up=999999999999999983222784.000000
  % 	x7 = 1,	Z1 = 28041563.7677023        
DEBUG EVAL: Second branch cutoff check: z=28041563.767702, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 10 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=20, varin=23, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 0 gives z=28013392.086300
  % 	x10 = 0,	Z0 = 28013392.0862997        
DEBUG EVAL: First branch cutoff check: z=28013392.086300, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 18 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=25, varin=37, theta=3.500000, up=999999999999999983222784.000000
ITER 2: row=1, varin=35, theta=2.500000, up=999999999999999983222784.000000
ITER 3: row=2, varin=26, theta=2.500000, up=999999999999999983222784.000000
ITER 4: row=34, varin=3, theta=2.500000, up=999999999999999983222784.000000
ITER 5: row=35, varin=30, theta=1.250000, up=999999999999999983222784.000000
ITER 6: row=30, varin=29, theta=2.500000, up=999999999999999983222784.000000
ITER 7: row=20, varin=27, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 18 = 1 gives z=28238346.649863
  % 	x18 = 1,	Z1 = 28257487.0839494        
DEBUG EVAL: First branch cutoff check: z=28257487.083949, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 18 = 0
ITER 1: row=25, varin=41, theta=0.250000, up=1.000000
  % 	x18 = 0,	Z0 = 27991528.8950708        
DEBUG EVAL: Second branch cutoff check: z=27991528.895071, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 17 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=22, varin=41, theta=0.250000, up=1.000000
DEBUG EVAL: Branch var 17 = 0 gives z=27991528.895071
  % 	x17 = 0,	Z0 = 27991528.8950708        
DEBUG EVAL: First branch cutoff check: z=27991528.895071, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 2 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=35, theta=3.500000, up=999999999999999983222784.000000
ITER 2: row=2, varin=33, theta=1.166667, up=999999999999999983222784.000000
ITER 3: row=25, varin=26, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 1 gives z=28095113.833641
  % 	x2 = 1,	Z1 = 28095113.8336414        
DEBUG EVAL: First branch cutoff check: z=28095113.833641, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 0
ITER 1: row=1, varin=37, theta=0.166667, up=999999999999999983222784.000000
  % 	x2 = 0,	Z0 = 27987041.5998119        
DEBUG EVAL: Second branch cutoff check: z=27987041.599812, best_z=INF, threshold=INF
  % Best branch is x9, Z0 = 28041563.7677023        , Z1 = 28075054.0542792        

DEBUG CAREFUL: Final result - returning best.var = 9
DEBUG BB: Branching variable chosen: j=9
 % @NC   11    7	x9 = 0	28041563.767702
 % @NC   12    7	x9 = 1	28075054.054279
 %       7     6 27985351.2085               28004082.9779   x19 U     4     3
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde8398c10
% @LO 0.01  27.98535120846072743461 99.9000000000
% @LN 0.01  28.00408297788409583973 99.9000000000
% Resuming node 6 at  28.00408297788409583973
DEBUG CONSTRNT: LP rows=37, pool->nlprows=37, pool->npend=0
DEBUG CONSTRNT: Checking 37 LP rows (pool tracks 37, total LP rows 37)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=36, expected 36
 % @PAP adding 52 rows, 206 nz to LP
DEBUG BB: Processing node 6, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 6 LP 2 Solution, length = 28004082.977884, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.111111 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.055556 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.444444 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.055556 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.055556 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.444444 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 1.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.555556 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.555556 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.555556 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.555556 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.555556 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.944444 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.944444 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28004082.977884, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28004082.977884, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 6 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 6
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.111111
DEBUG CAREFUL: Adding var 7 to fractional list (xi=0.111111)
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.055556
DEBUG CAREFUL: Adding var 12 to fractional list (xi=0.055556)
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.444444
DEBUG CAREFUL: Adding var 13 to fractional list (xi=0.444444)
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.055556
DEBUG CAREFUL: Adding var 14 to fractional list (xi=0.055556)
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.055556
DEBUG CAREFUL: Adding var 15 to fractional list (xi=0.055556)
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.444444
DEBUG CAREFUL: Adding var 16 to fractional list (xi=0.444444)
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=1.000000
DEBUG CAREFUL: Skipping var 20: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 6 fractional variables

  %  Carefully choosing branching variable, nfrac = 6
DEBUG CAREFUL: Testing fvar[0] = var 16
DEBUG CAREFUL: Calling compare_branch_vars for var 16
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 16
DEBUG CAREFUL: New best var: 16
DEBUG CAREFUL: Testing fvar[1] = var 7
DEBUG CAREFUL: Calling compare_branch_vars for var 7
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 7
DEBUG CAREFUL: Testing fvar[2] = var 13
DEBUG CAREFUL: Calling compare_branch_vars for var 13
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 13
DEBUG CAREFUL: Testing fvar[3] = var 14
DEBUG CAREFUL: Calling compare_branch_vars for var 14
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 14
DEBUG CAREFUL: New best var: 14
DEBUG CAREFUL: Testing fvar[4] = var 15
DEBUG CAREFUL: Calling compare_branch_vars for var 15
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 15
DEBUG CAREFUL: Testing fvar[5] = var 12
DEBUG CAREFUL: Calling compare_branch_vars for var 12
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 12
  % Initial guess is x14, Z0 = 28004082.9778841        , Z1 = 28236039.9918646        

DEBUG EVAL: Testing var 16 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=44, varin=11, theta=82.500000, up=999999999999999983222784.000000
ITER 2: row=5, varin=34, theta=0.966667, up=999999999999999983222784.000000
ITER 3: row=46, varin=17, theta=29.000000, up=999999999999999983222784.000000
ITER 4: row=7, varin=55, theta=2.600000, up=1.000000
ITER 5: row=7, varin=52, theta=2.666667, up=999999999999999983222784.000000
ITER 6: row=50, varin=36, theta=0.666667, up=999999999999999983222784.000000
ITER 7: row=47, varin=77, theta=4.000000, up=1.000000
ITER 8: row=47, varin=37, theta=0.666667, up=999999999999999983222784.000000
ITER 9: row=22, varin=55, theta=1.000000, up=1.000000
ITER 10: row=3, varin=77, theta=0.500000, up=1.000000
DEBUG EVAL: Branch var 16 = 1 gives z=28298717.409585
  % 	x16 = 1,	Z1 = 28298717.4095852        
DEBUG EVAL: First branch cutoff check: z=28298717.409585, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 16 = 0
ITER 1: row=44, varin=45, theta=0.666667, up=999999999999999983222784.000000
  % 	x16 = 0,	Z0 = 28028141.7897481        
DEBUG EVAL: Second branch cutoff check: z=28028141.789748, best_z=INF, threshold=INF
  %   New best:  x16, Z = 28028141.7897481        
DEBUG EVAL: Testing var 7 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=8, varin=11, theta=8.250000, up=999999999999999983222784.000000
ITER 2: row=13, varin=17, theta=2.250000, up=999999999999999983222784.000000
ITER 3: row=2, varin=55, theta=0.300000, up=1.000000
ITER 4: row=22, varin=52, theta=0.500000, up=999999999999999983222784.000000
ITER 5: row=50, varin=62, theta=0.111111, up=1.000000
DEBUG EVAL: Branch var 7 = 0 gives z=28014035.427024
  % 	x7 = 0,	Z0 = 28014035.4270235        
DEBUG EVAL: First branch cutoff check: z=28014035.427024, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 13 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=27, varin=51, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=33, varin=34, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=46, varin=36, theta=0.750000, up=999999999999999983222784.000000
ITER 4: row=47, varin=12, theta=1.571429, up=999999999999999983222784.000000
ITER 5: row=1, varin=37, theta=0.600000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 13 = 0 gives z=28107210.235288
  % 	x13 = 0,	Z0 = 28107210.2352878        
DEBUG EVAL: First branch cutoff check: z=28107210.235288, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 13 = 1
ITER 1: row=27, varin=11, theta=82.500000, up=999999999999999983222784.000000
ITER 2: row=5, varin=45, theta=1.611111, up=999999999999999983222784.000000
ITER 3: row=13, varin=17, theta=3.000000, up=999999999999999983222784.000000
ITER 4: row=2, varin=54, theta=1.000000, up=1.000000
ITER 5: row=44, varin=55, theta=1.200000, up=1.000000
ITER 6: row=44, varin=52, theta=0.333333, up=999999999999999983222784.000000
ITER 7: row=22, varin=55, theta=1.000000, up=1.000000
ITER 8: row=50, varin=77, theta=2.000000, up=1.000000
ITER 9: row=50, varin=25, theta=2.000000, up=999999999999999983222784.000000
ITER 10: row=3, varin=5, theta=1.000000, up=999999999999999983222784.000000
  % 	x13 = 1,	Z1 = 28167827.4834132        
DEBUG EVAL: Second branch cutoff check: z=28167827.483413, best_z=INF, threshold=INF
  %   New best:  x13, Z = 28107210.2352878        
DEBUG EVAL: Testing var 14 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=34, varin=52, theta=2.428571, up=999999999999999983222784.000000
ITER 2: row=50, varin=51, theta=1.545455, up=999999999999999983222784.000000
ITER 3: row=48, varin=50, theta=1.500000, up=999999999999999983222784.000000
ITER 4: row=33, varin=45, theta=2.000000, up=999999999999999983222784.000000
ITER 5: row=44, varin=12, theta=1.571429, up=999999999999999983222784.000000
ITER 6: row=1, varin=38, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=38, varin=11, theta=45.000000, up=999999999999999983222784.000000
ITER 8: row=5, varin=25, theta=8.400000, up=999999999999999983222784.000000
ITER 9: row=25, varin=35, theta=1.800000, up=999999999999999983222784.000000
ITER 10: row=36, varin=6, theta=0.800000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 14 = 1 gives z=28236039.991865
  % 	x14 = 1,	Z1 = 28236039.9918646        
DEBUG EVAL: First branch cutoff check: z=28236039.991865, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 14 = 0
ITER 1: row=34, varin=11, theta=8.250000, up=999999999999999983222784.000000
ITER 2: row=13, varin=49, theta=0.111111, up=999999999999999983222784.000000
  % 	x14 = 0,	Z0 = 28008159.4053406        
DEBUG EVAL: Second branch cutoff check: z=28008159.405341, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 15 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=48, varin=51, theta=4.250000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 15 = 1 gives z=28066565.862122
  % 	x15 = 1,	Z1 = 28188739.9666865        
DEBUG EVAL: First branch cutoff check: z=28188739.966686, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 15 = 0
ITER 1: row=48, varin=11, theta=8.250000, up=999999999999999983222784.000000
  % 	x15 = 0,	Z0 = 28004401.0457693        
DEBUG EVAL: Second branch cutoff check: z=28004401.045769, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 12 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=33, varin=52, theta=2.428571, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 12 = 1 gives z=28043666.470104
  % 	x12 = 1,	Z1 = 28043666.4701038        
DEBUG EVAL: First branch cutoff check: z=28043666.470104, best_z=INF, threshold=INF
  % Best branch is x13, Z0 = 28107210.2352878        , Z1 = 28167827.4834132        

DEBUG CAREFUL: Final result - returning best.var = 13
DEBUG BB: Branching variable chosen: j=13
 % @NC   13    6	x13 = 0	28107210.235288
 % @NC   14    6	x13 = 1	28167827.483413
 %       6     7 28004082.9779               28040170.9328   x19 D     3     3
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde8397250
% @LO 0.01  28.00408297788409583973 99.9000000000
% @LN 0.01  28.04017093278566008507 99.9000000000
% Resuming node 9 at  28.04017093278566008507
DEBUG CONSTRNT: LP rows=52, pool->nlprows=52, pool->npend=0
DEBUG CONSTRNT: Checking 52 LP rows (pool tracks 52, total LP rows 52)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 65
DEBUG CONSTRNT: Pool row 65 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 141
DEBUG CONSTRNT: Pool row 141 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 145
DEBUG CONSTRNT: Pool row 145 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 159
DEBUG CONSTRNT: Pool row 159 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 49
DEBUG CONSTRNT: Pool row 49 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 68
DEBUG CONSTRNT: Pool row 68 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 82
DEBUG CONSTRNT: Pool row 82 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=51, expected 51
 % @PAP adding 48 rows, 223 nz to LP
DEBUG BB: Processing node 9, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=39, varin=73, theta=8.940989, up=1.000000
ITER 2: row=39, varin=17, theta=3.277088, up=999999999999999983222784.000000
ITER 3: row=21, varin=41, theta=0.770029, up=999999999999999983222784.000000
ITER 4: row=6, varin=13, theta=1.811706, up=999999999999999983222784.000000
ITER 5: row=7, varin=23, theta=1.116785, up=999999999999999983222784.000000
ITER 6: row=2, varin=67, theta=0.409185, up=1.000000
ITER 7: row=3, varin=73, theta=1.000000, up=1.000000
ITER 8: row=19, varin=7, theta=1.968257, up=999999999999999983222784.000000
ITER 9: row=39, varin=39, theta=513496.666667, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=9)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 28040170.932786
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 48 rows, 60 cols, 283 nonzeros, 1 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 8 rows, 42 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=48, varin=39, theta=0.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=55)
DEBUG SOLUTION: LP solution array indices: FST[56-95], not_covered[96-115]
DEBUG SOLUTION: lp->best_solution[0] = 28042389.508549
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 55 rows, 60 cols, 285 nonzeros, 8 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 8 slack rows
  % @PAP adding 1 rows, 40 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=48, varin=17, theta=0.518951, up=999999999999999983222784.000000
ITER 2: row=11, varin=68, theta=0.045556, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 28044581.364367
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 48 rows, 60 cols, 283 nonzeros, 0 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 9 LP 1 Solution, length = 28044581.364367, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.045556 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.431665 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.954444 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.431665 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.568335 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.568335 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.045556 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.045556 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.568335 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.568335 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.045556 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.045556 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.568335 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=28044581.364367, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 9 at  28.04458136436742421438
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde8397010
% @LO 0.01  28.04017093278566008507 99.9000000000
% @LN 0.01  28.04156376770228220607 99.9000000000
% Resuming node 11 at  28.04156376770228220607
DEBUG CONSTRNT: LP rows=48, pool->nlprows=48, pool->npend=0
DEBUG CONSTRNT: Checking 48 LP rows (pool tracks 48, total LP rows 48)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=47, expected 47
 % @PAP adding 37 rows, 159 nz to LP
DEBUG BB: Processing node 11, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=19, varin=28, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=37)
DEBUG SOLUTION: LP solution array indices: FST[38-77], not_covered[78-97]
DEBUG SOLUTION: lp->best_solution[0] = 28041563.767702
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 37 rows, 60 cols, 219 nonzeros, 1 slack, 36 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 5 rows, 22 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=42, varin=29, theta=0.066667, up=999999999999999983222784.000000
ITER 2: row=38, varin=46, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 28053919.140923
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 42 rows, 60 cols, 241 nonzeros, 1 slack, 41 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 6 rows, 31 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=42, varin=74, theta=0.545455, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 28061679.226255
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 47 rows, 60 cols, 270 nonzeros, 5 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % @PAP adding 3 rows, 7 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=43, varin=39, theta=0.833333, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 28063619.101680
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 45 rows, 60 cols, 244 nonzeros, 1 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 11 LP 1 Solution, length = 28063619.101680, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.166667 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.166667 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.166667 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.166667 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.166667 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.166667 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.833333 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.833333 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.833333 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.833333 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.833333 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.833333 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.833333 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28063619.101680, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 11 at  28.06361910167995077359
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde8397250
% @LO 0.01  28.04156376770228220607 99.9000000000
% @LN 0.01  28.04458136436742421438 99.9000000000
% Resuming node 9 at  28.04458136436742421438
DEBUG CONSTRNT: LP rows=44, pool->nlprows=44, pool->npend=0
DEBUG CONSTRNT: Checking 44 LP rows (pool tracks 44, total LP rows 44)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=43, expected 43
 % @PAP adding 48 rows, 223 nz to LP
DEBUG BB: Processing node 9, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 9 LP 2 Solution, length = 28044581.364367, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.045556 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.431665 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.954444 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.431665 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.568335 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.568335 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.045556 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.045556 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.568335 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.568335 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.045556 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.045556 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.568335 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=28044581.364367, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28044581.364367, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 9 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 9
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=1.000000
DEBUG CAREFUL: Skipping var 5: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.045556
DEBUG CAREFUL: Adding var 15 to fractional list (xi=0.045556)
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.431665
DEBUG CAREFUL: Adding var 18 to fractional list (xi=0.431665)
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.954444
DEBUG CAREFUL: Adding var 19 to fractional list (xi=0.954444)
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.431665
DEBUG CAREFUL: Adding var 20 to fractional list (xi=0.431665)
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 4 fractional variables

  %  Carefully choosing branching variable, nfrac = 4
DEBUG CAREFUL: Testing fvar[0] = var 19
DEBUG CAREFUL: Calling compare_branch_vars for var 19
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 19
DEBUG CAREFUL: New best var: 19
DEBUG CAREFUL: Testing fvar[1] = var 15
DEBUG CAREFUL: Calling compare_branch_vars for var 15
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 15
DEBUG CAREFUL: Testing fvar[2] = var 18
DEBUG CAREFUL: Calling compare_branch_vars for var 18
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 18
DEBUG CAREFUL: New best var: 18
DEBUG CAREFUL: Testing fvar[3] = var 20
DEBUG CAREFUL: Calling compare_branch_vars for var 20
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 20
  % Initial guess is x18, Z0 = 28044581.3643674        , Z1 = 28257487.0839494        

DEBUG EVAL: Testing var 19 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=19, varin=5, theta=0.339419, up=999999999999999983222784.000000
ITER 2: row=7, varin=27, theta=0.384931, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 19 = 1 gives z=28045383.590762
  % 	x19 = 1,	Z1 = 28045383.5907617        
DEBUG EVAL: First branch cutoff check: z=28045383.590762, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 19 = 0
ITER 1: row=19, varin=44, theta=1.457113, up=999999999999999983222784.000000
ITER 2: row=39, varin=3, theta=0.404973, up=999999999999999983222784.000000
ITER 3: row=17, varin=24, theta=0.370648, up=999999999999999983222784.000000
ITER 4: row=8, varin=12, theta=0.232524, up=999999999999999983222784.000000
ITER 5: row=3, varin=39, theta=0.504794, up=999999999999999983222784.000000
ITER 6: row=24, varin=2, theta=0.377372, up=999999999999999983222784.000000
ITER 7: row=1, varin=5, theta=3.214024, up=999999999999999983222784.000000
ITER 8: row=5, varin=8, theta=0.065694, up=999999999999999983222784.000000
ITER 9: row=2, varin=29, theta=0.071341, up=999999999999999983222784.000000
  % 	x19 = 0,	Z0 = 28225476.4149264        
DEBUG EVAL: Second branch cutoff check: z=28225476.414926, best_z=INF, threshold=INF
  %   New best:  x19, Z = 28045383.5907617        
DEBUG EVAL: Testing var 15 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=38, varin=44, theta=1.457113, up=999999999999999983222784.000000
ITER 2: row=39, varin=43, theta=0.155657, up=999999999999999983222784.000000
ITER 3: row=24, varin=3, theta=0.404973, up=999999999999999983222784.000000
ITER 4: row=17, varin=24, theta=0.370648, up=999999999999999983222784.000000
ITER 5: row=8, varin=12, theta=0.232524, up=999999999999999983222784.000000
ITER 6: row=3, varin=2, theta=0.377372, up=999999999999999983222784.000000
ITER 7: row=1, varin=5, theta=3.214024, up=999999999999999983222784.000000
ITER 8: row=5, varin=8, theta=0.065694, up=999999999999999983222784.000000
ITER 9: row=21, varin=21, theta=0.039318, up=999999999999999983222784.000000
ITER 10: row=2, varin=18, theta=0.071341, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 15 = 1 gives z=28225476.414926
  % 	x15 = 1,	Z1 = 28225476.4149264        
DEBUG EVAL: First branch cutoff check: z=28225476.414926, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 15 = 0
ITER 1: row=38, varin=5, theta=0.339419, up=999999999999999983222784.000000
ITER 2: row=7, varin=27, theta=0.384931, up=999999999999999983222784.000000
  % 	x15 = 0,	Z0 = 28045383.5907617        
DEBUG EVAL: Second branch cutoff check: z=28045383.590762, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 18 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=39, varin=18, theta=1.141497, up=999999999999999983222784.000000
ITER 2: row=45, varin=2, theta=1.016159, up=999999999999999983222784.000000
ITER 3: row=17, varin=3, theta=7.847859, up=999999999999999983222784.000000
ITER 4: row=3, varin=33, theta=1.107357, up=999999999999999983222784.000000
ITER 5: row=46, varin=12, theta=1.562341, up=999999999999999983222784.000000
ITER 6: row=1, varin=8, theta=3.042021, up=999999999999999983222784.000000
ITER 7: row=2, varin=24, theta=2.441546, up=999999999999999983222784.000000
ITER 8: row=8, varin=32, theta=1.075199, up=999999999999999983222784.000000
ITER 9: row=47, varin=5, theta=111.075068, up=999999999999999983222784.000000
ITER 10: row=5, varin=34, theta=1.016637, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 18 = 1 gives z=28691698.840497
  % 	x18 = 1,	Z1 = 28691698.8404968        
DEBUG EVAL: First branch cutoff check: z=28691698.840497, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 18 = 0
ITER 1: row=39, varin=44, theta=0.894578, up=999999999999999983222784.000000
  % 	x18 = 0,	Z0 = 28078728.1831994        
DEBUG EVAL: Second branch cutoff check: z=28078728.183199, best_z=INF, threshold=INF
  %   New best:  x18, Z = 28078728.1831994        
DEBUG EVAL: Testing var 20 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=6, varin=34, theta=-28.121497, up=999999999999999983222784.000000
ITER 2: row=47, varin=5, theta=1.445284, up=999999999999999983222784.000000
ITER 3: row=7, varin=11, theta=2.233962, up=999999999999999983222784.000000
ITER 4: row=1, varin=7, theta=0.343322, up=999999999999999983222784.000000
ITER 5: row=2, varin=27, theta=0.623771, up=999999999999999983222784.000000
ITER 6: row=20, varin=48, theta=89569.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 20 = 0 gives z=28049433.730818
  % 	x20 = 0,	Z0 = 28049433.7308179        
DEBUG EVAL: First branch cutoff check: z=28049433.730818, best_z=INF, threshold=INF
  % Best branch is x18, Z0 = 28078728.1831994        , Z1 = 28691698.8404968        

DEBUG CAREFUL: Final result - returning best.var = 18
DEBUG BB: Branching variable chosen: j=18
 % @NC   15    9	x18 = 0	28078728.183199
 % @NC   16    9	x18 = 1	28691698.840497
 %       9     8 28044581.3644               28055758.5621   x17 D     2     2
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde8386600
% @LO 0.01  28.04458136436742421438 99.9000000000
% @LN 0.01  28.05575856214834473690 99.9000000000
% Resuming node 8 at  28.05575856214834473690
DEBUG CONSTRNT: LP rows=48, pool->nlprows=48, pool->npend=0
DEBUG CONSTRNT: Checking 48 LP rows (pool tracks 48, total LP rows 48)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=47, expected 47
 % @PAP adding 52 rows, 216 nz to LP
DEBUG BB: Processing node 8, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 8 LP 2 Solution, length = 28055758.562148, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.500000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.500000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.500000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.500000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.500000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.500000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.500000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.500000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.500000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.500000 (terminal 19)
 % 3 fractional variables
DEBUG CG: LP optimal, z=28055758.562148, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28055758.562148, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 8 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 8
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.500000
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.500000
DEBUG CAREFUL: Adding var 13 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.500000
DEBUG CAREFUL: Adding var 16 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 3 fractional variables

  %  Carefully choosing branching variable, nfrac = 3
DEBUG CAREFUL: Testing fvar[0] = var 16
DEBUG CAREFUL: Calling compare_branch_vars for var 16
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 16
DEBUG CAREFUL: New best var: 16
DEBUG CAREFUL: Testing fvar[1] = var 13
DEBUG CAREFUL: Calling compare_branch_vars for var 13
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 13
DEBUG CAREFUL: Testing fvar[2] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
  % Initial guess is x16, Z0 = 28055758.5621483        , Z1 = 28091052.3594654        

DEBUG EVAL: Testing var 16 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=35, varin=49, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=30, varin=35, theta=0.800000, up=999999999999999983222784.000000
ITER 3: row=47, varin=65, theta=2.000000, up=1.000000
ITER 4: row=47, varin=11, theta=33.000000, up=999999999999999983222784.000000
ITER 5: row=5, varin=37, theta=0.458333, up=999999999999999983222784.000000
ITER 6: row=13, varin=54, theta=1.000000, up=1.000000
ITER 7: row=48, varin=17, theta=9.000000, up=999999999999999983222784.000000
ITER 8: row=12, varin=13, theta=2.000000, up=999999999999999983222784.000000
ITER 9: row=7, varin=55, theta=0.800000, up=1.000000
ITER 10: row=8, varin=38, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 16 = 1 gives z=28225460.646901
  % 	x16 = 1,	Z1 = 28225460.6469015        
DEBUG EVAL: First branch cutoff check: z=28225460.646901, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 16 = 0
ITER 1: row=35, varin=67, theta=1.000000, up=1.000000
ITER 2: row=30, varin=46, theta=0.666667, up=999999999999999983222784.000000
ITER 3: row=52, varin=63, theta=2.000000, up=1.000000
ITER 4: row=52, varin=27, theta=0.028571, up=999999999999999983222784.000000
  % 	x16 = 0,	Z0 = 28075501.3326654        
DEBUG EVAL: Second branch cutoff check: z=28075501.332665, best_z=INF, threshold=INF
  %   New best:  x16, Z = 28075501.3326654        
DEBUG EVAL: Testing var 13 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=29, varin=67, theta=1.000000, up=1.000000
ITER 2: row=30, varin=35, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=47, varin=26, theta=4.000000, up=999999999999999983222784.000000
ITER 4: row=51, varin=41, theta=2.000000, up=999999999999999983222784.000000
ITER 5: row=40, varin=37, theta=0.800000, up=999999999999999983222784.000000
ITER 6: row=48, varin=12, theta=2.095238, up=999999999999999983222784.000000
ITER 7: row=1, varin=38, theta=0.666667, up=999999999999999983222784.000000
ITER 8: row=52, varin=27, theta=0.058824, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 13 = 0 gives z=28161839.139721
  % 	x13 = 0,	Z0 = 28161839.1397207        
DEBUG EVAL: First branch cutoff check: z=28161839.139721, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 13 = 1
ITER 1: row=29, varin=46, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=33, varin=65, theta=0.500000, up=1.000000
ITER 3: row=50, varin=26, theta=0.125000, up=999999999999999983222784.000000
ITER 4: row=52, varin=11, theta=16.500000, up=999999999999999983222784.000000
ITER 5: row=5, varin=27, theta=0.075758, up=999999999999999983222784.000000
ITER 6: row=13, varin=54, theta=1.000000, up=1.000000
ITER 7: row=35, varin=49, theta=0.157895, up=999999999999999983222784.000000
  % 	x13 = 1,	Z1 = 28094570.7207295        
DEBUG EVAL: Second branch cutoff check: z=28094570.720729, best_z=INF, threshold=INF
  %   New best:  x13, Z = 28094570.7207295        
DEBUG EVAL: Testing var 10 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=30, varin=67, theta=0.111111, up=1.000000
ITER 2: row=52, varin=27, theta=0.019231, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 1 gives z=28058630.572256
  % 	x10 = 1,	Z1 = 28058630.572256         
DEBUG EVAL: First branch cutoff check: z=28058630.572256, best_z=INF, threshold=INF
  % Best branch is x13, Z0 = 28161839.1397207        , Z1 = 28094570.7207295        

DEBUG CAREFUL: Final result - returning best.var = 13
DEBUG BB: Branching variable chosen: j=13
 % @NC   17    8	x13 = 1	28094570.720729
 % @NC   18    8	x13 = 0	28161839.139721
 %       8     9 28055758.5621               28063619.1017   x19 D     4     3
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde8397010
% @LO 0.01  28.05575856214834473690 99.9000000000
% @LN 0.01  28.06361910167995077359 99.9000000000
% Resuming node 11 at  28.06361910167995077359
DEBUG CONSTRNT: LP rows=52, pool->nlprows=52, pool->npend=0
DEBUG CONSTRNT: Checking 52 LP rows (pool tracks 52, total LP rows 52)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 65
DEBUG CONSTRNT: Pool row 65 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 49
DEBUG CONSTRNT: Pool row 49 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 68
DEBUG CONSTRNT: Pool row 68 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 82
DEBUG CONSTRNT: Pool row 82 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 121
DEBUG CONSTRNT: Pool row 121 has lprow=51, expected 51
 % @PAP adding 44 rows, 174 nz to LP
DEBUG BB: Processing node 11, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 11 LP 2 Solution, length = 28063619.101680, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.166667 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.166667 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.166667 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.166667 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.166667 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.166667 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.833333 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.833333 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.833333 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.833333 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.833333 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.833333 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.833333 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28063619.101680, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28063619.101680, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 11 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 11
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.166667
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.166667
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=1.000000
DEBUG CAREFUL: Skipping var 7: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.166667
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.166667
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.166667
DEBUG CAREFUL: Adding var 18 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.166667
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 6 fractional variables

  %  Carefully choosing branching variable, nfrac = 6
DEBUG CAREFUL: Testing fvar[0] = var 18
DEBUG CAREFUL: Calling compare_branch_vars for var 18
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 18
DEBUG CAREFUL: New best var: 18
DEBUG CAREFUL: Testing fvar[1] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[2] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[3] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[4] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 3
DEBUG CAREFUL: Testing fvar[5] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
  % Initial guess is x18, Z0 = 28063619.10168          , Z1 = 28257487.0839494        

DEBUG EVAL: Testing var 18 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=31, varin=42, theta=5.000000, up=999999999999999983222784.000000
ITER 2: row=39, varin=39, theta=2.000000, up=999999999999999983222784.000000
ITER 3: row=12, varin=35, theta=2.000000, up=999999999999999983222784.000000
ITER 4: row=1, varin=33, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=2, varin=26, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=32, varin=3, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=33, varin=28, theta=0.500000, up=999999999999999983222784.000000
ITER 8: row=28, varin=36, theta=1.000000, up=999999999999999983222784.000000
ITER 9: row=20, varin=27, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 18 = 1 gives z=28240507.899494
  % 	x18 = 1,	Z1 = 28257487.0839494        
DEBUG EVAL: First branch cutoff check: z=28257487.083949, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 18 = 0
ITER 1: row=31, varin=31, theta=0.333333, up=999999999999999983222784.000000
ITER 2: row=37, varin=81, theta=1.000000, up=1.000000
  % 	x18 = 0,	Z0 = 28101595.7323779        
DEBUG EVAL: Second branch cutoff check: z=28101595.732378, best_z=INF, threshold=INF
  %   New best:  x18, Z = 28101595.7323779        
DEBUG EVAL: Testing var 17 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=25, varin=26, theta=0.333333, up=999999999999999983222784.000000
ITER 2: row=32, varin=81, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 17 = 0 gives z=28101595.732378
  % 	x17 = 0,	Z0 = 28101595.7323779        
DEBUG EVAL: First branch cutoff check: z=28101595.732378, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 17 = 1
ITER 1: row=25, varin=42, theta=5.000000, up=999999999999999983222784.000000
ITER 2: row=39, varin=39, theta=2.000000, up=999999999999999983222784.000000
ITER 3: row=12, varin=31, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=37, varin=35, theta=2.000000, up=999999999999999983222784.000000
ITER 5: row=1, varin=33, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=2, varin=36, theta=0.333333, up=999999999999999983222784.000000
  % 	x17 = 1,	Z1 = 28169457.1629941        
DEBUG EVAL: Second branch cutoff check: z=28169457.162994, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 10 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=20, varin=23, theta=0.200000, up=999999999999999983222784.000000
ITER 2: row=37, varin=81, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 10 = 0 gives z=28101595.732378
  % 	x10 = 0,	Z0 = 28101595.7323779        
DEBUG EVAL: First branch cutoff check: z=28101595.732378, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 1
ITER 1: row=20, varin=42, theta=5.000000, up=999999999999999983222784.000000
ITER 2: row=39, varin=39, theta=2.000000, up=999999999999999983222784.000000
ITER 3: row=12, varin=36, theta=0.500000, up=999999999999999983222784.000000
  % 	x10 = 1,	Z1 = 28131397.4170842        
DEBUG EVAL: Second branch cutoff check: z=28131397.417084, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 2 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=42, theta=5.000000, up=999999999999999983222784.000000
ITER 2: row=39, varin=39, theta=2.000000, up=999999999999999983222784.000000
ITER 3: row=12, varin=31, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=37, varin=26, theta=0.666667, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 1 gives z=28162023.688798
  % 	x2 = 1,	Z1 = 28162023.6887982        
DEBUG EVAL: First branch cutoff check: z=28162023.688798, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 0
ITER 1: row=1, varin=35, theta=0.200000, up=999999999999999983222784.000000
  % 	x2 = 0,	Z0 = 28070058.6380969        
DEBUG EVAL: Second branch cutoff check: z=28070058.638097, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 3 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=12, varin=42, theta=5.000000, up=999999999999999983222784.000000
ITER 2: row=39, varin=31, theta=2.000000, up=999999999999999983222784.000000
ITER 3: row=37, varin=35, theta=4.000000, up=999999999999999983222784.000000
ITER 4: row=1, varin=25, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=40, varin=33, theta=3.000000, up=999999999999999983222784.000000
ITER 6: row=2, varin=36, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 3 = 1 gives z=28250002.705040
  % 	x3 = 1,	Z1 = 28250002.7050401        
DEBUG EVAL: First branch cutoff check: z=28250002.705040, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 3 = 0
ITER 1: row=12, varin=39, theta=0.250000, up=999999999999999983222784.000000
  % 	x3 = 0,	Z0 = 28068469.0820587        
DEBUG EVAL: Second branch cutoff check: z=28068469.082059, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 26 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=39, varin=39, theta=2.500000, up=999999999999999983222784.000000
ITER 2: row=12, varin=36, theta=0.750000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 26 = 1 gives z=28149185.025128
  % 	x26 = 1,	Z1 = 28149185.0251278        
DEBUG EVAL: First branch cutoff check: z=28149185.025128, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 26 = 0
ITER 1: row=39, varin=42, theta=0.200000, up=999999999999999983222784.000000
  % 	x26 = 0,	Z0 = 28064472.6468668        
DEBUG EVAL: Second branch cutoff check: z=28064472.646867, best_z=INF, threshold=INF
  % Best branch is x18, Z0 = 28101595.7323779        , Z1 = 28257487.0839494        

DEBUG CAREFUL: Final result - returning best.var = 18
DEBUG BB: Branching variable chosen: j=18
 % @NC   19   11	x18 = 0	28101595.732378
 % @NC   20   11	x18 = 1	28257487.083949
 %      11    10 28063619.1017               28075054.0543    x9 D     7     4
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde83a0240
% @LO 0.01  28.06361910167995077359 99.9000000000
% @LN 0.01  28.07505405427917111183 99.9000000000
% Resuming node 12 at  28.07505405427917111183
DEBUG CONSTRNT: LP rows=44, pool->nlprows=44, pool->npend=0
DEBUG CONSTRNT: Checking 44 LP rows (pool tracks 44, total LP rows 44)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=43, expected 43
 % @PAP adding 37 rows, 159 nz to LP
DEBUG BB: Processing node 12, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=19, varin=21, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=37)
DEBUG SOLUTION: LP solution array indices: FST[38-77], not_covered[78-97]
DEBUG SOLUTION: lp->best_solution[0] = 28075054.054279
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 37 rows, 60 cols, 219 nonzeros, 1 slack, 36 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 44 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=39, varin=5, theta=0.326968, up=999999999999999983222784.000000
ITER 2: row=5, varin=43, theta=0.153479, up=1.000000
ITER 3: row=38, varin=66, theta=-1.790434, up=1.000000
ITER 4: row=38, varin=41, theta=0.738216, up=1.000000
ITER 5: row=39, varin=39, theta=192592.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=39)
DEBUG SOLUTION: LP solution array indices: FST[40-79], not_covered[80-99]
DEBUG SOLUTION: lp->best_solution[0] = 28087409.427499
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 39 rows, 60 cols, 263 nonzeros, 2 slack, 37 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 6 rows, 31 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=38, varin=22, theta=0.166667, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 28088519.471299
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 43 rows, 60 cols, 252 nonzeros, 4 slack, 39 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % Node 12 LP 1 Solution, length = 28088519.471299, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.166667 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.166667 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 1.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.833333 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.166667 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.166667 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.833333 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.833333 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.833333 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.166667 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.833333 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.166667 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28088519.471299, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 12 at  28.08851947129891968302
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde8398c10
% @LO 0.02  28.07505405427917111183 99.9000000000
% @LN 0.02  28.07872818319941288223 99.9000000000
% Resuming node 15 at  28.07872818319941288223
DEBUG CONSTRNT: LP rows=39, pool->nlprows=39, pool->npend=0
DEBUG CONSTRNT: Checking 39 LP rows (pool tracks 39, total LP rows 39)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=38, expected 38
 % @PAP adding 48 rows, 223 nz to LP
DEBUG BB: Processing node 15, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=39, varin=44, theta=0.894578, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
ITER 2: row=7, varin=5, theta=0.000000, up=999999999999999983222784.000000
ITER 3: row=1, varin=11, theta=2.000000, up=999999999999999983222784.000000
ITER 4: row=2, varin=7, theta=0.000000, up=999999999999999983222784.000000
ITER 5: row=19, varin=27, theta=0.144093, up=999999999999999983222784.000000
ITER 6: row=19, varin=48, theta=89569.000000, up=999999999999999983222784.000000
ITER 7: row=13, varin=49, theta=0.000000, up=1.000000
ITER 8: row=8, varin=50, theta=0.670061, up=1.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 28062466.127621
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.670061
DEBUG SOLUTION: lp->best_solution[5] = 2.670061
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.670061
DEBUG SOLUTION: lp->best_solution[10] = 0.670061
DEBUG SOLUTION: lp->best_solution[11] = 3.340122
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.670061
  % @PL 48 rows, 60 cols, 283 nonzeros, 18 slack, 30 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 3 rows, 7 nz to LP
% Column 60 singular!
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=48, varin=111, theta=0.670061, up=1.000000
ITER 2: row=49, varin=54, theta=0.927954, up=1.000000
ITER 3: row=50, varin=71, theta=0.333333, up=1.000000
LP PHASE: Switching to primal (iter=3)
ITER 4: row=27, varin=48, theta=855240.333333, up=999999999999999983222784.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 28073707.569722
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 51 rows, 60 cols, 290 nonzeros, 7 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 15 LP 1 Solution, length = 28073707.569722, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.687928 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.333333 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.666667 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.687928 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.312072 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.312072 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.333333 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.333333 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.312072 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.312072 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.312072 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.333333 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.333333 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.312072 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=28073707.569722, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28073707.569722, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 15 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 15
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.687928
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.687928)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=1.000000
DEBUG CAREFUL: Skipping var 5: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.333333
DEBUG CAREFUL: Adding var 15 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.666667
DEBUG CAREFUL: Adding var 19 to fractional list (xi=0.666667)
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.687928
DEBUG CAREFUL: Adding var 20 to fractional list (xi=0.687928)
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 4 fractional variables

  %  Carefully choosing branching variable, nfrac = 4
DEBUG CAREFUL: Testing fvar[0] = var 15
DEBUG CAREFUL: Calling compare_branch_vars for var 15
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 15
DEBUG CAREFUL: New best var: 15
DEBUG CAREFUL: Testing fvar[1] = var 19
DEBUG CAREFUL: Calling compare_branch_vars for var 19
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 19
DEBUG CAREFUL: New best var: 19
DEBUG CAREFUL: Testing fvar[2] = var 20
DEBUG CAREFUL: Calling compare_branch_vars for var 20
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 20
DEBUG CAREFUL: Testing fvar[3] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
  % Initial guess is x19, Z0 = 28225476.4149264        , Z1 = 28073707.5697221        

DEBUG EVAL: Testing var 15 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=38, varin=50, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=17, varin=43, theta=0.285714, up=999999999999999983222784.000000
ITER 3: row=24, varin=13, theta=6.000000, up=999999999999999983222784.000000
ITER 4: row=11, varin=49, theta=2.000000, up=999999999999999983222784.000000
ITER 5: row=48, varin=24, theta=0.370648, up=999999999999999983222784.000000
ITER 6: row=1, varin=27, theta=3.214024, up=999999999999999983222784.000000
ITER 7: row=27, varin=12, theta=0.022723, up=999999999999999983222784.000000
ITER 8: row=2, varin=17, theta=0.356707, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 15 = 1 gives z=28225476.414926
  % 	x15 = 1,	Z1 = 28225476.4149264        
DEBUG EVAL: First branch cutoff check: z=28225476.414926, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 15 = 0
ITER 1: row=38, varin=59, theta=0.250000, up=1.000000
ITER 2: row=35, varin=66, theta=0.333333, up=1.000000
  % 	x15 = 0,	Z0 = 28074193.8498227        
DEBUG EVAL: Second branch cutoff check: z=28074193.849823, best_z=INF, threshold=INF
  %   New best:  x15, Z = 28074193.8498227        
DEBUG EVAL: Testing var 19 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=19, varin=55, theta=0.500000, up=1.000000
DEBUG EVAL: Branch var 19 = 1 gives z=28080443.703809
  % 	x19 = 1,	Z1 = 28080443.7038087        
DEBUG EVAL: First branch cutoff check: z=28080443.703809, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 19 = 0
ITER 1: row=19, varin=50, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=17, varin=13, theta=6.000000, up=999999999999999983222784.000000
ITER 3: row=11, varin=49, theta=2.000000, up=999999999999999983222784.000000
ITER 4: row=48, varin=24, theta=0.370648, up=999999999999999983222784.000000
ITER 5: row=1, varin=27, theta=3.214024, up=999999999999999983222784.000000
ITER 6: row=27, varin=12, theta=0.022723, up=999999999999999983222784.000000
ITER 7: row=2, varin=17, theta=0.356707, up=999999999999999983222784.000000
  % 	x19 = 0,	Z0 = 28225476.4149264        
DEBUG EVAL: Second branch cutoff check: z=28225476.414926, best_z=INF, threshold=INF
  %   New best:  x19, Z = 28080443.7038087        
DEBUG EVAL: Testing var 20 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=6, varin=27, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=48, varin=49, theta=1.350945, up=999999999999999983222784.000000
ITER 3: row=6, varin=13, theta=0.386319, up=999999999999999983222784.000000
ITER 4: row=11, varin=50, theta=0.170320, up=999999999999999983222784.000000
ITER 5: row=17, varin=12, theta=0.120365, up=999999999999999983222784.000000
ITER 6: row=3, varin=8, theta=0.272282, up=999999999999999983222784.000000
ITER 7: row=21, varin=24, theta=0.218535, up=999999999999999983222784.000000
ITER 8: row=1, varin=2, theta=0.225912, up=999999999999999983222784.000000
ITER 9: row=2, varin=3, theta=0.952690, up=999999999999999983222784.000000
ITER 10: row=50, varin=21, theta=0.327198, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 20 = 1 gives z=28202233.098748
  % 	x20 = 1,	Z1 = 28202233.098748         
DEBUG EVAL: First branch cutoff check: z=28202233.098748, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 20 = 0
  % 	x20 = 0,	Z0 = 28073707.5697221        
DEBUG EVAL: Second branch cutoff check: z=28073707.569722, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 2 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=27, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=48, varin=13, theta=1.487114, up=999999999999999983222784.000000
ITER 3: row=11, varin=50, theta=0.655640, up=999999999999999983222784.000000
ITER 4: row=17, varin=18, theta=0.393305, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 1 gives z=28125303.460096
  % 	x2 = 1,	Z1 = 28125303.4600963        
DEBUG EVAL: First branch cutoff check: z=28125303.460096, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 0
  % 	x2 = 0,	Z0 = 28073707.5697221        
DEBUG EVAL: Second branch cutoff check: z=28073707.569722, best_z=INF, threshold=INF
  % Best branch is x19, Z0 = 28225476.4149264        , Z1 = 28080443.7038087        

DEBUG CAREFUL: Final result - returning best.var = 19
DEBUG BB: Branching variable chosen: j=19
 % @NC   21   15	x19 = 1	28080443.703809
 % @NC   22   15	x19 = 0	28225476.414926
 %      15    11 28073707.5697               28080443.7038   x18 D     9     3
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde8397010
% @LO 0.02  28.07872818319941288223 99.9000000000
% @LN 0.02  28.08044370380870091708 99.9000000000
% Resuming node 21 at  28.08044370380870091708
DEBUG CONSTRNT: LP rows=51, pool->nlprows=51, pool->npend=0
DEBUG CONSTRNT: Checking 51 LP rows (pool tracks 51, total LP rows 51)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=50, expected 50
 % @PAP adding 51 rows, 230 nz to LP
DEBUG BB: Processing node 21, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=19, varin=55, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 28080443.703809
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 51 rows, 60 cols, 290 nonzeros, 1 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 6 rows, 31 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=52, varin=84, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=57)
DEBUG SOLUTION: LP solution array indices: FST[58-97], not_covered[98-117]
DEBUG SOLUTION: lp->best_solution[0] = 28085875.938632
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 57 rows, 60 cols, 321 nonzeros, 1 slack, 56 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 4 rows, 17 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=57, varin=27, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=60)
DEBUG SOLUTION: LP solution array indices: FST[61-100], not_covered[101-120]
DEBUG SOLUTION: lp->best_solution[0] = 28091549.804420
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 60 rows, 60 cols, 298 nonzeros, 12 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 12 slack rows
  % Node 21 LP 1 Solution, length = 28091549.804420, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.500000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.500000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.500000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.500000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.500000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.500000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.500000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.500000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.500000 (terminal 19)
 % 3 fractional variables
DEBUG CG: LP optimal, z=28091549.804420, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 21 at  28.09154980441989835072
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde83a0240
% @LO 0.02  28.08044370380870091708 99.9000000000
% @LN 0.02  28.08851947129891968302 99.9000000000
% Resuming node 12 at  28.08851947129891968302
DEBUG CONSTRNT: LP rows=48, pool->nlprows=48, pool->npend=0
DEBUG CONSTRNT: Checking 48 LP rows (pool tracks 48, total LP rows 48)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=47, expected 47
 % @PAP adding 39 rows, 165 nz to LP
DEBUG BB: Processing node 12, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 12 LP 2 Solution, length = 28088519.471299, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.166667 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.166667 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 1.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.833333 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.166667 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.166667 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.833333 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.833333 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.833333 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.166667 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.833333 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.166667 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28088519.471299, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28088519.471299, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 12 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 12
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.166667
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.166667
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=1.000000
DEBUG CAREFUL: Skipping var 9: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.833333
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.833333)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.166667
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.166667
DEBUG CAREFUL: Adding var 18 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 18
DEBUG CAREFUL: Calling compare_branch_vars for var 18
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 18
DEBUG CAREFUL: New best var: 18
DEBUG CAREFUL: Testing fvar[1] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[2] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[3] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 3
DEBUG CAREFUL: Testing fvar[4] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
  % Initial guess is x18, Z0 = 28088519.4712989        , Z1 = 28257487.0839494        

DEBUG EVAL: Testing var 18 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=31, varin=37, theta=2.500000, up=999999999999999983222784.000000
ITER 2: row=12, varin=35, theta=3.000000, up=999999999999999983222784.000000
ITER 3: row=35, varin=33, theta=2.000000, up=999999999999999983222784.000000
ITER 4: row=2, varin=24, theta=2.000000, up=999999999999999983222784.000000
ITER 5: row=32, varin=3, theta=2.000000, up=999999999999999983222784.000000
ITER 6: row=33, varin=12, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=1, varin=28, theta=1.000000, up=999999999999999983222784.000000
ITER 8: row=28, varin=25, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 18 = 1 gives z=28339214.426669
  % 	x18 = 1,	Z1 = 28339214.4266688        
DEBUG EVAL: First branch cutoff check: z=28339214.426669, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 18 = 0
ITER 1: row=31, varin=66, theta=1.000000, up=1.000000
  % 	x18 = 0,	Z0 = 28092841.6623228        
DEBUG EVAL: Second branch cutoff check: z=28092841.662323, best_z=INF, threshold=INF
  %   New best:  x18, Z = 28092841.6623228        
DEBUG EVAL: Testing var 17 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=23, varin=66, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 17 = 0 gives z=28092841.662323
  % 	x17 = 0,	Z0 = 28092841.6623228        
DEBUG EVAL: First branch cutoff check: z=28092841.662323, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 17 = 1
ITER 1: row=23, varin=37, theta=2.500000, up=999999999999999983222784.000000
ITER 2: row=12, varin=31, theta=1.000000, up=999999999999999983222784.000000
  % 	x17 = 1,	Z1 = 28158806.2476876        
DEBUG EVAL: Second branch cutoff check: z=28158806.247688, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 10 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=20, varin=66, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 10 = 1 gives z=28092841.662323
  % 	x10 = 1,	Z1 = 28092841.6623228        
DEBUG EVAL: First branch cutoff check: z=28092841.662323, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 0
ITER 1: row=20, varin=37, theta=2.500000, up=999999999999999983222784.000000
ITER 2: row=12, varin=36, theta=0.750000, up=999999999999999983222784.000000
  % 	x10 = 0,	Z0 = 28131135.8099572        
DEBUG EVAL: Second branch cutoff check: z=28131135.809957, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 3 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=12, varin=31, theta=1.666667, up=999999999999999983222784.000000
ITER 2: row=22, varin=35, theta=2.000000, up=999999999999999983222784.000000
ITER 3: row=1, varin=33, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=3, varin=36, theta=0.333333, up=999999999999999983222784.000000
ITER 5: row=31, varin=23, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=38, varin=3, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=33, varin=28, theta=0.500000, up=999999999999999983222784.000000
ITER 8: row=28, varin=2, theta=1.000000, up=999999999999999983222784.000000
ITER 9: row=2, varin=24, theta=0.500000, up=999999999999999983222784.000000
ITER 10: row=39, varin=25, theta=0.333333, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 3 = 1 gives z=28308276.566790
  % 	x3 = 1,	Z1 = 28308276.5667899        
DEBUG EVAL: First branch cutoff check: z=28308276.566790, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 3 = 0
ITER 1: row=12, varin=37, theta=0.250000, up=999999999999999983222784.000000
  % 	x3 = 0,	Z0 = 28089074.4931987        
DEBUG EVAL: Second branch cutoff check: z=28089074.493199, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 2 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=37, theta=2.500000, up=999999999999999983222784.000000
ITER 2: row=12, varin=31, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 1 gives z=28158806.247688
  % 	x2 = 1,	Z1 = 28158806.2476876        
DEBUG EVAL: First branch cutoff check: z=28158806.247688, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 0
ITER 1: row=1, varin=66, theta=1.000000, up=1.000000
  % 	x2 = 0,	Z0 = 28092841.6623228        
DEBUG EVAL: Second branch cutoff check: z=28092841.662323, best_z=INF, threshold=INF
  % Best branch is x18, Z0 = 28092841.6623228        , Z1 = 28339214.4266688        

DEBUG CAREFUL: Final result - returning best.var = 18
DEBUG BB: Branching variable chosen: j=18
 % @NC   23   12	x18 = 0	28092841.662323
 % @NC   24   12	x18 = 1	28339214.426669
 %      12    12 28088519.4713               28091549.8044    x9 U     7     4
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde8397010
% @LO 0.02  28.08851947129891968302 99.9000000000
% @LN 0.02  28.09154980441989835072 99.9000000000
% Resuming node 21 at  28.09154980441989835072
DEBUG CONSTRNT: LP rows=39, pool->nlprows=39, pool->npend=0
DEBUG CONSTRNT: Checking 39 LP rows (pool tracks 39, total LP rows 39)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=38, expected 38
 % @PAP adding 48 rows, 185 nz to LP
DEBUG BB: Processing node 21, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 21 LP 2 Solution, length = 28091549.804420, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.500000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.500000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.500000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.500000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.500000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.500000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.500000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.500000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.500000 (terminal 19)
 % 3 fractional variables
DEBUG CG: LP optimal, z=28091549.804420, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28091549.804420, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 21 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 21
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.500000
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.500000
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=1.000000
DEBUG CAREFUL: Skipping var 5: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.500000
DEBUG CAREFUL: Adding var 20 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 3 fractional variables

  %  Carefully choosing branching variable, nfrac = 3
DEBUG CAREFUL: Testing fvar[0] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 3
DEBUG CAREFUL: New best var: 3
DEBUG CAREFUL: Testing fvar[1] = var 20
DEBUG CAREFUL: Calling compare_branch_vars for var 20
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 20
DEBUG CAREFUL: New best var: 20
DEBUG CAREFUL: Testing fvar[2] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
  % Initial guess is x20, Z0 = 28091549.8044199        , Z1 = 28202233.098748         

DEBUG EVAL: Testing var 3 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=24, varin=47, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=47, varin=41, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 3 = 1 gives z=28125153.626358
  % 	x3 = 1,	Z1 = 28161707.9221572        
DEBUG EVAL: First branch cutoff check: z=28161707.922157, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 3 = 0
ITER 1: row=24, varin=56, theta=1.000000, up=1.000000
ITER 2: row=32, varin=72, theta=1.000000, up=1.000000
ITER 3: row=43, varin=60, theta=0.500000, up=1.000000
  % 	x3 = 0,	Z0 = 28202851.8159734        
DEBUG EVAL: Second branch cutoff check: z=28202851.815973, best_z=INF, threshold=INF
  %   New best:  x3, Z = 28161707.9221572        
DEBUG EVAL: Testing var 20 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=6, varin=47, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=47, varin=44, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 20 = 1 gives z=28102655.905031
  % 	x20 = 1,	Z1 = 28202233.098748         
DEBUG EVAL: First branch cutoff check: z=28202233.098748, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 20 = 0
ITER 1: row=6, varin=56, theta=1.000000, up=1.000000
ITER 2: row=32, varin=72, theta=1.000000, up=1.000000
ITER 3: row=43, varin=60, theta=0.500000, up=1.000000
  % 	x20 = 0,	Z0 = 28202851.8159734        
DEBUG EVAL: Second branch cutoff check: z=28202851.815973, best_z=INF, threshold=INF
  %   New best:  x20, Z = 28202233.098748         
DEBUG EVAL: Testing var 2 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=47, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=47, varin=44, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 1 gives z=28102655.905031
  % 	x2 = 1,	Z1 = 28125303.4600963        
DEBUG EVAL: First branch cutoff check: z=28125303.460096, best_z=INF, threshold=INF
  % Best branch is x20, Z0 = 28202851.8159734        , Z1 = 28202233.098748         

DEBUG CAREFUL: Final result - returning best.var = 20
DEBUG BB: Branching variable chosen: j=20
 % @NC   25   21	x20 = 1	28202233.098748
 % @NC   26   21	x20 = 0	28202851.815973
 %      21    13 28091549.8044               28092841.6623   x19 U    15     4
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde8398c10
% @LO 0.02  28.09154980441989835072 99.9000000000
% @LN 0.02  28.09284166232277257791 99.9000000000
% Resuming node 23 at  28.09284166232277257791
DEBUG CONSTRNT: LP rows=48, pool->nlprows=48, pool->npend=0
DEBUG CONSTRNT: Checking 48 LP rows (pool tracks 48, total LP rows 48)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=47, expected 47
 % @PAP adding 39 rows, 165 nz to LP
DEBUG BB: Processing node 23, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=31, varin=66, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=39)
DEBUG SOLUTION: LP solution array indices: FST[40-79], not_covered[80-99]
DEBUG SOLUTION: lp->best_solution[0] = 28092841.662323
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 39 rows, 60 cols, 225 nonzeros, 0 slack, 39 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=40, varin=31, theta=0.333333, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=40)
DEBUG SOLUTION: LP solution array indices: FST[41-80], not_covered[81-100]
DEBUG SOLUTION: lp->best_solution[0] = 28111208.367562
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 40 rows, 60 cols, 227 nonzeros, 2 slack, 38 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 1 rows, 40 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=39, varin=5, theta=0.210331, up=999999999999999983222784.000000
ITER 2: row=5, varin=34, theta=0.074561, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=39)
DEBUG SOLUTION: LP solution array indices: FST[40-79], not_covered[80-99]
DEBUG SOLUTION: lp->best_solution[0] = 28114020.427010
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 39 rows, 60 cols, 263 nonzeros, 1 slack, 38 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 23 LP 1 Solution, length = 28114020.427010, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.308480 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.308480 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 1.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.925439 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.308480 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.074561 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.691520 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.691520 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.691520 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.074561 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.691520 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.074561 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28114020.427010, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 23 at  28.11402042700998649138
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde8397250
% @LO 0.02  28.09284166232277257791 99.9000000000
% @LN 0.02  28.09457072072948591313 99.9000000000
% Resuming node 17 at  28.09457072072948591313
DEBUG CONSTRNT: LP rows=38, pool->nlprows=38, pool->npend=0
DEBUG CONSTRNT: Checking 38 LP rows (pool tracks 38, total LP rows 38)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 158
DEBUG CONSTRNT: Pool row 158 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=37, expected 37
 % @PAP adding 52 rows, 216 nz to LP
DEBUG BB: Processing node 17, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=29, varin=46, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=33, varin=65, theta=0.500000, up=1.000000
ITER 3: row=50, varin=26, theta=0.125000, up=999999999999999983222784.000000
ITER 4: row=52, varin=11, theta=16.500000, up=999999999999999983222784.000000
ITER 5: row=5, varin=27, theta=0.075758, up=999999999999999983222784.000000
ITER 6: row=13, varin=54, theta=1.000000, up=1.000000
ITER 7: row=35, varin=49, theta=0.157895, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=7)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 28094570.720729
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 52 rows, 60 cols, 276 nonzeros, 7 slack, 45 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=54, varin=17, theta=4.500000, up=999999999999999983222784.000000
ITER 2: row=2, varin=57, theta=0.600000, up=1.000000
ITER 3: row=42, varin=18, theta=0.069767, up=999999999999999983222784.000000
ITER 4: row=22, varin=42, theta=8.000000, up=999999999999999983222784.000000
ITER 5: row=43, varin=79, theta=1.000000, up=1.000000
ITER 6: row=3, varin=73, theta=0.333333, up=1.000000
ITER 7: row=44, varin=31, theta=0.055556, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=7)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=54)
DEBUG SOLUTION: LP solution array indices: FST[55-94], not_covered[95-114]
DEBUG SOLUTION: lp->best_solution[0] = 28141568.847576
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.944444
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 54 rows, 60 cols, 280 nonzeros, 8 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 8 slack rows
  % @PAP adding 7 rows, 26 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=53, varin=106, theta=0.051095, up=1.000000
ITER 2: row=48, varin=5, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=53)
DEBUG SOLUTION: LP solution array indices: FST[54-93], not_covered[94-113]
DEBUG SOLUTION: lp->best_solution[0] = 28145615.282191
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 2.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 53 rows, 60 cols, 277 nonzeros, 11 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 11 slack rows
  % @PAP adding 3 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=43, varin=12, theta=2.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 28154127.533854
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 45 rows, 60 cols, 253 nonzeros, 4 slack, 41 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % @PAP adding 2 rows, 12 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=43, varin=25, theta=0.719298, up=999999999999999983222784.000000
ITER 2: row=42, varin=39, theta=3.200000, up=999999999999999983222784.000000
ITER 3: row=33, varin=30, theta=6.666667, up=999999999999999983222784.000000
ITER 4: row=31, varin=47, theta=0.400000, up=1.000000
ITER 5: row=43, varin=43, theta=0.076923, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 28180684.295929
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 43 rows, 60 cols, 254 nonzeros, 3 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 3 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=41, varin=70, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 28182057.490005
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 43 rows, 60 cols, 234 nonzeros, 0 slack, 43 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 17 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=44, varin=25, theta=0.666667, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 28186325.215939
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 47 rows, 60 cols, 251 nonzeros, 2 slack, 45 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % Node 17 LP 1 Solution, length = 28186325.215939, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.166667 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.166667 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.166667 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 1.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.166667 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.166667 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.166667 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.833333 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.833333 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.833333 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.833333 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.833333 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.833333 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.833333 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28186325.215939, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 17 at  28.18632521593903206281
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde8386600
% @LO 0.02  28.09457072072948591313 99.9000000000
% @LN 0.02  28.10159573237790908706 99.9000000000
% Resuming node 19 at  28.10159573237790908706
DEBUG CONSTRNT: LP rows=45, pool->nlprows=45, pool->npend=0
DEBUG CONSTRNT: Checking 45 LP rows (pool tracks 45, total LP rows 45)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 65
DEBUG CONSTRNT: Pool row 65 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 121
DEBUG CONSTRNT: Pool row 121 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=44, expected 44
 % @PAP adding 44 rows, 174 nz to LP
DEBUG BB: Processing node 19, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=31, varin=31, theta=0.333333, up=999999999999999983222784.000000
ITER 2: row=37, varin=81, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28101595.732378
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 44 rows, 60 cols, 234 nonzeros, 0 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=45, varin=36, theta=0.333333, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 28113591.833460
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 45 rows, 60 cols, 238 nonzeros, 4 slack, 41 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % Node 19 LP 1 Solution, length = 28113591.833460, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.333333 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.333333 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.333333 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.333333 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.333333 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.666667 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.666667 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.666667 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.666667 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.666667 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.666667 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.666667 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28113591.833460, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 19 at  28.11359183346042911467
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde8397490
% @LO 0.02  28.10159573237790908706 99.9000000000
% @LN 0.02  28.10721023528783035772 99.9000000000
% Resuming node 13 at  28.10721023528783035772
DEBUG CONSTRNT: LP rows=41, pool->nlprows=41, pool->npend=0
DEBUG CONSTRNT: Checking 41 LP rows (pool tracks 41, total LP rows 41)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=40, expected 40
 % @PAP adding 52 rows, 206 nz to LP
DEBUG BB: Processing node 13, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=27, varin=51, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=33, varin=34, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=46, varin=36, theta=0.750000, up=999999999999999983222784.000000
ITER 4: row=47, varin=12, theta=1.571429, up=999999999999999983222784.000000
ITER 5: row=1, varin=37, theta=0.600000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 28107210.235288
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 52 rows, 60 cols, 266 nonzeros, 5 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=53, varin=55, theta=1.428571, up=1.000000
ITER 2: row=53, varin=49, theta=0.150000, up=999999999999999983222784.000000
ITER 3: row=12, varin=55, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=54)
DEBUG SOLUTION: LP solution array indices: FST[55-94], not_covered[95-114]
DEBUG SOLUTION: lp->best_solution[0] = 28113266.900980
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 54 rows, 60 cols, 274 nonzeros, 6 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 6 slack rows
  % Node 13 LP 1 Solution, length = 28113266.900980, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.500000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.500000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.500000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 1.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.500000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.500000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.500000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.500000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 3 fractional variables
DEBUG CG: LP optimal, z=28113266.900980, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
 % @LO 0.02  28.10721023528783035772 99.9000000000
 % @LN 0.02  28.11326690097957481385 99.9000000000
DEBUG CG: Second cutoff check: z=28113266.900980, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 13 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 13
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.500000
DEBUG CAREFUL: Adding var 7 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.500000
DEBUG CAREFUL: Adding var 15 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.500000
DEBUG CAREFUL: Adding var 16 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=1.000000
DEBUG CAREFUL: Skipping var 20: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 3 fractional variables

  %  Carefully choosing branching variable, nfrac = 3
DEBUG CAREFUL: Testing fvar[0] = var 16
DEBUG CAREFUL: Calling compare_branch_vars for var 16
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 16
DEBUG CAREFUL: New best var: 16
DEBUG CAREFUL: Testing fvar[1] = var 7
DEBUG CAREFUL: Calling compare_branch_vars for var 7
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 7
DEBUG CAREFUL: Testing fvar[2] = var 15
DEBUG CAREFUL: Calling compare_branch_vars for var 15
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 15
  % Initial guess is x16, Z0 = 28113266.9009796        , Z1 = 28298717.4095852        

DEBUG EVAL: Testing var 16 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=33, varin=34, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=27, varin=61, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 16 = 1 gives z=28156359.266737
  % 	x16 = 1,	Z1 = 28298717.4095852        
DEBUG EVAL: First branch cutoff check: z=28298717.409585, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 16 = 0
ITER 1: row=33, varin=12, theta=1.047619, up=999999999999999983222784.000000
ITER 2: row=1, varin=35, theta=0.666667, up=999999999999999983222784.000000
ITER 3: row=35, varin=47, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=45, varin=11, theta=30.000000, up=999999999999999983222784.000000
ITER 5: row=5, varin=44, theta=1.800000, up=999999999999999983222784.000000
ITER 6: row=44, varin=8, theta=0.800000, up=999999999999999983222784.000000
ITER 7: row=13, varin=17, theta=4.000000, up=999999999999999983222784.000000
  % 	x16 = 0,	Z0 = 28188739.9666865        
DEBUG EVAL: Second branch cutoff check: z=28188739.966686, best_z=INF, threshold=INF
  %   New best:  x16, Z = 28188739.9666865        
DEBUG EVAL: Testing var 7 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=8, varin=34, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=27, varin=58, theta=0.400000, up=1.000000
DEBUG EVAL: Branch var 7 = 0 gives z=28152499.057225
  % 	x7 = 0,	Z0 = 28152499.0572254        
DEBUG EVAL: First branch cutoff check: z=28152499.057225, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 15 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=27, varin=12, theta=1.047619, up=999999999999999983222784.000000
ITER 2: row=1, varin=47, theta=0.333333, up=999999999999999983222784.000000
ITER 3: row=47, varin=35, theta=0.666667, up=999999999999999983222784.000000
ITER 4: row=35, varin=11, theta=30.000000, up=999999999999999983222784.000000
ITER 5: row=5, varin=8, theta=1.800000, up=999999999999999983222784.000000
ITER 6: row=12, varin=6, theta=1.800000, up=999999999999999983222784.000000
ITER 7: row=6, varin=18, theta=1.800000, up=999999999999999983222784.000000
ITER 8: row=18, varin=28, theta=1.800000, up=999999999999999983222784.000000
ITER 9: row=28, varin=29, theta=0.800000, up=999999999999999983222784.000000
ITER 10: row=29, varin=31, theta=0.800000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 15 = 1 gives z=28188739.966686
  % 	x15 = 1,	Z1 = 28188739.9666865        
DEBUG EVAL: First branch cutoff check: z=28188739.966686, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 15 = 0
ITER 1: row=27, varin=34, theta=0.400000, up=999999999999999983222784.000000
  % 	x15 = 0,	Z0 = 28116670.2403234        
DEBUG EVAL: Second branch cutoff check: z=28116670.240323, best_z=INF, threshold=INF
  % Best branch is x16, Z0 = 28188739.9666865        , Z1 = 28298717.4095852        

DEBUG CAREFUL: Final result - returning best.var = 16
DEBUG BB: Branching variable chosen: j=16
 % @NC   27   13	x16 = 0	28188739.966686
 % @NC   28   13	x16 = 1	28298717.409585
 %      13    14 28113266.9010               28113591.8335   x13 D     6     4
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde8386600
% @LO 0.02  28.11326690097957481385 99.9000000000
% @LN 0.02  28.11359183346042911467 99.9000000000
% Resuming node 19 at  28.11359183346042911467
DEBUG CONSTRNT: LP rows=48, pool->nlprows=48, pool->npend=0
DEBUG CONSTRNT: Checking 48 LP rows (pool tracks 48, total LP rows 48)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 141
DEBUG CONSTRNT: Pool row 141 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 145
DEBUG CONSTRNT: Pool row 145 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 159
DEBUG CONSTRNT: Pool row 159 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 49
DEBUG CONSTRNT: Pool row 49 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 68
DEBUG CONSTRNT: Pool row 68 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 82
DEBUG CONSTRNT: Pool row 82 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=47, expected 47
 % @PAP adding 41 rows, 170 nz to LP
DEBUG BB: Processing node 19, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 19 LP 2 Solution, length = 28113591.833460, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.333333 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.333333 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.333333 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.333333 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.333333 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.666667 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.666667 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.666667 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.666667 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.666667 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.666667 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.666667 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28113591.833460, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28113591.833460, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 19 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 19
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.333333
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.333333
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=1.000000
DEBUG CAREFUL: Skipping var 7: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.333333
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.333333
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.333333
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 17
DEBUG CAREFUL: New best var: 17
DEBUG CAREFUL: Testing fvar[1] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[2] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[3] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 3
DEBUG CAREFUL: New best var: 3
DEBUG CAREFUL: Testing fvar[4] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
  % Initial guess is x3, Z0 = 28113591.8334604        , Z1 = 28250002.7050401        

DEBUG EVAL: Testing var 17 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=25, varin=41, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=41, varin=38, theta=2.000000, up=999999999999999983222784.000000
ITER 3: row=35, varin=35, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 17 = 1 gives z=28227504.983713
  % 	x17 = 1,	Z1 = 28227504.9837129        
DEBUG EVAL: First branch cutoff check: z=28227504.983713, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 17 = 0
ITER 1: row=25, varin=65, theta=1.000000, up=1.000000
ITER 2: row=32, varin=76, theta=0.500000, up=1.000000
  % 	x17 = 0,	Z0 = 28129343.6756135        
DEBUG EVAL: Second branch cutoff check: z=28129343.675614, best_z=INF, threshold=INF
  %   New best:  x17, Z = 28129343.6756135        
DEBUG EVAL: Testing var 10 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=20, varin=41, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=41, varin=34, theta=0.666667, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 1 gives z=28185339.338411
  % 	x10 = 1,	Z1 = 28185339.3384108        
DEBUG EVAL: First branch cutoff check: z=28185339.338411, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 0
ITER 1: row=20, varin=65, theta=1.000000, up=1.000000
ITER 2: row=32, varin=76, theta=0.500000, up=1.000000
  % 	x10 = 0,	Z0 = 28129343.6756135        
DEBUG EVAL: Second branch cutoff check: z=28129343.675614, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 2 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=41, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=41, varin=26, theta=0.666667, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 1 gives z=28204107.204762
  % 	x2 = 1,	Z1 = 28204107.2047624        
DEBUG EVAL: First branch cutoff check: z=28204107.204762, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 0
ITER 1: row=1, varin=65, theta=1.000000, up=1.000000
ITER 2: row=32, varin=76, theta=0.500000, up=1.000000
  % 	x2 = 0,	Z0 = 28129343.6756135        
DEBUG EVAL: Second branch cutoff check: z=28129343.675614, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 3 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=12, varin=41, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=41, varin=25, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=36, varin=38, theta=2.000000, up=999999999999999983222784.000000
ITER 4: row=35, varin=33, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 3 = 1 gives z=28250002.705040
  % 	x3 = 1,	Z1 = 28250002.7050401        
DEBUG EVAL: First branch cutoff check: z=28250002.705040, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 3 = 0
ITER 1: row=12, varin=65, theta=1.000000, up=1.000000
ITER 2: row=32, varin=76, theta=0.500000, up=1.000000
  % 	x3 = 0,	Z0 = 28129343.6756135        
DEBUG EVAL: Second branch cutoff check: z=28129343.675614, best_z=INF, threshold=INF
  %   New best:  x3, Z = 28129343.6756135        
DEBUG EVAL: Testing var 26 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=35, varin=41, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=41, varin=34, theta=0.666667, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 26 = 1 gives z=28185339.338411
  % 	x26 = 1,	Z1 = 28185339.3384108        
DEBUG EVAL: First branch cutoff check: z=28185339.338411, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 26 = 0
ITER 1: row=35, varin=65, theta=1.000000, up=1.000000
ITER 2: row=32, varin=76, theta=0.500000, up=1.000000
  % 	x26 = 0,	Z0 = 28129343.6756135        
DEBUG EVAL: Second branch cutoff check: z=28129343.675614, best_z=INF, threshold=INF
  % Best branch is x3, Z0 = 28129343.6756135        , Z1 = 28250002.7050401        

DEBUG CAREFUL: Final result - returning best.var = 3
DEBUG BB: Branching variable chosen: j=3
 % @NC   29   19	x3 = 0	28129343.675614
 % @NC   30   19	x3 = 1	28250002.705040
 %      19    15 28113591.8335               28114020.4270   x18 D    11     5
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde8398c10
% @LO 0.02  28.11359183346042911467 99.9000000000
% @LN 0.02  28.11402042700998649138 99.9000000000
% Resuming node 23 at  28.11402042700998649138
DEBUG CONSTRNT: LP rows=41, pool->nlprows=41, pool->npend=0
DEBUG CONSTRNT: Checking 41 LP rows (pool tracks 41, total LP rows 41)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=40, expected 40
 % @PAP adding 38 rows, 199 nz to LP
DEBUG BB: Processing node 23, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 23 LP 2 Solution, length = 28114020.427010, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.308480 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.308480 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 1.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.925439 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.308480 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.074561 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.691520 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.691520 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.691520 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.074561 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.691520 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.074561 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28114020.427010, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28114020.427010, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 23 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 23
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.308480
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.308480)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.308480
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.308480)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=1.000000
DEBUG CAREFUL: Skipping var 9: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.925439
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.925439)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.308480
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.308480)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.074561
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.074561)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 17
DEBUG CAREFUL: New best var: 17
DEBUG CAREFUL: Testing fvar[1] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[2] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 3
DEBUG CAREFUL: New best var: 3
DEBUG CAREFUL: Testing fvar[3] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[4] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
  % Initial guess is x3, Z0 = 28114020.42701          , Z1 = 28308276.5667899        

DEBUG EVAL: Testing var 17 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=23, varin=34, theta=1.562764, up=999999999999999983222784.000000
ITER 2: row=12, varin=31, theta=0.709805, up=999999999999999983222784.000000
ITER 3: row=2, varin=37, theta=1.443366, up=999999999999999983222784.000000
ITER 4: row=22, varin=33, theta=0.959198, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 17 = 1 gives z=28241678.362737
  % 	x17 = 1,	Z1 = 28241678.3627366        
DEBUG EVAL: First branch cutoff check: z=28241678.362737, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 17 = 0
ITER 1: row=23, varin=75, theta=1.218033, up=1.000000
ITER 2: row=23, varin=62, theta=0.336329, up=1.000000
ITER 3: row=32, varin=40, theta=0.467310, up=1.000000
ITER 4: row=5, varin=38, theta=121916.000000, up=999999999999999983222784.000000
  % 	x17 = 0,	Z0 = 28135086.0189548        
DEBUG EVAL: Second branch cutoff check: z=28135086.018955, best_z=INF, threshold=INF
  %   New best:  x17, Z = 28135086.0189548        
DEBUG EVAL: Testing var 10 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=20, varin=62, theta=0.146931, up=1.000000
ITER 2: row=32, varin=75, theta=0.310387, up=1.000000
DEBUG EVAL: Branch var 10 = 1 gives z=28118619.679153
  % 	x10 = 1,	Z1 = 28118619.6791532        
DEBUG EVAL: First branch cutoff check: z=28118619.679153, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 3 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=12, varin=37, theta=4.008146, up=999999999999999983222784.000000
ITER 2: row=34, varin=31, theta=2.000000, up=999999999999999983222784.000000
ITER 3: row=2, varin=23, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=35, varin=33, theta=2.000000, up=999999999999999983222784.000000
ITER 5: row=1, varin=24, theta=0.500000, up=999999999999999983222784.000000
ITER 6: row=36, varin=3, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=31, varin=28, theta=0.500000, up=999999999999999983222784.000000
ITER 8: row=20, varin=25, theta=0.463228, up=999999999999999983222784.000000
ITER 9: row=29, varin=63, theta=0.428956, up=1.000000
ITER 10: row=32, varin=21, theta=0.237282, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 3 = 1 gives z=28423255.068273
  % 	x3 = 1,	Z1 = 28423255.0682732        
DEBUG EVAL: First branch cutoff check: z=28423255.068273, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 3 = 0
ITER 1: row=12, varin=75, theta=1.218033, up=1.000000
ITER 2: row=12, varin=62, theta=0.336329, up=1.000000
ITER 3: row=32, varin=40, theta=0.467310, up=1.000000
ITER 4: row=5, varin=38, theta=121916.000000, up=999999999999999983222784.000000
  % 	x3 = 0,	Z0 = 28135086.0189548        
DEBUG EVAL: Second branch cutoff check: z=28135086.018955, best_z=INF, threshold=INF
  %   New best:  x3, Z = 28135086.0189548        
DEBUG EVAL: Testing var 2 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=34, theta=1.562764, up=999999999999999983222784.000000
ITER 2: row=12, varin=31, theta=0.709805, up=999999999999999983222784.000000
ITER 3: row=2, varin=24, theta=0.564417, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 1 gives z=28229860.873517
  % 	x2 = 1,	Z1 = 28229860.8735168        
DEBUG EVAL: First branch cutoff check: z=28229860.873517, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 0
ITER 1: row=1, varin=75, theta=1.218033, up=1.000000
ITER 2: row=1, varin=62, theta=0.336329, up=1.000000
ITER 3: row=32, varin=33, theta=0.073850, up=999999999999999983222784.000000
ITER 4: row=22, varin=32, theta=0.263350, up=999999999999999983222784.000000
ITER 5: row=1, varin=40, theta=0.467310, up=1.000000
ITER 6: row=5, varin=75, theta=0.457865, up=1.000000
  % 	x2 = 0,	Z0 = 28134752.088376         
DEBUG EVAL: Second branch cutoff check: z=28134752.088376, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 26 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=34, varin=62, theta=0.146931, up=1.000000
ITER 2: row=32, varin=75, theta=0.310387, up=1.000000
DEBUG EVAL: Branch var 26 = 0 gives z=28118619.679153
  % 	x26 = 0,	Z0 = 28118619.6791532        
DEBUG EVAL: First branch cutoff check: z=28118619.679153, best_z=INF, threshold=INF
  % Best branch is x3, Z0 = 28135086.0189548        , Z1 = 28423255.0682732        

DEBUG CAREFUL: Final result - returning best.var = 3
DEBUG BB: Branching variable chosen: j=3
 % @NC   31   23	x3 = 0	28135086.018955
 % @NC   32   23	x3 = 1	28423255.068273
 %      23    16 28114020.4270               28129343.6756   x18 D    12     5
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde8397490
% @LO 0.02  28.11402042700998649138 99.9000000000
% @LN 0.02  28.12934367561350867959 99.9000000000
% Resuming node 29 at  28.12934367561350867959
DEBUG CONSTRNT: LP rows=38, pool->nlprows=38, pool->npend=0
DEBUG CONSTRNT: Checking 38 LP rows (pool tracks 38, total LP rows 38)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 158
DEBUG CONSTRNT: Pool row 158 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=37, expected 37
 % @PAP adding 41 rows, 170 nz to LP
DEBUG BB: Processing node 29, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=12, varin=65, theta=1.000000, up=1.000000
ITER 2: row=32, varin=76, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=41)
DEBUG SOLUTION: LP solution array indices: FST[42-81], not_covered[82-101]
DEBUG SOLUTION: lp->best_solution[0] = 28129343.675614
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 41 rows, 60 cols, 230 nonzeros, 0 slack, 41 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 29 LP 1 Solution, length = 28129343.675614, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.500000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.500000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.500000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.500000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 3 fractional variables
DEBUG CG: LP optimal, z=28129343.675614, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28129343.675614, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 29 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 29
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.500000
DEBUG CAREFUL: Adding var 7 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.500000
DEBUG CAREFUL: Adding var 34 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.500000
DEBUG CAREFUL: Adding var 36 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 3 fractional variables

  %  Carefully choosing branching variable, nfrac = 3
DEBUG CAREFUL: Testing fvar[0] = var 34
DEBUG CAREFUL: Calling compare_branch_vars for var 34
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 34
DEBUG CAREFUL: New best var: 34
DEBUG CAREFUL: Testing fvar[1] = var 7
DEBUG CAREFUL: Calling compare_branch_vars for var 7
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 7
DEBUG CAREFUL: Testing fvar[2] = var 36
DEBUG CAREFUL: Calling compare_branch_vars for var 36
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 36
  % Initial guess is x34, Z0 = 28129343.6756135        , Z1 = 28157091.6188491        

DEBUG EVAL: Testing var 34 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=19, varin=32, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=32, varin=41, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 34 = 1 gives z=28157091.618849
  % 	x34 = 1,	Z1 = 28157091.6188491        
DEBUG EVAL: First branch cutoff check: z=28157091.618849, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 34 = 0
ITER 1: row=19, varin=22, theta=1.000000, up=999999999999999983222784.000000
  % 	x34 = 0,	Z0 = 28160147.2754937        
DEBUG EVAL: Second branch cutoff check: z=28160147.275494, best_z=INF, threshold=INF
  %   New best:  x34, Z = 28157091.6188491        
DEBUG EVAL: Testing var 7 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=32, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=32, varin=41, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 7 = 0 gives z=28157091.618849
  % 	x7 = 0,	Z0 = 28157091.6188491        
DEBUG EVAL: First branch cutoff check: z=28157091.618849, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 7 = 1
ITER 1: row=1, varin=53, theta=0.500000, up=1.000000
  % 	x7 = 1,	Z1 = 28176327.2530872        
DEBUG EVAL: Second branch cutoff check: z=28176327.253087, best_z=INF, threshold=INF
  %   New best:  x7, Z = 28157091.6188491        
DEBUG EVAL: Testing var 36 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=22, varin=41, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 36 = 0 gives z=28157091.618849
  % 	x36 = 0,	Z0 = 28157091.6188491        
DEBUG EVAL: First branch cutoff check: z=28157091.618849, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 36 = 1
ITER 1: row=22, varin=32, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=32, varin=22, theta=1.000000, up=999999999999999983222784.000000
  % 	x36 = 1,	Z1 = 28160147.2754937        
DEBUG EVAL: Second branch cutoff check: z=28160147.275494, best_z=INF, threshold=INF
  % Best branch is x7, Z0 = 28157091.6188491        , Z1 = 28176327.2530872        

DEBUG CAREFUL: Final result - returning best.var = 7
DEBUG BB: Branching variable chosen: j=7
 % @NC   33   29	x7 = 0	28157091.618849
 % @NC   34   29	x7 = 1	28176327.253087
 %      29    17 28129343.6756               28135086.0190    x3 D    19     6
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde8386600
% @LO 0.03  28.12934367561350867959 99.9000000000
% @LN 0.03  28.13508601895479799282 99.9000000000
% Resuming node 31 at  28.13508601895479799282
DEBUG CONSTRNT: LP rows=41, pool->nlprows=41, pool->npend=0
DEBUG CONSTRNT: Checking 41 LP rows (pool tracks 41, total LP rows 41)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=40, expected 40
 % @PAP adding 38 rows, 199 nz to LP
DEBUG BB: Processing node 31, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=12, varin=75, theta=1.218033, up=1.000000
ITER 2: row=12, varin=62, theta=0.336329, up=1.000000
ITER 3: row=32, varin=40, theta=0.467310, up=1.000000
ITER 4: row=5, varin=38, theta=121916.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
ITER 5: row=32, varin=32, theta=0.000000, up=999999999999999983222784.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=38)
DEBUG SOLUTION: LP solution array indices: FST[39-78], not_covered[79-98]
DEBUG SOLUTION: lp->best_solution[0] = 28135086.018955
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 38 rows, 60 cols, 259 nonzeros, 1 slack, 37 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=39, varin=77, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=40)
DEBUG SOLUTION: LP solution array indices: FST[41-80], not_covered[81-100]
DEBUG SOLUTION: lp->best_solution[0] = 28148923.418001
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 40 rows, 60 cols, 267 nonzeros, 1 slack, 39 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 4 rows, 17 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=40, varin=67, theta=0.500000, up=1.000000
ITER 2: row=32, varin=34, theta=0.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 28153864.832844
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 43 rows, 60 cols, 244 nonzeros, 4 slack, 39 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % Node 31 LP 1 Solution, length = 28153864.832844, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.500000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 1.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.500000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.500000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.500000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.500000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.500000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.500000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.500000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.500000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.500000 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=28153864.832844, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
 % @LO 0.03  28.13508601895479799282 99.9000000000
 % @LN 0.03  28.15386483284418162043 99.9000000000
DEBUG CG: Second cutoff check: z=28153864.832844, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 31 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 31
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.500000
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=1.000000
DEBUG CAREFUL: Skipping var 9: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.500000
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.500000
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.500000
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 4 fractional variables

  %  Carefully choosing branching variable, nfrac = 4
DEBUG CAREFUL: Testing fvar[0] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 17
DEBUG CAREFUL: New best var: 17
DEBUG CAREFUL: Testing fvar[1] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[2] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[3] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
  % Initial guess is x17, Z0 = 28153864.8328442        , Z1 = 28241678.3627366        

DEBUG EVAL: Testing var 17 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=20, varin=32, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=32, varin=37, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 17 = 1 gives z=28158806.247688
  % 	x17 = 1,	Z1 = 28241678.3627366        
DEBUG EVAL: First branch cutoff check: z=28241678.362737, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 17 = 0
ITER 1: row=20, varin=51, theta=0.250000, up=1.000000
  % 	x17 = 0,	Z0 = 28179370.4788324        
DEBUG EVAL: Second branch cutoff check: z=28179370.478832, best_z=INF, threshold=INF
  %   New best:  x17, Z = 28179370.4788324        
DEBUG EVAL: Testing var 2 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=32, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=32, varin=37, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 1 gives z=28158806.247688
  % 	x2 = 1,	Z1 = 28229860.8735168        
DEBUG EVAL: First branch cutoff check: z=28229860.873517, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 0
ITER 1: row=1, varin=51, theta=0.250000, up=1.000000
  % 	x2 = 0,	Z0 = 28179370.4788324        
DEBUG EVAL: Second branch cutoff check: z=28179370.478832, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 10 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=12, varin=34, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 0 gives z=28214888.003366
  % 	x10 = 0,	Z0 = 28214888.0033656        
DEBUG EVAL: First branch cutoff check: z=28214888.003366, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 1
ITER 1: row=12, varin=37, theta=1.000000, up=999999999999999983222784.000000
  % 	x10 = 1,	Z1 = 28158806.2476876        
DEBUG EVAL: Second branch cutoff check: z=28158806.247688, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 26 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=23, varin=37, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 26 = 0 gives z=28158806.247688
  % 	x26 = 0,	Z0 = 28158806.2476876        
DEBUG EVAL: First branch cutoff check: z=28158806.247688, best_z=INF, threshold=INF
  % Best branch is x17, Z0 = 28179370.4788324        , Z1 = 28241678.3627366        

DEBUG CAREFUL: Final result - returning best.var = 17
DEBUG BB: Branching variable chosen: j=17
 % @NC   35   31	x17 = 0	28179370.478832
 % @NC   36   31	x17 = 1	28241678.362737
 %      31    18 28153864.8328               28157091.6188    x3 D    23     6
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde8398c10
% @LO 0.03  28.15386483284418162043 99.9000000000
% @LN 0.03  28.15709161884910471940 99.9000000000
% Resuming node 33 at  28.15709161884910471940
DEBUG CONSTRNT: LP rows=39, pool->nlprows=39, pool->npend=0
DEBUG CONSTRNT: Checking 39 LP rows (pool tracks 39, total LP rows 39)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 158
DEBUG CONSTRNT: Pool row 158 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=38, expected 38
 % @PAP adding 41 rows, 170 nz to LP
DEBUG BB: Processing node 33, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=32, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=32, varin=41, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=41)
DEBUG SOLUTION: LP solution array indices: FST[42-81], not_covered[82-101]
DEBUG SOLUTION: lp->best_solution[0] = 28157091.618849
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 41 rows, 60 cols, 230 nonzeros, 1 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 11 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=42, varin=22, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=43, varin=67, theta=1.000000, up=1.000000
ITER 3: row=32, varin=21, theta=0.142857, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 28189131.805935
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 43 rows, 60 cols, 241 nonzeros, 2 slack, 41 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 3 rows, 10 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=42, varin=56, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28234878.796203
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 44 rows, 60 cols, 237 nonzeros, 1 slack, 43 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 6 rows, 34 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=44, varin=54, theta=0.500000, up=1.000000
ITER 2: row=45, varin=33, theta=0.066667, up=999999999999999983222784.000000
ITER 3: row=49, varin=45, theta=0.076923, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 28248743.670960
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 49 rows, 60 cols, 267 nonzeros, 5 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % @PAP adding 3 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=45, varin=44, theta=0.800000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 28251146.125548
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 47 rows, 60 cols, 249 nonzeros, 1 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 33 LP 1 Solution, length = 28251146.125548, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.200000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.200000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.200000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.200000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.200000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.200000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.800000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.800000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.800000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.800000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.800000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.800000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.800000 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28251146.125548, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 33 at  28.25114612554849458093
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde839c580
% @LO 0.03  28.15709161884910471940 99.9000000000
% @LN 0.03  28.16183913972073682430 99.9000000000
% Resuming node 18 at  28.16183913972073682430
DEBUG CONSTRNT: LP rows=46, pool->nlprows=46, pool->npend=0
DEBUG CONSTRNT: Checking 46 LP rows (pool tracks 46, total LP rows 46)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 85
DEBUG CONSTRNT: Pool row 85 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=45, expected 45
 % @PAP adding 52 rows, 216 nz to LP
DEBUG BB: Processing node 18, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=29, varin=67, theta=1.000000, up=1.000000
ITER 2: row=30, varin=35, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=47, varin=26, theta=4.000000, up=999999999999999983222784.000000
ITER 4: row=51, varin=41, theta=2.000000, up=999999999999999983222784.000000
ITER 5: row=40, varin=37, theta=0.800000, up=999999999999999983222784.000000
ITER 6: row=48, varin=12, theta=2.095238, up=999999999999999983222784.000000
ITER 7: row=1, varin=38, theta=0.666667, up=999999999999999983222784.000000
ITER 8: row=52, varin=27, theta=0.058824, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=8)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 28161839.139721
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 52 rows, 60 cols, 276 nonzeros, 6 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 3 rows, 10 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=53, varin=56, theta=1.428571, up=1.000000
ITER 2: row=53, varin=52, theta=0.750000, up=999999999999999983222784.000000
ITER 3: row=12, varin=56, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=55)
DEBUG SOLUTION: LP solution array indices: FST[56-95], not_covered[96-115]
DEBUG SOLUTION: lp->best_solution[0] = 28170746.001032
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 55 rows, 60 cols, 286 nonzeros, 8 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 8 slack rows
  % Node 18 LP 1 Solution, length = 28170746.001032, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.500000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 1.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.500000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.500000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.500000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.500000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.500000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.500000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 3 fractional variables
DEBUG CG: LP optimal, z=28170746.001032, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 18 at  28.17074600103212844715
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde839a8b0
% @LO 0.03  28.16183913972073682430 99.9000000000
% @LN 0.03  28.16782748341324449370 99.9000000000
% Resuming node 14 at  28.16782748341324449370
DEBUG CONSTRNT: LP rows=47, pool->nlprows=47, pool->npend=0
DEBUG CONSTRNT: Checking 47 LP rows (pool tracks 47, total LP rows 47)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 49
DEBUG CONSTRNT: Pool row 49 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 68
DEBUG CONSTRNT: Pool row 68 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 82
DEBUG CONSTRNT: Pool row 82 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=46, expected 46
 % @PAP adding 52 rows, 206 nz to LP
DEBUG BB: Processing node 14, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=27, varin=11, theta=82.500000, up=999999999999999983222784.000000
ITER 2: row=5, varin=45, theta=1.611111, up=999999999999999983222784.000000
ITER 3: row=13, varin=17, theta=3.000000, up=999999999999999983222784.000000
ITER 4: row=2, varin=54, theta=1.000000, up=1.000000
ITER 5: row=44, varin=55, theta=1.200000, up=1.000000
ITER 6: row=44, varin=52, theta=0.333333, up=999999999999999983222784.000000
ITER 7: row=22, varin=55, theta=1.000000, up=1.000000
ITER 8: row=50, varin=77, theta=2.000000, up=1.000000
ITER 9: row=50, varin=25, theta=2.000000, up=999999999999999983222784.000000
ITER 10: row=3, varin=5, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=10)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 28167827.483413
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 2.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 2.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 52 rows, 60 cols, 266 nonzeros, 17 slack, 35 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 48 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=56, varin=13, theta=2.797454, up=999999999999999983222784.000000
ITER 2: row=11, varin=81, theta=1.825253, up=1.000000
ITER 3: row=11, varin=83, theta=1.427495, up=1.000000
ITER 4: row=11, varin=2, theta=0.328426, up=999999999999999983222784.000000
ITER 5: row=17, varin=80, theta=0.386991, up=1.000000
ITER 6: row=54, varin=8, theta=0.431545, up=999999999999999983222784.000000
ITER 7: row=13, varin=30, theta=0.606299, up=999999999999999983222784.000000
ITER 8: row=30, varin=78, theta=0.358571, up=1.000000
LP PHASE: Switching to primal (iter=8)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=56)
DEBUG SOLUTION: LP solution array indices: FST[57-96], not_covered[97-116]
DEBUG SOLUTION: lp->best_solution[0] = 28351673.135567
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 56 rows, 60 cols, 314 nonzeros, 7 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 7 slack rows
  % @PAP adding 6 rows, 21 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=50, varin=66, theta=1.000000, up=1.000000
ITER 2: row=27, varin=82, theta=1.000000, up=1.000000
ITER 3: row=55, varin=43, theta=0.514936, up=999999999999999983222784.000000
ITER 4: row=52, varin=83, theta=1.541588, up=1.000000
ITER 5: row=52, varin=85, theta=0.864050, up=1.000000
ITER 6: row=20, varin=112, theta=0.667811, up=1.000000
ITER 7: row=48, varin=81, theta=0.103100, up=1.000000
ITER 8: row=24, varin=42, theta=0.027274, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=8)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=55)
DEBUG SOLUTION: LP solution array indices: FST[56-95], not_covered[96-115]
DEBUG SOLUTION: lp->best_solution[0] = 28750186.359312
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 55 rows, 60 cols, 318 nonzeros, 5 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % @PAP adding 7 rows, 20 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=51, varin=81, theta=1.000000, up=1.000000
ITER 2: row=53, varin=12, theta=0.278996, up=999999999999999983222784.000000
ITER 3: row=57, varin=85, theta=0.500000, up=1.000000
ITER 4: row=56, varin=86, theta=1.052472, up=1.000000
ITER 5: row=56, varin=50, theta=0.093872, up=999999999999999983222784.000000
ITER 6: row=1, varin=80, theta=0.022483, up=1.000000
ITER 7: row=35, varin=30, theta=0.033829, up=999999999999999983222784.000000
ITER 8: row=30, varin=27, theta=0.038914, up=999999999999999983222784.000000
ITER 9: row=27, varin=57, theta=0.158439, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=9)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=57)
DEBUG SOLUTION: LP solution array indices: FST[58-97], not_covered[98-117]
DEBUG SOLUTION: lp->best_solution[0] = 28863198.032869
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 57 rows, 60 cols, 325 nonzeros, 3 slack, 54 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 1 rows, 5 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=55, varin=84, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=55)
DEBUG SOLUTION: LP solution array indices: FST[56-95], not_covered[96-115]
DEBUG SOLUTION: lp->best_solution[0] = 29039276.918354
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 55 rows, 60 cols, 317 nonzeros, 0 slack, 55 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 9 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=57, varin=89, theta=7.170994, up=1.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=57)
DEBUG SOLUTION: LP solution array indices: FST[58-97], not_covered[98-117]
DEBUG SOLUTION: lp->best_solution[0] = 999999999999999983222784.000000
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 57 rows, 60 cols, 326 nonzeros, 0 slack, 57 tight.
  % Node 14 LP 1 Solution, length = 999999999999999983222784.000000, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.176905 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.823095 (FST 12)
  % DEBUG LP_VARS: x[13] = 1.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 1.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.823095 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.823095 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.176905 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.823095 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.176905 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.176905 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
DEBUG BB: compute_good_lower_bound returned status=1
DEBUG BB: Node 14 is INFEASIBLE
 %      14    17    infeasible               28170746.0010   x13 U     6     4
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde839c580
% @LO 0.03  28.16782748341324449370 99.9000000000
% @LN 0.03  28.17074600103212844715 99.9000000000
% Resuming node 18 at  28.17074600103212844715
DEBUG CONSTRNT: LP rows=57, pool->nlprows=57, pool->npend=0
DEBUG CONSTRNT: Checking 57 LP rows (pool tracks 57, total LP rows 57)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 65
DEBUG CONSTRNT: Pool row 65 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 141
DEBUG CONSTRNT: Pool row 141 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 145
DEBUG CONSTRNT: Pool row 145 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 159
DEBUG CONSTRNT: Pool row 159 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=54, expected 54
DEBUG CONSTRNT: Checking LP row 55 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=55, expected 55
DEBUG CONSTRNT: Checking LP row 56 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=56, expected 56
 % @PAP adding 47 rows, 202 nz to LP
DEBUG BB: Processing node 18, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 18 LP 2 Solution, length = 28170746.001032, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.500000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 1.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.500000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.500000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.500000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.500000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.500000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.500000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 3 fractional variables
DEBUG CG: LP optimal, z=28170746.001032, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28170746.001032, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 18 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 18
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.500000
DEBUG CAREFUL: Adding var 7 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=1.000000
DEBUG CAREFUL: Skipping var 10: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.500000
DEBUG CAREFUL: Adding var 15 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.500000
DEBUG CAREFUL: Adding var 16 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 3 fractional variables

  %  Carefully choosing branching variable, nfrac = 3
DEBUG CAREFUL: Testing fvar[0] = var 16
DEBUG CAREFUL: Calling compare_branch_vars for var 16
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 16
DEBUG CAREFUL: New best var: 16
DEBUG CAREFUL: Testing fvar[1] = var 15
DEBUG CAREFUL: Calling compare_branch_vars for var 15
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 15
DEBUG CAREFUL: New best var: 15
DEBUG CAREFUL: Testing fvar[2] = var 7
DEBUG CAREFUL: Calling compare_branch_vars for var 7
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 7
  % Initial guess is x15, Z0 = 28170746.0010321        , Z1 = 28246219.066739         

DEBUG EVAL: Testing var 16 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=30, varin=35, theta=5.000000, up=999999999999999983222784.000000
ITER 2: row=36, varin=33, theta=2.000000, up=999999999999999983222784.000000
ITER 3: row=27, varin=58, theta=2.000000, up=1.000000
ITER 4: row=27, varin=60, theta=0.500000, up=1.000000
DEBUG EVAL: Branch var 16 = 1 gives z=28209582.262771
  % 	x16 = 1,	Z1 = 28225460.6469015        
DEBUG EVAL: First branch cutoff check: z=28225460.646901, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 16 = 0
ITER 1: row=30, varin=12, theta=1.047619, up=999999999999999983222784.000000
ITER 2: row=1, varin=34, theta=0.588235, up=999999999999999983222784.000000
ITER 3: row=34, varin=46, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=44, varin=11, theta=30.000000, up=999999999999999983222784.000000
ITER 5: row=5, varin=8, theta=1.800000, up=999999999999999983222784.000000
ITER 6: row=12, varin=18, theta=1.800000, up=999999999999999983222784.000000
ITER 7: row=13, varin=17, theta=4.000000, up=999999999999999983222784.000000
  % 	x16 = 0,	Z0 = 28246219.066739         
DEBUG EVAL: Second branch cutoff check: z=28246219.066739, best_z=INF, threshold=INF
  %   New best:  x16, Z = 28225460.6469015        
DEBUG EVAL: Testing var 15 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=27, varin=12, theta=1.047619, up=999999999999999983222784.000000
ITER 2: row=1, varin=46, theta=0.333333, up=999999999999999983222784.000000
ITER 3: row=46, varin=34, theta=0.588235, up=999999999999999983222784.000000
ITER 4: row=34, varin=11, theta=30.000000, up=999999999999999983222784.000000
ITER 5: row=5, varin=8, theta=1.800000, up=999999999999999983222784.000000
ITER 6: row=12, varin=18, theta=1.800000, up=999999999999999983222784.000000
ITER 7: row=13, varin=17, theta=4.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 15 = 1 gives z=28246219.066739
  % 	x15 = 1,	Z1 = 28246219.066739         
DEBUG EVAL: First branch cutoff check: z=28246219.066739, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 15 = 0
ITER 1: row=27, varin=33, theta=0.400000, up=999999999999999983222784.000000
  % 	x15 = 0,	Z0 = 28174149.340376         
DEBUG EVAL: Second branch cutoff check: z=28174149.340376, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 7 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=8, varin=35, theta=5.000000, up=999999999999999983222784.000000
ITER 2: row=36, varin=33, theta=2.000000, up=999999999999999983222784.000000
ITER 3: row=27, varin=58, theta=2.000000, up=1.000000
ITER 4: row=27, varin=57, theta=0.200000, up=1.000000
DEBUG EVAL: Branch var 7 = 0 gives z=28207652.158015
  % 	x7 = 0,	Z0 = 28207652.1580147        
DEBUG EVAL: First branch cutoff check: z=28207652.158015, best_z=INF, threshold=INF
  % Best branch is x16, Z0 = 28246219.066739         , Z1 = 28225460.6469015        

DEBUG CAREFUL: Final result - returning best.var = 16
DEBUG BB: Branching variable chosen: j=16
 % @NC   37   18	x16 = 1	28225460.646901
 % @NC   38   18	x16 = 0	28246219.066739
 %      18    18 28170746.0010               28176327.2531   x13 D     8     4
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde83afb10
% @LO 0.03  28.17074600103212844715 99.9000000000
% @LN 0.03  28.17632725308718377732 99.9000000000
% Resuming node 34 at  28.17632725308718377732
DEBUG CONSTRNT: LP rows=47, pool->nlprows=47, pool->npend=0
DEBUG CONSTRNT: Checking 47 LP rows (pool tracks 47, total LP rows 47)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 49
DEBUG CONSTRNT: Pool row 49 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 68
DEBUG CONSTRNT: Pool row 68 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 82
DEBUG CONSTRNT: Pool row 82 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=46, expected 46
 % @PAP adding 41 rows, 170 nz to LP
DEBUG BB: Processing node 34, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=53, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=41)
DEBUG SOLUTION: LP solution array indices: FST[42-81], not_covered[82-101]
DEBUG SOLUTION: lp->best_solution[0] = 28176327.253087
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 41 rows, 60 cols, 230 nonzeros, 0 slack, 41 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 6 rows, 34 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=42, varin=52, theta=0.500000, up=1.000000
ITER 2: row=43, varin=35, theta=0.066667, up=999999999999999983222784.000000
ITER 3: row=47, varin=43, theta=0.076923, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 28190192.127844
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 47 rows, 60 cols, 264 nonzeros, 5 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % @PAP adding 3 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=43, varin=42, theta=0.800000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 28192594.582433
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 45 rows, 60 cols, 246 nonzeros, 1 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 34 LP 1 Solution, length = 28192594.582433, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.200000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.200000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.200000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.200000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.200000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.200000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.800000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.800000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.800000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.800000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.800000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.800000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.800000 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28192594.582433, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 34 at  28.19259458243265470401
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde8397490
% @LO 0.03  28.17632725308718377732 99.9000000000
% @LN 0.03  28.17937047883243906199 99.9000000000
% Resuming node 35 at  28.17937047883243906199
DEBUG CONSTRNT: LP rows=44, pool->nlprows=44, pool->npend=0
DEBUG CONSTRNT: Checking 44 LP rows (pool tracks 44, total LP rows 44)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=43, expected 43
 % @PAP adding 39 rows, 168 nz to LP
DEBUG BB: Processing node 35, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=20, varin=51, theta=0.250000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=39)
DEBUG SOLUTION: LP solution array indices: FST[40-79], not_covered[80-99]
DEBUG SOLUTION: lp->best_solution[0] = 28179370.478832
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 39 rows, 60 cols, 228 nonzeros, 0 slack, 39 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 22 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=40, varin=48, theta=0.250000, up=1.000000
ITER 2: row=41, varin=24, theta=0.031250, up=999999999999999983222784.000000
ITER 3: row=42, varin=40, theta=0.031250, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 28189795.057182
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 43 rows, 60 cols, 250 nonzeros, 2 slack, 41 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 3 rows, 11 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=42, varin=101, theta=0.500000, up=1.000000
ITER 2: row=35, varin=74, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28229019.912336
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 44 rows, 60 cols, 257 nonzeros, 0 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 13 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=45, varin=19, theta=0.062500, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 28234281.219689
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 48 rows, 60 cols, 270 nonzeros, 2 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=47, varin=16, theta=0.214286, up=999999999999999983222784.000000
ITER 2: row=16, varin=81, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 28253760.276449
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 47 rows, 60 cols, 264 nonzeros, 0 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 14 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=48, varin=3, theta=0.250000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 28254360.297511
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.750000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 51 rows, 60 cols, 278 nonzeros, 3 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % Node 35 LP 1 Solution, length = 28254360.297511, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.250000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.250000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 1.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.500000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.500000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.250000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.250000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.750000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.750000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.750000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.750000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.500000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.500000 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28254360.297511, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 35 at  28.25436029751072197769
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde839dbe0
% @LO 0.03  28.17937047883243906199 99.9000000000
% @LN 0.03  28.18594163958271181514 99.9000000000
% Resuming node 10 at  28.18594163958271181514
DEBUG CONSTRNT: LP rows=48, pool->nlprows=48, pool->npend=0
DEBUG CONSTRNT: Checking 48 LP rows (pool tracks 48, total LP rows 48)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 158
DEBUG CONSTRNT: Pool row 158 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=47, expected 47
 % @PAP adding 48 rows, 223 nz to LP
DEBUG BB: Processing node 10, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=39, varin=13, theta=1.704957, up=999999999999999983222784.000000
ITER 2: row=11, varin=18, theta=0.851567, up=999999999999999983222784.000000
ITER 3: row=42, varin=12, theta=1.190041, up=999999999999999983222784.000000
ITER 4: row=1, varin=24, theta=1.877570, up=999999999999999983222784.000000
ITER 5: row=8, varin=32, theta=0.826838, up=999999999999999983222784.000000
ITER 6: row=43, varin=34, theta=0.803504, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 28185941.639583
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.196496
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 48 rows, 60 cols, 283 nonzeros, 4 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % @PAP adding 6 rows, 27 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=45, varin=30, theta=-6.962921, up=999999999999999983222784.000000
ITER 2: row=35, varin=51, theta=0.396849, up=1.000000
ITER 3: row=11, varin=53, theta=0.688735, up=1.000000
ITER 4: row=22, varin=10, theta=1.528796, up=999999999999999983222784.000000
ITER 5: row=12, varin=75, theta=2.213801, up=1.000000
ITER 6: row=12, varin=16, theta=0.500911, up=999999999999999983222784.000000
ITER 7: row=3, varin=75, theta=0.857534, up=1.000000
ITER 8: row=2, varin=5, theta=0.271180, up=999999999999999983222784.000000
ITER 9: row=19, varin=12, theta=0.419505, up=999999999999999983222784.000000
ITER 10: row=22, varin=69, theta=0.206547, up=1.000000
LP PHASE: Switching to primal (iter=12)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28286088.684593
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.723434
DEBUG SOLUTION: lp->best_solution[5] = 2.723434
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.723434
DEBUG SOLUTION: lp->best_solution[9] = 0.723434
DEBUG SOLUTION: lp->best_solution[10] = 3.446868
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.723434
DEBUG SOLUTION: lp->best_solution[14] = 0.723434
  % @PL 50 rows, 60 cols, 302 nonzeros, 11 slack, 39 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 11 slack rows
  % @PAP adding 5 rows, 11 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=41, varin=4, theta=0.811681, up=999999999999999983222784.000000
ITER 2: row=7, varin=14, theta=1.474718, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28288221.154093
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.262641
DEBUG SOLUTION: lp->best_solution[13] = 0.262641
DEBUG SOLUTION: lp->best_solution[14] = 1.525282
  % @PL 44 rows, 60 cols, 281 nonzeros, 6 slack, 38 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 6 slack rows
  % Node 10 LP 1 Solution, length = 28288221.154093, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.737359 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.420880 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 1.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.579120 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.420880 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.420880 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.262641 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.420880 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.420880 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 3 fractional variables
DEBUG CG: LP optimal, z=28288221.154093, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 10 at  28.28822115409331772184
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde8397250
% @LO 0.03  28.18594163958271181514 99.9000000000
% @LN 0.03  28.18632521593903206281 99.9000000000
% Resuming node 17 at  28.18632521593903206281
DEBUG CONSTRNT: LP rows=38, pool->nlprows=38, pool->npend=0
DEBUG CONSTRNT: Checking 38 LP rows (pool tracks 38, total LP rows 38)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 141
DEBUG CONSTRNT: Pool row 141 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 145
DEBUG CONSTRNT: Pool row 145 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 159
DEBUG CONSTRNT: Pool row 159 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=37, expected 37
 % @PAP adding 45 rows, 173 nz to LP
DEBUG BB: Processing node 17, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 17 LP 2 Solution, length = 28186325.215939, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.166667 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.166667 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.166667 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 1.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.166667 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.166667 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.166667 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.833333 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.833333 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.833333 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.833333 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.833333 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.833333 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.833333 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28186325.215939, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28186325.215939, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 17 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 17
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.166667
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.166667
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.166667
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=1.000000
DEBUG CAREFUL: Skipping var 13: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.166667
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.166667
DEBUG CAREFUL: Adding var 18 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.166667
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 6 fractional variables

  %  Carefully choosing branching variable, nfrac = 6
DEBUG CAREFUL: Testing fvar[0] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 17
DEBUG CAREFUL: New best var: 17
DEBUG CAREFUL: Testing fvar[1] = var 18
DEBUG CAREFUL: Calling compare_branch_vars for var 18
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 18
DEBUG CAREFUL: New best var: 18
DEBUG CAREFUL: Testing fvar[2] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[3] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 3
DEBUG CAREFUL: Testing fvar[4] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[5] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
  % Initial guess is x18, Z0 = 28186325.215939         , Z1 = 28370238.210743         

DEBUG EVAL: Testing var 17 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=22, varin=23, theta=0.333333, up=999999999999999983222784.000000
ITER 2: row=34, varin=82, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 17 = 0 gives z=28224301.846637
  % 	x17 = 0,	Z0 = 28224301.846637         
DEBUG EVAL: First branch cutoff check: z=28224301.846637, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 17 = 1
ITER 1: row=22, varin=43, theta=5.000000, up=999999999999999983222784.000000
ITER 2: row=40, varin=30, theta=4.000000, up=999999999999999983222784.000000
ITER 3: row=29, varin=40, theta=2.000000, up=999999999999999983222784.000000
ITER 4: row=9, varin=32, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=35, varin=39, theta=2.000000, up=999999999999999983222784.000000
ITER 6: row=1, varin=37, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=2, varin=33, theta=0.333333, up=999999999999999983222784.000000
  % 	x17 = 1,	Z1 = 28292163.2772531        
DEBUG EVAL: Second branch cutoff check: z=28292163.277253, best_z=INF, threshold=INF
  %   New best:  x17, Z = 28224301.846637         
DEBUG EVAL: Testing var 18 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=32, varin=43, theta=5.000000, up=999999999999999983222784.000000
ITER 2: row=40, varin=30, theta=4.000000, up=999999999999999983222784.000000
ITER 3: row=29, varin=40, theta=2.000000, up=999999999999999983222784.000000
ITER 4: row=9, varin=39, theta=2.000000, up=999999999999999983222784.000000
ITER 5: row=1, varin=37, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=2, varin=23, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=34, varin=31, theta=0.526316, up=999999999999999983222784.000000
ITER 8: row=27, varin=3, theta=1.000000, up=999999999999999983222784.000000
ITER 9: row=37, varin=62, theta=0.387097, up=1.000000
ITER 10: row=13, varin=33, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 18 = 1 gives z=28363214.013753
  % 	x18 = 1,	Z1 = 28370238.210743         
DEBUG EVAL: First branch cutoff check: z=28370238.210743, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 18 = 0
ITER 1: row=32, varin=32, theta=0.333333, up=999999999999999983222784.000000
ITER 2: row=35, varin=82, theta=1.000000, up=1.000000
  % 	x18 = 0,	Z0 = 28224301.846637         
DEBUG EVAL: Second branch cutoff check: z=28224301.846637, best_z=INF, threshold=INF
  %   New best:  x18, Z = 28224301.846637         
DEBUG EVAL: Testing var 10 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=14, varin=16, theta=0.200000, up=999999999999999983222784.000000
ITER 2: row=35, varin=82, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 10 = 0 gives z=28224301.846637
  % 	x10 = 0,	Z0 = 28224301.846637         
DEBUG EVAL: First branch cutoff check: z=28224301.846637, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 1
ITER 1: row=14, varin=43, theta=5.000000, up=999999999999999983222784.000000
ITER 2: row=40, varin=30, theta=4.000000, up=999999999999999983222784.000000
ITER 3: row=29, varin=40, theta=2.000000, up=999999999999999983222784.000000
ITER 4: row=9, varin=33, theta=0.500000, up=999999999999999983222784.000000
  % 	x10 = 1,	Z1 = 28254103.5313433        
DEBUG EVAL: Second branch cutoff check: z=28254103.531343, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 3 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=9, varin=43, theta=5.000000, up=999999999999999983222784.000000
ITER 2: row=40, varin=30, theta=4.000000, up=999999999999999983222784.000000
ITER 3: row=29, varin=32, theta=2.000000, up=999999999999999983222784.000000
ITER 4: row=35, varin=39, theta=4.000000, up=999999999999999983222784.000000
ITER 5: row=1, varin=22, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=41, varin=37, theta=3.000000, up=999999999999999983222784.000000
ITER 7: row=2, varin=33, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 3 = 1 gives z=28372708.819299
  % 	x3 = 1,	Z1 = 28372708.8192992        
DEBUG EVAL: First branch cutoff check: z=28372708.819299, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 3 = 0
ITER 1: row=9, varin=40, theta=0.250000, up=999999999999999983222784.000000
  % 	x3 = 0,	Z0 = 28191175.1963178        
DEBUG EVAL: Second branch cutoff check: z=28191175.196318, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 2 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=39, theta=0.200000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 0 gives z=28192764.752356
  % 	x2 = 0,	Z0 = 28192764.752356         
DEBUG EVAL: First branch cutoff check: z=28192764.752356, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 26 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=40, varin=30, theta=5.000000, up=999999999999999983222784.000000
ITER 2: row=29, varin=40, theta=2.500000, up=999999999999999983222784.000000
ITER 3: row=9, varin=33, theta=0.750000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 26 = 1 gives z=28271891.139387
  % 	x26 = 1,	Z1 = 28271891.1393869        
DEBUG EVAL: First branch cutoff check: z=28271891.139387, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 26 = 0
ITER 1: row=40, varin=43, theta=0.200000, up=999999999999999983222784.000000
  % 	x26 = 0,	Z0 = 28187178.7611258        
DEBUG EVAL: Second branch cutoff check: z=28187178.761126, best_z=INF, threshold=INF
  % Best branch is x18, Z0 = 28224301.846637         , Z1 = 28370238.210743         

DEBUG CAREFUL: Final result - returning best.var = 18
DEBUG BB: Branching variable chosen: j=18
 % @NC   39   17	x18 = 0	28224301.846637
 % @NC   40   17	x18 = 1	28370238.210743
 %      17    19 28186325.2159               28188739.9667   x13 U     8     4
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde8397010
% @LO 0.03  28.18632521593903206281 99.9000000000
% @LN 0.03  28.18873996668646952912 99.9000000000
% Resuming node 27 at  28.18873996668646952912
DEBUG CONSTRNT: LP rows=45, pool->nlprows=45, pool->npend=0
DEBUG CONSTRNT: Checking 45 LP rows (pool tracks 45, total LP rows 45)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 65
DEBUG CONSTRNT: Pool row 65 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 121
DEBUG CONSTRNT: Pool row 121 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=44, expected 44
 % @PAP adding 48 rows, 202 nz to LP
DEBUG BB: Processing node 27, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=33, varin=12, theta=1.047619, up=999999999999999983222784.000000
ITER 2: row=1, varin=35, theta=0.666667, up=999999999999999983222784.000000
ITER 3: row=35, varin=47, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=45, varin=11, theta=30.000000, up=999999999999999983222784.000000
ITER 5: row=5, varin=44, theta=1.800000, up=999999999999999983222784.000000
ITER 6: row=44, varin=8, theta=0.800000, up=999999999999999983222784.000000
ITER 7: row=13, varin=17, theta=4.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=7)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 28188739.966686
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 0.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 48 rows, 60 cols, 262 nonzeros, 12 slack, 36 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 8 rows, 79 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=56, varin=58, theta=1.168075, up=1.000000
ITER 2: row=56, varin=33, theta=0.088683, up=999999999999999983222784.000000
ITER 3: row=55, varin=43, theta=0.147024, up=999999999999999983222784.000000
ITER 4: row=51, varin=42, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=11, varin=108, theta=0.324390, up=1.000000
ITER 6: row=49, varin=41, theta=0.911317, up=999999999999999983222784.000000
ITER 7: row=54, varin=55, theta=11.088683, up=999999999999999983222784.000000
ITER 8: row=44, varin=114, theta=0.278839, up=1.000000
ITER 9: row=47, varin=34, theta=0.374847, up=999999999999999983222784.000000
ITER 10: row=53, varin=54, theta=0.363486, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=10)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=56)
DEBUG SOLUTION: LP solution array indices: FST[57-96], not_covered[97-116]
DEBUG SOLUTION: lp->best_solution[0] = 28222493.363767
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 56 rows, 60 cols, 341 nonzeros, 10 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 10 slack rows
  % @PAP adding 2 rows, 11 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=47, varin=39, theta=0.824070, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 28244290.507331
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 48 rows, 60 cols, 293 nonzeros, 2 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 5 rows, 24 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=47, varin=61, theta=0.271438, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 28249685.734525
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 51 rows, 60 cols, 306 nonzeros, 3 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % Node 27 LP 1 Solution, length = 28249685.734525, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.542876 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.271438 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.500000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.500000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 1.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.457124 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.500000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.500000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.457124 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.457124 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.500000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=28249685.734525, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 27 at  28.24968573452535380852
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde83afb10
% @LO 0.03  28.18873996668646952912 99.9000000000
% @LN 0.03  28.19259458243265470401 99.9000000000
% Resuming node 34 at  28.19259458243265470401
DEBUG CONSTRNT: LP rows=48, pool->nlprows=48, pool->npend=0
DEBUG CONSTRNT: Checking 48 LP rows (pool tracks 48, total LP rows 48)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 141
DEBUG CONSTRNT: Pool row 141 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 145
DEBUG CONSTRNT: Pool row 145 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 159
DEBUG CONSTRNT: Pool row 159 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=47, expected 47
 % @PAP adding 44 rows, 176 nz to LP
DEBUG BB: Processing node 34, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 34 LP 2 Solution, length = 28192594.582433, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.200000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.200000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.200000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.200000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.200000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.200000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.800000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.800000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.800000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.800000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.800000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.800000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.800000 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28192594.582433, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28192594.582433, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 34 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 34
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.200000
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.200000)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.200000
DEBUG CAREFUL: Adding var 4 to fractional list (xi=0.200000)
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=1.000000
DEBUG CAREFUL: Skipping var 7: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.200000
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.200000)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.200000
DEBUG CAREFUL: Adding var 11 to fractional list (xi=0.200000)
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.200000
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.200000)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.200000
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.200000)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 6 fractional variables

  %  Carefully choosing branching variable, nfrac = 6
DEBUG CAREFUL: Testing fvar[0] = var 4
DEBUG CAREFUL: Calling compare_branch_vars for var 4
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 4
DEBUG CAREFUL: New best var: 4
DEBUG CAREFUL: Testing fvar[1] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[2] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[3] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[4] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
DEBUG CAREFUL: Testing fvar[5] = var 11
DEBUG CAREFUL: Calling compare_branch_vars for var 11
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 11
  % Initial guess is x4, Z0 = 28192594.5824327        , Z1 = 28445872.1377927        

DEBUG EVAL: Testing var 4 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=12, varin=39, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=39, varin=32, theta=2.000000, up=999999999999999983222784.000000
ITER 3: row=32, varin=38, theta=2.000000, up=999999999999999983222784.000000
ITER 4: row=38, varin=22, theta=2.000000, up=999999999999999983222784.000000
ITER 5: row=22, varin=25, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=43, varin=35, theta=2.000000, up=999999999999999983222784.000000
ITER 7: row=35, varin=33, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 4 = 1 gives z=28519545.610648
  % 	x4 = 1,	Z1 = 28519545.6106478        
DEBUG EVAL: First branch cutoff check: z=28519545.610648, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 4 = 0
ITER 1: row=12, varin=42, theta=0.333333, up=999999999999999983222784.000000
  % 	x4 = 0,	Z0 = 28195197.2415702        
DEBUG EVAL: Second branch cutoff check: z=28195197.241570, best_z=INF, threshold=INF
  %   New best:  x4, Z = 28195197.2415702        
DEBUG EVAL: Testing var 17 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=25, varin=42, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=12, varin=39, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 17 = 1 gives z=28232937.218536
  % 	x17 = 1,	Z1 = 28232937.2185362        
DEBUG EVAL: First branch cutoff check: z=28232937.218536, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 17 = 0
ITER 1: row=25, varin=26, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=40, varin=101, theta=1.000000, up=1.000000
  % 	x17 = 0,	Z0 = 28245184.5070717        
DEBUG EVAL: Second branch cutoff check: z=28245184.507072, best_z=INF, threshold=INF
  %   New best:  x17, Z = 28232937.2185362        
DEBUG EVAL: Testing var 10 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=20, varin=24, theta=0.250000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 0 gives z=28239925.823024
  % 	x10 = 0,	Z0 = 28239925.8230239        
DEBUG EVAL: First branch cutoff check: z=28239925.823024, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 1
ITER 1: row=20, varin=42, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=12, varin=39, theta=1.000000, up=999999999999999983222784.000000
  % 	x10 = 1,	Z1 = 28232937.2185362        
DEBUG EVAL: Second branch cutoff check: z=28232937.218536, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 2 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=42, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=12, varin=39, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 1 gives z=28232937.218536
  % 	x2 = 1,	Z1 = 28232937.2185362        
DEBUG EVAL: First branch cutoff check: z=28232937.218536, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 0
ITER 1: row=1, varin=33, theta=0.250000, up=999999999999999983222784.000000
  % 	x2 = 0,	Z0 = 28232887.873142         
DEBUG EVAL: Second branch cutoff check: z=28232887.873142, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 26 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=35, varin=35, theta=0.250000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 26 = 0 gives z=28225905.384104
  % 	x26 = 0,	Z0 = 28225905.3841043        
DEBUG EVAL: First branch cutoff check: z=28225905.384104, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 11 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=39, varin=42, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=12, varin=32, theta=2.000000, up=999999999999999983222784.000000
ITER 3: row=32, varin=38, theta=2.000000, up=999999999999999983222784.000000
ITER 4: row=38, varin=22, theta=2.000000, up=999999999999999983222784.000000
ITER 5: row=22, varin=26, theta=2.000000, up=999999999999999983222784.000000
ITER 6: row=40, varin=35, theta=2.000000, up=999999999999999983222784.000000
ITER 7: row=35, varin=33, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 11 = 1 gives z=28494818.929369
  % 	x11 = 1,	Z1 = 28494818.9293695        
DEBUG EVAL: First branch cutoff check: z=28494818.929369, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 11 = 0
ITER 1: row=39, varin=39, theta=0.333333, up=999999999999999983222784.000000
  % 	x11 = 0,	Z0 = 28203439.468663         
DEBUG EVAL: Second branch cutoff check: z=28203439.468663, best_z=INF, threshold=INF
  % Best branch is x17, Z0 = 28245184.5070717        , Z1 = 28232937.2185362        

DEBUG CAREFUL: Final result - returning best.var = 17
DEBUG BB: Branching variable chosen: j=17
 % @NC   41   34	x17 = 1	28232937.218536
 % @NC   42   34	x17 = 0	28245184.507072
 %      34    20 28192594.5824               28202233.0987    x7 U    29     7
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde83a0240
% @LO 0.04  28.19259458243265470401 99.9000000000
% @LN 0.04  28.20223309874799255681 99.9000000000
% Resuming node 25 at  28.20223309874799255681
DEBUG CONSTRNT: LP rows=44, pool->nlprows=44, pool->npend=0
DEBUG CONSTRNT: Checking 44 LP rows (pool tracks 44, total LP rows 44)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=43, expected 43
 % @PAP adding 48 rows, 185 nz to LP
DEBUG BB: Processing node 25, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=6, varin=47, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=47, varin=44, theta=0.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 28102655.905031
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 48 rows, 60 cols, 245 nonzeros, 3 slack, 45 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 54 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=52, varin=13, theta=2.325336, up=999999999999999983222784.000000
ITER 2: row=11, varin=79, theta=5.639756, up=1.000000
ITER 3: row=11, varin=42, theta=1.337811, up=999999999999999983222784.000000
ITER 4: row=17, varin=41, theta=7.285676, up=999999999999999983222784.000000
ITER 5: row=24, varin=76, theta=3.417459, up=1.000000
ITER 6: row=24, varin=8, theta=1.031664, up=999999999999999983222784.000000
ITER 7: row=13, varin=12, theta=1.334814, up=999999999999999983222784.000000
ITER 8: row=3, varin=2, theta=2.842065, up=999999999999999983222784.000000
ITER 9: row=2, varin=75, theta=2.246091, up=1.000000
ITER 10: row=2, varin=74, theta=1.194956, up=1.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 999999999999999983222784.000000
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 52 rows, 60 cols, 299 nonzeros, 10 slack, 42 tight.
  % Node 25 LP 1 Solution, length = 999999999999999983222784.000000, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.500000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 1.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
DEBUG BB: compute_good_lower_bound returned status=1
DEBUG BB: Node 25 is INFEASIBLE
 %      25    19    infeasible               28202851.8160   x20 U    21     5
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde83b0540
% @LO 0.04  28.20223309874799255681 99.9000000000
% @LN 0.04  28.20285181597337142989 99.9000000000
% Resuming node 26 at  28.20285181597337142989
DEBUG CONSTRNT: LP rows=52, pool->nlprows=52, pool->npend=0
DEBUG CONSTRNT: Checking 52 LP rows (pool tracks 52, total LP rows 52)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=51, expected 51
 % @PAP adding 48 rows, 185 nz to LP
DEBUG BB: Processing node 26, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=6, varin=56, theta=1.000000, up=1.000000
ITER 2: row=32, varin=72, theta=1.000000, up=1.000000
ITER 3: row=43, varin=60, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 28202851.815973
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 48 rows, 60 cols, 245 nonzeros, 0 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 6 rows, 34 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=49, varin=64, theta=1.000000, up=1.000000
ITER 2: row=35, varin=59, theta=0.500000, up=1.000000
ITER 3: row=50, varin=91, theta=1.000000, up=1.000000
ITER 4: row=32, varin=18, theta=0.062500, up=999999999999999983222784.000000
ITER 5: row=54, varin=31, theta=0.058824, up=999999999999999983222784.000000
ITER 6: row=51, varin=49, theta=0.066176, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=54)
DEBUG SOLUTION: LP solution array indices: FST[55-94], not_covered[95-114]
DEBUG SOLUTION: lp->best_solution[0] = 28241437.916622
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 54 rows, 60 cols, 279 nonzeros, 5 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % @PAP adding 4 rows, 13 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=50, varin=6, theta=0.346154, up=999999999999999983222784.000000
ITER 2: row=43, varin=110, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=53)
DEBUG SOLUTION: LP solution array indices: FST[54-93], not_covered[94-113]
DEBUG SOLUTION: lp->best_solution[0] = 28271709.069958
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 2.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 2.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 53 rows, 60 cols, 282 nonzeros, 11 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 11 slack rows
  % @PAP adding 1 rows, 3 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=43, varin=8, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=5, varin=73, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 28286929.876470
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 43 rows, 60 cols, 253 nonzeros, 0 slack, 43 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 26 LP 1 Solution, length = 28286929.876470, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.500000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.500000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.500000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.500000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.500000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.500000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.500000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.500000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.500000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 0.500000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28286929.876470, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 26 at  28.28692987646958201253
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde839c580
% @LO 0.04  28.20285181597337142989 99.9000000000
% @LN 0.04  28.22430184663699037628 99.9000000000
% Resuming node 39 at  28.22430184663699037628
DEBUG CONSTRNT: LP rows=43, pool->nlprows=43, pool->npend=0
DEBUG CONSTRNT: Checking 43 LP rows (pool tracks 43, total LP rows 43)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 142
DEBUG CONSTRNT: Pool row 142 has lprow=42, expected 42
 % @PAP adding 45 rows, 173 nz to LP
DEBUG BB: Processing node 39, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=32, varin=32, theta=0.333333, up=999999999999999983222784.000000
ITER 2: row=35, varin=82, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 28224301.846637
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 45 rows, 60 cols, 233 nonzeros, 0 slack, 45 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=46, varin=33, theta=0.333333, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 28236297.947720
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 47 rows, 60 cols, 241 nonzeros, 4 slack, 43 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % Node 39 LP 1 Solution, length = 28236297.947720, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.333333 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.333333 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.333333 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 1.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.333333 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.333333 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.666667 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.666667 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.666667 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.666667 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.666667 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.666667 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.666667 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28236297.947720, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 39 at  28.23629794771950685117
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde839a8b0
% @LO 0.04  28.22430184663699037628 99.9000000000
% @LN 0.04  28.22546064690148881482 99.9000000000
% Resuming node 37 at  28.22546064690148881482
DEBUG CONSTRNT: LP rows=43, pool->nlprows=43, pool->npend=0
DEBUG CONSTRNT: Checking 43 LP rows (pool tracks 43, total LP rows 43)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 65
DEBUG CONSTRNT: Pool row 65 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 121
DEBUG CONSTRNT: Pool row 121 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=42, expected 42
 % @PAP adding 47 rows, 202 nz to LP
DEBUG BB: Processing node 37, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=30, varin=35, theta=5.000000, up=999999999999999983222784.000000
ITER 2: row=36, varin=33, theta=2.000000, up=999999999999999983222784.000000
ITER 3: row=27, varin=58, theta=2.000000, up=1.000000
ITER 4: row=27, varin=60, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 28209582.262771
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 47 rows, 60 cols, 262 nonzeros, 0 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 16 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=48, varin=11, theta=16.500000, up=999999999999999983222784.000000
ITER 2: row=8, varin=67, theta=0.833333, up=1.000000
ITER 3: row=47, varin=17, theta=5.000000, up=999999999999999983222784.000000
ITER 4: row=2, varin=54, theta=0.600000, up=1.000000
ITER 5: row=47, varin=53, theta=1.000000, up=1.000000
ITER 6: row=37, varin=18, theta=0.069767, up=999999999999999983222784.000000
ITER 7: row=22, varin=37, theta=8.000000, up=999999999999999983222784.000000
ITER 8: row=38, varin=76, theta=1.000000, up=1.000000
ITER 9: row=13, varin=17, theta=1.500000, up=999999999999999983222784.000000
ITER 10: row=3, varin=70, theta=0.333333, up=1.000000
LP PHASE: Switching to primal (iter=12)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 28272458.773748
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.944444
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 51 rows, 60 cols, 278 nonzeros, 5 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % @PAP adding 7 rows, 26 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=53, varin=64, theta=0.051095, up=1.000000
ITER 2: row=48, varin=5, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=53)
DEBUG SOLUTION: LP solution array indices: FST[54-93], not_covered[94-113]
DEBUG SOLUTION: lp->best_solution[0] = 28276505.208363
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 2.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 53 rows, 60 cols, 281 nonzeros, 11 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 11 slack rows
  % @PAP adding 3 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=43, varin=12, theta=2.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 28285017.460026
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 45 rows, 60 cols, 257 nonzeros, 4 slack, 41 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % @PAP adding 2 rows, 12 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=43, varin=20, theta=0.719298, up=999999999999999983222784.000000
ITER 2: row=42, varin=39, theta=3.200000, up=999999999999999983222784.000000
ITER 3: row=33, varin=47, theta=0.400000, up=1.000000
ITER 4: row=43, varin=43, theta=0.076923, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 28311574.222101
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 43 rows, 60 cols, 258 nonzeros, 3 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 3 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=41, varin=70, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 28312947.416177
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 43 rows, 60 cols, 238 nonzeros, 0 slack, 43 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 17 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=44, varin=20, theta=0.666667, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 28317215.142111
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 47 rows, 60 cols, 255 nonzeros, 2 slack, 45 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % Node 37 LP 1 Solution, length = 28317215.142111, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.166667 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.166667 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.166667 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 1.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.166667 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.166667 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.166667 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.833333 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.833333 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.833333 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.833333 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.833333 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.833333 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.833333 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28317215.142111, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 37 at  28.31721514211102430636
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde83b0600
% @LO 0.04  28.22546064690148881482 99.9000000000
% @LN 0.04  28.22547641492642966909 99.9000000000
% Resuming node 22 at  28.22547641492642966909
DEBUG CONSTRNT: LP rows=45, pool->nlprows=45, pool->npend=0
DEBUG CONSTRNT: Checking 45 LP rows (pool tracks 45, total LP rows 45)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 49
DEBUG CONSTRNT: Pool row 49 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 68
DEBUG CONSTRNT: Pool row 68 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 82
DEBUG CONSTRNT: Pool row 82 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 121
DEBUG CONSTRNT: Pool row 121 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=44, expected 44
 % @PAP adding 51 rows, 230 nz to LP
DEBUG BB: Processing node 22, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=19, varin=50, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=17, varin=13, theta=6.000000, up=999999999999999983222784.000000
ITER 3: row=11, varin=49, theta=2.000000, up=999999999999999983222784.000000
ITER 4: row=48, varin=24, theta=0.370648, up=999999999999999983222784.000000
ITER 5: row=1, varin=27, theta=3.214024, up=999999999999999983222784.000000
ITER 6: row=27, varin=12, theta=0.022723, up=999999999999999983222784.000000
ITER 7: row=2, varin=17, theta=0.356707, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=7)
ITER 8: row=39, varin=39, theta=0.000000, up=999999999999999983222784.000000
ITER 9: row=3, varin=3, theta=0.000000, up=999999999999999983222784.000000
ITER 10: row=7, varin=8, theta=0.000000, up=999999999999999983222784.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 28225476.414926
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.928659
DEBUG SOLUTION: lp->best_solution[13] = 0.928659
DEBUG SOLUTION: lp->best_solution[14] = 0.928659
  % @PL 51 rows, 60 cols, 290 nonzeros, 15 slack, 36 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 6 rows, 32 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=52, varin=20, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=17, varin=111, theta=0.928659, up=1.000000
ITER 3: row=54, varin=28, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=27, varin=72, theta=0.453458, up=1.000000
ITER 5: row=57, varin=29, theta=0.166667, up=999999999999999983222784.000000
ITER 6: row=56, varin=57, theta=1.203366, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=57)
DEBUG SOLUTION: LP solution array indices: FST[58-97], not_covered[98-117]
DEBUG SOLUTION: lp->best_solution[0] = 28258852.178615
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 57 rows, 60 cols, 322 nonzeros, 13 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 13 slack rows
  % @PAP adding 4 rows, 12 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=45, varin=19, theta=0.941751, up=999999999999999983222784.000000
ITER 2: row=47, varin=50, theta=0.849887, up=1.000000
ITER 3: row=8, varin=61, theta=0.426268, up=1.000000
ITER 4: row=36, varin=56, theta=0.279945, up=1.000000
ITER 5: row=32, varin=73, theta=0.840459, up=1.000000
ITER 6: row=3, varin=51, theta=0.469485, up=1.000000
ITER 7: row=23, varin=58, theta=0.272294, up=1.000000
LP PHASE: Switching to primal (iter=7)
ITER 8: row=12, varin=49, theta=0.000000, up=1.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 28334000.558980
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 48 rows, 60 cols, 285 nonzeros, 2 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % Node 22 LP 1 Solution, length = 28334000.558980, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.272294 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.272294 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.363853 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.363853 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.816881 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.183119 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.183119 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.636147 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.636147 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.183119 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.183119 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.636147 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.636147 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.183119 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28334000.558980, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 22 at  28.33400055898005831523
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde8397250
% @LO 0.04  28.22547641492642966909 99.9000000000
% @LN 0.04  28.23293721853624660412 99.9000000000
% Resuming node 41 at  28.23293721853624660412
DEBUG CONSTRNT: LP rows=46, pool->nlprows=46, pool->npend=0
DEBUG CONSTRNT: Checking 46 LP rows (pool tracks 46, total LP rows 46)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=45, expected 45
 % @PAP adding 44 rows, 176 nz to LP
DEBUG BB: Processing node 41, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=25, varin=42, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=12, varin=39, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28232937.218536
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 44 rows, 60 cols, 236 nonzeros, 6 slack, 38 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 42 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=46, varin=5, theta=2.073430, up=999999999999999983222784.000000
ITER 2: row=5, varin=31, theta=1.312646, up=999999999999999983222784.000000
ITER 3: row=2, varin=76, theta=2.604387, up=1.000000
ITER 4: row=2, varin=103, theta=1.790341, up=1.000000
ITER 5: row=2, varin=69, theta=0.570138, up=1.000000
ITER 6: row=1, varin=103, theta=9.224599, up=1.000000
ITER 7: row=1, varin=24, theta=1.445744, up=999999999999999983222784.000000
ITER 8: row=20, varin=38, theta=0.883685, up=999999999999999983222784.000000
ITER 9: row=38, varin=22, theta=0.994881, up=999999999999999983222784.000000
ITER 10: row=22, varin=20, theta=0.555332, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=11)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=46)
DEBUG SOLUTION: LP solution array indices: FST[47-86], not_covered[87-106]
DEBUG SOLUTION: lp->best_solution[0] = 28841892.412239
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 46 rows, 60 cols, 278 nonzeros, 10 slack, 36 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 10 slack rows
  % @PAP adding 5 rows, 17 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=37, varin=71, theta=1.000000, up=1.000000
ITER 2: row=41, varin=63, theta=1.601070, up=1.000000
ITER 3: row=41, varin=69, theta=0.773882, up=1.000000
ITER 4: row=29, varin=63, theta=1.000000, up=1.000000
ITER 5: row=41, varin=98, theta=1.308759, up=1.000000
ITER 6: row=41, varin=70, theta=0.253067, up=1.000000
ITER 7: row=31, varin=98, theta=0.500000, up=1.000000
ITER 8: row=17, varin=76, theta=5.120989, up=1.000000
ITER 9: row=17, varin=72, theta=0.941042, up=1.000000
ITER 10: row=1, varin=76, theta=1.867489, up=1.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=41)
DEBUG SOLUTION: LP solution array indices: FST[42-81], not_covered[82-101]
DEBUG SOLUTION: lp->best_solution[0] = 999999999999999983222784.000000
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 41 rows, 60 cols, 275 nonzeros, 4 slack, 37 tight.
  % Node 41 LP 1 Solution, length = 999999999999999983222784.000000, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.106903 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 1.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.893097 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 1.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.893097 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
DEBUG BB: compute_good_lower_bound returned status=1
DEBUG BB: Node 41 is INFEASIBLE
 %      41    18    infeasible               28236297.9477   x17 U    34     8
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde839c580
% @LO 0.04  28.23293721853624660412 99.9000000000
% @LN 0.04  28.23629794771950685117 99.9000000000
% Resuming node 39 at  28.23629794771950685117
DEBUG CONSTRNT: LP rows=41, pool->nlprows=41, pool->npend=0
DEBUG CONSTRNT: Checking 41 LP rows (pool tracks 41, total LP rows 41)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=40, expected 40
 % @PAP adding 43 rows, 173 nz to LP
DEBUG BB: Processing node 39, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 39 LP 2 Solution, length = 28236297.947720, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.333333 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.333333 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.333333 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 1.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.333333 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.333333 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.666667 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.666667 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.666667 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.666667 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.666667 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.666667 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.666667 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28236297.947720, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28236297.947720, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 39 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 39
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.333333
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.333333
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.333333
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=1.000000
DEBUG CAREFUL: Skipping var 13: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.333333
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.333333
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 17
DEBUG CAREFUL: New best var: 17
DEBUG CAREFUL: Testing fvar[1] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[2] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 3
DEBUG CAREFUL: New best var: 3
DEBUG CAREFUL: Testing fvar[3] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[4] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
  % Initial guess is x3, Z0 = 28236297.9477195        , Z1 = 28372708.8192992        

DEBUG EVAL: Testing var 17 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=22, varin=42, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=42, varin=39, theta=2.000000, up=999999999999999983222784.000000
ITER 3: row=36, varin=30, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=29, varin=36, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 17 = 1 gives z=28350211.097972
  % 	x17 = 1,	Z1 = 28350211.097972         
DEBUG EVAL: First branch cutoff check: z=28350211.097972, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 17 = 0
ITER 1: row=22, varin=67, theta=1.000000, up=1.000000
ITER 2: row=34, varin=55, theta=0.500000, up=1.000000
  % 	x17 = 0,	Z0 = 28299033.3673463        
DEBUG EVAL: Second branch cutoff check: z=28299033.367346, best_z=INF, threshold=INF
  %   New best:  x17, Z = 28299033.3673463        
DEBUG EVAL: Testing var 10 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=14, varin=42, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=42, varin=32, theta=0.666667, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 1 gives z=28308045.452670
  % 	x10 = 1,	Z1 = 28308045.4526699        
DEBUG EVAL: First branch cutoff check: z=28308045.452670, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 0
ITER 1: row=14, varin=67, theta=1.000000, up=1.000000
ITER 2: row=34, varin=17, theta=0.500000, up=999999999999999983222784.000000
  % 	x10 = 0,	Z0 = 28291459.0544158        
DEBUG EVAL: Second branch cutoff check: z=28291459.054416, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 3 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=9, varin=42, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=42, varin=22, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=37, varin=39, theta=2.000000, up=999999999999999983222784.000000
ITER 4: row=36, varin=30, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=29, varin=35, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 3 = 1 gives z=28372708.819299
  % 	x3 = 1,	Z1 = 28372708.8192992        
DEBUG EVAL: First branch cutoff check: z=28372708.819299, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 3 = 0
ITER 1: row=9, varin=67, theta=1.000000, up=1.000000
ITER 2: row=34, varin=55, theta=0.500000, up=1.000000
  % 	x3 = 0,	Z0 = 28299033.3673463        
DEBUG EVAL: Second branch cutoff check: z=28299033.367346, best_z=INF, threshold=INF
  %   New best:  x3, Z = 28299033.3673463        
DEBUG EVAL: Testing var 2 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=67, theta=1.000000, up=1.000000
ITER 2: row=34, varin=35, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 0 gives z=28277383.154652
  % 	x2 = 0,	Z0 = 28277383.1546521        
DEBUG EVAL: First branch cutoff check: z=28277383.154652, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 26 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=36, varin=42, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=42, varin=32, theta=0.666667, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 26 = 1 gives z=28308045.452670
  % 	x26 = 1,	Z1 = 28308045.4526699        
DEBUG EVAL: First branch cutoff check: z=28308045.452670, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 26 = 0
ITER 1: row=36, varin=67, theta=1.000000, up=1.000000
ITER 2: row=34, varin=39, theta=0.500000, up=999999999999999983222784.000000
  % 	x26 = 0,	Z0 = 28263418.1765768        
DEBUG EVAL: Second branch cutoff check: z=28263418.176577, best_z=INF, threshold=INF
  % Best branch is x3, Z0 = 28299033.3673463        , Z1 = 28372708.8192992        

DEBUG CAREFUL: Final result - returning best.var = 3
DEBUG BB: Branching variable chosen: j=3
 % @NC   43   39	x3 = 0	28299033.367346
 % @NC   44   39	x3 = 1	28372708.819299
 %      39    19 28236297.9477               28241678.3627   x18 D    17     5
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde83b6e50
% @LO 0.04  28.23629794771950685117 99.9000000000
% @LN 0.04  28.24167836273661080781 99.9000000000
% Resuming node 36 at  28.24167836273661080781
DEBUG CONSTRNT: LP rows=43, pool->nlprows=43, pool->npend=0
DEBUG CONSTRNT: Checking 43 LP rows (pool tracks 43, total LP rows 43)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 65
DEBUG CONSTRNT: Pool row 65 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 121
DEBUG CONSTRNT: Pool row 121 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=42, expected 42
 % @PAP adding 39 rows, 168 nz to LP
DEBUG BB: Processing node 36, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=20, varin=32, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=32, varin=37, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=39)
DEBUG SOLUTION: LP solution array indices: FST[40-79], not_covered[80-99]
DEBUG SOLUTION: lp->best_solution[0] = 28158806.247688
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 39 rows, 60 cols, 228 nonzeros, 3 slack, 36 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 40 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=40, varin=5, theta=2.107425, up=999999999999999983222784.000000
ITER 2: row=5, varin=35, theta=0.983264, up=999999999999999983222784.000000
ITER 3: row=35, varin=31, theta=0.709805, up=999999999999999983222784.000000
ITER 4: row=2, varin=34, theta=1.443366, up=999999999999999983222784.000000
ITER 5: row=37, varin=64, theta=0.422906, up=1.000000
ITER 6: row=20, varin=33, theta=0.868317, up=999999999999999983222784.000000
ITER 7: row=32, varin=21, theta=0.710575, up=999999999999999983222784.000000
ITER 8: row=36, varin=20, theta=1.360393, up=999999999999999983222784.000000
ITER 9: row=12, varin=70, theta=0.607633, up=1.000000
ITER 10: row=39, varin=94, theta=1.098117, up=1.000000
LP PHASE: Switching to primal (iter=13)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=40)
DEBUG SOLUTION: LP solution array indices: FST[41-80], not_covered[81-100]
DEBUG SOLUTION: lp->best_solution[0] = 28498886.165167
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 40 rows, 60 cols, 268 nonzeros, 2 slack, 38 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 7 rows, 29 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=43, varin=37, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=38, varin=22, theta=1.063271, up=999999999999999983222784.000000
ITER 3: row=45, varin=67, theta=2.040606, up=1.000000
ITER 4: row=45, varin=75, theta=1.708134, up=1.000000
ITER 5: row=45, varin=73, theta=0.640465, up=1.000000
ITER 6: row=30, varin=67, theta=1.000000, up=1.000000
ITER 7: row=45, varin=74, theta=1.145431, up=1.000000
ITER 8: row=45, varin=76, theta=0.549777, up=1.000000
ITER 9: row=40, varin=52, theta=1.479825, up=1.000000
ITER 10: row=40, varin=60, theta=0.516545, up=1.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 999999999999999983222784.000000
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 45 rows, 60 cols, 293 nonzeros, 6 slack, 39 tight.
  % Node 36 LP 1 Solution, length = 999999999999999983222784.000000, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 1.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 1.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.299911 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.700089 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
DEBUG BB: compute_good_lower_bound returned status=1
DEBUG BB: Node 36 is INFEASIBLE
 %      36    18    infeasible               28245184.5071   x17 U    31     7
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde83b5ba0
% @LO 0.04  28.24167836273661080781 99.9000000000
% @LN 0.04  28.24518450707174110903 99.9000000000
% Resuming node 42 at  28.24518450707174110903
DEBUG CONSTRNT: LP rows=45, pool->nlprows=45, pool->npend=0
DEBUG CONSTRNT: Checking 45 LP rows (pool tracks 45, total LP rows 45)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=44, expected 44
 % @PAP adding 44 rows, 176 nz to LP
DEBUG BB: Processing node 42, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=25, varin=26, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=40, varin=101, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28245184.507072
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 44 rows, 60 cols, 236 nonzeros, 0 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 3 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=45, varin=5, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=6, varin=75, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 28260405.313583
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 45 rows, 60 cols, 239 nonzeros, 0 slack, 45 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 42 LP 1 Solution, length = 28260405.313583, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.500000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.500000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.500000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.500000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.500000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.500000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.500000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.500000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.500000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 0.500000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28260405.313583, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 42 at  28.26040531358339791268
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde8386600
% @LO 0.04  28.24518450707174110903 99.9000000000
% @LN 0.04  28.24621906673902316243 99.9000000000
% Resuming node 38 at  28.24621906673902316243
DEBUG CONSTRNT: LP rows=45, pool->nlprows=45, pool->npend=0
DEBUG CONSTRNT: Checking 45 LP rows (pool tracks 45, total LP rows 45)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 142
DEBUG CONSTRNT: Pool row 142 has lprow=44, expected 44
 % @PAP adding 47 rows, 202 nz to LP
DEBUG BB: Processing node 38, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=30, varin=12, theta=1.047619, up=999999999999999983222784.000000
ITER 2: row=1, varin=34, theta=0.588235, up=999999999999999983222784.000000
ITER 3: row=34, varin=46, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=44, varin=11, theta=30.000000, up=999999999999999983222784.000000
ITER 5: row=5, varin=8, theta=1.800000, up=999999999999999983222784.000000
ITER 6: row=12, varin=18, theta=1.800000, up=999999999999999983222784.000000
ITER 7: row=13, varin=17, theta=4.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=7)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 28246219.066739
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 0.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 47 rows, 60 cols, 262 nonzeros, 14 slack, 33 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 9 rows, 50 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=54, varin=42, theta=0.153846, up=999999999999999983222784.000000
ITER 2: row=48, varin=40, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=37, varin=101, theta=0.153846, up=1.000000
ITER 4: row=50, varin=41, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=11, varin=58, theta=1.615385, up=1.000000
ITER 6: row=11, varin=114, theta=0.051282, up=1.000000
ITER 7: row=55, varin=43, theta=1.000000, up=999999999999999983222784.000000
ITER 8: row=52, varin=54, theta=11.000000, up=999999999999999983222784.000000
ITER 9: row=46, varin=33, theta=1.000000, up=999999999999999983222784.000000
ITER 10: row=51, varin=66, theta=0.066667, up=1.000000
LP PHASE: Switching to primal (iter=10)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=56)
DEBUG SOLUTION: LP solution array indices: FST[57-96], not_covered[97-116]
DEBUG SOLUTION: lp->best_solution[0] = 28296870.846813
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 56 rows, 60 cols, 312 nonzeros, 10 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 10 slack rows
  % @PAP adding 3 rows, 11 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=47, varin=44, theta=4.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 28301836.714676
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 49 rows, 60 cols, 276 nonzeros, 2 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % Node 38 LP 1 Solution, length = 28301836.714676, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.666667 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.333333 (FST 9)
  % DEBUG LP_VARS: x[10] = 1.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.500000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.500000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.333333 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.500000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.500000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.333333 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.333333 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.500000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=28301836.714676, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 38 at  28.30183671467629125118
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde8397010
% @LO 0.04  28.24621906673902316243 99.9000000000
% @LN 0.04  28.24968573452535380852 99.9000000000
% Resuming node 27 at  28.24968573452535380852
DEBUG CONSTRNT: LP rows=47, pool->nlprows=47, pool->npend=0
DEBUG CONSTRNT: Checking 47 LP rows (pool tracks 47, total LP rows 47)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=46, expected 46
 % @PAP adding 48 rows, 226 nz to LP
DEBUG BB: Processing node 27, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 27 LP 2 Solution, length = 28249685.734525, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.542876 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.271438 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.500000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.500000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 1.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.457124 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.500000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.500000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.457124 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.457124 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.500000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=28249685.734525, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28249685.734525, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 27 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 27
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.542876
DEBUG CAREFUL: Adding var 7 to fractional list (xi=0.542876)
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.271438
DEBUG CAREFUL: Adding var 9 to fractional list (xi=0.271438)
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.500000
DEBUG CAREFUL: Adding var 14 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.500000
DEBUG CAREFUL: Adding var 15 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=1.000000
DEBUG CAREFUL: Skipping var 20: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 4 fractional variables

  %  Carefully choosing branching variable, nfrac = 4
DEBUG CAREFUL: Testing fvar[0] = var 14
DEBUG CAREFUL: Calling compare_branch_vars for var 14
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 14
DEBUG CAREFUL: New best var: 14
DEBUG CAREFUL: Testing fvar[1] = var 15
DEBUG CAREFUL: Calling compare_branch_vars for var 15
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 15
DEBUG CAREFUL: Testing fvar[2] = var 9
DEBUG CAREFUL: Calling compare_branch_vars for var 9
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 9
DEBUG CAREFUL: New best var: 9
DEBUG CAREFUL: Testing fvar[3] = var 7
DEBUG CAREFUL: Calling compare_branch_vars for var 7
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 7
  % Initial guess is x9, Z0 = 28249685.7345254        , Z1 = 28278312.0089414        

DEBUG EVAL: Testing var 14 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=27, varin=47, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 14 = 0 gives z=28256232.784452
  % 	x14 = 0,	Z0 = 28256232.7844521        
DEBUG EVAL: First branch cutoff check: z=28256232.784452, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 14 = 1
ITER 1: row=27, varin=43, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=48, varin=40, theta=1.000000, up=999999999999999983222784.000000
  % 	x14 = 1,	Z1 = 28306121.4452404        
DEBUG EVAL: Second branch cutoff check: z=28306121.445240, best_z=INF, threshold=INF
  %   New best:  x14, Z = 28256232.7844521        
DEBUG EVAL: Testing var 15 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=39, varin=57, theta=1.000000, up=1.000000
ITER 2: row=42, varin=43, theta=0.253276, up=999999999999999983222784.000000
ITER 3: row=48, varin=40, theta=0.132225, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 15 = 0 gives z=28264605.384342
  % 	x15 = 0,	Z0 = 28264605.3843423        
DEBUG EVAL: First branch cutoff check: z=28264605.384342, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 15 = 1
ITER 1: row=39, varin=47, theta=1.000000, up=999999999999999983222784.000000
  % 	x15 = 1,	Z1 = 28256232.7844521        
DEBUG EVAL: Second branch cutoff check: z=28256232.784452, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 9 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=42, varin=47, theta=2.211873, up=999999999999999983222784.000000
ITER 2: row=27, varin=41, theta=1.269838, up=999999999999999983222784.000000
ITER 3: row=41, varin=40, theta=0.269838, up=999999999999999983222784.000000
ITER 4: row=46, varin=46, theta=0.269838, up=999999999999999983222784.000000
ITER 5: row=1, varin=30, theta=0.350262, up=999999999999999983222784.000000
ITER 6: row=30, varin=27, theta=0.367589, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 9 = 1 gives z=28330795.778978
  % 	x9 = 1,	Z1 = 28330795.7789778        
DEBUG EVAL: First branch cutoff check: z=28330795.778978, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 9 = 0
ITER 1: row=42, varin=66, theta=0.197915, up=1.000000
ITER 2: row=33, varin=57, theta=0.757350, up=1.000000
  % 	x9 = 0,	Z0 = 28256194.2010733        
DEBUG EVAL: Second branch cutoff check: z=28256194.201073, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 7 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=57, theta=1.614196, up=1.000000
ITER 2: row=1, varin=61, theta=0.295227, up=1.000000
ITER 3: row=42, varin=30, theta=0.426701, up=999999999999999983222784.000000
ITER 4: row=28, varin=27, theta=0.419254, up=999999999999999983222784.000000
ITER 5: row=27, varin=57, theta=0.408054, up=1.000000
DEBUG EVAL: Branch var 7 = 1 gives z=28331494.075493
  % 	x7 = 1,	Z1 = 28331494.0754934        
DEBUG EVAL: First branch cutoff check: z=28331494.075493, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 7 = 0
ITER 1: row=1, varin=47, theta=1.590956, up=999999999999999983222784.000000
ITER 2: row=27, varin=45, theta=158589.000000, up=999999999999999983222784.000000
  % 	x7 = 0,	Z0 = 28264912.0473018        
DEBUG EVAL: Second branch cutoff check: z=28264912.047302, best_z=INF, threshold=INF
  %   New best:  x7, Z = 28264912.0473018        
  % Best branch is x7, Z0 = 28264912.0473018        , Z1 = 28331494.0754934        

DEBUG CAREFUL: Final result - returning best.var = 7
DEBUG BB: Branching variable chosen: j=7
 % @NC   45   27	x7 = 0	28264912.047302
 % @NC   46   27	x7 = 1	28331494.075493
 %      27    19 28249685.7345               28250002.7050   x16 D    13     5
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde8395b40
% @LO 0.04  28.24968573452535380852 99.9000000000
% @LN 0.04  28.25000270504013499817 99.9000000000
% Resuming node 30 at  28.25000270504013499817
DEBUG CONSTRNT: LP rows=48, pool->nlprows=48, pool->npend=0
DEBUG CONSTRNT: Checking 48 LP rows (pool tracks 48, total LP rows 48)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 141
DEBUG CONSTRNT: Pool row 141 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 145
DEBUG CONSTRNT: Pool row 145 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 159
DEBUG CONSTRNT: Pool row 159 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=47, expected 47
 % @PAP adding 41 rows, 170 nz to LP
DEBUG BB: Processing node 30, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=12, varin=41, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=41, varin=25, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=36, varin=38, theta=2.000000, up=999999999999999983222784.000000
ITER 4: row=35, varin=33, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=41)
DEBUG SOLUTION: LP solution array indices: FST[42-81], not_covered[82-101]
DEBUG SOLUTION: lp->best_solution[0] = 28250002.705040
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 41 rows, 60 cols, 230 nonzeros, 4 slack, 37 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 54 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=45, varin=5, theta=2.223168, up=999999999999999983222784.000000
ITER 2: row=5, varin=31, theta=2.665478, up=999999999999999983222784.000000
ITER 3: row=2, varin=22, theta=1.173025, up=999999999999999983222784.000000
ITER 4: row=42, varin=26, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=37, varin=27, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=1, varin=72, theta=1.000000, up=1.000000
ITER 7: row=38, varin=46, theta=1.000000, up=1.000000
ITER 8: row=5, varin=69, theta=1.000000, up=1.000000
ITER 9: row=32, varin=80, theta=1.000000, up=1.000000
ITER 10: row=2, varin=82, theta=0.920951, up=1.000000
LP PHASE: Switching to primal (iter=12)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 28581658.289127
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 45 rows, 60 cols, 284 nonzeros, 4 slack, 41 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % Node 30 LP 1 Solution, length = 28581658.289127, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 1.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.500000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.500000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.500000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.500000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 3 fractional variables
DEBUG CG: LP optimal, z=28581658.289127, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 30 at  28.58165828912695616282
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde8398c10
% @LO 0.04  28.25000270504013499817 99.9000000000
% @LN 0.04  28.25114612554849458093 99.9000000000
% Resuming node 33 at  28.25114612554849458093
DEBUG CONSTRNT: LP rows=41, pool->nlprows=41, pool->npend=0
DEBUG CONSTRNT: Checking 41 LP rows (pool tracks 41, total LP rows 41)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=40, expected 40
 % @PAP adding 46 rows, 179 nz to LP
DEBUG BB: Processing node 33, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 33 LP 2 Solution, length = 28251146.125548, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.200000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.200000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.200000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.200000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.200000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.200000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.800000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.800000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.800000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.800000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.800000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.800000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.800000 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28251146.125548, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28251146.125548, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 33 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 33
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.200000
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.200000)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.200000
DEBUG CAREFUL: Adding var 4 to fractional list (xi=0.200000)
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.200000
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.200000)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.200000
DEBUG CAREFUL: Adding var 11 to fractional list (xi=0.200000)
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.200000
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.200000)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.200000
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.200000)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 6 fractional variables

  %  Carefully choosing branching variable, nfrac = 6
DEBUG CAREFUL: Testing fvar[0] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 17
DEBUG CAREFUL: New best var: 17
DEBUG CAREFUL: Testing fvar[1] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[2] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[3] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
DEBUG CAREFUL: Testing fvar[4] = var 4
DEBUG CAREFUL: Calling compare_branch_vars for var 4
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 4
DEBUG CAREFUL: New best var: 4
DEBUG CAREFUL: Testing fvar[5] = var 11
DEBUG CAREFUL: Calling compare_branch_vars for var 11
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 11
  % Initial guess is x4, Z0 = 28251146.1255485        , Z1 = 28445872.1377927        

DEBUG EVAL: Testing var 17 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=23, varin=24, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=42, varin=103, theta=1.000000, up=1.000000
ITER 3: row=39, varin=76, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 17 = 0 gives z=28334177.663211
  % 	x17 = 0,	Z0 = 28334177.6632109        
DEBUG EVAL: First branch cutoff check: z=28334177.663211, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 17 = 1
ITER 1: row=23, varin=44, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=12, varin=41, theta=1.000000, up=999999999999999983222784.000000
  % 	x17 = 1,	Z1 = 28291488.7616521        
DEBUG EVAL: Second branch cutoff check: z=28291488.761652, best_z=INF, threshold=INF
  %   New best:  x17, Z = 28291488.7616521        
DEBUG EVAL: Testing var 10 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=20, varin=22, theta=0.250000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 0 gives z=28298477.366140
  % 	x10 = 0,	Z0 = 28298477.3661397        
DEBUG EVAL: First branch cutoff check: z=28298477.366140, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 1
ITER 1: row=20, varin=44, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=12, varin=41, theta=1.000000, up=999999999999999983222784.000000
  % 	x10 = 1,	Z1 = 28291488.7616521        
DEBUG EVAL: Second branch cutoff check: z=28291488.761652, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 2 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=31, theta=0.250000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 0 gives z=28291439.416258
  % 	x2 = 0,	Z0 = 28291439.4162578        
DEBUG EVAL: First branch cutoff check: z=28291439.416258, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 26 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=33, varin=33, theta=0.250000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 26 = 0 gives z=28284456.927220
  % 	x26 = 0,	Z0 = 28284456.9272202        
DEBUG EVAL: First branch cutoff check: z=28284456.927220, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 4 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=12, varin=41, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=41, varin=38, theta=2.000000, up=999999999999999983222784.000000
ITER 3: row=38, varin=36, theta=2.000000, up=999999999999999983222784.000000
ITER 4: row=36, varin=30, theta=2.000000, up=999999999999999983222784.000000
ITER 5: row=30, varin=23, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=45, varin=33, theta=2.000000, up=999999999999999983222784.000000
ITER 7: row=33, varin=31, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 4 = 1 gives z=28578097.153764
  % 	x4 = 1,	Z1 = 28578097.1537636        
DEBUG EVAL: First branch cutoff check: z=28578097.153764, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 4 = 0
ITER 1: row=12, varin=44, theta=0.333333, up=999999999999999983222784.000000
  % 	x4 = 0,	Z0 = 28253748.784686         
DEBUG EVAL: Second branch cutoff check: z=28253748.784686, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 11 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=41, varin=44, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=12, varin=38, theta=2.000000, up=999999999999999983222784.000000
ITER 3: row=38, varin=36, theta=2.000000, up=999999999999999983222784.000000
ITER 4: row=36, varin=30, theta=2.000000, up=999999999999999983222784.000000
ITER 5: row=30, varin=24, theta=2.000000, up=999999999999999983222784.000000
ITER 6: row=42, varin=33, theta=2.000000, up=999999999999999983222784.000000
ITER 7: row=33, varin=31, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 11 = 1 gives z=28553370.472485
  % 	x11 = 1,	Z1 = 28553370.4724853        
DEBUG EVAL: First branch cutoff check: z=28553370.472485, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 11 = 0
ITER 1: row=41, varin=41, theta=0.333333, up=999999999999999983222784.000000
  % 	x11 = 0,	Z0 = 28261991.0117788        
DEBUG EVAL: Second branch cutoff check: z=28261991.011779, best_z=INF, threshold=INF
  % Best branch is x17, Z0 = 28334177.6632109        , Z1 = 28291488.7616521        

DEBUG CAREFUL: Final result - returning best.var = 17
DEBUG BB: Branching variable chosen: j=17
 % @NC   47   33	x17 = 1	28291488.761652
 % @NC   48   33	x17 = 0	28334177.663211
 %      33    20 28251146.1255               28254360.2975    x7 D    29     7
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde8397490
% @LO 0.04  28.25114612554849458093 99.9000000000
% @LN 0.04  28.25436029751072197769 99.9000000000
% Resuming node 35 at  28.25436029751072197769
DEBUG CONSTRNT: LP rows=46, pool->nlprows=46, pool->npend=0
DEBUG CONSTRNT: Checking 46 LP rows (pool tracks 46, total LP rows 46)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 85
DEBUG CONSTRNT: Pool row 85 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=45, expected 45
 % @PAP adding 48 rows, 206 nz to LP
DEBUG BB: Processing node 35, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 35 LP 2 Solution, length = 28254360.297511, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.250000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.250000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 1.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.500000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.500000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.250000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.250000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.750000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.750000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.750000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.750000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.500000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.500000 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28254360.297511, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28254360.297511, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 35 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 35
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.250000
DEBUG CAREFUL: Adding var 0 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.250000
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=1.000000
DEBUG CAREFUL: Skipping var 9: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.500000
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.500000
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.250000
DEBUG CAREFUL: Adding var 29 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.250000
DEBUG CAREFUL: Adding var 33 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 6 fractional variables

  %  Carefully choosing branching variable, nfrac = 6
DEBUG CAREFUL: Testing fvar[0] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 10
DEBUG CAREFUL: New best var: 10
DEBUG CAREFUL: Testing fvar[1] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
DEBUG CAREFUL: Testing fvar[2] = var 0
DEBUG CAREFUL: Calling compare_branch_vars for var 0
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 0
DEBUG CAREFUL: Testing fvar[3] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 1
DEBUG CAREFUL: Testing fvar[4] = var 33
DEBUG CAREFUL: Calling compare_branch_vars for var 33
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 33
DEBUG CAREFUL: New best var: 33
DEBUG CAREFUL: Testing fvar[5] = var 29
DEBUG CAREFUL: Calling compare_branch_vars for var 29
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 29
  % Initial guess is x33, Z0 = 28254360.2975107        , Z1 = 28358597.1348963        

DEBUG EVAL: Testing var 10 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=11, varin=31, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 0 gives z=28415878.932699
  % 	x10 = 0,	Z0 = 28415878.9326987        
DEBUG EVAL: First branch cutoff check: z=28415878.932699, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 1
ITER 1: row=11, varin=34, theta=1.000000, up=999999999999999983222784.000000
  % 	x10 = 1,	Z1 = 28359797.1770206        
DEBUG EVAL: Second branch cutoff check: z=28359797.177021, best_z=INF, threshold=INF
  %   New best:  x10, Z = 28359797.1770206        
DEBUG EVAL: Testing var 26 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=29, varin=34, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 26 = 0 gives z=28359797.177021
  % 	x26 = 0,	Z0 = 28359797.1770206        
DEBUG EVAL: First branch cutoff check: z=28359797.177021, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 26 = 1
ITER 1: row=29, varin=18, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=36, varin=20, theta=1.000000, up=999999999999999983222784.000000
  % 	x26 = 1,	Z1 = 29010240.4736037        
DEBUG EVAL: Second branch cutoff check: z=29010240.473604, best_z=INF, threshold=INF
  %   New best:  x26, Z = 28359797.1770206        
DEBUG EVAL: Testing var 0 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=76, theta=0.500000, up=1.000000
DEBUG EVAL: Branch var 0 = 0 gives z=28285398.331775
  % 	x0 = 0,	Z0 = 28285398.3317746        
DEBUG EVAL: First branch cutoff check: z=28285398.331775, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 1 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=2, varin=4, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=5, varin=76, theta=0.500000, up=1.000000
DEBUG EVAL: Branch var 1 = 0 gives z=28285398.331775
  % 	x1 = 0,	Z0 = 28285398.3317746        
DEBUG EVAL: First branch cutoff check: z=28285398.331775, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 33 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=43, varin=62, theta=0.900000, up=1.000000
ITER 2: row=19, varin=43, theta=1.500000, up=999999999999999983222784.000000
ITER 3: row=31, varin=46, theta=0.375000, up=999999999999999983222784.000000
ITER 4: row=18, varin=40, theta=0.250000, up=999999999999999983222784.000000
ITER 5: row=40, varin=38, theta=0.250000, up=999999999999999983222784.000000
ITER 6: row=38, varin=32, theta=0.500000, up=999999999999999983222784.000000
ITER 7: row=32, varin=34, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 33 = 1 gives z=28410477.947369
  % 	x33 = 1,	Z1 = 28410477.9473694        
DEBUG EVAL: First branch cutoff check: z=28410477.947369, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 33 = 0
ITER 1: row=43, varin=47, theta=0.500000, up=999999999999999983222784.000000
  % 	x33 = 0,	Z0 = 28254960.3185729        
DEBUG EVAL: Second branch cutoff check: z=28254960.318573, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 29 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=31, varin=47, theta=1.500000, up=999999999999999983222784.000000
ITER 2: row=43, varin=62, theta=0.300000, up=1.000000
ITER 3: row=19, varin=46, theta=0.375000, up=999999999999999983222784.000000
ITER 4: row=18, varin=40, theta=0.250000, up=999999999999999983222784.000000
ITER 5: row=40, varin=38, theta=0.250000, up=999999999999999983222784.000000
ITER 6: row=38, varin=32, theta=0.500000, up=999999999999999983222784.000000
ITER 7: row=32, varin=34, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 29 = 1 gives z=28360997.219145
  % 	x29 = 1,	Z1 = 28360997.219145         
DEBUG EVAL: First branch cutoff check: z=28360997.219145, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 29 = 0
ITER 1: row=31, varin=43, theta=0.500000, up=999999999999999983222784.000000
  % 	x29 = 0,	Z0 = 28279700.6826851        
DEBUG EVAL: Second branch cutoff check: z=28279700.682685, best_z=INF, threshold=INF
  % Best branch is x26, Z0 = 28359797.1770206        , Z1 = 29010240.4736037        

DEBUG CAREFUL: Final result - returning best.var = 26
DEBUG BB: Branching variable chosen: j=26
 % @NC   49   35	x26 = 0	28359797.177021
 % @NC   50   35	x26 = 1	29010240.473604
 %      35    21 28254360.2975               28257487.0839   x17 D    31     7
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde83ad260
% @LO 0.04  28.25436029751072197769 99.9000000000
% @LN 0.04  28.25748708394939257005 99.9000000000
% Resuming node 20 at  28.25748708394939257005
DEBUG CONSTRNT: LP rows=48, pool->nlprows=48, pool->npend=0
DEBUG CONSTRNT: Checking 48 LP rows (pool tracks 48, total LP rows 48)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 158
DEBUG CONSTRNT: Pool row 158 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=47, expected 47
 % @PAP adding 44 rows, 174 nz to LP
DEBUG BB: Processing node 20, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=31, varin=42, theta=5.000000, up=999999999999999983222784.000000
ITER 2: row=39, varin=39, theta=2.000000, up=999999999999999983222784.000000
ITER 3: row=12, varin=35, theta=2.000000, up=999999999999999983222784.000000
ITER 4: row=1, varin=33, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=2, varin=26, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=32, varin=3, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=33, varin=28, theta=0.500000, up=999999999999999983222784.000000
ITER 8: row=28, varin=36, theta=1.000000, up=999999999999999983222784.000000
ITER 9: row=20, varin=27, theta=0.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=9)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28240507.899494
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 44 rows, 60 cols, 234 nonzeros, 10 slack, 34 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 5 rows, 59 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=49, varin=5, theta=3.068378, up=999999999999999983222784.000000
ITER 2: row=5, varin=60, theta=1.115121, up=1.000000
ITER 3: row=5, varin=62, theta=0.149382, up=1.000000
ITER 4: row=36, varin=60, theta=1.000000, up=1.000000
ITER 5: row=28, varin=74, theta=3.060413, up=1.000000
ITER 6: row=28, varin=22, theta=1.089979, up=999999999999999983222784.000000
ITER 7: row=3, varin=74, theta=1.000000, up=1.000000
ITER 8: row=47, varin=23, theta=1.000000, up=999999999999999983222784.000000
ITER 9: row=38, varin=24, theta=1.000000, up=999999999999999983222784.000000
ITER 10: row=45, varin=52, theta=2.000000, up=1.000000
LP PHASE: Switching to primal (iter=21)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 28754587.351357
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 49 rows, 60 cols, 293 nonzeros, 9 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 9 slack rows
  % @PAP adding 6 rows, 24 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=41, varin=69, theta=0.441289, up=1.000000
ITER 2: row=45, varin=83, theta=0.496265, up=1.000000
ITER 3: row=46, varin=54, theta=0.054958, up=1.000000
ITER 4: row=19, varin=21, theta=0.060940, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=46)
DEBUG SOLUTION: LP solution array indices: FST[47-86], not_covered[87-106]
DEBUG SOLUTION: lp->best_solution[0] = 28838155.276952
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 46 rows, 60 cols, 289 nonzeros, 1 slack, 45 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 5 rows, 19 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=48, varin=107, theta=0.818651, up=1.000000
ITER 2: row=47, varin=72, theta=0.738634, up=1.000000
ITER 3: row=24, varin=78, theta=0.832973, up=1.000000
ITER 4: row=28, varin=93, theta=0.049835, up=1.000000
ITER 5: row=50, varin=74, theta=0.446203, up=1.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28860153.940636
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 50 rows, 60 cols, 306 nonzeros, 2 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 4 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=52, varin=48, theta=0.956693, up=999999999999999983222784.000000
ITER 2: row=49, varin=81, theta=0.741902, up=1.000000
ITER 3: row=17, varin=83, theta=1.063942, up=1.000000
ITER 4: row=17, varin=55, theta=0.063132, up=1.000000
ITER 5: row=40, varin=83, theta=1.000000, up=1.000000
ITER 6: row=52, varin=85, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 29034659.453687
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 52 rows, 60 cols, 310 nonzeros, 1 slack, 51 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 3 rows, 9 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=52, varin=6, theta=0.250000, up=999999999999999983222784.000000
ITER 2: row=53, varin=55, theta=0.250000, up=1.000000
ITER 3: row=2, varin=44, theta=1.700000, up=999999999999999983222784.000000
ITER 4: row=49, varin=59, theta=0.500000, up=1.000000
ITER 5: row=34, varin=88, theta=1.000000, up=1.000000
ITER 6: row=39, varin=86, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=54)
DEBUG SOLUTION: LP solution array indices: FST[55-94], not_covered[95-114]
DEBUG SOLUTION: lp->best_solution[0] = 29128073.493192
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 54 rows, 60 cols, 317 nonzeros, 1 slack, 53 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=54, varin=52, theta=0.170494, up=999999999999999983222784.000000
ITER 2: row=5, varin=7, theta=0.146005, up=999999999999999983222784.000000
ITER 3: row=40, varin=43, theta=0.714605, up=999999999999999983222784.000000
ITER 4: row=50, varin=79, theta=0.055555, up=1.000000
ITER 5: row=54, varin=85, theta=0.061090, up=1.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=54)
DEBUG SOLUTION: LP solution array indices: FST[55-94], not_covered[95-114]
DEBUG SOLUTION: lp->best_solution[0] = 29176199.398746
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 54 rows, 60 cols, 317 nonzeros, 2 slack, 52 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=53, varin=48, theta=0.073540, up=999999999999999983222784.000000
ITER 2: row=46, varin=4, theta=0.040313, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=53)
DEBUG SOLUTION: LP solution array indices: FST[54-93], not_covered[94-113]
DEBUG SOLUTION: lp->best_solution[0] = 29190913.822061
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.959687
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.959687
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 53 rows, 60 cols, 304 nonzeros, 3 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 5 rows, 12 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=53, varin=72, theta=0.089124, up=1.000000
ITER 2: row=14, varin=36, theta=0.069963, up=999999999999999983222784.000000
ITER 3: row=51, varin=48, theta=0.128599, up=999999999999999983222784.000000
ITER 4: row=5, varin=32, theta=0.375683, up=999999999999999983222784.000000
ITER 5: row=28, varin=17, theta=0.137142, up=999999999999999983222784.000000
ITER 6: row=17, varin=94, theta=8.857868, up=1.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=55)
DEBUG SOLUTION: LP solution array indices: FST[56-95], not_covered[96-115]
DEBUG SOLUTION: lp->best_solution[0] = 999999999999999983222784.000000
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.959687
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.959687
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 55 rows, 60 cols, 310 nonzeros, 2 slack, 53 tight.
  % Node 20 LP 1 Solution, length = 999999999999999983222784.000000, 0.01 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.075278 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.115590 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.500000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 1.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.075278 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.500000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.115590 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.155903 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.500000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.115590 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.115590 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.924722 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.884410 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.884410 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.884410 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.500000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 0.962361 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
DEBUG BB: compute_good_lower_bound returned status=1
DEBUG BB: Node 20 is INFEASIBLE
 %      20    20    infeasible               28260405.3136   x18 U    11     5
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde83b5ba0
% @LO 0.05  28.25748708394939257005 99.9000000000
% @LN 0.05  28.26040531358339791268 99.9000000000
% Resuming node 42 at  28.26040531358339791268
DEBUG CONSTRNT: LP rows=55, pool->nlprows=55, pool->npend=0
DEBUG CONSTRNT: Checking 55 LP rows (pool tracks 55, total LP rows 55)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 145
DEBUG CONSTRNT: Pool row 145 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 159
DEBUG CONSTRNT: Pool row 159 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 133
DEBUG CONSTRNT: Pool row 133 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 134
DEBUG CONSTRNT: Pool row 134 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=54, expected 54
 % @PAP adding 45 rows, 179 nz to LP
DEBUG BB: Processing node 42, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 42 LP 2 Solution, length = 28260405.313583, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.500000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.500000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.500000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.500000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.500000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.500000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.500000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.500000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.500000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 0.500000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28260405.313583, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28260405.313583, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 42 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 42
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.500000
DEBUG CAREFUL: Adding var 0 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.500000
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=1.000000
DEBUG CAREFUL: Skipping var 7: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.500000
DEBUG CAREFUL: Adding var 23 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.500000
DEBUG CAREFUL: Adding var 24 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.500000
DEBUG CAREFUL: Adding var 29 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 29
DEBUG CAREFUL: Calling compare_branch_vars for var 29
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 29
DEBUG CAREFUL: New best var: 29
DEBUG CAREFUL: Testing fvar[1] = var 23
DEBUG CAREFUL: Calling compare_branch_vars for var 23
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 23
DEBUG CAREFUL: Testing fvar[2] = var 0
DEBUG CAREFUL: Calling compare_branch_vars for var 0
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 0
DEBUG CAREFUL: Testing fvar[3] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 1
DEBUG CAREFUL: Testing fvar[4] = var 24
DEBUG CAREFUL: Calling compare_branch_vars for var 24
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 24
  % Initial guess is x29, Z0 = 28260405.3135834        , Z1 = 28292371.2633835        

DEBUG EVAL: Testing var 29 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=6, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=5, varin=45, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 29 = 1 gives z=28275626.120095
  % 	x29 = 1,	Z1 = 28292371.2633835        
DEBUG EVAL: First branch cutoff check: z=28292371.263383, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 29 = 0
ITER 1: row=1, varin=79, theta=0.500000, up=1.000000
  % 	x29 = 0,	Z0 = 28285145.6776956        
DEBUG EVAL: Second branch cutoff check: z=28285145.677696, best_z=INF, threshold=INF
  %   New best:  x29, Z = 28285145.6776956        
DEBUG EVAL: Testing var 23 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=32, varin=6, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=5, varin=45, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 23 = 0 gives z=28275626.120095
  % 	x23 = 0,	Z0 = 28275626.120095         
DEBUG EVAL: First branch cutoff check: z=28275626.120095, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 0 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=6, varin=6, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=5, varin=45, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 0 = 0 gives z=28275626.120095
  % 	x0 = 0,	Z0 = 28275626.120095         
DEBUG EVAL: First branch cutoff check: z=28275626.120095, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 1 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=7, varin=45, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 1 = 0 gives z=28275626.120095
  % 	x1 = 0,	Z0 = 28275626.120095         
DEBUG EVAL: First branch cutoff check: z=28275626.120095, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 24 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=3, varin=6, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=5, varin=45, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 24 = 0 gives z=28275626.120095
  % 	x24 = 0,	Z0 = 28275626.120095         
DEBUG EVAL: First branch cutoff check: z=28275626.120095, best_z=INF, threshold=INF
  % Best branch is x29, Z0 = 28285145.6776956        , Z1 = 28292371.2633835        

DEBUG CAREFUL: Final result - returning best.var = 29
DEBUG BB: Branching variable chosen: j=29
 % @NC   51   42	x29 = 0	28285145.677696
 % @NC   52   42	x29 = 1	28292371.263383
 %      42    21 28260405.3136               28264912.0473   x17 D    34     8
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde83b6e50
% @LO 0.05  28.26040531358339791268 99.9000000000
% @LN 0.05  28.26491204730176320936 99.9000000000
% Resuming node 45 at  28.26491204730176320936
DEBUG CONSTRNT: LP rows=45, pool->nlprows=45, pool->npend=0
DEBUG CONSTRNT: Checking 45 LP rows (pool tracks 45, total LP rows 45)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 142
DEBUG CONSTRNT: Pool row 142 has lprow=44, expected 44
 % @PAP adding 48 rows, 226 nz to LP
DEBUG BB: Processing node 45, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=47, theta=1.590956, up=999999999999999983222784.000000
ITER 2: row=27, varin=45, theta=158589.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 28264912.047302
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 48 rows, 60 cols, 286 nonzeros, 3 slack, 45 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 5 rows, 29 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=51, varin=44, theta=0.120000, up=999999999999999983222784.000000
ITER 2: row=50, varin=51, theta=11.000000, up=999999999999999983222784.000000
ITER 3: row=45, varin=68, theta=0.160995, up=1.000000
ITER 4: row=52, varin=45, theta=419065.666667, up=999999999999999983222784.000000
ITER 5: row=47, varin=62, theta=0.333333, up=1.000000
ITER 6: row=53, varin=46, theta=0.043478, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=53)
DEBUG SOLUTION: LP solution array indices: FST[54-93], not_covered[94-113]
DEBUG SOLUTION: lp->best_solution[0] = 28285446.178582
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 53 rows, 60 cols, 315 nonzeros, 5 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=49, varin=48, theta=1.200000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 28286514.480745
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 49 rows, 60 cols, 257 nonzeros, 1 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 45 LP 1 Solution, length = 28286514.480745, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.200000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.200000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.400000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.400000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 1.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.600000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.600000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.600000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.800000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.600000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.600000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=28286514.480745, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 45 at  28.28651448074497665175
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde83ad260
% @LO 0.05  28.26491204730176320936 99.9000000000
% @LN 0.05  28.28514567769556364851 99.9000000000
% Resuming node 51 at  28.28514567769556364851
DEBUG CONSTRNT: LP rows=48, pool->nlprows=48, pool->npend=0
DEBUG CONSTRNT: Checking 48 LP rows (pool tracks 48, total LP rows 48)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 141
DEBUG CONSTRNT: Pool row 141 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 145
DEBUG CONSTRNT: Pool row 145 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 159
DEBUG CONSTRNT: Pool row 159 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 79
DEBUG CONSTRNT: Pool row 79 has lprow=47, expected 47
 % @PAP adding 45 rows, 179 nz to LP
DEBUG BB: Processing node 51, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=79, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 28285145.677696
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 45 rows, 60 cols, 239 nonzeros, 0 slack, 45 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 51 LP 1 Solution, length = 28285145.677696, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.500000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.500000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.500000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.500000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.500000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.500000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.500000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.500000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.500000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 0.500000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28285145.677696, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28285145.677696, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 51 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 51
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.500000
DEBUG CAREFUL: Adding var 0 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.500000
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=1.000000
DEBUG CAREFUL: Skipping var 7: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.500000
DEBUG CAREFUL: Adding var 23 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.500000
DEBUG CAREFUL: Adding var 24 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.500000
DEBUG CAREFUL: Adding var 33 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 33
DEBUG CAREFUL: Calling compare_branch_vars for var 33
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 33
DEBUG CAREFUL: New best var: 33
DEBUG CAREFUL: Testing fvar[1] = var 23
DEBUG CAREFUL: Calling compare_branch_vars for var 23
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 23
DEBUG CAREFUL: Testing fvar[2] = var 0
DEBUG CAREFUL: Calling compare_branch_vars for var 0
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 0
DEBUG CAREFUL: Testing fvar[3] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 1
DEBUG CAREFUL: Testing fvar[4] = var 24
DEBUG CAREFUL: Calling compare_branch_vars for var 24
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 24
  % Initial guess is x33, Z0 = 28285145.6776956        , Z1 = 28328555.0147235        

DEBUG EVAL: Testing var 33 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=6, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=5, varin=45, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 33 = 1 gives z=28325106.848319
  % 	x33 = 1,	Z1 = 28328555.0147235        
DEBUG EVAL: First branch cutoff check: z=28328555.014723, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 33 = 0
ITER 1: row=1, varin=31, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=32, varin=73, theta=0.250000, up=1.000000
  % 	x33 = 0,	Z0 = 28304737.7535093        
DEBUG EVAL: Second branch cutoff check: z=28304737.753509, best_z=INF, threshold=INF
  %   New best:  x33, Z = 28304737.7535093        
DEBUG EVAL: Testing var 23 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=32, varin=6, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=5, varin=45, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 23 = 0 gives z=28325106.848319
  % 	x23 = 0,	Z0 = 28325106.8483194        
DEBUG EVAL: First branch cutoff check: z=28325106.848319, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 23 = 1
ITER 1: row=32, varin=31, theta=0.250000, up=999999999999999983222784.000000
  % 	x23 = 1,	Z1 = 28288918.7258463        
DEBUG EVAL: Second branch cutoff check: z=28288918.725846, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 0 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=6, varin=6, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=5, varin=45, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 0 = 0 gives z=28325106.848319
  % 	x0 = 0,	Z0 = 28325106.8483194        
DEBUG EVAL: First branch cutoff check: z=28325106.848319, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 0 = 1
ITER 1: row=6, varin=7, theta=1.000000, up=999999999999999983222784.000000
  % 	x0 = 1,	Z1 = 28676753.2806788        
DEBUG EVAL: Second branch cutoff check: z=28676753.280679, best_z=INF, threshold=INF
  %   New best:  x0, Z = 28325106.8483194        
DEBUG EVAL: Testing var 1 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=7, varin=45, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 1 = 0 gives z=28325106.848319
  % 	x1 = 0,	Z0 = 28325106.8483194        
DEBUG EVAL: First branch cutoff check: z=28325106.848319, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 1 = 1
ITER 1: row=7, varin=6, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=5, varin=4, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=1, varin=31, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=32, varin=73, theta=0.500000, up=1.000000
  % 	x1 = 1,	Z1 = 28791639.1976941        
DEBUG EVAL: Second branch cutoff check: z=28791639.197694, best_z=INF, threshold=INF
  %   New best:  x1, Z = 28325106.8483194        
DEBUG EVAL: Testing var 24 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=3, varin=6, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=5, varin=45, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 24 = 0 gives z=28325106.848319
  % 	x24 = 0,	Z0 = 28325106.8483194        
DEBUG EVAL: First branch cutoff check: z=28325106.848319, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 24 = 1
ITER 1: row=3, varin=2, theta=0.500000, up=999999999999999983222784.000000
  % 	x24 = 1,	Z1 = 28433973.3436738        
DEBUG EVAL: Second branch cutoff check: z=28433973.343674, best_z=INF, threshold=INF
  % Best branch is x1, Z0 = 28325106.8483194        , Z1 = 28791639.1976941        

DEBUG CAREFUL: Final result - returning best.var = 1
DEBUG BB: Branching variable chosen: j=1
 % @NC   53   51	x1 = 0	28325106.848319
 % @NC   54   51	x1 = 1	28791639.197694
 %      51    22 28285145.6777               28286514.4807   x29 D    42     9
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde83b6e50
% @LO 0.05  28.28514567769556364851 99.9000000000
% @LN 0.05  28.28651448074497665175 99.9000000000
% Resuming node 45 at  28.28651448074497665175
DEBUG CONSTRNT: LP rows=45, pool->nlprows=45, pool->npend=0
DEBUG CONSTRNT: Checking 45 LP rows (pool tracks 45, total LP rows 45)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 142
DEBUG CONSTRNT: Pool row 142 has lprow=44, expected 44
 % @PAP adding 48 rows, 188 nz to LP
DEBUG BB: Processing node 45, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 45 LP 2 Solution, length = 28286514.480745, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.200000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.200000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.400000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.400000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 1.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.600000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.600000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.600000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.800000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.600000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.600000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=28286514.480745, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28286514.480745, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 45 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 45
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.200000
DEBUG CAREFUL: Adding var 8 to fractional list (xi=0.200000)
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.200000
DEBUG CAREFUL: Adding var 9 to fractional list (xi=0.200000)
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.400000
DEBUG CAREFUL: Adding var 14 to fractional list (xi=0.400000)
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.400000
DEBUG CAREFUL: Adding var 15 to fractional list (xi=0.400000)
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=1.000000
DEBUG CAREFUL: Skipping var 20: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 4 fractional variables

  %  Carefully choosing branching variable, nfrac = 4
DEBUG CAREFUL: Testing fvar[0] = var 8
DEBUG CAREFUL: Calling compare_branch_vars for var 8
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 8
DEBUG CAREFUL: New best var: 8
DEBUG CAREFUL: Testing fvar[1] = var 9
DEBUG CAREFUL: Calling compare_branch_vars for var 9
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 9
DEBUG CAREFUL: New best var: 9
DEBUG CAREFUL: Testing fvar[2] = var 14
DEBUG CAREFUL: Calling compare_branch_vars for var 14
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 14
DEBUG CAREFUL: Testing fvar[3] = var 15
DEBUG CAREFUL: Calling compare_branch_vars for var 15
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 15
  % Initial guess is x9, Z0 = 28286514.480745         , Z1 = 28330795.7789778        

DEBUG EVAL: Testing var 8 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=44, theta=1.333333, up=999999999999999983222784.000000
ITER 2: row=44, varin=47, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 8 = 1 gives z=28309344.663301
  % 	x8 = 1,	Z1 = 28309344.6633007        
DEBUG EVAL: First branch cutoff check: z=28309344.663301, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 8 = 0
ITER 1: row=1, varin=48, theta=0.500000, up=999999999999999983222784.000000
  % 	x8 = 0,	Z0 = 28288562.0598908        
DEBUG EVAL: Second branch cutoff check: z=28288562.059891, best_z=INF, threshold=INF
  %   New best:  x8, Z = 28288562.0598908        
DEBUG EVAL: Testing var 9 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=27, varin=48, theta=1.333333, up=999999999999999983222784.000000
ITER 2: row=1, varin=44, theta=0.333333, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 9 = 1 gives z=28296188.971931
  % 	x9 = 1,	Z1 = 28330795.7789778        
DEBUG EVAL: First branch cutoff check: z=28330795.778978, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 9 = 0
ITER 1: row=27, varin=66, theta=0.166667, up=1.000000
ITER 2: row=33, varin=49, theta=0.352941, up=1.000000
ITER 3: row=12, varin=50, theta=0.428571, up=1.000000
ITER 4: row=2, varin=43, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=45, varin=61, theta=0.250000, up=1.000000
  % 	x9 = 0,	Z0 = 28303220.7401699        
DEBUG EVAL: Second branch cutoff check: z=28303220.740170, best_z=INF, threshold=INF
  %   New best:  x9, Z = 28303220.7401699        
DEBUG EVAL: Testing var 14 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=41, varin=43, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=45, varin=48, theta=3.000000, up=999999999999999983222784.000000
ITER 3: row=27, varin=66, theta=0.333333, up=1.000000
ITER 4: row=1, varin=40, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 14 = 1 gives z=28327722.322049
  % 	x14 = 1,	Z1 = 28327722.3220494        
DEBUG EVAL: First branch cutoff check: z=28327722.322049, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 14 = 0
ITER 1: row=41, varin=44, theta=0.500000, up=999999999999999983222784.000000
  % 	x14 = 0,	Z0 = 28294883.480086         
DEBUG EVAL: Second branch cutoff check: z=28294883.480086, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 15 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=39, varin=43, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=45, varin=47, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 15 = 0 gives z=28309344.663301
  % 	x15 = 0,	Z0 = 28309344.6633007        
DEBUG EVAL: First branch cutoff check: z=28309344.663301, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 15 = 1
ITER 1: row=39, varin=48, theta=3.000000, up=999999999999999983222784.000000
ITER 2: row=47, varin=66, theta=0.333333, up=1.000000
ITER 3: row=1, varin=44, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=33, varin=49, theta=0.705882, up=1.000000
ITER 5: row=12, varin=50, theta=0.857143, up=1.000000
ITER 6: row=2, varin=61, theta=0.500000, up=1.000000
  % 	x15 = 1,	Z1 = 28340760.1565686        
DEBUG EVAL: Second branch cutoff check: z=28340760.156569, best_z=INF, threshold=INF
  %   New best:  x15, Z = 28309344.6633007        
  % Best branch is x15, Z0 = 28309344.6633007        , Z1 = 28340760.1565686        

DEBUG CAREFUL: Final result - returning best.var = 15
DEBUG BB: Branching variable chosen: j=15
 % @NC   55   45	x15 = 0	28309344.663301
 % @NC   56   45	x15 = 1	28340760.156569
 %      45    23 28286514.4807               28286929.8765    x7 D    27     6
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde83b0540
% @LO 0.05  28.28651448074497665175 99.9000000000
% @LN 0.05  28.28692987646958201253 99.9000000000
% Resuming node 26 at  28.28692987646958201253
DEBUG CONSTRNT: LP rows=48, pool->nlprows=48, pool->npend=0
DEBUG CONSTRNT: Checking 48 LP rows (pool tracks 48, total LP rows 48)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 141
DEBUG CONSTRNT: Pool row 141 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 145
DEBUG CONSTRNT: Pool row 145 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 159
DEBUG CONSTRNT: Pool row 159 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 79
DEBUG CONSTRNT: Pool row 79 has lprow=47, expected 47
 % @PAP adding 43 rows, 193 nz to LP
DEBUG BB: Processing node 26, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 26 LP 2 Solution, length = 28286929.876470, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.500000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.500000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.500000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.500000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.500000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.500000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.500000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.500000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.500000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 0.500000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28286929.876470, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28286929.876470, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 26 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 26
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.500000
DEBUG CAREFUL: Adding var 0 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.500000
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=1.000000
DEBUG CAREFUL: Skipping var 5: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.500000
DEBUG CAREFUL: Adding var 23 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.500000
DEBUG CAREFUL: Adding var 24 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.500000
DEBUG CAREFUL: Adding var 29 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 29
DEBUG CAREFUL: Calling compare_branch_vars for var 29
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 29
DEBUG CAREFUL: New best var: 29
DEBUG CAREFUL: Testing fvar[1] = var 23
DEBUG CAREFUL: Calling compare_branch_vars for var 23
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 23
DEBUG CAREFUL: Testing fvar[2] = var 0
DEBUG CAREFUL: Calling compare_branch_vars for var 0
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 0
DEBUG CAREFUL: Testing fvar[3] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 1
DEBUG CAREFUL: Testing fvar[4] = var 24
DEBUG CAREFUL: Calling compare_branch_vars for var 24
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 24
  % Initial guess is x29, Z0 = 28286929.8764696        , Z1 = 28320214.2940316        

DEBUG EVAL: Testing var 29 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=5, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=8, varin=43, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 29 = 1 gives z=28302150.682981
  % 	x29 = 1,	Z1 = 28320214.2940316        
DEBUG EVAL: First branch cutoff check: z=28320214.294032, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 29 = 0
ITER 1: row=1, varin=17, theta=0.132353, up=999999999999999983222784.000000
ITER 2: row=42, varin=77, theta=0.500000, up=1.000000
  % 	x29 = 0,	Z0 = 28311670.2405818        
DEBUG EVAL: Second branch cutoff check: z=28311670.240582, best_z=INF, threshold=INF
  %   New best:  x29, Z = 28311670.2405818        
DEBUG EVAL: Testing var 23 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=30, varin=5, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=8, varin=43, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 23 = 0 gives z=28302150.682981
  % 	x23 = 0,	Z0 = 28302150.6829812        
DEBUG EVAL: First branch cutoff check: z=28302150.682981, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 0 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=5, varin=5, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=8, varin=43, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 0 = 0 gives z=28302150.682981
  % 	x0 = 0,	Z0 = 28302150.6829812        
DEBUG EVAL: First branch cutoff check: z=28302150.682981, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 1 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=6, varin=43, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 1 = 0 gives z=28302150.682981
  % 	x1 = 0,	Z0 = 28302150.6829812        
DEBUG EVAL: First branch cutoff check: z=28302150.682981, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 24 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=3, varin=5, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=8, varin=43, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 24 = 0 gives z=28302150.682981
  % 	x24 = 0,	Z0 = 28302150.6829812        
DEBUG EVAL: First branch cutoff check: z=28302150.682981, best_z=INF, threshold=INF
  % Best branch is x29, Z0 = 28311670.2405818        , Z1 = 28320214.2940316        

DEBUG CAREFUL: Final result - returning best.var = 29
DEBUG BB: Branching variable chosen: j=29
 % @NC   57   26	x29 = 0	28311670.240582
 % @NC   58   26	x29 = 1	28320214.294032
 %      26    24 28286929.8765               28288221.1541   x20 D    21     5
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde839dbe0
% @LO 0.05  28.28692987646958201253 99.9000000000
% @LN 0.05  28.28822115409331772184 99.9000000000
% Resuming node 10 at  28.28822115409331772184
DEBUG CONSTRNT: LP rows=43, pool->nlprows=43, pool->npend=0
DEBUG CONSTRNT: Checking 43 LP rows (pool tracks 43, total LP rows 43)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 142
DEBUG CONSTRNT: Pool row 142 has lprow=42, expected 42
 % @PAP adding 38 rows, 207 nz to LP
DEBUG BB: Processing node 10, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 10 LP 2 Solution, length = 28288221.154093, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.737359 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.420880 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 1.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.579120 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.420880 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.420880 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.262641 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.420880 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.420880 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 3 fractional variables
DEBUG CG: LP optimal, z=28288221.154093, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28288221.154093, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 10 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 10
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.737359
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.737359)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=1.000000
DEBUG CAREFUL: Skipping var 5: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.420880
DEBUG CAREFUL: Adding var 15 to fractional list (xi=0.420880)
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=1.000000
DEBUG CAREFUL: Skipping var 17: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.579120
DEBUG CAREFUL: Adding var 19 to fractional list (xi=0.579120)
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 3 fractional variables

  %  Carefully choosing branching variable, nfrac = 3
DEBUG CAREFUL: Testing fvar[0] = var 19
DEBUG CAREFUL: Calling compare_branch_vars for var 19
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 19
DEBUG CAREFUL: New best var: 19
DEBUG CAREFUL: Testing fvar[1] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[2] = var 15
DEBUG CAREFUL: Calling compare_branch_vars for var 15
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 15
  % Initial guess is x19, Z0 = 28288221.1540933        , Z1 = 28288221.1540933        

DEBUG EVAL: Testing var 19 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=8, varin=7, theta=1.389909, up=999999999999999983222784.000000
ITER 2: row=4, varin=37, theta=0.757832, up=999999999999999983222784.000000
ITER 3: row=21, varin=65, theta=1.284990, up=1.000000
ITER 4: row=21, varin=62, theta=0.277186, up=1.000000
ITER 5: row=7, varin=4, theta=0.452667, up=999999999999999983222784.000000
ITER 6: row=8, varin=34, theta=0.249665, up=999999999999999983222784.000000
ITER 7: row=38, varin=68, theta=0.895311, up=1.000000
ITER 8: row=34, varin=6, theta=0.603465, up=999999999999999983222784.000000
ITER 9: row=2, varin=92, theta=1.212918, up=1.000000
ITER 10: row=2, varin=61, theta=0.052407, up=1.000000
DEBUG EVAL: Branch var 19 = 1 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x19 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=8, varin=21, theta=498944.000000, up=999999999999999983222784.000000
ITER 2: row=1, varin=37, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=2, varin=34, theta=0.333333, up=999999999999999983222784.000000
ITER 4: row=34, varin=3, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=37, varin=26, theta=0.500000, up=999999999999999983222784.000000
ITER 6: row=11, varin=6, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=8, varin=13, theta=0.071747, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=7)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=38)
DEBUG SOLUTION: LP solution array indices: FST[39-78], not_covered[79-98]
DEBUG SOLUTION: lp->best_solution[0] = 28422871.333622
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.071747
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.071747
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.928253
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
   % @PL 38 rows, 60 cols, 267 nonzeros, 3 slack, 35 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 3 slack rows
   % @PAP adding 6 rows, 32 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=36, varin=7, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=41, varin=18, theta=285652.500000, up=999999999999999983222784.000000
ITER 3: row=38, varin=10, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=4, varin=56, theta=0.583333, up=1.000000
ITER 5: row=40, varin=41, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=41)
DEBUG SOLUTION: LP solution array indices: FST[42-81], not_covered[82-101]
DEBUG SOLUTION: lp->best_solution[0] = 28456363.564867
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 0.666667
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.666667
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 41 rows, 60 cols, 293 nonzeros, 8 slack, 33 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 8 slack rows
   % @PAP adding 4 rows, 12 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=34, varin=6, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=36, varin=38, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=37)
DEBUG SOLUTION: LP solution array indices: FST[38-77], not_covered[78-97]
DEBUG SOLUTION: lp->best_solution[0] = 28502471.327741
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.500000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 37 rows, 60 cols, 228 nonzeros, 3 slack, 34 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 3 slack rows
   % @PAP adding 5 rows, 55 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=39, varin=47, theta=0.619842, up=1.000000
ITER 2: row=10, varin=3, theta=0.691750, up=999999999999999983222784.000000
ITER 3: row=38, varin=52, theta=0.304168, up=1.000000
ITER 4: row=36, varin=39, theta=158183.500000, up=999999999999999983222784.000000
ITER 5: row=18, varin=64, theta=1.000000, up=1.000000
ITER 6: row=27, varin=84, theta=0.454545, up=1.000000
ITER 7: row=36, varin=49, theta=0.267454, up=1.000000
ITER 8: row=37, varin=39, theta=112493.333333, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=8)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=39)
DEBUG SOLUTION: LP solution array indices: FST[40-79], not_covered[80-99]
DEBUG SOLUTION: lp->best_solution[0] = 28536841.411498
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 0.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 39 rows, 60 cols, 273 nonzeros, 1 slack, 38 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
   % @PAP adding 2 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=39, varin=38, theta=6.000000, up=999999999999999983222784.000000
ITER 2: row=5, varin=59, theta=0.166667, up=1.000000
ITER 3: row=3, varin=86, theta=1.000000, up=1.000000
ITER 4: row=24, varin=93, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=40)
DEBUG SOLUTION: LP solution array indices: FST[41-80], not_covered[81-100]
DEBUG SOLUTION: lp->best_solution[0] = 28581022.003578
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 0.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.500000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 40 rows, 60 cols, 241 nonzeros, 2 slack, 38 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 2 slack rows
   % @PAP adding 4 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=39, varin=45, theta=0.333333, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 28582099.097149
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 0.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 42 rows, 60 cols, 241 nonzeros, 0 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 10 at  28.58209909714920016199
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde8397010
% @LO 0.05  28.28822115409331772184 99.9000000000
% @LN 0.05  28.29148876165208648104 99.9000000000
% Resuming node 47 at  28.29148876165208648104
DEBUG CONSTRNT: LP rows=42, pool->nlprows=42, pool->npend=0
DEBUG CONSTRNT: Checking 42 LP rows (pool tracks 42, total LP rows 42)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 141
DEBUG CONSTRNT: Pool row 141 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 145
DEBUG CONSTRNT: Pool row 145 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 159
DEBUG CONSTRNT: Pool row 159 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 63
DEBUG CONSTRNT: Pool row 63 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=41, expected 41
 % @PAP adding 46 rows, 179 nz to LP
DEBUG BB: Processing node 47, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=23, varin=44, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=12, varin=41, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=46)
DEBUG SOLUTION: LP solution array indices: FST[47-86], not_covered[87-106]
DEBUG SOLUTION: lp->best_solution[0] = 28291488.761652
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 46 rows, 60 cols, 239 nonzeros, 6 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 42 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=48, varin=5, theta=0.178187, up=999999999999999983222784.000000
ITER 2: row=47, varin=22, theta=0.500000, up=999999999999999983222784.000000
ITER 3: row=48, varin=48, theta=28984.250000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 28378017.578162
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 48 rows, 60 cols, 281 nonzeros, 9 slack, 39 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 9 slack rows
  % @PAP adding 3 rows, 15 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=40, varin=47, theta=0.250000, up=1.000000
ITER 2: row=41, varin=99, theta=0.500000, up=1.000000
ITER 3: row=37, varin=72, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 28427667.011666
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 42 rows, 60 cols, 240 nonzeros, 0 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 13 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=43, varin=19, theta=0.062500, up=999999999999999983222784.000000
ITER 2: row=38, varin=36, theta=0.055556, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=46)
DEBUG SOLUTION: LP solution array indices: FST[47-86], not_covered[87-106]
DEBUG SOLUTION: lp->best_solution[0] = 28440320.883462
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 46 rows, 60 cols, 253 nonzeros, 3 slack, 43 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 2 rows, 42 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=45, varin=79, theta=0.247600, up=1.000000
ITER 2: row=44, varin=45, theta=67094.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 28452407.375778
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 45 rows, 60 cols, 285 nonzeros, 1 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 4 rows, 14 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=45, varin=3, theta=0.250000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 28453007.396840
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.750000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 48 rows, 60 cols, 259 nonzeros, 3 slack, 45 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 1 rows, 40 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=46, varin=74, theta=0.160537, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=46)
DEBUG SOLUTION: LP solution array indices: FST[47-86], not_covered[87-106]
DEBUG SOLUTION: lp->best_solution[0] = 28462972.909718
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 46 rows, 60 cols, 287 nonzeros, 0 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=47, varin=70, theta=0.145753, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 28464959.688309
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 47 rows, 60 cols, 289 nonzeros, 0 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=48, varin=79, theta=0.195017, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 28466594.142057
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 48 rows, 60 cols, 293 nonzeros, 0 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 3 rows, 10 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=49, varin=73, theta=0.027738, up=1.000000
ITER 2: row=25, varin=84, theta=0.045329, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 28468435.141874
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 51 rows, 60 cols, 303 nonzeros, 0 slack, 51 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 47 LP 1 Solution, length = 28468435.141874, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.151557 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.151557 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.500000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 1.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.500000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.151557 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.151557 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.045329 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.151557 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.848443 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.848443 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.848443 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.848443 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.500000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.500000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 8 fractional variables
DEBUG CG: LP optimal, z=28468435.141874, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 47 at  28.46843514187361279255
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde8397490
% @LO 0.05  28.29148876165208648104 99.9000000000
% @LN 0.05  28.29237126338349028742 99.9000000000
% Resuming node 52 at  28.29237126338349028742
DEBUG CONSTRNT: LP rows=51, pool->nlprows=51, pool->npend=0
DEBUG CONSTRNT: Checking 51 LP rows (pool tracks 51, total LP rows 51)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 85
DEBUG CONSTRNT: Pool row 85 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 158
DEBUG CONSTRNT: Pool row 158 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 145
DEBUG CONSTRNT: Pool row 145 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 159
DEBUG CONSTRNT: Pool row 159 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 133
DEBUG CONSTRNT: Pool row 133 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=50, expected 50
 % @PAP adding 45 rows, 179 nz to LP
DEBUG BB: Processing node 52, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=6, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=5, varin=45, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 28275626.120095
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 45 rows, 60 cols, 239 nonzeros, 1 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 13 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=46, varin=40, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=45, varin=7, theta=0.500000, up=999999999999999983222784.000000
ITER 3: row=48, varin=4, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=41, varin=11, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=48, varin=34, theta=0.250000, up=999999999999999983222784.000000
ITER 6: row=46, varin=83, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 28665123.435148
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.500000
DEBUG SOLUTION: lp->best_solution[7] = 0.500000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.500000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 49 rows, 60 cols, 252 nonzeros, 5 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=45, varin=5, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 29056731.038132
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 0.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 45 rows, 60 cols, 239 nonzeros, 1 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 2 rows, 42 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=46, varin=36, theta=0.026098, up=999999999999999983222784.000000
ITER 2: row=45, varin=27, theta=0.840130, up=999999999999999983222784.000000
ITER 3: row=28, varin=74, theta=0.795194, up=1.000000
ITER 4: row=46, varin=69, theta=-2.872930, up=1.000000
ITER 5: row=46, varin=46, theta=117997.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=46)
DEBUG SOLUTION: LP solution array indices: FST[47-86], not_covered[87-106]
DEBUG SOLUTION: lp->best_solution[0] = 29120007.148784
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 46 rows, 60 cols, 279 nonzeros, 1 slack, 45 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 2 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=46, varin=70, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 29139934.737037
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 47 rows, 60 cols, 245 nonzeros, 0 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 19 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=48, varin=82, theta=0.666667, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 29160882.764035
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 51 rows, 60 cols, 264 nonzeros, 1 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 4 rows, 10 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=51, varin=87, theta=0.250000, up=1.000000
ITER 2: row=46, varin=76, theta=0.250000, up=1.000000
ITER 3: row=26, varin=21, theta=0.125000, up=999999999999999983222784.000000
ITER 4: row=54, varin=51, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=38, varin=34, theta=0.250000, up=999999999999999983222784.000000
ITER 6: row=39, varin=78, theta=1.000000, up=1.000000
ITER 7: row=52, varin=38, theta=0.250000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=7)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=54)
DEBUG SOLUTION: LP solution array indices: FST[55-94], not_covered[95-114]
DEBUG SOLUTION: lp->best_solution[0] = 29207986.869263
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 54 rows, 60 cols, 272 nonzeros, 3 slack, 51 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % Node 52 LP 1 Solution, length = 29207986.869263, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.500000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.250000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.500000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.500000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.250000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 1.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.500000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.250000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.500000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.500000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.500000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.750000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.750000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 0.500000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 8 fractional variables
DEBUG CG: LP optimal, z=29207986.869263, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 52 at  29.20798686926306331202
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde83a93e0
% @LO 0.05  28.29237126338349028742 99.9000000000
% @LN 0.05  28.29871740958521186826 99.9000000000
% Resuming node 28 at  28.29871740958521186826
DEBUG CONSTRNT: LP rows=51, pool->nlprows=51, pool->npend=0
DEBUG CONSTRNT: Checking 51 LP rows (pool tracks 51, total LP rows 51)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 142
DEBUG CONSTRNT: Pool row 142 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 143
DEBUG CONSTRNT: Pool row 143 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 135
DEBUG CONSTRNT: Pool row 135 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=50, expected 50
 % @PAP adding 48 rows, 202 nz to LP
DEBUG BB: Processing node 28, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=33, varin=34, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=27, varin=61, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 28156359.266737
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 48 rows, 60 cols, 262 nonzeros, 0 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 5 rows, 56 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=53, varin=12, theta=0.017093, up=999999999999999983222784.000000
ITER 2: row=49, varin=69, theta=2.129443, up=1.000000
ITER 3: row=49, varin=56, theta=0.960914, up=1.000000
ITER 4: row=48, varin=69, theta=1.000000, up=1.000000
ITER 5: row=22, varin=78, theta=3.735895, up=1.000000
ITER 6: row=22, varin=8, theta=4.575069, up=999999999999999983222784.000000
ITER 7: row=8, varin=45, theta=1.936249, up=999999999999999983222784.000000
ITER 8: row=51, varin=80, theta=1.623204, up=1.000000
ITER 9: row=51, varin=77, theta=0.579974, up=1.000000
ITER 10: row=3, varin=78, theta=1.046539, up=1.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=53)
DEBUG SOLUTION: LP solution array indices: FST[54-93], not_covered[94-113]
DEBUG SOLUTION: lp->best_solution[0] = 999999999999999983222784.000000
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 53 rows, 60 cols, 318 nonzeros, 3 slack, 50 tight.
  % Node 28 LP 1 Solution, length = 999999999999999983222784.000000, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 1.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 1.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 1.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
DEBUG BB: compute_good_lower_bound returned status=1
DEBUG BB: Node 28 is INFEASIBLE
 %      28    23    infeasible               28299033.3673   x16 U    13     5
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde8397250
% @LO 0.05  28.29871740958521186826 99.9000000000
% @LN 0.05  28.29903336734626506654 99.9000000000
% Resuming node 43 at  28.29903336734626506654
DEBUG CONSTRNT: LP rows=53, pool->nlprows=53, pool->npend=0
DEBUG CONSTRNT: Checking 53 LP rows (pool tracks 53, total LP rows 53)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 141
DEBUG CONSTRNT: Pool row 141 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 145
DEBUG CONSTRNT: Pool row 145 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 159
DEBUG CONSTRNT: Pool row 159 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 49
DEBUG CONSTRNT: Pool row 49 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 68
DEBUG CONSTRNT: Pool row 68 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 82
DEBUG CONSTRNT: Pool row 82 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 121
DEBUG CONSTRNT: Pool row 121 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=52, expected 52
 % @PAP adding 43 rows, 173 nz to LP
DEBUG BB: Processing node 43, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=9, varin=67, theta=1.000000, up=1.000000
ITER 2: row=34, varin=55, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 28299033.367346
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 43 rows, 60 cols, 233 nonzeros, 0 slack, 43 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 6 rows, 34 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=44, varin=54, theta=0.500000, up=1.000000
ITER 2: row=45, varin=36, theta=0.066667, up=999999999999999983222784.000000
ITER 3: row=49, varin=45, theta=0.076923, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 28312898.242103
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 49 rows, 60 cols, 267 nonzeros, 5 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % @PAP adding 3 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=45, varin=44, theta=0.800000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 28315300.696692
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 47 rows, 60 cols, 249 nonzeros, 1 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 43 LP 1 Solution, length = 28315300.696692, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.200000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.200000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.200000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.200000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 1.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.200000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.200000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.800000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.800000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.800000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.800000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.800000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.800000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.800000 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28315300.696692, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 43 at  28.31530069669173244051
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde8386600
% @LO 0.05  28.29903336734626506654 99.9000000000
% @LN 0.05  28.30183671467629125118 99.9000000000
% Resuming node 38 at  28.30183671467629125118
DEBUG CONSTRNT: LP rows=46, pool->nlprows=46, pool->npend=0
DEBUG CONSTRNT: Checking 46 LP rows (pool tracks 46, total LP rows 46)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 65
DEBUG CONSTRNT: Pool row 65 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 121
DEBUG CONSTRNT: Pool row 121 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=45, expected 45
 % @PAP adding 47 rows, 198 nz to LP
DEBUG BB: Processing node 38, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 38 LP 2 Solution, length = 28301836.714676, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.666667 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.333333 (FST 9)
  % DEBUG LP_VARS: x[10] = 1.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.500000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.500000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.333333 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.500000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.500000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.333333 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.333333 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.500000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=28301836.714676, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28301836.714676, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 38 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 38
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.666667
DEBUG CAREFUL: Adding var 7 to fractional list (xi=0.666667)
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.333333
DEBUG CAREFUL: Adding var 9 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=1.000000
DEBUG CAREFUL: Skipping var 10: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.500000
DEBUG CAREFUL: Adding var 14 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.500000
DEBUG CAREFUL: Adding var 15 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 4 fractional variables

  %  Carefully choosing branching variable, nfrac = 4
DEBUG CAREFUL: Testing fvar[0] = var 9
DEBUG CAREFUL: Calling compare_branch_vars for var 9
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 9
DEBUG CAREFUL: New best var: 9
DEBUG CAREFUL: Testing fvar[1] = var 14
DEBUG CAREFUL: Calling compare_branch_vars for var 14
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 14
DEBUG CAREFUL: Testing fvar[2] = var 15
DEBUG CAREFUL: Calling compare_branch_vars for var 15
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 15
DEBUG CAREFUL: Testing fvar[3] = var 7
DEBUG CAREFUL: Calling compare_branch_vars for var 7
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 7
  % Initial guess is x9, Z0 = 28301836.7146763        , Z1 = 28335791.1089939        

DEBUG EVAL: Testing var 9 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=42, varin=46, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=39, varin=49, theta=4.000000, up=1.000000
ITER 3: row=39, varin=5, theta=2.250000, up=999999999999999983222784.000000
ITER 4: row=8, varin=11, theta=3.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 9 = 1 gives z=28335791.108994
  % 	x9 = 1,	Z1 = 28335791.1089939        
DEBUG EVAL: First branch cutoff check: z=28335791.108994, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 9 = 0
ITER 1: row=42, varin=65, theta=0.367347, up=1.000000
ITER 2: row=37, varin=48, theta=0.705882, up=1.000000
ITER 3: row=12, varin=49, theta=0.857143, up=1.000000
ITER 4: row=2, varin=56, theta=0.500000, up=1.000000
  % 	x9 = 0,	Z0 = 28319401.5653056        
DEBUG EVAL: Second branch cutoff check: z=28319401.565306, best_z=INF, threshold=INF
  %   New best:  x9, Z = 28319401.5653056        
DEBUG EVAL: Testing var 14 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=27, varin=46, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 14 = 0 gives z=28308044.049506
  % 	x14 = 0,	Z0 = 28308044.0495056        
DEBUG EVAL: First branch cutoff check: z=28308044.049506, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 15 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=39, varin=43, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=47, varin=56, theta=1.000000, up=1.000000
ITER 3: row=42, varin=40, theta=0.333333, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 15 = 0 gives z=28343092.302185
  % 	x15 = 0,	Z0 = 28343092.3021845        
DEBUG EVAL: First branch cutoff check: z=28343092.302185, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 15 = 1
ITER 1: row=39, varin=46, theta=1.000000, up=999999999999999983222784.000000
  % 	x15 = 1,	Z1 = 28308044.0495056        
DEBUG EVAL: Second branch cutoff check: z=28308044.049506, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 7 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=65, theta=0.367347, up=1.000000
ITER 2: row=37, varin=48, theta=0.705882, up=1.000000
ITER 3: row=12, varin=49, theta=0.857143, up=1.000000
ITER 4: row=2, varin=29, theta=0.580645, up=999999999999999983222784.000000
ITER 5: row=35, varin=58, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 7 = 1 gives z=28328061.122936
  % 	x7 = 1,	Z1 = 28328061.122936         
DEBUG EVAL: First branch cutoff check: z=28328061.122936, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 7 = 0
ITER 1: row=1, varin=46, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=27, varin=30, theta=0.500000, up=999999999999999983222784.000000
  % 	x7 = 0,	Z0 = 28322391.1473543        
DEBUG EVAL: Second branch cutoff check: z=28322391.147354, best_z=INF, threshold=INF
  %   New best:  x7, Z = 28322391.1473543        
  % Best branch is x7, Z0 = 28322391.1473543        , Z1 = 28328061.122936         

DEBUG CAREFUL: Final result - returning best.var = 7
DEBUG BB: Branching variable chosen: j=7
 % @NC   59   38	x7 = 0	28322391.147354
 % @NC   60   38	x7 = 1	28328061.122936
 %      38    24 28301836.7147               28309344.6633   x16 D    18     5
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde83ad260
% @LO 0.05  28.30183671467629125118 99.9000000000
% @LN 0.05  28.30934466330073462359 99.9000000000
% Resuming node 55 at  28.30934466330073462359
DEBUG CONSTRNT: LP rows=47, pool->nlprows=47, pool->npend=0
DEBUG CONSTRNT: Checking 47 LP rows (pool tracks 47, total LP rows 47)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=46, expected 46
 % @PAP adding 48 rows, 188 nz to LP
DEBUG BB: Processing node 55, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=39, varin=43, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=45, varin=47, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 28309344.663301
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 48 rows, 60 cols, 248 nonzeros, 1 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 29 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=49, varin=40, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=52, varin=46, theta=0.100000, up=999999999999999983222784.000000
ITER 3: row=51, varin=49, theta=0.769231, up=999999999999999983222784.000000
ITER 4: row=47, varin=52, theta=5.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 28318533.492675
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 52 rows, 60 cols, 277 nonzeros, 5 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % Node 55 LP 1 Solution, length = 28318533.492675, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.500000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.500000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.500000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 1.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.500000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.500000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.500000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 3 fractional variables
DEBUG CG: LP optimal, z=28318533.492675, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 55 at  28.31853349267506203546
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde83b6e50
% @LO 0.05  28.30934466330073462359 99.9000000000
% @LN 0.05  28.31167024058175130108 99.9000000000
% Resuming node 57 at  28.31167024058175130108
DEBUG CONSTRNT: LP rows=47, pool->nlprows=47, pool->npend=0
DEBUG CONSTRNT: Checking 47 LP rows (pool tracks 47, total LP rows 47)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 141
DEBUG CONSTRNT: Pool row 141 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 145
DEBUG CONSTRNT: Pool row 145 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 159
DEBUG CONSTRNT: Pool row 159 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 79
DEBUG CONSTRNT: Pool row 79 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 45
DEBUG CONSTRNT: Pool row 45 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 62
DEBUG CONSTRNT: Pool row 62 has lprow=46, expected 46
 % @PAP adding 43 rows, 193 nz to LP
DEBUG BB: Processing node 57, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=17, theta=0.132353, up=999999999999999983222784.000000
ITER 2: row=42, varin=77, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 28311670.240582
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 43 rows, 60 cols, 253 nonzeros, 0 slack, 43 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 57 LP 1 Solution, length = 28311670.240582, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.500000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.500000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.500000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.500000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.500000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.500000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.500000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.500000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.500000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 0.500000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28311670.240582, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28311670.240582, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 57 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 57
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.500000
DEBUG CAREFUL: Adding var 0 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.500000
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=1.000000
DEBUG CAREFUL: Skipping var 5: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.500000
DEBUG CAREFUL: Adding var 23 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.500000
DEBUG CAREFUL: Adding var 24 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.500000
DEBUG CAREFUL: Adding var 33 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 33
DEBUG CAREFUL: Calling compare_branch_vars for var 33
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 33
DEBUG CAREFUL: New best var: 33
DEBUG CAREFUL: Testing fvar[1] = var 23
DEBUG CAREFUL: Calling compare_branch_vars for var 23
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 23
DEBUG CAREFUL: Testing fvar[2] = var 0
DEBUG CAREFUL: Calling compare_branch_vars for var 0
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 0
DEBUG CAREFUL: Testing fvar[3] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 1
DEBUG CAREFUL: Testing fvar[4] = var 24
DEBUG CAREFUL: Calling compare_branch_vars for var 24
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 24
  % Initial guess is x33, Z0 = 28311670.2405818        , Z1 = 28368648.7975011        

DEBUG EVAL: Testing var 33 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=42, theta=0.102941, up=999999999999999983222784.000000
ITER 2: row=37, varin=5, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=8, varin=43, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 33 = 1 gives z=28351631.411206
  % 	x33 = 1,	Z1 = 28368648.7975011        
DEBUG EVAL: First branch cutoff check: z=28368648.797501, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 33 = 0
ITER 1: row=1, varin=29, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=30, varin=39, theta=0.102941, up=999999999999999983222784.000000
  % 	x33 = 0,	Z0 = 28324222.7394867        
DEBUG EVAL: Second branch cutoff check: z=28324222.739487, best_z=INF, threshold=INF
  %   New best:  x33, Z = 28324222.7394867        
DEBUG EVAL: Testing var 23 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=30, varin=5, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=8, varin=43, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 23 = 0 gives z=28351631.411206
  % 	x23 = 0,	Z0 = 28351631.4112056        
DEBUG EVAL: First branch cutoff check: z=28351631.411206, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 23 = 1
ITER 1: row=30, varin=29, theta=0.250000, up=999999999999999983222784.000000
  % 	x23 = 1,	Z1 = 28315443.2887325        
DEBUG EVAL: Second branch cutoff check: z=28315443.288732, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 0 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=5, varin=5, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=8, varin=43, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 0 = 0 gives z=28351631.411206
  % 	x0 = 0,	Z0 = 28351631.4112056        
DEBUG EVAL: First branch cutoff check: z=28351631.411206, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 0 = 1
ITER 1: row=5, varin=6, theta=1.000000, up=999999999999999983222784.000000
  % 	x0 = 1,	Z1 = 28703277.8435649        
DEBUG EVAL: Second branch cutoff check: z=28703277.843565, best_z=INF, threshold=INF
  %   New best:  x0, Z = 28351631.4112056        
DEBUG EVAL: Testing var 1 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=6, varin=43, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 1 = 0 gives z=28351631.411206
  % 	x1 = 0,	Z0 = 28351631.4112056        
DEBUG EVAL: First branch cutoff check: z=28351631.411206, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 1 = 1
ITER 1: row=6, varin=5, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=8, varin=7, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=1, varin=29, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=30, varin=39, theta=0.205882, up=999999999999999983222784.000000
  % 	x1 = 1,	Z1 = 28804084.6067626        
DEBUG EVAL: Second branch cutoff check: z=28804084.606763, best_z=INF, threshold=INF
  %   New best:  x1, Z = 28351631.4112056        
DEBUG EVAL: Testing var 24 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=3, varin=5, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=8, varin=43, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 24 = 0 gives z=28351631.411206
  % 	x24 = 0,	Z0 = 28351631.4112056        
DEBUG EVAL: First branch cutoff check: z=28351631.411206, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 24 = 1
ITER 1: row=3, varin=2, theta=0.500000, up=999999999999999983222784.000000
  % 	x24 = 1,	Z1 = 28460497.9065599        
DEBUG EVAL: Second branch cutoff check: z=28460497.906560, best_z=INF, threshold=INF
  % Best branch is x1, Z0 = 28351631.4112056        , Z1 = 28804084.6067626        

DEBUG CAREFUL: Final result - returning best.var = 1
DEBUG BB: Branching variable chosen: j=1
 % @NC   61   57	x1 = 0	28351631.411206
 % @NC   62   57	x1 = 1	28804084.606763
 %      57    25 28311670.2406               28315300.6967   x29 D    26     6
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde8397250
% @LO 0.05  28.31167024058175130108 99.9000000000
% @LN 0.05  28.31530069669173244051 99.9000000000
% Resuming node 43 at  28.31530069669173244051
DEBUG CONSTRNT: LP rows=43, pool->nlprows=43, pool->npend=0
DEBUG CONSTRNT: Checking 43 LP rows (pool tracks 43, total LP rows 43)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 142
DEBUG CONSTRNT: Pool row 142 has lprow=42, expected 42
 % @PAP adding 46 rows, 179 nz to LP
DEBUG BB: Processing node 43, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 43 LP 2 Solution, length = 28315300.696692, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.200000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.200000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.200000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.200000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 1.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.200000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.200000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.800000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.800000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.800000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.800000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.800000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.800000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.800000 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28315300.696692, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28315300.696692, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 43 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 43
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.200000
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.200000)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.200000
DEBUG CAREFUL: Adding var 4 to fractional list (xi=0.200000)
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.200000
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.200000)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.200000
DEBUG CAREFUL: Adding var 11 to fractional list (xi=0.200000)
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=1.000000
DEBUG CAREFUL: Skipping var 13: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.200000
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.200000)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.200000
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.200000)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 6 fractional variables

  %  Carefully choosing branching variable, nfrac = 6
DEBUG CAREFUL: Testing fvar[0] = var 4
DEBUG CAREFUL: Calling compare_branch_vars for var 4
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 4
DEBUG CAREFUL: New best var: 4
DEBUG CAREFUL: Testing fvar[1] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[2] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[3] = var 11
DEBUG CAREFUL: Calling compare_branch_vars for var 11
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 11
DEBUG CAREFUL: Testing fvar[4] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[5] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
  % Initial guess is x4, Z0 = 28315300.6966917        , Z1 = 28548357.1833914        

DEBUG EVAL: Testing var 4 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=9, varin=41, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=41, varin=34, theta=2.000000, up=999999999999999983222784.000000
ITER 3: row=34, varin=39, theta=2.000000, up=999999999999999983222784.000000
ITER 4: row=39, varin=22, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=45, varin=36, theta=2.000000, up=999999999999999983222784.000000
ITER 6: row=36, varin=30, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=29, varin=35, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 4 = 1 gives z=28642251.724907
  % 	x4 = 1,	Z1 = 28642251.7249068        
DEBUG EVAL: First branch cutoff check: z=28642251.724907, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 4 = 0
ITER 1: row=9, varin=44, theta=0.333333, up=999999999999999983222784.000000
  % 	x4 = 0,	Z0 = 28317903.3558293        
DEBUG EVAL: Second branch cutoff check: z=28317903.355829, best_z=INF, threshold=INF
  %   New best:  x4, Z = 28317903.3558293        
DEBUG EVAL: Testing var 17 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=22, varin=44, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=9, varin=41, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 17 = 1 gives z=28355643.332795
  % 	x17 = 1,	Z1 = 28355643.3327953        
DEBUG EVAL: First branch cutoff check: z=28355643.332795, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 17 = 0
ITER 1: row=22, varin=23, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=42, varin=103, theta=1.000000, up=1.000000
ITER 3: row=40, varin=76, theta=1.000000, up=1.000000
  % 	x17 = 0,	Z0 = 28398332.2343541        
DEBUG EVAL: Second branch cutoff check: z=28398332.234354, best_z=INF, threshold=INF
  %   New best:  x17, Z = 28355643.3327953        
DEBUG EVAL: Testing var 10 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=14, varin=17, theta=0.250000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 0 gives z=28362631.937283
  % 	x10 = 0,	Z0 = 28362631.9372829        
DEBUG EVAL: First branch cutoff check: z=28362631.937283, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 1
ITER 1: row=14, varin=44, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=9, varin=41, theta=1.000000, up=999999999999999983222784.000000
  % 	x10 = 1,	Z1 = 28355643.3327953        
DEBUG EVAL: Second branch cutoff check: z=28355643.332795, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 11 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=41, varin=44, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=9, varin=34, theta=2.000000, up=999999999999999983222784.000000
ITER 3: row=34, varin=39, theta=2.000000, up=999999999999999983222784.000000
ITER 4: row=39, varin=23, theta=2.000000, up=999999999999999983222784.000000
ITER 5: row=42, varin=36, theta=2.000000, up=999999999999999983222784.000000
ITER 6: row=36, varin=30, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=29, varin=35, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 11 = 1 gives z=28617525.043629
  % 	x11 = 1,	Z1 = 28617525.0436286        
DEBUG EVAL: First branch cutoff check: z=28617525.043629, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 11 = 0
ITER 1: row=41, varin=41, theta=0.333333, up=999999999999999983222784.000000
  % 	x11 = 0,	Z0 = 28326145.582922         
DEBUG EVAL: Second branch cutoff check: z=28326145.582922, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 2 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=35, theta=0.250000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 0 gives z=28355593.987401
  % 	x2 = 0,	Z0 = 28355593.9874011        
DEBUG EVAL: First branch cutoff check: z=28355593.987401, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 26 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=36, varin=36, theta=0.250000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 26 = 0 gives z=28348611.498363
  % 	x26 = 0,	Z0 = 28348611.4983634        
DEBUG EVAL: First branch cutoff check: z=28348611.498363, best_z=INF, threshold=INF
  % Best branch is x17, Z0 = 28398332.2343541        , Z1 = 28355643.3327953        

DEBUG CAREFUL: Final result - returning best.var = 17
DEBUG BB: Branching variable chosen: j=17
 % @NC   63   43	x17 = 1	28355643.332795
 % @NC   64   43	x17 = 0	28398332.234354
 %      43    26 28315300.6967               28317215.1421    x3 D    39     6
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde839a8b0
% @LO 0.05  28.31530069669173244051 99.9000000000
% @LN 0.05  28.31721514211102430636 99.9000000000
% Resuming node 37 at  28.31721514211102430636
DEBUG CONSTRNT: LP rows=46, pool->nlprows=46, pool->npend=0
DEBUG CONSTRNT: Checking 46 LP rows (pool tracks 46, total LP rows 46)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 65
DEBUG CONSTRNT: Pool row 65 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 121
DEBUG CONSTRNT: Pool row 121 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=45, expected 45
 % @PAP adding 45 rows, 177 nz to LP
DEBUG BB: Processing node 37, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 37 LP 2 Solution, length = 28317215.142111, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.166667 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.166667 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.166667 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 1.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.166667 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.166667 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.166667 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.833333 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.833333 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.833333 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.833333 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.833333 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.833333 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.833333 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28317215.142111, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28317215.142111, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 37 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 37
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.166667
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.166667
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.166667
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=1.000000
DEBUG CAREFUL: Skipping var 16: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.166667
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.166667
DEBUG CAREFUL: Adding var 18 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.166667
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 6 fractional variables

  %  Carefully choosing branching variable, nfrac = 6
DEBUG CAREFUL: Testing fvar[0] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 17
DEBUG CAREFUL: New best var: 17
DEBUG CAREFUL: Testing fvar[1] = var 18
DEBUG CAREFUL: Calling compare_branch_vars for var 18
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 18
DEBUG CAREFUL: New best var: 18
DEBUG CAREFUL: Testing fvar[2] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[3] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 3
DEBUG CAREFUL: New best var: 3
DEBUG CAREFUL: Testing fvar[4] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[5] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
  % Initial guess is x3, Z0 = 28317215.142111         , Z1 = 28414747.8137938        

DEBUG EVAL: Testing var 17 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=17, varin=18, theta=0.333333, up=999999999999999983222784.000000
ITER 2: row=34, varin=82, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 17 = 0 gives z=28355191.772809
  % 	x17 = 0,	Z0 = 28355191.772809         
DEBUG EVAL: First branch cutoff check: z=28355191.772809, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 17 = 1
ITER 1: row=17, varin=43, theta=5.000000, up=999999999999999983222784.000000
ITER 2: row=40, varin=40, theta=2.000000, up=999999999999999983222784.000000
ITER 3: row=9, varin=32, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=35, varin=39, theta=2.000000, up=999999999999999983222784.000000
ITER 5: row=1, varin=37, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=2, varin=30, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=29, varin=33, theta=0.333333, up=999999999999999983222784.000000
  % 	x17 = 1,	Z1 = 28423053.2034251        
DEBUG EVAL: Second branch cutoff check: z=28423053.203425, best_z=INF, threshold=INF
  %   New best:  x17, Z = 28355191.772809         
DEBUG EVAL: Testing var 18 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=32, varin=43, theta=5.000000, up=999999999999999983222784.000000
ITER 2: row=40, varin=40, theta=2.000000, up=999999999999999983222784.000000
ITER 3: row=9, varin=39, theta=2.000000, up=999999999999999983222784.000000
ITER 4: row=1, varin=37, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=2, varin=30, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=29, varin=18, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=34, varin=3, theta=1.000000, up=999999999999999983222784.000000
ITER 8: row=37, varin=28, theta=0.428571, up=999999999999999983222784.000000
ITER 9: row=28, varin=33, theta=1.000000, up=999999999999999983222784.000000
ITER 10: row=12, varin=19, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 18 = 1 gives z=28494103.939925
  % 	x18 = 1,	Z1 = 28494103.9399246        
DEBUG EVAL: First branch cutoff check: z=28494103.939925, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 18 = 0
ITER 1: row=32, varin=32, theta=0.333333, up=999999999999999983222784.000000
ITER 2: row=35, varin=82, theta=1.000000, up=1.000000
  % 	x18 = 0,	Z0 = 28355191.772809         
DEBUG EVAL: Second branch cutoff check: z=28355191.772809, best_z=INF, threshold=INF
  %   New best:  x18, Z = 28355191.772809         
DEBUG EVAL: Testing var 10 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=12, varin=43, theta=5.000000, up=999999999999999983222784.000000
ITER 2: row=40, varin=40, theta=2.000000, up=999999999999999983222784.000000
ITER 3: row=9, varin=33, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 1 gives z=28384993.457515
  % 	x10 = 1,	Z1 = 28384993.4575153        
DEBUG EVAL: First branch cutoff check: z=28384993.457515, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 0
ITER 1: row=12, varin=14, theta=0.200000, up=999999999999999983222784.000000
ITER 2: row=35, varin=82, theta=1.000000, up=1.000000
  % 	x10 = 0,	Z0 = 28355191.772809         
DEBUG EVAL: Second branch cutoff check: z=28355191.772809, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 3 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=9, varin=43, theta=5.000000, up=999999999999999983222784.000000
ITER 2: row=40, varin=32, theta=2.000000, up=999999999999999983222784.000000
ITER 3: row=35, varin=39, theta=4.000000, up=999999999999999983222784.000000
ITER 4: row=1, varin=17, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=41, varin=37, theta=3.000000, up=999999999999999983222784.000000
ITER 6: row=2, varin=30, theta=3.000000, up=999999999999999983222784.000000
ITER 7: row=29, varin=33, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 3 = 1 gives z=28503598.745471
  % 	x3 = 1,	Z1 = 28503598.7454712        
DEBUG EVAL: First branch cutoff check: z=28503598.745471, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 3 = 0
ITER 1: row=9, varin=40, theta=0.250000, up=999999999999999983222784.000000
  % 	x3 = 0,	Z0 = 28322065.1224897        
DEBUG EVAL: Second branch cutoff check: z=28322065.122490, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 2 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=39, theta=0.200000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 0 gives z=28323654.678528
  % 	x2 = 0,	Z0 = 28323654.678528         
DEBUG EVAL: First branch cutoff check: z=28323654.678528, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 26 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=40, varin=40, theta=2.500000, up=999999999999999983222784.000000
ITER 2: row=9, varin=33, theta=0.750000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 26 = 1 gives z=28402781.065559
  % 	x26 = 1,	Z1 = 28402781.0655589        
DEBUG EVAL: First branch cutoff check: z=28402781.065559, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 26 = 0
ITER 1: row=40, varin=43, theta=0.200000, up=999999999999999983222784.000000
  % 	x26 = 0,	Z0 = 28318068.6872978        
DEBUG EVAL: Second branch cutoff check: z=28318068.687298, best_z=INF, threshold=INF
  % Best branch is x18, Z0 = 28355191.772809         , Z1 = 28494103.9399246        

DEBUG CAREFUL: Final result - returning best.var = 18
DEBUG BB: Branching variable chosen: j=18
 % @NC   65   37	x18 = 0	28355191.772809
 % @NC   66   37	x18 = 1	28494103.939925
 %      37    27 28317215.1421               28318533.4927   x16 U    18     5
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde83ad260
% @LO 0.06  28.31721514211102430636 99.9000000000
% @LN 0.06  28.31853349267506203546 99.9000000000
% Resuming node 55 at  28.31853349267506203546
DEBUG CONSTRNT: LP rows=45, pool->nlprows=45, pool->npend=0
DEBUG CONSTRNT: Checking 45 LP rows (pool tracks 45, total LP rows 45)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 49
DEBUG CONSTRNT: Pool row 49 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 68
DEBUG CONSTRNT: Pool row 68 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 82
DEBUG CONSTRNT: Pool row 82 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 121
DEBUG CONSTRNT: Pool row 121 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=44, expected 44
 % @PAP adding 47 rows, 186 nz to LP
DEBUG BB: Processing node 55, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 55 LP 2 Solution, length = 28318533.492675, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.500000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.500000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.500000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 1.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.500000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.500000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.500000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 3 fractional variables
DEBUG CG: LP optimal, z=28318533.492675, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28318533.492675, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 55 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 55
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.500000
DEBUG CAREFUL: Adding var 8 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.500000
DEBUG CAREFUL: Adding var 9 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.500000
DEBUG CAREFUL: Adding var 14 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=1.000000
DEBUG CAREFUL: Skipping var 20: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 3 fractional variables

  %  Carefully choosing branching variable, nfrac = 3
DEBUG CAREFUL: Testing fvar[0] = var 9
DEBUG CAREFUL: Calling compare_branch_vars for var 9
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 9
DEBUG CAREFUL: New best var: 9
DEBUG CAREFUL: Testing fvar[1] = var 8
DEBUG CAREFUL: Calling compare_branch_vars for var 8
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 8
DEBUG CAREFUL: Testing fvar[2] = var 14
DEBUG CAREFUL: Calling compare_branch_vars for var 14
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 14
  % Initial guess is x9, Z0 = 28318533.4926751        , Z1 = 28330795.7789778        

DEBUG EVAL: Testing var 9 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=27, varin=45, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 9 = 1 gives z=28327722.322049
  % 	x9 = 1,	Z1 = 28330795.7789778        
DEBUG EVAL: First branch cutoff check: z=28330795.778978, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 9 = 0
ITER 1: row=27, varin=65, theta=0.333333, up=1.000000
ITER 2: row=33, varin=48, theta=0.705882, up=1.000000
ITER 3: row=12, varin=49, theta=0.857143, up=1.000000
ITER 4: row=2, varin=60, theta=0.500000, up=1.000000
  % 	x9 = 0,	Z0 = 28357039.6826076        
DEBUG EVAL: Second branch cutoff check: z=28357039.682608, best_z=INF, threshold=INF
  %   New best:  x9, Z = 28330795.7789778        
DEBUG EVAL: Testing var 8 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=45, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 8 = 0 gives z=28327722.322049
  % 	x8 = 0,	Z0 = 28327722.3220494        
DEBUG EVAL: First branch cutoff check: z=28327722.322049, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 14 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=40, varin=45, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 14 = 1 gives z=28327722.322049
  % 	x14 = 1,	Z1 = 28327722.3220494        
DEBUG EVAL: First branch cutoff check: z=28327722.322049, best_z=INF, threshold=INF
  % Best branch is x9, Z0 = 28357039.6826076        , Z1 = 28330795.7789778        

DEBUG CAREFUL: Final result - returning best.var = 9
DEBUG BB: Branching variable chosen: j=9
 % @NC   67   55	x9 = 1	28330795.778978
 % @NC   68   55	x9 = 0	28357039.682608
 %      55    28 28318533.4927               28320214.2940   x15 D    45     7
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde83adf70
% @LO 0.06  28.31853349267506203546 99.9000000000
% @LN 0.06  28.32021429403160794891 99.9000000000
% Resuming node 58 at  28.32021429403160794891
DEBUG CONSTRNT: LP rows=47, pool->nlprows=47, pool->npend=0
DEBUG CONSTRNT: Checking 47 LP rows (pool tracks 47, total LP rows 47)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 141
DEBUG CONSTRNT: Pool row 141 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 145
DEBUG CONSTRNT: Pool row 145 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 159
DEBUG CONSTRNT: Pool row 159 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 79
DEBUG CONSTRNT: Pool row 79 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 45
DEBUG CONSTRNT: Pool row 45 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 62
DEBUG CONSTRNT: Pool row 62 has lprow=46, expected 46
 % @PAP adding 43 rows, 193 nz to LP
DEBUG BB: Processing node 58, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=5, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=8, varin=43, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 28302150.682981
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 43 rows, 60 cols, 253 nonzeros, 1 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 13 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=44, varin=32, theta=0.346154, up=999999999999999983222784.000000
ITER 2: row=40, varin=39, theta=0.382979, up=999999999999999983222784.000000
ITER 3: row=43, varin=8, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=5, varin=7, theta=0.500000, up=999999999999999983222784.000000
ITER 5: row=46, varin=5, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=42, varin=40, theta=5.000000, up=999999999999999983222784.000000
ITER 7: row=37, varin=11, theta=1.000000, up=999999999999999983222784.000000
ITER 8: row=46, varin=17, theta=0.070175, up=999999999999999983222784.000000
ITER 9: row=44, varin=81, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=9)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 28691647.998035
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 0.500000
DEBUG SOLUTION: lp->best_solution[8] = 0.500000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.500000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 47 rows, 60 cols, 266 nonzeros, 5 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=43, varin=6, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 29083255.601018
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 43 rows, 60 cols, 253 nonzeros, 1 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 2 rows, 42 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=44, varin=25, theta=0.448120, up=999999999999999983222784.000000
ITER 2: row=26, varin=39, theta=0.137906, up=999999999999999983222784.000000
ITER 3: row=43, varin=72, theta=1.159482, up=1.000000
ITER 4: row=43, varin=75, theta=0.141784, up=1.000000
ITER 5: row=26, varin=67, theta=0.259208, up=1.000000
ITER 6: row=3, varin=33, theta=0.629725, up=999999999999999983222784.000000
ITER 7: row=26, varin=39, theta=0.244333, up=999999999999999983222784.000000
ITER 8: row=43, varin=72, theta=0.205110, up=1.000000
LP PHASE: Switching to primal (iter=8)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 29140756.174731
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.903478
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.903478
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 44 rows, 60 cols, 293 nonzeros, 6 slack, 38 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 6 slack rows
  % @PAP adding 5 rows, 12 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=41, varin=74, theta=0.938800, up=1.000000
ITER 2: row=33, varin=66, theta=0.697033, up=1.000000
ITER 3: row=43, varin=31, theta=0.580719, up=999999999999999983222784.000000
ITER 4: row=39, varin=29, theta=0.371513, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
ITER 5: row=31, varin=38, theta=132544.000000, up=999999999999999983222784.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 29767752.345174
DEBUG SOLUTION: lp->best_solution[1] = 19.297210
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 43 rows, 60 cols, 282 nonzeros, 2 slack, 41 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 6 rows, 63 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=61, theta=4.000000, up=1.000000
ITER 2: row=1, varin=64, theta=3.000000, up=1.000000
ITER 3: row=1, varin=63, theta=2.000000, up=1.000000
ITER 4: row=1, varin=56, theta=1.500000, up=1.000000
ITER 5: row=1, varin=62, theta=0.333333, up=1.000000
ITER 6: row=47, varin=56, theta=8.154564, up=1.000000
ITER 7: row=47, varin=88, theta=9.542470, up=1.000000
ITER 8: row=47, varin=89, theta=8.542470, up=1.000000
ITER 9: row=47, varin=90, theta=7.542470, up=1.000000
ITER 10: row=47, varin=91, theta=6.542470, up=1.000000
LP PHASE: Switching to primal (iter=81)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 29180970.939972
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 47 rows, 60 cols, 301 nonzeros, 6 slack, 41 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=48, varin=81, theta=0.973359, up=1.000000
LP PHASE: Switching to primal (iter=1)
ITER 2: row=19, varin=70, theta=0.000000, up=1.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 29191412.842598
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 48 rows, 60 cols, 303 nonzeros, 5 slack, 43 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=49, varin=74, theta=0.365883, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 29197523.916464
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 50 rows, 60 cols, 309 nonzeros, 5 slack, 45 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 58 LP 1 Solution, length = 29197523.916464, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.634117 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.105686 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.105686 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.105686 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.105686 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.105686 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.634117 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.634117 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.105686 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 1.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.365883 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.105686 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.365883 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.365883 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.894314 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.365883 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.894314 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.894314 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.894314 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 0.365883 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.894314 (terminal 19)
 % 12 fractional variables
DEBUG CG: LP optimal, z=29197523.916464, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 58 at  29.19752391646374789502
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde83a93e0
% @LO 0.06  28.32021429403160794891 99.9000000000
% @LN 0.06  28.32239114735432039538 99.9000000000
% Resuming node 59 at  28.32239114735432039538
DEBUG CONSTRNT: LP rows=50, pool->nlprows=50, pool->npend=0
DEBUG CONSTRNT: Checking 50 LP rows (pool tracks 50, total LP rows 50)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 142
DEBUG CONSTRNT: Pool row 142 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 143
DEBUG CONSTRNT: Pool row 143 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 135
DEBUG CONSTRNT: Pool row 135 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=49, expected 49
 % @PAP adding 47 rows, 198 nz to LP
DEBUG BB: Processing node 59, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=46, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=27, varin=30, theta=0.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 28322391.147354
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 47 rows, 60 cols, 258 nonzeros, 3 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 5 rows, 29 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=50, varin=44, theta=0.120000, up=999999999999999983222784.000000
ITER 2: row=49, varin=50, theta=11.000000, up=999999999999999983222784.000000
ITER 3: row=51, varin=67, theta=0.666667, up=1.000000
ITER 4: row=46, varin=61, theta=0.333333, up=1.000000
ITER 5: row=52, varin=45, theta=0.043478, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 28342925.278634
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 52 rows, 60 cols, 287 nonzeros, 5 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=48, varin=47, theta=1.200000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 28343993.580798
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 48 rows, 60 cols, 257 nonzeros, 1 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 59 LP 1 Solution, length = 28343993.580798, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.200000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.200000 (FST 9)
  % DEBUG LP_VARS: x[10] = 1.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.400000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.400000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.600000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.600000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.600000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.800000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.600000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.600000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=28343993.580798, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 59 at  28.34399358079753028505
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde83b5ba0
% @LO 0.06  28.32239114735432039538 99.9000000000
% @LN 0.06  28.32510684831938618800 99.9000000000
% Resuming node 53 at  28.32510684831938618800
DEBUG CONSTRNT: LP rows=47, pool->nlprows=47, pool->npend=0
DEBUG CONSTRNT: Checking 47 LP rows (pool tracks 47, total LP rows 47)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 79
DEBUG CONSTRNT: Pool row 79 has lprow=46, expected 46
 % @PAP adding 45 rows, 179 nz to LP
DEBUG BB: Processing node 53, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=7, varin=45, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 28325106.848319
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 45 rows, 60 cols, 239 nonzeros, 1 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 14 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=46, varin=31, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=32, varin=77, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 28364290.999947
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 49 rows, 60 cols, 253 nonzeros, 2 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 3 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=48, varin=81, theta=0.500000, up=1.000000
ITER 2: row=47, varin=73, theta=0.500000, up=1.000000
ITER 3: row=50, varin=74, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28408310.547225
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 50 rows, 60 cols, 256 nonzeros, 0 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 19 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=51, varin=87, theta=1.000000, up=1.000000
ITER 2: row=49, varin=76, theta=1.000000, up=1.000000
ITER 3: row=30, varin=25, theta=0.500000, up=999999999999999983222784.000000
ITER 4: row=42, varin=27, theta=0.200000, up=999999999999999983222784.000000
ITER 5: row=40, varin=38, theta=0.250000, up=999999999999999983222784.000000
ITER 6: row=43, varin=7, theta=0.250000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=54)
DEBUG SOLUTION: LP solution array indices: FST[55-94], not_covered[95-114]
DEBUG SOLUTION: lp->best_solution[0] = 28466170.535836
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 0.750000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 0.750000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 54 rows, 60 cols, 275 nonzeros, 2 slack, 52 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 2 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=53, varin=40, theta=0.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=54)
DEBUG SOLUTION: LP solution array indices: FST[55-94], not_covered[95-114]
DEBUG SOLUTION: lp->best_solution[0] = 28478937.018029
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 54 rows, 60 cols, 275 nonzeros, 3 slack, 51 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 2 rows, 7 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=53, varin=30, theta=0.333333, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=53)
DEBUG SOLUTION: LP solution array indices: FST[54-93], not_covered[94-113]
DEBUG SOLUTION: lp->best_solution[0] = 28484890.257664
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 53 rows, 60 cols, 276 nonzeros, 5 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % @PAP adding 3 rows, 14 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=51, varin=39, theta=0.066667, up=999999999999999983222784.000000
ITER 2: row=49, varin=80, theta=1.000000, up=1.000000
ITER 3: row=15, varin=51, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=47, varin=41, theta=0.250000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 28494706.697229
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 51 rows, 60 cols, 269 nonzeros, 2 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % Node 53 LP 1 Solution, length = 28494706.697229, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.250000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.250000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.250000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.250000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.250000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.250000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.250000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.750000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.750000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.750000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.750000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.750000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.750000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.750000 (terminal 19)
 % 7 fractional variables
DEBUG CG: LP optimal, z=28494706.697229, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 53 at  28.49470669722931859269
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde83b0540
% @LO 0.06  28.32510684831938618800 99.9000000000
% @LN 0.06  28.32806112293601685792 99.9000000000
% Resuming node 60 at  28.32806112293601685792
DEBUG CONSTRNT: LP rows=49, pool->nlprows=49, pool->npend=0
DEBUG CONSTRNT: Checking 49 LP rows (pool tracks 49, total LP rows 49)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=48, expected 48
 % @PAP adding 47 rows, 198 nz to LP
DEBUG BB: Processing node 60, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=65, theta=0.367347, up=1.000000
ITER 2: row=37, varin=48, theta=0.705882, up=1.000000
ITER 3: row=12, varin=49, theta=0.857143, up=1.000000
ITER 4: row=2, varin=29, theta=0.580645, up=999999999999999983222784.000000
ITER 5: row=35, varin=58, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 28328061.122936
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 47 rows, 60 cols, 258 nonzeros, 0 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 60 LP 1 Solution, length = 28328061.122936, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.500000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.500000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.500000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.500000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.500000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 2 fractional variables
DEBUG CG: LP optimal, z=28328061.122936, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28328061.122936, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 60 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 60
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=1.000000
DEBUG CAREFUL: Skipping var 7: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.500000
DEBUG CAREFUL: Adding var 14 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.500000
DEBUG CAREFUL: Adding var 15 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 2 fractional variables

  %  Carefully choosing branching variable, nfrac = 2
DEBUG CAREFUL: Testing fvar[0] = var 14
DEBUG CAREFUL: Calling compare_branch_vars for var 14
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 14
DEBUG CAREFUL: New best var: 14
DEBUG CAREFUL: Testing fvar[1] = var 15
DEBUG CAREFUL: Calling compare_branch_vars for var 15
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 15
DEBUG CAREFUL: New best var: 15
  % Initial guess is x15, Z0 = 28343092.3021845        , Z1 = 28328061.122936         

DEBUG EVAL: Testing var 14 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=27, varin=46, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=28, varin=60, theta=0.500000, up=1.000000
DEBUG EVAL: Branch var 14 = 0 gives z=28364748.970044
  % 	x14 = 0,	Z0 = 28364748.9700442        
DEBUG EVAL: First branch cutoff check: z=28364748.970044, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 14 = 1
ITER 1: row=27, varin=43, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=47, varin=40, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=28, varin=60, theta=0.500000, up=1.000000
  % 	x14 = 1,	Z1 = 28412048.9952223        
DEBUG EVAL: Second branch cutoff check: z=28412048.995222, best_z=INF, threshold=INF
  %   New best:  x14, Z = 28364748.9700442        
DEBUG EVAL: Testing var 15 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=39, varin=46, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=28, varin=60, theta=0.500000, up=1.000000
DEBUG EVAL: Branch var 15 = 1 gives z=28364748.970044
  % 	x15 = 1,	Z1 = 28364748.9700442        
DEBUG EVAL: First branch cutoff check: z=28364748.970044, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 15 = 0
ITER 1: row=39, varin=43, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=47, varin=56, theta=1.000000, up=1.000000
ITER 3: row=28, varin=60, theta=0.500000, up=1.000000
ITER 4: row=11, varin=27, theta=0.500000, up=999999999999999983222784.000000
  % 	x15 = 0,	Z0 = 28402901.2163998        
DEBUG EVAL: Second branch cutoff check: z=28402901.216400, best_z=INF, threshold=INF
  % Best branch is x14, Z0 = 28364748.9700442        , Z1 = 28412048.9952223        

DEBUG CAREFUL: Final result - returning best.var = 14
DEBUG BB: Branching variable chosen: j=14
 % @NC   69   60	x14 = 0	28364748.970044
 % @NC   70   60	x14 = 1	28412048.995222
 %      60    29 28328061.1229               28330795.7790    x7 U    38     6
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde839a8b0
% @LO 0.06  28.32806112293601685792 99.9000000000
% @LN 0.06  28.33079577897780154672 99.9000000000
% Resuming node 67 at  28.33079577897780154672
DEBUG CONSTRNT: LP rows=47, pool->nlprows=47, pool->npend=0
DEBUG CONSTRNT: Checking 47 LP rows (pool tracks 47, total LP rows 47)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=46, expected 46
 % @PAP adding 47 rows, 186 nz to LP
DEBUG BB: Processing node 67, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=27, varin=45, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 28327722.322049
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 47 rows, 60 cols, 246 nonzeros, 2 slack, 45 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 58 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=51, varin=30, theta=0.539023, up=999999999999999983222784.000000
ITER 2: row=28, varin=27, theta=0.440501, up=999999999999999983222784.000000
ITER 3: row=50, varin=28, theta=0.061655, up=999999999999999983222784.000000
ITER 4: row=48, varin=50, theta=11.087517, up=999999999999999983222784.000000
ITER 5: row=46, varin=47, theta=0.919460, up=999999999999999983222784.000000
ITER 6: row=50, varin=64, theta=0.273031, up=1.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 28412542.236850
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 51 rows, 60 cols, 304 nonzeros, 5 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % @PAP adding 4 rows, 15 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=47, varin=105, theta=3.901860, up=1.000000
ITER 2: row=47, varin=68, theta=0.242065, up=1.000000
ITER 3: row=29, varin=105, theta=1.000000, up=1.000000
ITER 4: row=32, varin=53, theta=0.437695, up=1.000000
ITER 5: row=22, varin=75, theta=0.954061, up=1.000000
ITER 6: row=3, varin=38, theta=0.651527, up=999999999999999983222784.000000
ITER 7: row=49, varin=77, theta=0.400437, up=1.000000
ITER 8: row=50, varin=51, theta=0.503767, up=1.000000
ITER 9: row=12, varin=44, theta=0.330579, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=9)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28537273.434957
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 50 rows, 60 cols, 291 nonzeros, 3 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 2 rows, 5 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=48, varin=56, theta=0.414405, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 28561405.487737
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 49 rows, 60 cols, 287 nonzeros, 0 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=50, varin=25, theta=3.716429, up=999999999999999983222784.000000
ITER 2: row=1, varin=75, theta=0.120374, up=1.000000
ITER 3: row=44, varin=54, theta=0.140012, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 28565344.033889
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 51 rows, 60 cols, 291 nonzeros, 3 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 4 rows, 13 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=49, varin=82, theta=0.177066, up=1.000000
ITER 2: row=14, varin=74, theta=0.129729, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 28606562.631625
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 52 rows, 60 cols, 296 nonzeros, 0 slack, 52 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 16 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=53, varin=84, theta=0.167028, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=56)
DEBUG SOLUTION: LP solution array indices: FST[57-96], not_covered[97-116]
DEBUG SOLUTION: lp->best_solution[0] = 28612855.101384
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 56 rows, 60 cols, 312 nonzeros, 0 slack, 56 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 67 LP 1 Solution, length = 28612855.101384, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.832972 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 1.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 1.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.167028 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.167028 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 2 fractional variables
DEBUG CG: LP optimal, z=28612855.101384, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 67 at  28.61285510138388232804
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde839c580
% @LO 0.06  28.33079577897780154672 99.9000000000
% @LN 0.06  28.33149407549343834489 99.9000000000
% Resuming node 46 at  28.33149407549343834489
DEBUG CONSTRNT: LP rows=56, pool->nlprows=56, pool->npend=0
DEBUG CONSTRNT: Checking 56 LP rows (pool tracks 56, total LP rows 56)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 141
DEBUG CONSTRNT: Pool row 141 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 145
DEBUG CONSTRNT: Pool row 145 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 159
DEBUG CONSTRNT: Pool row 159 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 63
DEBUG CONSTRNT: Pool row 63 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=54, expected 54
DEBUG CONSTRNT: Checking LP row 55 -> pool row 121
DEBUG CONSTRNT: Pool row 121 has lprow=55, expected 55
 % @PAP adding 48 rows, 226 nz to LP
DEBUG BB: Processing node 46, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=57, theta=1.614196, up=1.000000
ITER 2: row=1, varin=61, theta=0.295227, up=1.000000
ITER 3: row=42, varin=30, theta=0.426701, up=999999999999999983222784.000000
ITER 4: row=28, varin=27, theta=0.419254, up=999999999999999983222784.000000
ITER 5: row=27, varin=57, theta=0.408054, up=1.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 28331494.075493
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 48 rows, 60 cols, 286 nonzeros, 1 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 8 rows, 47 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=49, varin=71, theta=0.200893, up=1.000000
ITER 2: row=51, varin=81, theta=1.753660, up=1.000000
ITER 3: row=51, varin=83, theta=0.389718, up=1.000000
ITER 4: row=3, varin=81, theta=1.000000, up=1.000000
ITER 5: row=55, varin=49, theta=0.276152, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=56)
DEBUG SOLUTION: LP solution array indices: FST[57-96], not_covered[97-116]
DEBUG SOLUTION: lp->best_solution[0] = 28445166.289107
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 56 rows, 60 cols, 333 nonzeros, 6 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 6 slack rows
  % @PAP adding 2 rows, 5 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=51, varin=38, theta=1.243549, up=999999999999999983222784.000000
ITER 2: row=49, varin=76, theta=0.793032, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 28472144.456159
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 52 rows, 60 cols, 293 nonzeros, 0 slack, 52 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 5 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=53, varin=57, theta=1.105040, up=1.000000
ITER 2: row=53, varin=50, theta=1.356885, up=999999999999999983222784.000000
ITER 3: row=50, varin=77, theta=0.071140, up=1.000000
ITER 4: row=22, varin=57, theta=1.000000, up=1.000000
ITER 5: row=32, varin=76, theta=0.723811, up=1.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=54)
DEBUG SOLUTION: LP solution array indices: FST[55-94], not_covered[95-114]
DEBUG SOLUTION: lp->best_solution[0] = 28689860.014737
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 54 rows, 60 cols, 298 nonzeros, 0 slack, 54 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 13 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=55, varin=88, theta=0.671447, up=1.000000
ITER 2: row=14, varin=65, theta=1.370541, up=1.000000
ITER 3: row=14, varin=84, theta=0.137493, up=1.000000
ITER 4: row=56, varin=65, theta=0.084406, up=1.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=58)
DEBUG SOLUTION: LP solution array indices: FST[59-98], not_covered[99-118]
DEBUG SOLUTION: lp->best_solution[0] = 28731407.384746
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 58 rows, 60 cols, 311 nonzeros, 1 slack, 57 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 6 rows, 30 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=58, varin=56, theta=0.224990, up=999999999999999983222784.000000
ITER 2: row=62, varin=92, theta=0.253914, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=63)
DEBUG SOLUTION: LP solution array indices: FST[64-103], not_covered[104-123]
DEBUG SOLUTION: lp->best_solution[0] = 28773958.363265
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 63 rows, 60 cols, 337 nonzeros, 4 slack, 59 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % @PAP adding 2 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=60, varin=46, theta=0.026198, up=999999999999999983222784.000000
ITER 2: row=58, varin=57, theta=0.022823, up=999999999999999983222784.000000
ITER 3: row=61, varin=60, theta=0.063425, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=61)
DEBUG SOLUTION: LP solution array indices: FST[62-101], not_covered[102-121]
DEBUG SOLUTION: lp->best_solution[0] = 28775730.683662
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 61 rows, 60 cols, 312 nonzeros, 4 slack, 57 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % Node 46 LP 1 Solution, length = 28775730.683662, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.194033 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.257458 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.194033 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.257458 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 1.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.257458 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.257458 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.194033 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.742542 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.805967 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.742542 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.742542 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 7 fractional variables
DEBUG CG: LP optimal, z=28775730.683662, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 46 at  28.77573068366179853683
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde83b0600
% @LO 0.06  28.33149407549343834489 99.9000000000
% @LN 0.06  28.33400055898005831523 99.9000000000
% Resuming node 22 at  28.33400055898005831523
DEBUG CONSTRNT: LP rows=57, pool->nlprows=57, pool->npend=0
DEBUG CONSTRNT: Checking 57 LP rows (pool tracks 57, total LP rows 57)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 141
DEBUG CONSTRNT: Pool row 141 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 145
DEBUG CONSTRNT: Pool row 145 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 159
DEBUG CONSTRNT: Pool row 159 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=54, expected 54
DEBUG CONSTRNT: Checking LP row 55 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=55, expected 55
DEBUG CONSTRNT: Checking LP row 56 -> pool row 58
DEBUG CONSTRNT: Pool row 58 has lprow=56, expected 56
 % @PAP adding 46 rows, 217 nz to LP
DEBUG BB: Processing node 22, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 22 LP 2 Solution, length = 28334000.558980, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.272294 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.272294 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.363853 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.363853 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.816881 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.183119 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.183119 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.636147 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.636147 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.183119 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.183119 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.636147 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.636147 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.183119 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28334000.558980, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28334000.558980, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 22 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 22
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=1.000000
DEBUG CAREFUL: Skipping var 5: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.272294
DEBUG CAREFUL: Adding var 9 to fractional list (xi=0.272294)
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.272294
DEBUG CAREFUL: Adding var 12 to fractional list (xi=0.272294)
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.363853
DEBUG CAREFUL: Adding var 14 to fractional list (xi=0.363853)
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.363853
DEBUG CAREFUL: Adding var 15 to fractional list (xi=0.363853)
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.816881
DEBUG CAREFUL: Adding var 20 to fractional list (xi=0.816881)
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 20
DEBUG CAREFUL: Calling compare_branch_vars for var 20
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 20
DEBUG CAREFUL: New best var: 20
DEBUG CAREFUL: Testing fvar[1] = var 9
DEBUG CAREFUL: Calling compare_branch_vars for var 9
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 9
DEBUG CAREFUL: New best var: 9
DEBUG CAREFUL: Testing fvar[2] = var 12
DEBUG CAREFUL: Calling compare_branch_vars for var 12
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 12
DEBUG CAREFUL: Testing fvar[3] = var 14
DEBUG CAREFUL: Calling compare_branch_vars for var 14
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 14
DEBUG CAREFUL: Testing fvar[4] = var 15
DEBUG CAREFUL: Calling compare_branch_vars for var 15
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 15
  % Initial guess is x9, Z0 = 28334000.5589801        , Z1 = 28418982.9053198        

DEBUG EVAL: Testing var 20 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=6, varin=12, theta=0.212213, up=999999999999999983222784.000000
ITER 2: row=11, varin=7, theta=0.353244, up=999999999999999983222784.000000
ITER 3: row=1, varin=22, theta=1.665843, up=999999999999999983222784.000000
ITER 4: row=8, varin=8, theta=0.740662, up=999999999999999983222784.000000
ITER 5: row=2, varin=34, theta=0.537824, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 20 = 1 gives z=28407748.031880
  % 	x20 = 1,	Z1 = 28407748.0318802        
DEBUG EVAL: First branch cutoff check: z=28407748.031880, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 20 = 0
ITER 1: row=6, varin=7, theta=1.896202, up=999999999999999983222784.000000
ITER 2: row=13, varin=38, theta=892415.000000, up=999999999999999983222784.000000
ITER 3: row=39, varin=3, theta=0.618638, up=999999999999999983222784.000000
  % 	x20 = 0,	Z0 = 28387986.6549873        
DEBUG EVAL: Second branch cutoff check: z=28387986.654987, best_z=INF, threshold=INF
  %   New best:  x20, Z = 28387986.6549873        
DEBUG EVAL: Testing var 9 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=22, varin=12, theta=0.618523, up=999999999999999983222784.000000
ITER 2: row=11, varin=22, theta=0.836468, up=999999999999999983222784.000000
ITER 3: row=8, varin=7, theta=0.700078, up=999999999999999983222784.000000
ITER 4: row=1, varin=3, theta=2.246134, up=999999999999999983222784.000000
ITER 5: row=3, varin=35, theta=1.139205, up=999999999999999983222784.000000
ITER 6: row=34, varin=31, theta=0.266324, up=999999999999999983222784.000000
ITER 7: row=31, varin=8, theta=0.272051, up=999999999999999983222784.000000
ITER 8: row=19, varin=45, theta=0.288521, up=999999999999999983222784.000000
ITER 9: row=35, varin=19, theta=0.162823, up=999999999999999983222784.000000
ITER 10: row=2, varin=27, theta=0.295438, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 9 = 1 gives z=28418982.905320
  % 	x9 = 1,	Z1 = 28418982.9053198        
DEBUG EVAL: First branch cutoff check: z=28418982.905320, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 9 = 0
ITER 1: row=22, varin=7, theta=1.069031, up=999999999999999983222784.000000
ITER 2: row=13, varin=38, theta=892415.000000, up=999999999999999983222784.000000
ITER 3: row=39, varin=25, theta=1.435660, up=999999999999999983222784.000000
  % 	x9 = 0,	Z0 = 28370530.2725491        
DEBUG EVAL: Second branch cutoff check: z=28370530.272549, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 12 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=34, varin=12, theta=0.618523, up=999999999999999983222784.000000
ITER 2: row=11, varin=22, theta=0.836468, up=999999999999999983222784.000000
ITER 3: row=8, varin=7, theta=0.700078, up=999999999999999983222784.000000
ITER 4: row=1, varin=3, theta=2.246134, up=999999999999999983222784.000000
ITER 5: row=3, varin=8, theta=2.226377, up=999999999999999983222784.000000
ITER 6: row=19, varin=34, theta=0.932765, up=999999999999999983222784.000000
ITER 7: row=6, varin=45, theta=0.640606, up=999999999999999983222784.000000
ITER 8: row=35, varin=97, theta=1.714270, up=1.000000
ITER 9: row=35, varin=38, theta=71629.500000, up=999999999999999983222784.000000
ITER 10: row=13, varin=97, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 12 = 1 gives z=28475087.883434
  % 	x12 = 1,	Z1 = 28475087.8834343        
DEBUG EVAL: First branch cutoff check: z=28475087.883434, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 12 = 0
ITER 1: row=34, varin=7, theta=1.069031, up=999999999999999983222784.000000
ITER 2: row=13, varin=38, theta=892415.000000, up=999999999999999983222784.000000
ITER 3: row=39, varin=25, theta=1.435660, up=999999999999999983222784.000000
  % 	x12 = 0,	Z0 = 28370530.2725491        
DEBUG EVAL: Second branch cutoff check: z=28370530.272549, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 14 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=35, varin=12, theta=0.618523, up=999999999999999983222784.000000
ITER 2: row=11, varin=22, theta=0.836468, up=999999999999999983222784.000000
ITER 3: row=8, varin=7, theta=0.700078, up=999999999999999983222784.000000
ITER 4: row=1, varin=3, theta=2.246134, up=999999999999999983222784.000000
ITER 5: row=3, varin=45, theta=0.556266, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 14 = 0 gives z=28371054.202557
  % 	x14 = 0,	Z0 = 28371054.2025573        
DEBUG EVAL: First branch cutoff check: z=28371054.202557, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 15 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=38, varin=12, theta=0.618523, up=999999999999999983222784.000000
ITER 2: row=11, varin=22, theta=0.836468, up=999999999999999983222784.000000
ITER 3: row=8, varin=7, theta=0.700078, up=999999999999999983222784.000000
ITER 4: row=1, varin=41, theta=0.732996, up=999999999999999983222784.000000
ITER 5: row=46, varin=3, theta=2.246134, up=999999999999999983222784.000000
ITER 6: row=3, varin=35, theta=1.139205, up=999999999999999983222784.000000
ITER 7: row=34, varin=43, theta=0.135762, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 15 = 0 gives z=28399872.857730
  % 	x15 = 0,	Z0 = 28399872.8577303        
DEBUG EVAL: First branch cutoff check: z=28399872.857730, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 15 = 1
ITER 1: row=38, varin=7, theta=4.995057, up=999999999999999983222784.000000
ITER 2: row=2, varin=38, theta=3543723.750000, up=999999999999999983222784.000000
ITER 3: row=39, varin=45, theta=1.839101, up=999999999999999983222784.000000
ITER 4: row=2, varin=48, theta=1.000000, up=1.000000
ITER 5: row=35, varin=25, theta=3.060627, up=999999999999999983222784.000000
  % 	x15 = 1,	Z1 = 28478488.158448         
DEBUG EVAL: Second branch cutoff check: z=28478488.158448, best_z=INF, threshold=INF
  %   New best:  x15, Z = 28399872.8577303        
  % Best branch is x15, Z0 = 28399872.8577303        , Z1 = 28478488.158448         

DEBUG CAREFUL: Final result - returning best.var = 15
DEBUG BB: Branching variable chosen: j=15
 % @NC   71   22	x15 = 0	28399872.857730
 % @NC   72   22	x15 = 1	28478488.158448
 %      22    30 28334000.5590               28334177.6632   x19 D    15     4
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde83afb10
% @LO 0.06  28.33400055898005831523 99.9000000000
% @LN 0.06  28.33417766321088393511 99.9000000000
% Resuming node 48 at  28.33417766321088393511
DEBUG CONSTRNT: LP rows=46, pool->nlprows=46, pool->npend=0
DEBUG CONSTRNT: Checking 46 LP rows (pool tracks 46, total LP rows 46)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=45, expected 45
 % @PAP adding 46 rows, 179 nz to LP
DEBUG BB: Processing node 48, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=23, varin=24, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=42, varin=103, theta=1.000000, up=1.000000
ITER 3: row=39, varin=76, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=46)
DEBUG SOLUTION: LP solution array indices: FST[47-86], not_covered[87-106]
DEBUG SOLUTION: lp->best_solution[0] = 28334177.663211
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 46 rows, 60 cols, 239 nonzeros, 0 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 13 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=47, varin=19, theta=0.125000, up=999999999999999983222784.000000
ITER 2: row=40, varin=38, theta=0.111111, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28359485.406804
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 50 rows, 60 cols, 252 nonzeros, 3 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 3 rows, 7 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=48, varin=84, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28383658.391435
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 50 rows, 60 cols, 249 nonzeros, 2 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 4 rows, 14 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=49, varin=3, theta=0.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 28384858.433560
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.500000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 52 rows, 60 cols, 258 nonzeros, 3 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % Node 48 LP 1 Solution, length = 28384858.433560, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.500000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.500000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.500000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.500000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.500000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.500000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.500000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.500000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=28384858.433560, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 48 at  28.38485843355959303835
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde83b0d20
% @LO 0.06  28.33417766321088393511 99.9000000000
% @LN 0.06  28.33921442666879642047 99.9000000000
% Resuming node 24 at  28.33921442666879642047
DEBUG CONSTRNT: LP rows=49, pool->nlprows=49, pool->npend=0
DEBUG CONSTRNT: Checking 49 LP rows (pool tracks 49, total LP rows 49)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 85
DEBUG CONSTRNT: Pool row 85 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=48, expected 48
 % @PAP adding 39 rows, 165 nz to LP
DEBUG BB: Processing node 24, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=31, varin=37, theta=2.500000, up=999999999999999983222784.000000
ITER 2: row=12, varin=35, theta=3.000000, up=999999999999999983222784.000000
ITER 3: row=35, varin=33, theta=2.000000, up=999999999999999983222784.000000
ITER 4: row=2, varin=24, theta=2.000000, up=999999999999999983222784.000000
ITER 5: row=32, varin=3, theta=2.000000, up=999999999999999983222784.000000
ITER 6: row=33, varin=12, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=1, varin=28, theta=1.000000, up=999999999999999983222784.000000
ITER 8: row=28, varin=25, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=8)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=39)
DEBUG SOLUTION: LP solution array indices: FST[40-79], not_covered[80-99]
DEBUG SOLUTION: lp->best_solution[0] = 28339214.426669
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 39 rows, 60 cols, 225 nonzeros, 5 slack, 34 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 3 rows, 52 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=42, varin=5, theta=0.660101, up=999999999999999983222784.000000
ITER 2: row=40, varin=22, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=7, varin=55, theta=0.920359, up=1.000000
ITER 4: row=28, varin=45, theta=1.220653, up=1.000000
ITER 5: row=28, varin=67, theta=0.351874, up=1.000000
ITER 6: row=12, varin=45, theta=1.000000, up=1.000000
ITER 7: row=3, varin=69, theta=1.987012, up=1.000000
ITER 8: row=3, varin=66, theta=0.920793, up=1.000000
ITER 9: row=34, varin=21, theta=1.605806, up=999999999999999983222784.000000
ITER 10: row=21, varin=46, theta=0.850558, up=1.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 999999999999999983222784.000000
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 42 rows, 60 cols, 277 nonzeros, 9 slack, 33 tight.
  % Node 24 LP 1 Solution, length = 999999999999999983222784.000000, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 1.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 1.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
DEBUG BB: compute_good_lower_bound returned status=1
DEBUG BB: Node 24 is INFEASIBLE
 %      24    29    infeasible               28340760.1566   x18 U    12     5
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde83ba750
% @LO 0.06  28.33921442666879642047 99.9000000000
% @LN 0.06  28.34076015656856739611 99.9000000000
% Resuming node 56 at  28.34076015656856739611
DEBUG CONSTRNT: LP rows=42, pool->nlprows=42, pool->npend=0
DEBUG CONSTRNT: Checking 42 LP rows (pool tracks 42, total LP rows 42)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=41, expected 41
 % @PAP adding 48 rows, 188 nz to LP
DEBUG BB: Processing node 56, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=39, varin=48, theta=3.000000, up=999999999999999983222784.000000
ITER 2: row=47, varin=66, theta=0.333333, up=1.000000
ITER 3: row=1, varin=44, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=33, varin=49, theta=0.705882, up=1.000000
ITER 5: row=12, varin=50, theta=0.857143, up=1.000000
ITER 6: row=2, varin=61, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 28340760.156569
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 48 rows, 60 cols, 248 nonzeros, 3 slack, 45 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 52 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=52, varin=2, theta=0.219127, up=999999999999999983222784.000000
ITER 2: row=17, varin=104, theta=0.369992, up=1.000000
ITER 3: row=49, varin=61, theta=0.716208, up=1.000000
ITER 4: row=27, varin=55, theta=1.001182, up=1.000000
ITER 5: row=27, varin=77, theta=0.002699, up=1.000000
ITER 6: row=22, varin=55, theta=1.000000, up=1.000000
ITER 7: row=3, varin=17, theta=12.060501, up=999999999999999983222784.000000
ITER 8: row=17, varin=79, theta=1.247566, up=1.000000
ITER 9: row=17, varin=25, theta=0.913706, up=999999999999999983222784.000000
ITER 10: row=52, varin=104, theta=0.345681, up=1.000000
LP PHASE: Switching to primal (iter=10)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 28512666.921325
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 52 rows, 60 cols, 300 nonzeros, 6 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 6 slack rows
  % @PAP adding 2 rows, 5 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=47, varin=75, theta=1.000000, up=1.000000
ITER 2: row=46, varin=72, theta=0.747863, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 28559227.852534
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 48 rows, 60 cols, 291 nonzeros, 0 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 13 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=49, varin=87, theta=1.120832, up=1.000000
ITER 2: row=49, varin=89, theta=0.129402, up=1.000000
ITER 3: row=46, varin=2, theta=0.068034, up=999999999999999983222784.000000
ITER 4: row=17, varin=13, theta=0.247837, up=999999999999999983222784.000000
ITER 5: row=19, varin=74, theta=0.198337, up=1.000000
ITER 6: row=49, varin=87, theta=0.222528, up=1.000000
ITER 7: row=45, varin=80, theta=0.295905, up=1.000000
LP PHASE: Switching to primal (iter=7)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 28673832.593251
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 52 rows, 60 cols, 304 nonzeros, 0 slack, 52 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 3 rows, 13 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=53, varin=85, theta=0.992602, up=1.000000
ITER 2: row=20, varin=92, theta=0.605836, up=1.000000
ITER 3: row=50, varin=106, theta=0.261322, up=1.000000
ITER 4: row=55, varin=109, theta=0.491621, up=1.000000
ITER 5: row=8, varin=84, theta=1.000000, up=1.000000
ITER 6: row=5, varin=39, theta=0.137345, up=999999999999999983222784.000000
ITER 7: row=54, varin=107, theta=0.057752, up=1.000000
ITER 8: row=52, varin=54, theta=0.938374, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=8)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=55)
DEBUG SOLUTION: LP solution array indices: FST[56-95], not_covered[96-115]
DEBUG SOLUTION: lp->best_solution[0] = 28830957.836346
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 55 rows, 60 cols, 317 nonzeros, 1 slack, 54 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 2 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=55, varin=49, theta=0.626304, up=999999999999999983222784.000000
ITER 2: row=50, varin=68, theta=0.740917, up=1.000000
ITER 3: row=33, varin=3, theta=1.447283, up=999999999999999983222784.000000
ITER 4: row=3, varin=61, theta=0.846313, up=1.000000
ITER 5: row=31, varin=84, theta=0.902312, up=1.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=56)
DEBUG SOLUTION: LP solution array indices: FST[57-96], not_covered[97-116]
DEBUG SOLUTION: lp->best_solution[0] = 28936604.244023
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 56 rows, 60 cols, 316 nonzeros, 2 slack, 54 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 5 rows, 19 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=56, varin=96, theta=0.642857, up=1.000000
ITER 2: row=59, varin=91, theta=0.385263, up=1.000000
ITER 3: row=58, varin=59, theta=0.500000, up=999999999999999983222784.000000
ITER 4: row=55, varin=56, theta=0.219019, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=59)
DEBUG SOLUTION: LP solution array indices: FST[60-99], not_covered[100-119]
DEBUG SOLUTION: lp->best_solution[0] = 28980398.519623
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 59 rows, 60 cols, 331 nonzeros, 3 slack, 56 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=57, varin=90, theta=0.066205, up=1.000000
ITER 2: row=10, varin=88, theta=0.037897, up=1.000000
ITER 3: row=2, varin=82, theta=0.071111, up=1.000000
ITER 4: row=50, varin=114, theta=0.025886, up=1.000000
ITER 5: row=3, varin=81, theta=0.190368, up=1.000000
ITER 6: row=49, varin=5, theta=0.028448, up=999999999999999983222784.000000
ITER 7: row=15, varin=91, theta=0.029351, up=1.000000
LP PHASE: Switching to primal (iter=7)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=57)
DEBUG SOLUTION: LP solution array indices: FST[58-97], not_covered[98-117]
DEBUG SOLUTION: lp->best_solution[0] = 28996186.524043
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 57 rows, 60 cols, 318 nonzeros, 0 slack, 57 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=58, varin=49, theta=0.017351, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=58)
DEBUG SOLUTION: LP solution array indices: FST[59-98], not_covered[99-118]
DEBUG SOLUTION: lp->best_solution[0] = 28997619.223341
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 58 rows, 60 cols, 320 nonzeros, 1 slack, 57 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=58, varin=65, theta=0.122330, up=1.000000
ITER 2: row=24, varin=12, theta=0.029705, up=999999999999999983222784.000000
ITER 3: row=4, varin=11, theta=0.114575, up=999999999999999983222784.000000
ITER 4: row=13, varin=3, theta=0.049788, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=58)
DEBUG SOLUTION: LP solution array indices: FST[59-98], not_covered[99-118]
DEBUG SOLUTION: lp->best_solution[0] = 29018634.158456
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.950212
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 2.950212
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 58 rows, 60 cols, 320 nonzeros, 2 slack, 56 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % Node 56 LP 1 Solution, length = 29018634.158456, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.049788 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.049788 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.500000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.150425 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 1.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 1.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.500000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.049788 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.049788 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.500000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.049788 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.049788 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.150425 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.950212 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.950212 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.950212 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.950212 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.849575 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.500000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 11 fractional variables
DEBUG CG: LP optimal, z=29018634.158456, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 56 at  29.01863415845647153901
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde83a93e0
% @LO 0.06  28.34076015656856739611 99.9000000000
% @LN 0.06  28.34399358079753028505 99.9000000000
% Resuming node 59 at  28.34399358079753028505
DEBUG CONSTRNT: LP rows=56, pool->nlprows=56, pool->npend=0
DEBUG CONSTRNT: Checking 56 LP rows (pool tracks 56, total LP rows 56)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 141
DEBUG CONSTRNT: Pool row 141 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 145
DEBUG CONSTRNT: Pool row 145 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 159
DEBUG CONSTRNT: Pool row 159 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 133
DEBUG CONSTRNT: Pool row 133 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 58
DEBUG CONSTRNT: Pool row 58 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 134
DEBUG CONSTRNT: Pool row 134 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=54, expected 54
DEBUG CONSTRNT: Checking LP row 55 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=55, expected 55
 % @PAP adding 47 rows, 188 nz to LP
DEBUG BB: Processing node 59, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 59 LP 2 Solution, length = 28343993.580798, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.200000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.200000 (FST 9)
  % DEBUG LP_VARS: x[10] = 1.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.400000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.400000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.600000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.600000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.600000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.800000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.600000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.600000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=28343993.580798, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28343993.580798, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 59 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 59
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.200000
DEBUG CAREFUL: Adding var 8 to fractional list (xi=0.200000)
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.200000
DEBUG CAREFUL: Adding var 9 to fractional list (xi=0.200000)
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=1.000000
DEBUG CAREFUL: Skipping var 10: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.400000
DEBUG CAREFUL: Adding var 14 to fractional list (xi=0.400000)
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.400000
DEBUG CAREFUL: Adding var 15 to fractional list (xi=0.400000)
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 4 fractional variables

  %  Carefully choosing branching variable, nfrac = 4
DEBUG CAREFUL: Testing fvar[0] = var 8
DEBUG CAREFUL: Calling compare_branch_vars for var 8
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 8
DEBUG CAREFUL: New best var: 8
DEBUG CAREFUL: Testing fvar[1] = var 9
DEBUG CAREFUL: Calling compare_branch_vars for var 9
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 9
DEBUG CAREFUL: Testing fvar[2] = var 14
DEBUG CAREFUL: Calling compare_branch_vars for var 14
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 14
DEBUG CAREFUL: Testing fvar[3] = var 15
DEBUG CAREFUL: Calling compare_branch_vars for var 15
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 15
  % Initial guess is x8, Z0 = 28343993.5807975        , Z1 = 28364713.4754234        

DEBUG EVAL: Testing var 8 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=43, theta=1.333333, up=999999999999999983222784.000000
ITER 2: row=43, varin=46, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 8 = 1 gives z=28366823.763353
  % 	x8 = 1,	Z1 = 28366823.7633533        
DEBUG EVAL: First branch cutoff check: z=28366823.763353, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 8 = 0
ITER 1: row=1, varin=47, theta=0.500000, up=999999999999999983222784.000000
  % 	x8 = 0,	Z0 = 28346041.1599434        
DEBUG EVAL: Second branch cutoff check: z=28346041.159943, best_z=INF, threshold=INF
  %   New best:  x8, Z = 28346041.1599434        
DEBUG EVAL: Testing var 9 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=27, varin=65, theta=0.183673, up=1.000000
ITER 2: row=36, varin=48, theta=0.352941, up=1.000000
ITER 3: row=12, varin=49, theta=0.428571, up=1.000000
ITER 4: row=2, varin=42, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=44, varin=29, theta=0.290323, up=999999999999999983222784.000000
ITER 6: row=34, varin=58, theta=0.500000, up=1.000000
DEBUG EVAL: Branch var 9 = 0 gives z=28358571.788213
  % 	x9 = 0,	Z0 = 28358571.7882128        
DEBUG EVAL: First branch cutoff check: z=28358571.788213, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 9 = 1
ITER 1: row=27, varin=47, theta=1.333333, up=999999999999999983222784.000000
ITER 2: row=1, varin=43, theta=0.333333, up=999999999999999983222784.000000
  % 	x9 = 1,	Z1 = 28353668.0719832        
DEBUG EVAL: Second branch cutoff check: z=28353668.071983, best_z=INF, threshold=INF
  %   New best:  x9, Z = 28353668.0719832        
DEBUG EVAL: Testing var 14 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=40, varin=43, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 14 = 0 gives z=28352362.580139
  % 	x14 = 0,	Z0 = 28352362.5801386        
DEBUG EVAL: First branch cutoff check: z=28352362.580139, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 15 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=38, varin=42, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=44, varin=46, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 15 = 0 gives z=28366823.763353
  % 	x15 = 0,	Z0 = 28366823.7633533        
DEBUG EVAL: First branch cutoff check: z=28366823.763353, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 15 = 1
ITER 1: row=38, varin=47, theta=3.000000, up=999999999999999983222784.000000
ITER 2: row=46, varin=65, theta=0.367347, up=1.000000
ITER 3: row=1, varin=43, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=36, varin=48, theta=0.705882, up=1.000000
ITER 5: row=12, varin=49, theta=0.857143, up=1.000000
ITER 6: row=2, varin=29, theta=0.580645, up=999999999999999983222784.000000
ITER 7: row=34, varin=58, theta=1.000000, up=1.000000
  % 	x15 = 1,	Z1 = 28393983.1526019        
DEBUG EVAL: Second branch cutoff check: z=28393983.152602, best_z=INF, threshold=INF
  %   New best:  x15, Z = 28366823.7633533        
  % Best branch is x15, Z0 = 28366823.7633533        , Z1 = 28393983.1526019        

DEBUG CAREFUL: Final result - returning best.var = 15
DEBUG BB: Branching variable chosen: j=15
 % @NC   73   59	x15 = 0	28366823.763353
 % @NC   74   59	x15 = 1	28393983.152602
 %      59    30 28343993.5808               28351631.4112    x7 D    38     6
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde8386600
% @LO 0.06  28.34399358079753028505 99.9000000000
% @LN 0.06  28.35163141120557384056 99.9000000000
% Resuming node 61 at  28.35163141120557384056
DEBUG CONSTRNT: LP rows=47, pool->nlprows=47, pool->npend=0
DEBUG CONSTRNT: Checking 47 LP rows (pool tracks 47, total LP rows 47)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 79
DEBUG CONSTRNT: Pool row 79 has lprow=46, expected 46
 % @PAP adding 43 rows, 193 nz to LP
DEBUG BB: Processing node 61, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=6, varin=43, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 28351631.411206
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 43 rows, 60 cols, 253 nonzeros, 1 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 14 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=44, varin=29, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=30, varin=39, theta=0.205882, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 28376736.409015
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.764706
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 47 rows, 60 cols, 267 nonzeros, 8 slack, 39 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 8 slack rows
  % @PAP adding 4 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=42, varin=67, theta=1.000000, up=1.000000
ITER 2: row=43, varin=71, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 28414907.521858
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 43 rows, 60 cols, 247 nonzeros, 0 slack, 43 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=44, varin=76, theta=1.000000, up=1.000000
ITER 2: row=39, varin=34, theta=2.074074, up=999999999999999983222784.000000
ITER 3: row=40, varin=68, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 28434835.110111
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 45 rows, 60 cols, 253 nonzeros, 0 slack, 45 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 19 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=46, varin=32, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 28443203.653025
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 49 rows, 60 cols, 272 nonzeros, 5 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % Node 61 LP 1 Solution, length = 28443203.653025, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.200000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.200000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.200000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.200000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.200000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.200000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.800000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.800000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.800000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.800000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.800000 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28443203.653025, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 61 at  28.44320365302507624961
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde8397250
% @LO 0.06  28.35163141120557384056 99.9000000000
% @LN 0.06  28.35519177280898261984 99.9000000000
% Resuming node 65 at  28.35519177280898261984
DEBUG CONSTRNT: LP rows=44, pool->nlprows=44, pool->npend=0
DEBUG CONSTRNT: Checking 44 LP rows (pool tracks 44, total LP rows 44)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=43, expected 43
 % @PAP adding 45 rows, 177 nz to LP
DEBUG BB: Processing node 65, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=32, varin=32, theta=0.333333, up=999999999999999983222784.000000
ITER 2: row=35, varin=82, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 28355191.772809
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 45 rows, 60 cols, 237 nonzeros, 0 slack, 45 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=46, varin=33, theta=0.333333, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=46)
DEBUG SOLUTION: LP solution array indices: FST[47-86], not_covered[87-106]
DEBUG SOLUTION: lp->best_solution[0] = 28367187.873892
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 46 rows, 60 cols, 241 nonzeros, 4 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % Node 65 LP 1 Solution, length = 28367187.873892, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.333333 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.333333 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.333333 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 1.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.333333 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.333333 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.666667 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.666667 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.666667 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.666667 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.666667 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.666667 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.666667 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28367187.873892, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 65 at  28.36718787389150264744
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde83b6e50
% @LO 0.06  28.35519177280898261984 99.9000000000
% @LN 0.06  28.35564333279532434062 99.9000000000
% Resuming node 63 at  28.35564333279532434062
DEBUG CONSTRNT: LP rows=42, pool->nlprows=42, pool->npend=0
DEBUG CONSTRNT: Checking 42 LP rows (pool tracks 42, total LP rows 42)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 49
DEBUG CONSTRNT: Pool row 49 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 68
DEBUG CONSTRNT: Pool row 68 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 82
DEBUG CONSTRNT: Pool row 82 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 121
DEBUG CONSTRNT: Pool row 121 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=41, expected 41
 % @PAP adding 46 rows, 179 nz to LP
DEBUG BB: Processing node 63, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=22, varin=44, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=9, varin=41, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=46)
DEBUG SOLUTION: LP solution array indices: FST[47-86], not_covered[87-106]
DEBUG SOLUTION: lp->best_solution[0] = 28355643.332795
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 46 rows, 60 cols, 239 nonzeros, 6 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 42 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=48, varin=7, theta=0.550587, up=999999999999999983222784.000000
ITER 2: row=47, varin=17, theta=0.500000, up=999999999999999983222784.000000
ITER 3: row=4, varin=33, theta=0.101296, up=999999999999999983222784.000000
ITER 4: row=3, varin=78, theta=0.328215, up=1.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 28474763.527981
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 48 rows, 60 cols, 281 nonzeros, 8 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 8 slack rows
  % @PAP adding 7 rows, 28 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=41, varin=104, theta=0.366256, up=1.000000
ITER 2: row=38, varin=70, theta=0.264211, up=1.000000
ITER 3: row=45, varin=52, theta=0.112504, up=1.000000
ITER 4: row=46, varin=75, theta=1.481240, up=1.000000
ITER 5: row=46, varin=81, theta=0.108724, up=1.000000
ITER 6: row=38, varin=75, theta=0.786387, up=1.000000
ITER 7: row=42, varin=89, theta=0.041162, up=1.000000
ITER 8: row=32, varin=62, theta=5.696325, up=1.000000
ITER 9: row=32, varin=70, theta=-0.808982, up=1.000000
ITER 10: row=28, varin=62, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=11)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 28535605.327006
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 47 rows, 60 cols, 293 nonzeros, 1 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 5 rows, 12 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=51, varin=74, theta=0.301106, up=1.000000
ITER 2: row=47, varin=41, theta=0.058401, up=999999999999999983222784.000000
ITER 3: row=49, varin=3, theta=0.068204, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 28546977.814745
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.931796
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 51 rows, 60 cols, 303 nonzeros, 3 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 1 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=49, varin=80, theta=0.486485, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 28551055.076634
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
  % @PL 49 rows, 60 cols, 295 nonzeros, 0 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 15 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=50, varin=79, theta=0.341845, up=1.000000
ITER 2: row=26, varin=86, theta=0.511349, up=1.000000
ITER 3: row=51, varin=75, theta=0.191093, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=53)
DEBUG SOLUTION: LP solution array indices: FST[54-93], not_covered[94-113]
DEBUG SOLUTION: lp->best_solution[0] = 28573566.447071
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.936302
DEBUG SOLUTION: lp->best_solution[10] = 0.936302
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
  % @PL 53 rows, 60 cols, 310 nonzeros, 4 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % @PAP adding 3 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=50, varin=21, theta=0.133483, up=999999999999999983222784.000000
ITER 2: row=52, varin=81, theta=0.335640, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 28579749.638833
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 52 rows, 60 cols, 308 nonzeros, 0 slack, 52 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 5 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=53, varin=3, theta=0.362933, up=999999999999999983222784.000000
ITER 2: row=49, varin=22, theta=0.565063, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=53)
DEBUG SOLUTION: LP solution array indices: FST[54-93], not_covered[94-113]
DEBUG SOLUTION: lp->best_solution[0] = 28594555.251464
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 53 rows, 60 cols, 313 nonzeros, 2 slack, 51 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % Node 63 LP 1 Solution, length = 28594555.251464, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.030823 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.030823 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.500000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.188354 (FST 12)
  % DEBUG LP_VARS: x[13] = 1.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 1.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.188354 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.188354 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.500000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.030823 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.030823 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.030823 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.030823 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.969177 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.969177 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.969177 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.969177 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.500000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.500000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.811646 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.811646 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 11 fractional variables
DEBUG CG: LP optimal, z=28594555.251464, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 63 at  28.59455525146371002165
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde83bccf0
% @LO 0.06  28.35564333279532434062 99.9000000000
% @LN 0.06  28.35703968260757079634 99.9000000000
% Resuming node 68 at  28.35703968260757079634
DEBUG CONSTRNT: LP rows=51, pool->nlprows=51, pool->npend=0
DEBUG CONSTRNT: Checking 51 LP rows (pool tracks 51, total LP rows 51)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 65
DEBUG CONSTRNT: Pool row 65 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 158
DEBUG CONSTRNT: Pool row 158 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 145
DEBUG CONSTRNT: Pool row 145 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 159
DEBUG CONSTRNT: Pool row 159 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 133
DEBUG CONSTRNT: Pool row 133 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=50, expected 50
 % @PAP adding 47 rows, 186 nz to LP
DEBUG BB: Processing node 68, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=27, varin=65, theta=0.333333, up=1.000000
ITER 2: row=33, varin=48, theta=0.705882, up=1.000000
ITER 3: row=12, varin=49, theta=0.857143, up=1.000000
ITER 4: row=2, varin=60, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 28357039.682608
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 47 rows, 60 cols, 246 nonzeros, 1 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 6 rows, 30 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=50, varin=44, theta=0.115385, up=999999999999999983222784.000000
ITER 2: row=49, varin=50, theta=5.000000, up=999999999999999983222784.000000
ITER 3: row=51, varin=78, theta=0.800000, up=1.000000
ITER 4: row=3, varin=56, theta=0.600000, up=1.000000
ITER 5: row=22, varin=5, theta=0.666667, up=999999999999999983222784.000000
ITER 6: row=7, varin=39, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=48, varin=12, theta=1.000000, up=999999999999999983222784.000000
ITER 8: row=8, varin=11, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=8)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=53)
DEBUG SOLUTION: LP solution array indices: FST[54-93], not_covered[94-113]
DEBUG SOLUTION: lp->best_solution[0] = 28426991.505448
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.500000
DEBUG SOLUTION: lp->best_solution[5] = 2.500000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.500000
DEBUG SOLUTION: lp->best_solution[10] = 0.500000
DEBUG SOLUTION: lp->best_solution[11] = 3.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.500000
  % @PL 53 rows, 60 cols, 276 nonzeros, 15 slack, 38 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 15 slack rows
  % @PAP adding 3 rows, 45 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=41, varin=6, theta=0.182030, up=999999999999999983222784.000000
ITER 2: row=39, varin=36, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=33, varin=14, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=41, varin=41, theta=191753.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=41)
DEBUG SOLUTION: LP solution array indices: FST[42-81], not_covered[82-101]
DEBUG SOLUTION: lp->best_solution[0] = 28431247.631279
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.500000
DEBUG SOLUTION: lp->best_solution[13] = 0.500000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
  % @PL 41 rows, 60 cols, 266 nonzeros, 4 slack, 37 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % Node 68 LP 1 Solution, length = 28431247.631279, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.500000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.500000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.500000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.500000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 1.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.500000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.500000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.500000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.500000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.500000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=28431247.631279, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 68 at  28.43124763127927323580
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde8398c10
% @LO 0.06  28.35703968260757079634 99.9000000000
% @LN 0.06  28.35979717702063851448 99.9000000000
% Resuming node 49 at  28.35979717702063851448
DEBUG CONSTRNT: LP rows=37, pool->nlprows=37, pool->npend=0
DEBUG CONSTRNT: Checking 37 LP rows (pool tracks 37, total LP rows 37)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 141
DEBUG CONSTRNT: Pool row 141 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 145
DEBUG CONSTRNT: Pool row 145 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 159
DEBUG CONSTRNT: Pool row 159 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 79
DEBUG CONSTRNT: Pool row 79 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 45
DEBUG CONSTRNT: Pool row 45 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 62
DEBUG CONSTRNT: Pool row 62 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=36, expected 36
 % @PAP adding 48 rows, 206 nz to LP
DEBUG BB: Processing node 49, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=29, varin=34, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 28359797.177021
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 48 rows, 60 cols, 266 nonzeros, 3 slack, 45 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 40 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=49, varin=31, theta=0.309238, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 28377139.813413
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 49 rows, 60 cols, 306 nonzeros, 4 slack, 45 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % Node 49 LP 1 Solution, length = 28377139.813413, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.500000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.500000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 1.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.690762 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.500000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.500000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.500000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.500000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.500000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.500000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.309238 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.309238 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28377139.813413, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 49 at  28.37713981341276792136
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde83ad260
% @LO 0.07  28.35979717702063851448 99.9000000000
% @LN 0.07  28.36474897004423212366 99.9000000000
% Resuming node 69 at  28.36474897004423212366
DEBUG CONSTRNT: LP rows=45, pool->nlprows=45, pool->npend=0
DEBUG CONSTRNT: Checking 45 LP rows (pool tracks 45, total LP rows 45)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=44, expected 44
 % @PAP adding 47 rows, 198 nz to LP
DEBUG BB: Processing node 69, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=27, varin=46, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=28, varin=60, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 28364748.970044
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 47 rows, 60 cols, 258 nonzeros, 2 slack, 45 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 3 rows, 12 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=46, varin=27, theta=0.250000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 28376594.501615
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 48 rows, 60 cols, 266 nonzeros, 1 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 3 rows, 14 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=48, varin=59, theta=0.166667, up=1.000000
ITER 2: row=50, varin=48, theta=0.500000, up=999999999999999983222784.000000
ITER 3: row=11, varin=75, theta=0.800000, up=1.000000
ITER 4: row=3, varin=53, theta=0.564706, up=1.000000
ITER 5: row=22, varin=5, theta=0.666667, up=999999999999999983222784.000000
ITER 6: row=7, varin=35, theta=9.600000, up=999999999999999983222784.000000
ITER 7: row=32, varin=69, theta=0.333333, up=1.000000
ITER 8: row=49, varin=12, theta=2.000000, up=999999999999999983222784.000000
ITER 9: row=2, varin=61, theta=0.060606, up=1.000000
ITER 10: row=8, varin=52, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=11)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28431671.915636
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 2.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 2.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 50 rows, 60 cols, 272 nonzeros, 11 slack, 39 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 11 slack rows
  % @PAP adding 3 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=42, varin=18, theta=0.250000, up=999999999999999983222784.000000
ITER 2: row=40, varin=42, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 28433267.643313
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 3.000000
  % @PL 42 rows, 60 cols, 248 nonzeros, 2 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % Node 69 LP 1 Solution, length = 28433267.643313, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.500000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.500000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.500000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.500000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 2 fractional variables
DEBUG CG: LP optimal, z=28433267.643313, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 69 at  28.43326764331283129650
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde83b0d20
% @LO 0.07  28.36474897004423212366 99.9000000000
% @LN 0.07  28.36682376335328825689 99.9000000000
% Resuming node 73 at  28.36682376335328825689
DEBUG CONSTRNT: LP rows=40, pool->nlprows=40, pool->npend=0
DEBUG CONSTRNT: Checking 40 LP rows (pool tracks 40, total LP rows 40)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 91
DEBUG CONSTRNT: Pool row 91 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=39, expected 39
 % @PAP adding 47 rows, 188 nz to LP
DEBUG BB: Processing node 73, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=38, varin=42, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=44, varin=46, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 28366823.763353
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 47 rows, 60 cols, 248 nonzeros, 1 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 29 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=48, varin=39, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=51, varin=45, theta=0.100000, up=999999999999999983222784.000000
ITER 3: row=50, varin=48, theta=0.769231, up=999999999999999983222784.000000
ITER 4: row=46, varin=51, theta=5.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 28376012.592728
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 51 rows, 60 cols, 277 nonzeros, 5 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % Node 73 LP 1 Solution, length = 28376012.592728, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.500000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.500000 (FST 9)
  % DEBUG LP_VARS: x[10] = 1.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.500000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.500000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.500000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.500000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 3 fractional variables
DEBUG CG: LP optimal, z=28376012.592728, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 73 at  28.37601259272761566876
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde8397250
% @LO 0.07  28.36682376335328825689 99.9000000000
% @LN 0.07  28.36718787389150264744 99.9000000000
% Resuming node 65 at  28.36718787389150264744
DEBUG CONSTRNT: LP rows=46, pool->nlprows=46, pool->npend=0
DEBUG CONSTRNT: Checking 46 LP rows (pool tracks 46, total LP rows 46)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 79
DEBUG CONSTRNT: Pool row 79 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 45
DEBUG CONSTRNT: Pool row 45 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 62
DEBUG CONSTRNT: Pool row 62 has lprow=45, expected 45
 % @PAP adding 42 rows, 173 nz to LP
DEBUG BB: Processing node 65, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 65 LP 2 Solution, length = 28367187.873892, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.333333 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.333333 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.333333 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 1.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.333333 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.333333 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.666667 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.666667 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.666667 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.666667 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.666667 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.666667 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.666667 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28367187.873892, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28367187.873892, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 65 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 65
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.333333
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.333333
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.333333
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=1.000000
DEBUG CAREFUL: Skipping var 16: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.333333
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.333333
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 17
DEBUG CAREFUL: New best var: 17
DEBUG CAREFUL: Testing fvar[1] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[2] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 3
DEBUG CAREFUL: New best var: 3
DEBUG CAREFUL: Testing fvar[3] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[4] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
  % Initial guess is x3, Z0 = 28367187.8738915        , Z1 = 28503598.7454712        

DEBUG EVAL: Testing var 17 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=17, varin=42, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=39, varin=39, theta=2.000000, up=999999999999999983222784.000000
ITER 3: row=36, varin=36, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 17 = 1 gives z=28481101.024144
  % 	x17 = 1,	Z1 = 28481101.024144         
DEBUG EVAL: First branch cutoff check: z=28481101.024144, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 17 = 0
ITER 1: row=17, varin=66, theta=1.000000, up=1.000000
ITER 2: row=34, varin=54, theta=0.500000, up=1.000000
  % 	x17 = 0,	Z0 = 28429923.2935183        
DEBUG EVAL: Second branch cutoff check: z=28429923.293518, best_z=INF, threshold=INF
  %   New best:  x17, Z = 28429923.2935183        
DEBUG EVAL: Testing var 10 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=12, varin=42, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=39, varin=32, theta=0.666667, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 1 gives z=28438935.378842
  % 	x10 = 1,	Z1 = 28438935.3788419        
DEBUG EVAL: First branch cutoff check: z=28438935.378842, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 0
ITER 1: row=12, varin=66, theta=1.000000, up=1.000000
ITER 2: row=34, varin=15, theta=0.500000, up=999999999999999983222784.000000
  % 	x10 = 0,	Z0 = 28422348.9805878        
DEBUG EVAL: Second branch cutoff check: z=28422348.980588, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 3 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=9, varin=42, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=39, varin=17, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=37, varin=39, theta=2.000000, up=999999999999999983222784.000000
ITER 4: row=36, varin=35, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 3 = 1 gives z=28503598.745471
  % 	x3 = 1,	Z1 = 28503598.7454712        
DEBUG EVAL: First branch cutoff check: z=28503598.745471, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 3 = 0
ITER 1: row=9, varin=66, theta=1.000000, up=1.000000
ITER 2: row=34, varin=54, theta=0.500000, up=1.000000
  % 	x3 = 0,	Z0 = 28429923.2935183        
DEBUG EVAL: Second branch cutoff check: z=28429923.293518, best_z=INF, threshold=INF
  %   New best:  x3, Z = 28429923.2935183        
DEBUG EVAL: Testing var 2 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=66, theta=1.000000, up=1.000000
ITER 2: row=34, varin=35, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 0 gives z=28408273.080824
  % 	x2 = 0,	Z0 = 28408273.0808241        
DEBUG EVAL: First branch cutoff check: z=28408273.080824, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 26 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=36, varin=42, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=39, varin=32, theta=0.666667, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 26 = 1 gives z=28438935.378842
  % 	x26 = 1,	Z1 = 28438935.3788419        
DEBUG EVAL: First branch cutoff check: z=28438935.378842, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 26 = 0
ITER 1: row=36, varin=66, theta=1.000000, up=1.000000
ITER 2: row=34, varin=39, theta=0.500000, up=999999999999999983222784.000000
  % 	x26 = 0,	Z0 = 28394308.1027488        
DEBUG EVAL: Second branch cutoff check: z=28394308.102749, best_z=INF, threshold=INF
  % Best branch is x3, Z0 = 28429923.2935183        , Z1 = 28503598.7454712        

DEBUG CAREFUL: Final result - returning best.var = 3
DEBUG BB: Branching variable chosen: j=3
 % @NC   75   65	x3 = 0	28429923.293518
 % @NC   76   65	x3 = 1	28503598.745471
 %      65    31 28367187.8739               28370238.2107   x18 D    37     6
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde83af8d0
% @LO 0.07  28.36718787389150264744 99.9000000000
% @LN 0.07  28.37023821074304663625 99.9000000000
% Resuming node 40 at  28.37023821074304663625
DEBUG CONSTRNT: LP rows=42, pool->nlprows=42, pool->npend=0
DEBUG CONSTRNT: Checking 42 LP rows (pool tracks 42, total LP rows 42)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 49
DEBUG CONSTRNT: Pool row 49 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 68
DEBUG CONSTRNT: Pool row 68 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 82
DEBUG CONSTRNT: Pool row 82 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 121
DEBUG CONSTRNT: Pool row 121 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=41, expected 41
 % @PAP adding 45 rows, 173 nz to LP
DEBUG BB: Processing node 40, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=32, varin=43, theta=5.000000, up=999999999999999983222784.000000
ITER 2: row=40, varin=30, theta=4.000000, up=999999999999999983222784.000000
ITER 3: row=29, varin=40, theta=2.000000, up=999999999999999983222784.000000
ITER 4: row=9, varin=39, theta=2.000000, up=999999999999999983222784.000000
ITER 5: row=1, varin=37, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=2, varin=23, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=34, varin=31, theta=0.526316, up=999999999999999983222784.000000
ITER 8: row=27, varin=3, theta=1.000000, up=999999999999999983222784.000000
ITER 9: row=37, varin=62, theta=0.387097, up=1.000000
ITER 10: row=13, varin=33, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=11)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 28363214.013753
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 45 rows, 60 cols, 233 nonzeros, 10 slack, 35 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 5 rows, 59 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=50, varin=7, theta=1.545535, up=999999999999999983222784.000000
ITER 2: row=4, varin=61, theta=0.561684, up=1.000000
ITER 3: row=33, varin=66, theta=0.563713, up=1.000000
ITER 4: row=48, varin=16, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=36, varin=17, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=13, varin=75, theta=1.373417, up=1.000000
ITER 7: row=13, varin=63, theta=0.236599, up=1.000000
ITER 8: row=3, varin=75, theta=1.000000, up=1.000000
ITER 9: row=31, varin=77, theta=1.401953, up=1.000000
ITER 10: row=31, varin=74, theta=0.374985, up=1.000000
LP PHASE: Switching to primal (iter=18)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28971372.364888
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 50 rows, 60 cols, 292 nonzeros, 9 slack, 41 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 9 slack rows
  % @PAP adding 6 rows, 22 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=44, varin=77, theta=1.000000, up=1.000000
ITER 2: row=42, varin=75, theta=1.219917, up=1.000000
ITER 3: row=42, varin=104, theta=0.271171, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 29084587.587580
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 47 rows, 60 cols, 296 nonzeros, 1 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 5 rows, 14 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=51, varin=79, theta=0.591073, up=1.000000
ITER 2: row=47, varin=77, theta=1.000000, up=1.000000
ITER 3: row=25, varin=73, theta=0.600000, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 29144618.581343
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.800000
DEBUG SOLUTION: lp->best_solution[11] = 0.800000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 51 rows, 60 cols, 308 nonzeros, 5 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % @PAP adding 3 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=47, varin=86, theta=1.000000, up=1.000000
ITER 2: row=44, varin=20, theta=0.400000, up=999999999999999983222784.000000
ITER 3: row=49, varin=78, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 29185837.370912
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 49 rows, 60 cols, 304 nonzeros, 0 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 5 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=50, varin=43, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=43, varin=81, theta=1.000000, up=1.000000
ITER 3: row=40, varin=21, theta=1.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 29269281.011751
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 50 rows, 60 cols, 309 nonzeros, 2 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % Node 40 LP 1 Solution, length = 29269281.011751, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.609078 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.500000 (FST 12)
  % DEBUG LP_VARS: x[13] = 1.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 1.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.500000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.500000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.390922 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.390922 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.500000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=29269281.011751, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 40 at  29.26928101175057150840
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde83a0240
% @LO 0.07  28.37023821074304663625 99.9000000000
% @LN 0.07  28.37270881929921628739 99.9000000000
% Resuming node 44 at  28.37270881929921628739
DEBUG CONSTRNT: LP rows=48, pool->nlprows=48, pool->npend=0
DEBUG CONSTRNT: Checking 48 LP rows (pool tracks 48, total LP rows 48)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 65
DEBUG CONSTRNT: Pool row 65 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 145
DEBUG CONSTRNT: Pool row 145 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 159
DEBUG CONSTRNT: Pool row 159 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 133
DEBUG CONSTRNT: Pool row 133 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=47, expected 47
 % @PAP adding 43 rows, 173 nz to LP
DEBUG BB: Processing node 44, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=9, varin=42, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=42, varin=22, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=37, varin=39, theta=2.000000, up=999999999999999983222784.000000
ITER 4: row=36, varin=30, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=29, varin=35, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 28372708.819299
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 43 rows, 60 cols, 233 nonzeros, 4 slack, 39 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 54 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=47, varin=7, theta=0.700325, up=999999999999999983222784.000000
ITER 2: row=44, varin=23, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=47, varin=47, theta=615332.000000, up=999999999999999983222784.000000
ITER 4: row=38, varin=24, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=1, varin=29, theta=6.666667, up=999999999999999983222784.000000
ITER 6: row=30, varin=74, theta=1.000000, up=1.000000
ITER 7: row=39, varin=84, theta=1.000000, up=1.000000
ITER 8: row=42, varin=71, theta=1.000000, up=1.000000
ITER 9: row=34, varin=59, theta=0.500000, up=1.000000
ITER 10: row=46, varin=52, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=14)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 28850646.847868
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 47 rows, 60 cols, 287 nonzeros, 4 slack, 43 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % @PAP adding 4 rows, 13 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=44, varin=22, theta=0.125000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 28861169.462573
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 47 rows, 60 cols, 254 nonzeros, 2 slack, 45 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=46, varin=80, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=46)
DEBUG SOLUTION: LP solution array indices: FST[47-86], not_covered[87-106]
DEBUG SOLUTION: lp->best_solution[0] = 28900127.576092
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 46 rows, 60 cols, 248 nonzeros, 0 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 14 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=47, varin=3, theta=0.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28901327.618216
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.500000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 50 rows, 60 cols, 262 nonzeros, 3 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % Node 44 LP 1 Solution, length = 28901327.618216, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.500000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.500000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 1.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 1.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.500000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.500000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.500000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.500000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.500000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.500000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=28901327.618216, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 44 at  28.90132761821627838117
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde83b0d20
% @LO 0.07  28.37270881929921628739 99.9000000000
% @LN 0.07  28.37601259272761566876 99.9000000000
% Resuming node 73 at  28.37601259272761566876
DEBUG CONSTRNT: LP rows=47, pool->nlprows=47, pool->npend=0
DEBUG CONSTRNT: Checking 47 LP rows (pool tracks 47, total LP rows 47)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 65
DEBUG CONSTRNT: Pool row 65 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 121
DEBUG CONSTRNT: Pool row 121 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=46, expected 46
 % @PAP adding 46 rows, 186 nz to LP
DEBUG BB: Processing node 73, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 73 LP 2 Solution, length = 28376012.592728, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.500000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.500000 (FST 9)
  % DEBUG LP_VARS: x[10] = 1.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.500000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.500000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.500000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.500000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 3 fractional variables
DEBUG CG: LP optimal, z=28376012.592728, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28376012.592728, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 73 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 73
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.500000
DEBUG CAREFUL: Adding var 8 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.500000
DEBUG CAREFUL: Adding var 9 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=1.000000
DEBUG CAREFUL: Skipping var 10: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.500000
DEBUG CAREFUL: Adding var 14 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 3 fractional variables

  %  Carefully choosing branching variable, nfrac = 3
DEBUG CAREFUL: Testing fvar[0] = var 9
DEBUG CAREFUL: Calling compare_branch_vars for var 9
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 9
DEBUG CAREFUL: New best var: 9
DEBUG CAREFUL: Testing fvar[1] = var 8
DEBUG CAREFUL: Calling compare_branch_vars for var 8
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 8
DEBUG CAREFUL: Testing fvar[2] = var 14
DEBUG CAREFUL: Calling compare_branch_vars for var 14
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 14
  % Initial guess is x9, Z0 = 28376012.5927276        , Z1 = 28376012.5927276        

DEBUG EVAL: Testing var 9 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=27, varin=64, theta=0.367347, up=1.000000
ITER 2: row=36, varin=47, theta=0.705882, up=1.000000
ITER 3: row=12, varin=48, theta=0.857143, up=1.000000
ITER 4: row=2, varin=29, theta=0.580645, up=999999999999999983222784.000000
ITER 5: row=34, varin=57, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 9 = 0 gives z=28410262.678641
  % 	x9 = 0,	Z0 = 28410262.6786409        
DEBUG EVAL: First branch cutoff check: z=28410262.678641, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 9 = 1
ITER 1: row=27, varin=44, theta=1.000000, up=999999999999999983222784.000000
  % 	x9 = 1,	Z1 = 28385201.4221019        
DEBUG EVAL: Second branch cutoff check: z=28385201.422102, best_z=INF, threshold=INF
  %   New best:  x9, Z = 28385201.4221019        
DEBUG EVAL: Testing var 8 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=44, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 8 = 0 gives z=28385201.422102
  % 	x8 = 0,	Z0 = 28385201.4221019        
DEBUG EVAL: First branch cutoff check: z=28385201.422102, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 8 = 1
ITER 1: row=1, varin=43, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=45, varin=41, theta=1.000000, up=999999999999999983222784.000000
  % 	x8 = 1,	Z1 = 28397844.2624924        
DEBUG EVAL: Second branch cutoff check: z=28397844.262492, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 14 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=39, varin=43, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=45, varin=41, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 14 = 0 gives z=28397844.262492
  % 	x14 = 0,	Z0 = 28397844.2624924        
DEBUG EVAL: First branch cutoff check: z=28397844.262492, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 14 = 1
ITER 1: row=39, varin=44, theta=1.000000, up=999999999999999983222784.000000
  % 	x14 = 1,	Z1 = 28385201.4221019        
DEBUG EVAL: Second branch cutoff check: z=28385201.422102, best_z=INF, threshold=INF
  % Best branch is x9, Z0 = 28410262.6786409        , Z1 = 28385201.4221019        

DEBUG CAREFUL: Final result - returning best.var = 9
DEBUG BB: Branching variable chosen: j=9
 % @NC   77   73	x9 = 1	28385201.422102
 % @NC   78   73	x9 = 0	28410262.678641
 %      73    32 28376012.5927               28377139.8134   x15 D    59     7
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde8398c10
% @LO 0.07  28.37601259272761566876 99.9000000000
% @LN 0.07  28.37713981341276792136 99.9000000000
% Resuming node 49 at  28.37713981341276792136
DEBUG CONSTRNT: LP rows=46, pool->nlprows=46, pool->npend=0
DEBUG CONSTRNT: Checking 46 LP rows (pool tracks 46, total LP rows 46)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 79
DEBUG CONSTRNT: Pool row 79 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 45
DEBUG CONSTRNT: Pool row 45 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 62
DEBUG CONSTRNT: Pool row 62 has lprow=45, expected 45
 % @PAP adding 45 rows, 237 nz to LP
DEBUG BB: Processing node 49, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 49 LP 2 Solution, length = 28377139.813413, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.500000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.500000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 1.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.690762 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.500000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.500000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.500000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.500000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.500000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.500000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.309238 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.309238 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28377139.813413, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28377139.813413, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 49 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 49
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.500000
DEBUG CAREFUL: Adding var 0 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.500000
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=1.000000
DEBUG CAREFUL: Skipping var 9: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.690762
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.690762)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.500000
DEBUG CAREFUL: Adding var 29 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.500000
DEBUG CAREFUL: Adding var 33 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 0
DEBUG CAREFUL: Calling compare_branch_vars for var 0
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 0
DEBUG CAREFUL: New best var: 0
DEBUG CAREFUL: Testing fvar[1] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 1
DEBUG CAREFUL: Testing fvar[2] = var 33
DEBUG CAREFUL: Calling compare_branch_vars for var 33
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 33
DEBUG CAREFUL: New best var: 33
DEBUG CAREFUL: Testing fvar[3] = var 29
DEBUG CAREFUL: Calling compare_branch_vars for var 29
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 29
DEBUG CAREFUL: Testing fvar[4] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 10
DEBUG CAREFUL: New best var: 10
  % Initial guess is x10, Z0 = 28415878.9326987        , Z1 = 28377139.8134128        

DEBUG EVAL: Testing var 0 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=73, theta=1.000000, up=1.000000
ITER 2: row=20, varin=45, theta=287129.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 0 = 0 gives z=28421873.245548
  % 	x0 = 0,	Z0 = 28421873.2455484        
DEBUG EVAL: First branch cutoff check: z=28421873.245548, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 0 = 1
ITER 1: row=1, varin=59, theta=0.600000, up=1.000000
ITER 2: row=19, varin=43, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=20, varin=4, theta=0.008315, up=999999999999999983222784.000000
ITER 4: row=5, varin=73, theta=0.007646, up=1.000000
ITER 5: row=39, varin=68, theta=0.026198, up=1.000000
ITER 6: row=35, varin=36, theta=0.002193, up=999999999999999983222784.000000
ITER 7: row=36, varin=34, theta=0.002122, up=999999999999999983222784.000000
ITER 8: row=37, varin=35, theta=0.002309, up=999999999999999983222784.000000
ITER 9: row=34, varin=31, theta=0.004043, up=999999999999999983222784.000000
ITER 10: row=31, varin=67, theta=0.022955, up=1.000000
  % 	x0 = 1,	Z1 = 28420785.2495773        
DEBUG EVAL: Second branch cutoff check: z=28420785.249577, best_z=INF, threshold=INF
  %   New best:  x0, Z = 28420785.2495773        
DEBUG EVAL: Testing var 1 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=2, varin=73, theta=1.000000, up=1.000000
ITER 2: row=20, varin=4, theta=0.532001, up=999999999999999983222784.000000
ITER 3: row=5, varin=45, theta=287129.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 1 = 0 gives z=28421873.245548
  % 	x1 = 0,	Z0 = 28421873.2455484        
DEBUG EVAL: First branch cutoff check: z=28421873.245548, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 1 = 1
ITER 1: row=2, varin=59, theta=0.600000, up=1.000000
ITER 2: row=19, varin=43, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=20, varin=73, theta=0.007646, up=1.000000
ITER 4: row=39, varin=68, theta=0.026198, up=1.000000
ITER 5: row=20, varin=36, theta=0.001878, up=999999999999999983222784.000000
ITER 6: row=35, varin=73, theta=0.004385, up=1.000000
ITER 7: row=36, varin=34, theta=0.002122, up=999999999999999983222784.000000
ITER 8: row=37, varin=35, theta=0.002309, up=999999999999999983222784.000000
ITER 9: row=34, varin=31, theta=0.004043, up=999999999999999983222784.000000
ITER 10: row=31, varin=67, theta=0.022955, up=1.000000
  % 	x1 = 1,	Z1 = 28418625.5011979        
DEBUG EVAL: Second branch cutoff check: z=28418625.501198, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 33 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=39, varin=59, theta=0.600000, up=1.000000
ITER 2: row=19, varin=4, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=5, varin=39, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=20, varin=42, theta=1.000040, up=999999999999999983222784.000000
ITER 5: row=18, varin=36, theta=0.280706, up=999999999999999983222784.000000
ITER 6: row=36, varin=34, theta=0.296217, up=999999999999999983222784.000000
ITER 7: row=34, varin=31, theta=0.600602, up=999999999999999983222784.000000
ITER 8: row=31, varin=2, theta=0.238025, up=999999999999999983222784.000000
ITER 9: row=44, varin=5, theta=0.447807, up=999999999999999983222784.000000
ITER 10: row=19, varin=30, theta=0.713084, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 33 = 1 gives z=28673334.063473
  % 	x33 = 1,	Z1 = 28673334.0634725        
DEBUG EVAL: First branch cutoff check: z=28673334.063473, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 33 = 0
ITER 1: row=39, varin=73, theta=1.000000, up=1.000000
ITER 2: row=20, varin=43, theta=0.429112, up=999999999999999983222784.000000
  % 	x33 = 0,	Z0 = 28395750.5856112        
DEBUG EVAL: Second branch cutoff check: z=28395750.585611, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 29 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=29, varin=73, theta=1.000000, up=1.000000
ITER 2: row=20, varin=4, theta=0.532001, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 29 = 0 gives z=28416933.609430
  % 	x29 = 0,	Z0 = 28416933.6094297        
DEBUG EVAL: First branch cutoff check: z=28416933.609430, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 10 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=11, varin=73, theta=0.290906, up=1.000000
DEBUG EVAL: Branch var 10 = 1 gives z=28377855.450878
  % 	x10 = 1,	Z1 = 28377855.4508778        
DEBUG EVAL: First branch cutoff check: z=28377855.450878, best_z=INF, threshold=INF
  % Best branch is x0, Z0 = 28421873.2455484        , Z1 = 28420785.2495773        

DEBUG CAREFUL: Final result - returning best.var = 0
DEBUG BB: Branching variable chosen: j=0
 % @NC   79   49	x0 = 1	28420785.249577
 % @NC   80   49	x0 = 0	28421873.245548
 %      49    33 28377139.8134               28384858.4336   x26 D    35     8
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde83afb10
% @LO 0.07  28.37713981341276792136 99.9000000000
% @LN 0.07  28.38485843355959303835 99.9000000000
% Resuming node 48 at  28.38485843355959303835
DEBUG CONSTRNT: LP rows=45, pool->nlprows=45, pool->npend=0
DEBUG CONSTRNT: Checking 45 LP rows (pool tracks 45, total LP rows 45)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=44, expected 44
 % @PAP adding 49 rows, 186 nz to LP
DEBUG BB: Processing node 48, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 48 LP 2 Solution, length = 28384858.433560, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.500000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.500000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.500000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.500000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.500000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.500000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.500000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.500000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=28384858.433560, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28384858.433560, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 48 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 48
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.500000
DEBUG CAREFUL: Adding var 0 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.500000
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.500000
DEBUG CAREFUL: Adding var 29 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.500000
DEBUG CAREFUL: Adding var 33 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 4 fractional variables

  %  Carefully choosing branching variable, nfrac = 4
DEBUG CAREFUL: Testing fvar[0] = var 0
DEBUG CAREFUL: Calling compare_branch_vars for var 0
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 0
DEBUG CAREFUL: New best var: 0
DEBUG CAREFUL: Testing fvar[1] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 1
DEBUG CAREFUL: Testing fvar[2] = var 33
DEBUG CAREFUL: Calling compare_branch_vars for var 33
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 33
DEBUG CAREFUL: Testing fvar[3] = var 29
DEBUG CAREFUL: Calling compare_branch_vars for var 29
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 29
  % Initial guess is x0, Z0 = 28384858.4335596        , Z1 = 28384858.4335596        

DEBUG EVAL: Testing var 0 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=35, theta=6.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 0 = 0 gives z=28437452.821574
  % 	x0 = 0,	Z0 = 28437452.8215738        
DEBUG EVAL: First branch cutoff check: z=28437452.821574, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 0 = 1
ITER 1: row=1, varin=48, theta=1.000000, up=999999999999999983222784.000000
  % 	x0 = 1,	Z1 = 28386058.475684         
DEBUG EVAL: Second branch cutoff check: z=28386058.475684, best_z=INF, threshold=INF
  %   New best:  x0, Z = 28386058.475684         
DEBUG EVAL: Testing var 1 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=2, varin=35, theta=6.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 1 = 0 gives z=28437452.821574
  % 	x1 = 0,	Z0 = 28437452.8215738        
DEBUG EVAL: First branch cutoff check: z=28437452.821574, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 1 = 1
ITER 1: row=2, varin=48, theta=1.000000, up=999999999999999983222784.000000
  % 	x1 = 1,	Z1 = 28386058.475684         
DEBUG EVAL: Second branch cutoff check: z=28386058.475684, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 33 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=44, varin=48, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 33 = 0 gives z=28386058.475684
  % 	x33 = 0,	Z0 = 28386058.475684         
DEBUG EVAL: First branch cutoff check: z=28386058.475684, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 33 = 1
ITER 1: row=44, varin=44, theta=1.000000, up=999999999999999983222784.000000
  % 	x33 = 1,	Z1 = 28435539.2039083        
DEBUG EVAL: Second branch cutoff check: z=28435539.203908, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 29 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=28, varin=44, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 29 = 0 gives z=28435539.203908
  % 	x29 = 0,	Z0 = 28435539.2039083        
DEBUG EVAL: First branch cutoff check: z=28435539.203908, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 29 = 1
ITER 1: row=28, varin=48, theta=1.000000, up=999999999999999983222784.000000
  % 	x29 = 1,	Z1 = 28386058.475684         
DEBUG EVAL: Second branch cutoff check: z=28386058.475684, best_z=INF, threshold=INF
  % Best branch is x0, Z0 = 28437452.8215738        , Z1 = 28386058.475684         

DEBUG CAREFUL: Final result - returning best.var = 0
DEBUG BB: Branching variable chosen: j=0
 % @NC   81   48	x0 = 1	28386058.475684
 % @NC   82   48	x0 = 0	28437452.821574
 %      48    34 28384858.4336               28385201.4221   x17 D    33     8
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde8397250
% @LO 0.07  28.38485843355959303835 99.9000000000
% @LN 0.07  28.38520142210194308063 99.9000000000
% Resuming node 77 at  28.38520142210194308063
DEBUG CONSTRNT: LP rows=49, pool->nlprows=49, pool->npend=0
DEBUG CONSTRNT: Checking 49 LP rows (pool tracks 49, total LP rows 49)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 85
DEBUG CONSTRNT: Pool row 85 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=48, expected 48
 % @PAP adding 46 rows, 186 nz to LP
DEBUG BB: Processing node 77, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=27, varin=44, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=46)
DEBUG SOLUTION: LP solution array indices: FST[47-86], not_covered[87-106]
DEBUG SOLUTION: lp->best_solution[0] = 28385201.422102
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 46 rows, 60 cols, 246 nonzeros, 2 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 3 rows, 18 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=49, varin=51, theta=0.615385, up=1.000000
ITER 2: row=47, varin=49, theta=11.000000, up=999999999999999983222784.000000
ITER 3: row=8, varin=46, theta=0.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 28391522.842297
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 49 rows, 60 cols, 264 nonzeros, 4 slack, 45 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % @PAP adding 2 rows, 18 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=46, varin=8, theta=3.000000, up=999999999999999983222784.000000
ITER 2: row=17, varin=65, theta=0.367347, up=1.000000
ITER 3: row=36, varin=48, theta=0.738462, up=1.000000
ITER 4: row=12, varin=17, theta=2.571429, up=999999999999999983222784.000000
ITER 5: row=2, varin=29, theta=0.580645, up=999999999999999983222784.000000
ITER 6: row=34, varin=58, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 28441283.177780
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 47 rows, 60 cols, 262 nonzeros, 1 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 2 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=47, varin=61, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 28445539.281799
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 48 rows, 60 cols, 268 nonzeros, 1 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 3 rows, 12 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=48, varin=75, theta=0.800000, up=1.000000
ITER 2: row=3, varin=53, theta=0.564706, up=1.000000
ITER 3: row=22, varin=5, theta=0.666667, up=999999999999999983222784.000000
ITER 4: row=7, varin=35, theta=9.600000, up=999999999999999983222784.000000
ITER 5: row=32, varin=69, theta=0.333333, up=1.000000
ITER 6: row=7, varin=38, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=50, varin=33, theta=0.208333, up=999999999999999983222784.000000
ITER 8: row=37, varin=12, theta=2.000000, up=999999999999999983222784.000000
ITER 9: row=8, varin=35, theta=0.111111, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=9)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28508415.792777
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.944444
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 50 rows, 60 cols, 274 nonzeros, 5 slack, 45 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % @PAP adding 3 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=48, varin=10, theta=2.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 28512462.227391
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 2.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 48 rows, 60 cols, 259 nonzeros, 11 slack, 37 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 11 slack rows
  % @PAP adding 4 rows, 48 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=41, varin=5, theta=1.190004, up=999999999999999983222784.000000
ITER 2: row=6, varin=12, theta=1.297672, up=999999999999999983222784.000000
ITER 3: row=38, varin=6, theta=0.644056, up=999999999999999983222784.000000
ITER 4: row=41, varin=41, theta=168027.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=41)
DEBUG SOLUTION: LP solution array indices: FST[42-81], not_covered[82-101]
DEBUG SOLUTION: lp->best_solution[0] = 28520974.479055
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 41 rows, 60 cols, 275 nonzeros, 5 slack, 36 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % @PAP adding 2 rows, 12 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=37, varin=13, theta=0.315789, up=999999999999999983222784.000000
ITER 2: row=32, varin=42, theta=0.357143, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=38)
DEBUG SOLUTION: LP solution array indices: FST[39-78], not_covered[79-98]
DEBUG SOLUTION: lp->best_solution[0] = 28543947.933439
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.928571
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 38 rows, 60 cols, 236 nonzeros, 2 slack, 36 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 3 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=37, varin=17, theta=0.666667, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=39)
DEBUG SOLUTION: LP solution array indices: FST[40-79], not_covered[80-99]
DEBUG SOLUTION: lp->best_solution[0] = 28544582.244182
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 39 rows, 60 cols, 230 nonzeros, 1 slack, 38 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 77 LP 1 Solution, length = 28544582.244182, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.166667 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.166667 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 1.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.833333 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 1.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.166667 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.166667 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.833333 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.833333 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.833333 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.166667 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.833333 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.166667 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28544582.244182, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 77 at  28.54458224418169365322
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde8398c10
% @LO 0.07  28.38520142210194308063 99.9000000000
% @LN 0.07  28.38605847568396356451 99.9000000000
% Resuming node 81 at  28.38605847568396356451
DEBUG CONSTRNT: LP rows=38, pool->nlprows=38, pool->npend=0
DEBUG CONSTRNT: Checking 38 LP rows (pool tracks 38, total LP rows 38)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 63
DEBUG CONSTRNT: Pool row 63 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=37, expected 37
 % @PAP adding 49 rows, 186 nz to LP
DEBUG BB: Processing node 81, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=48, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 28386058.475684
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 49 rows, 60 cols, 246 nonzeros, 2 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 5 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=50, varin=4, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=5, varin=6, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=45, varin=44, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=1, varin=35, theta=6.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 28920902.407654
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 51 rows, 60 cols, 251 nonzeros, 5 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % @PAP adding 2 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=48, varin=82, theta=1.000000, up=1.000000
ITER 2: row=47, varin=76, theta=2.000000, up=1.000000
ITER 3: row=47, varin=71, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 29013587.787073
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 48 rows, 60 cols, 238 nonzeros, 2 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 6 rows, 25 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=47, varin=85, theta=1.000000, up=1.000000
ITER 2: row=50, varin=74, theta=2.000000, up=1.000000
ITER 3: row=50, varin=19, theta=0.500000, up=999999999999999983222784.000000
ITER 4: row=24, varin=74, theta=1.000000, up=1.000000
ITER 5: row=39, varin=21, theta=0.400000, up=999999999999999983222784.000000
ITER 6: row=49, varin=80, theta=0.600000, up=1.000000
ITER 7: row=37, varin=35, theta=0.500000, up=999999999999999983222784.000000
ITER 8: row=40, varin=39, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=8)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 29174768.316934
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 52 rows, 60 cols, 259 nonzeros, 3 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=50, varin=27, theta=0.333333, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 29180721.556570
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 50 rows, 60 cols, 255 nonzeros, 5 slack, 45 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % Node 81 LP 1 Solution, length = 29180721.556570, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 1.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.500000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.333333 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.333333 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.333333 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.333333 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.333333 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.500000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.500000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.666667 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.500000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.666667 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.500000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.666667 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.666667 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.666667 (terminal 19)
 % 8 fractional variables
DEBUG CG: LP optimal, z=29180721.556570, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 81 at  29.18072155656977528793
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde83b0600
% @LO 0.07  28.38605847568396356451 99.9000000000
% @LN 0.07  28.39398315260189420428 99.9000000000
% Resuming node 74 at  28.39398315260189420428
DEBUG CONSTRNT: LP rows=45, pool->nlprows=45, pool->npend=0
DEBUG CONSTRNT: Checking 45 LP rows (pool tracks 45, total LP rows 45)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 142
DEBUG CONSTRNT: Pool row 142 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 135
DEBUG CONSTRNT: Pool row 135 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 133
DEBUG CONSTRNT: Pool row 133 has lprow=44, expected 44
 % @PAP adding 47 rows, 188 nz to LP
DEBUG BB: Processing node 74, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=38, varin=47, theta=3.000000, up=999999999999999983222784.000000
ITER 2: row=46, varin=65, theta=0.367347, up=1.000000
ITER 3: row=1, varin=43, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=36, varin=48, theta=0.705882, up=1.000000
ITER 5: row=12, varin=49, theta=0.857143, up=1.000000
ITER 6: row=2, varin=29, theta=0.580645, up=999999999999999983222784.000000
ITER 7: row=34, varin=58, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=7)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 28393983.152602
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 47 rows, 60 cols, 248 nonzeros, 3 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=48, varin=62, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 28398239.256621
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 49 rows, 60 cols, 256 nonzeros, 4 slack, 45 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % @PAP adding 3 rows, 12 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=46, varin=57, theta=0.500000, up=1.000000
ITER 2: row=27, varin=73, theta=0.800000, up=1.000000
ITER 3: row=3, varin=51, theta=0.564706, up=1.000000
ITER 4: row=22, varin=5, theta=0.666667, up=999999999999999983222784.000000
ITER 5: row=7, varin=35, theta=9.600000, up=999999999999999983222784.000000
ITER 6: row=32, varin=67, theta=0.333333, up=1.000000
ITER 7: row=7, varin=33, theta=0.208333, up=999999999999999983222784.000000
ITER 8: row=37, varin=12, theta=2.000000, up=999999999999999983222784.000000
ITER 9: row=8, varin=35, theta=0.111111, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=9)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 28461115.767599
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.944444
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 48 rows, 60 cols, 256 nonzeros, 5 slack, 43 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % @PAP adding 3 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=46, varin=10, theta=2.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=46)
DEBUG SOLUTION: LP solution array indices: FST[47-86], not_covered[87-106]
DEBUG SOLUTION: lp->best_solution[0] = 28465162.202213
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 2.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 46 rows, 60 cols, 241 nonzeros, 11 slack, 35 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 11 slack rows
  % @PAP adding 4 rows, 48 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=39, varin=91, theta=0.123874, up=1.000000
ITER 2: row=36, varin=39, theta=444976.111111, up=999999999999999983222784.000000
ITER 3: row=34, varin=35, theta=0.272721, up=999999999999999983222784.000000
% Column 60 singular!
% SINGULAR BASIS!  Will attempt to recover.
LP PHASE: Starting dual phase (iter=3)
ITER 4: row=35, varin=99, theta=0.333333, up=1.000000
ITER 5: row=33, varin=12, theta=2.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=39)
DEBUG SOLUTION: LP solution array indices: FST[40-79], not_covered[80-99]
DEBUG SOLUTION: lp->best_solution[0] = 28473674.453877
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 39 rows, 60 cols, 257 nonzeros, 5 slack, 34 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % @PAP adding 2 rows, 12 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=35, varin=18, theta=1.250000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=36)
DEBUG SOLUTION: LP solution array indices: FST[37-76], not_covered[77-96]
DEBUG SOLUTION: lp->best_solution[0] = 28490082.116119
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 36 rows, 60 cols, 218 nonzeros, 2 slack, 34 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % Node 74 LP 1 Solution, length = 28490082.116119, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.250000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.750000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.750000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 1.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.250000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.250000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.750000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.750000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.250000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.250000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.750000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.250000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.750000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.250000 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28490082.116119, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 74 at  28.49008211611859664458
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde839c250
% @LO 0.07  28.39398315260189420428 99.9000000000
% @LN 0.07  28.39833223435412179469 99.9000000000
% Resuming node 64 at  28.39833223435412179469
DEBUG CONSTRNT: LP rows=34, pool->nlprows=34, pool->npend=0
DEBUG CONSTRNT: Checking 34 LP rows (pool tracks 34, total LP rows 34)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=33, expected 33
 % @PAP adding 46 rows, 179 nz to LP
DEBUG BB: Processing node 64, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=22, varin=23, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=42, varin=103, theta=1.000000, up=1.000000
ITER 3: row=40, varin=76, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=46)
DEBUG SOLUTION: LP solution array indices: FST[47-86], not_covered[87-106]
DEBUG SOLUTION: lp->best_solution[0] = 28398332.234354
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 46 rows, 60 cols, 239 nonzeros, 0 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 13 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=47, varin=25, theta=0.125000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28408854.849059
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 50 rows, 60 cols, 252 nonzeros, 2 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=49, varin=83, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 28447812.962578
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 49 rows, 60 cols, 246 nonzeros, 0 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 14 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=50, varin=3, theta=0.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=53)
DEBUG SOLUTION: LP solution array indices: FST[54-93], not_covered[94-113]
DEBUG SOLUTION: lp->best_solution[0] = 28449013.004703
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.500000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 53 rows, 60 cols, 260 nonzeros, 3 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % Node 64 LP 1 Solution, length = 28449013.004703, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.500000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.500000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 1.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.500000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.500000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.500000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.500000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.500000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.500000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=28449013.004703, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 64 at  28.44901300470283800337
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde83b0540
% @LO 0.07  28.39833223435412179469 99.9000000000
% @LN 0.07  28.39987285773028702351 99.9000000000
% Resuming node 71 at  28.39987285773028702351
DEBUG CONSTRNT: LP rows=50, pool->nlprows=50, pool->npend=0
DEBUG CONSTRNT: Checking 50 LP rows (pool tracks 50, total LP rows 50)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 65
DEBUG CONSTRNT: Pool row 65 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 121
DEBUG CONSTRNT: Pool row 121 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=49, expected 49
 % @PAP adding 46 rows, 217 nz to LP
DEBUG BB: Processing node 71, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=38, varin=12, theta=0.618523, up=999999999999999983222784.000000
ITER 2: row=11, varin=22, theta=0.836468, up=999999999999999983222784.000000
ITER 3: row=8, varin=7, theta=0.700078, up=999999999999999983222784.000000
ITER 4: row=1, varin=41, theta=0.732996, up=999999999999999983222784.000000
ITER 5: row=46, varin=3, theta=2.246134, up=999999999999999983222784.000000
ITER 6: row=3, varin=35, theta=1.139205, up=999999999999999983222784.000000
ITER 7: row=34, varin=43, theta=0.135762, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=7)
ITER 8: row=35, varin=59, theta=0.437529, up=1.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=46)
DEBUG SOLUTION: LP solution array indices: FST[47-86], not_covered[87-106]
DEBUG SOLUTION: lp->best_solution[0] = 28398686.141791
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 46 rows, 60 cols, 277 nonzeros, 2 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 7 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=47, varin=35, theta=0.864238, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 28399872.857730
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 48 rows, 60 cols, 284 nonzeros, 3 slack, 45 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=49, varin=75, theta=0.736365, up=1.000000
ITER 2: row=3, varin=51, theta=0.344267, up=1.000000
ITER 3: row=39, varin=53, theta=0.411338, up=1.000000
ITER 4: row=22, varin=3, theta=0.646538, up=999999999999999983222784.000000
ITER 5: row=12, varin=25, theta=1.257848, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=5)
ITER 6: row=35, varin=42, theta=0.500000, up=999999999999999983222784.000000
ITER 7: row=25, varin=38, theta=228329.000000, up=999999999999999983222784.000000
ITER 8: row=35, varin=35, theta=0.500000, up=999999999999999983222784.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28452584.397534
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 50 rows, 60 cols, 288 nonzeros, 7 slack, 43 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 7 slack rows
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=57, theta=5.666667, up=1.000000
ITER 2: row=1, varin=60, theta=4.666667, up=1.000000
ITER 3: row=1, varin=52, theta=5.500000, up=1.000000
ITER 4: row=1, varin=58, theta=3.000000, up=1.000000
ITER 5: row=1, varin=51, theta=3.000000, up=1.000000
ITER 6: row=1, varin=64, theta=1.000000, up=1.000000
ITER 7: row=32, varin=51, theta=7.000000, up=1.000000
ITER 8: row=32, varin=58, theta=6.000000, up=1.000000
ITER 9: row=32, varin=52, theta=2.500000, up=1.000000
ITER 10: row=32, varin=60, theta=1.500000, up=1.000000
LP PHASE: Switching to primal (iter=57)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 28438614.608660
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 43 rows, 60 cols, 233 nonzeros, 0 slack, 43 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=45, varin=103, theta=0.125000, up=1.000000
ITER 2: row=44, varin=45, theta=1.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 28442172.040492
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 45 rows, 60 cols, 241 nonzeros, 3 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 71 LP 1 Solution, length = 28442172.040492, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.500000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.500000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.500000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.500000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.500000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.500000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.500000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.500000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.500000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.500000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.500000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.500000 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=28442172.040492, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 71 at  28.44217204049230218743
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde83af990
% @LO 0.07  28.39987285773028702351 99.9000000000
% @LN 0.07  28.41026267864089760451 99.9000000000
% Resuming node 78 at  28.41026267864089760451
DEBUG CONSTRNT: LP rows=45, pool->nlprows=45, pool->npend=0
DEBUG CONSTRNT: Checking 45 LP rows (pool tracks 45, total LP rows 45)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 63
DEBUG CONSTRNT: Pool row 63 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 91
DEBUG CONSTRNT: Pool row 91 has lprow=44, expected 44
 % @PAP adding 46 rows, 186 nz to LP
DEBUG BB: Processing node 78, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=27, varin=64, theta=0.367347, up=1.000000
ITER 2: row=36, varin=47, theta=0.705882, up=1.000000
ITER 3: row=12, varin=48, theta=0.857143, up=1.000000
ITER 4: row=2, varin=29, theta=0.580645, up=999999999999999983222784.000000
ITER 5: row=34, varin=57, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=46)
DEBUG SOLUTION: LP solution array indices: FST[47-86], not_covered[87-106]
DEBUG SOLUTION: lp->best_solution[0] = 28410262.678641
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 46 rows, 60 cols, 246 nonzeros, 1 slack, 45 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 16 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=47, varin=43, theta=0.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 28416584.098836
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 48 rows, 60 cols, 262 nonzeros, 2 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % Node 78 LP 1 Solution, length = 28416584.098836, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.500000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.500000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.500000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.500000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.500000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 2 fractional variables
DEBUG CG: LP optimal, z=28416584.098836, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 78 at  28.41658409883611113855
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde83bf1e0
% @LO 0.07  28.41026267864089760451 99.9000000000
% @LN 0.07  28.41204899522232096842 99.9000000000
% Resuming node 70 at  28.41204899522232096842
DEBUG CONSTRNT: LP rows=46, pool->nlprows=46, pool->npend=0
DEBUG CONSTRNT: Checking 46 LP rows (pool tracks 46, total LP rows 46)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 79
DEBUG CONSTRNT: Pool row 79 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 45
DEBUG CONSTRNT: Pool row 45 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 62
DEBUG CONSTRNT: Pool row 62 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=45, expected 45
 % @PAP adding 47 rows, 198 nz to LP
DEBUG BB: Processing node 70, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=27, varin=43, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=47, varin=40, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=28, varin=60, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 28412048.995222
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 47 rows, 60 cols, 258 nonzeros, 2 slack, 45 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 3 rows, 12 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=48, varin=75, theta=0.800000, up=1.000000
ITER 2: row=3, varin=53, theta=0.564706, up=1.000000
ITER 3: row=22, varin=5, theta=0.666667, up=999999999999999983222784.000000
ITER 4: row=7, varin=36, theta=9.600000, up=999999999999999983222784.000000
ITER 5: row=33, varin=69, theta=0.333333, up=1.000000
ITER 6: row=7, varin=39, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=50, varin=34, theta=0.208333, up=999999999999999983222784.000000
ITER 8: row=38, varin=12, theta=2.000000, up=999999999999999983222784.000000
ITER 9: row=8, varin=36, theta=0.111111, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=9)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28474925.506200
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.944444
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 50 rows, 60 cols, 270 nonzeros, 7 slack, 43 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 7 slack rows
  % @PAP adding 7 rows, 26 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=50, varin=61, theta=0.051095, up=1.000000
ITER 2: row=45, varin=10, theta=2.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28478971.940815
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 2.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 50 rows, 60 cols, 269 nonzeros, 11 slack, 39 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 11 slack rows
  % @PAP adding 3 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=40, varin=12, theta=2.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 28487484.192478
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 42 rows, 60 cols, 245 nonzeros, 4 slack, 38 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % @PAP adding 2 rows, 12 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=40, varin=19, theta=0.719298, up=999999999999999983222784.000000
ITER 2: row=39, varin=36, theta=3.200000, up=999999999999999983222784.000000
ITER 3: row=30, varin=44, theta=0.400000, up=1.000000
ITER 4: row=40, varin=40, theta=0.076923, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=40)
DEBUG SOLUTION: LP solution array indices: FST[41-80], not_covered[81-100]
DEBUG SOLUTION: lp->best_solution[0] = 28514040.954553
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 40 rows, 60 cols, 246 nonzeros, 3 slack, 37 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 3 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=38, varin=67, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=40)
DEBUG SOLUTION: LP solution array indices: FST[41-80], not_covered[81-100]
DEBUG SOLUTION: lp->best_solution[0] = 28515414.148629
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 40 rows, 60 cols, 226 nonzeros, 0 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 17 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=41, varin=19, theta=0.666667, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28519681.874563
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 44 rows, 60 cols, 243 nonzeros, 2 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % Node 70 LP 1 Solution, length = 28519681.874563, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.166667 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.166667 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.166667 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 1.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.166667 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.166667 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.166667 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.833333 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.833333 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.833333 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.833333 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.833333 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.833333 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.833333 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28519681.874563, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 70 at  28.51968187456272829650
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde83af990
% @LO 0.07  28.41204899522232096842 99.9000000000
% @LN 0.07  28.41658409883611113855 99.9000000000
% Resuming node 78 at  28.41658409883611113855
DEBUG CONSTRNT: LP rows=42, pool->nlprows=42, pool->npend=0
DEBUG CONSTRNT: Checking 42 LP rows (pool tracks 42, total LP rows 42)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=41, expected 41
 % @PAP adding 46 rows, 186 nz to LP
DEBUG BB: Processing node 78, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 78 LP 2 Solution, length = 28416584.098836, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.500000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.500000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.500000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.500000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.500000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 2 fractional variables
DEBUG CG: LP optimal, z=28416584.098836, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28416584.098836, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 78 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 78
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.500000
DEBUG CAREFUL: Adding var 8 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.500000
DEBUG CAREFUL: Adding var 14 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 2 fractional variables

  %  Carefully choosing branching variable, nfrac = 2
DEBUG CAREFUL: Testing fvar[0] = var 8
DEBUG CAREFUL: Calling compare_branch_vars for var 8
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 8
DEBUG CAREFUL: New best var: 8
DEBUG CAREFUL: Testing fvar[1] = var 14
DEBUG CAREFUL: Calling compare_branch_vars for var 14
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 14
  % Initial guess is x8, Z0 = 28416584.0988361        , Z1 = 28416584.0988361        

DEBUG EVAL: Testing var 8 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=11, varin=45, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=30, varin=59, theta=0.500000, up=1.000000
DEBUG EVAL: Branch var 8 = 0 gives z=28470600.538338
  % 	x8 = 0,	Z0 = 28470600.5383382        
DEBUG EVAL: First branch cutoff check: z=28470600.538338, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 8 = 1
ITER 1: row=11, varin=46, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=44, varin=41, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=30, varin=59, theta=0.500000, up=1.000000
  % 	x8 = 1,	Z1 = 28483243.3787286        
DEBUG EVAL: Second branch cutoff check: z=28483243.378729, best_z=INF, threshold=INF
  %   New best:  x8, Z = 28470600.5383382        
DEBUG EVAL: Testing var 14 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=28, varin=45, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=30, varin=59, theta=0.500000, up=1.000000
DEBUG EVAL: Branch var 14 = 1 gives z=28470600.538338
  % 	x14 = 1,	Z1 = 28470600.5383382        
DEBUG EVAL: First branch cutoff check: z=28470600.538338, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 14 = 0
ITER 1: row=28, varin=46, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=44, varin=41, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=30, varin=59, theta=0.500000, up=1.000000
  % 	x14 = 0,	Z0 = 28483243.3787286        
DEBUG EVAL: Second branch cutoff check: z=28483243.378729, best_z=INF, threshold=INF
  %   New best:  x14, Z = 28470600.5383382        
  % Best branch is x14, Z0 = 28483243.3787286        , Z1 = 28470600.5383382        

DEBUG CAREFUL: Final result - returning best.var = 14
DEBUG BB: Branching variable chosen: j=14
 % @NC   83   78	x14 = 1	28470600.538338
 % @NC   84   78	x14 = 0	28483243.378729
 %      78    35 28416584.0988               28420785.2496    x9 D    73     8
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde83b0d20
% @LO 0.07  28.41658409883611113855 99.9000000000
% @LN 0.07  28.42078524957726060052 99.9000000000
% Resuming node 79 at  28.42078524957726060052
DEBUG CONSTRNT: LP rows=46, pool->nlprows=46, pool->npend=0
DEBUG CONSTRNT: Checking 46 LP rows (pool tracks 46, total LP rows 46)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 79
DEBUG CONSTRNT: Pool row 79 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 45
DEBUG CONSTRNT: Pool row 45 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 62
DEBUG CONSTRNT: Pool row 62 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=45, expected 45
 % @PAP adding 45 rows, 237 nz to LP
DEBUG BB: Processing node 79, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=59, theta=0.600000, up=1.000000
ITER 2: row=19, varin=43, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=20, varin=4, theta=0.008315, up=999999999999999983222784.000000
ITER 4: row=5, varin=73, theta=0.007646, up=1.000000
ITER 5: row=39, varin=68, theta=0.026198, up=1.000000
ITER 6: row=35, varin=36, theta=0.002193, up=999999999999999983222784.000000
ITER 7: row=36, varin=34, theta=0.002122, up=999999999999999983222784.000000
ITER 8: row=37, varin=35, theta=0.002309, up=999999999999999983222784.000000
ITER 9: row=34, varin=31, theta=0.004043, up=999999999999999983222784.000000
ITER 10: row=31, varin=67, theta=0.022955, up=1.000000
LP PHASE: Switching to primal (iter=16)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 28420785.249577
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.993900
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.993900
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 45 rows, 60 cols, 297 nonzeros, 5 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 11 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=48, varin=60, theta=0.610487, up=1.000000
ITER 2: row=46, varin=52, theta=1.081411, up=1.000000
ITER 3: row=46, varin=73, theta=0.179801, up=1.000000
ITER 4: row=30, varin=52, theta=1.000000, up=1.000000
ITER 5: row=42, varin=21, theta=0.251191, up=999999999999999983222784.000000
ITER 6: row=35, varin=78, theta=1.397876, up=1.000000
ITER 7: row=35, varin=22, theta=0.077136, up=999999999999999983222784.000000
ITER 8: row=16, varin=78, theta=1.000000, up=1.000000
ITER 9: row=37, varin=82, theta=0.934824, up=1.000000
ITER 10: row=47, varin=83, theta=1.288360, up=1.000000
LP PHASE: Switching to primal (iter=13)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 29140925.845337
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 49 rows, 60 cols, 308 nonzeros, 9 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 9 slack rows
  % @PAP adding 7 rows, 22 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=47, varin=81, theta=1.000000, up=1.000000
ITER 2: row=41, varin=70, theta=1.000000, up=1.000000
ITER 3: row=43, varin=29, theta=7.613037, up=999999999999999983222784.000000
ITER 4: row=9, varin=16, theta=0.703820, up=999999999999999983222784.000000
ITER 5: row=46, varin=27, theta=1.297809, up=999999999999999983222784.000000
ITER 6: row=27, varin=9, theta=7.022309, up=999999999999999983222784.000000
ITER 7: row=43, varin=47, theta=10.453180, up=999999999999999983222784.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 999999999999999983222784.000000
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 47 rows, 60 cols, 312 nonzeros, 4 slack, 43 tight.
  % Node 79 LP 1 Solution, length = 999999999999999983222784.000000, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 1.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.025881 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 1.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.059162 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 1.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.025881 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.147889 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.025881 (FST 32)
  % DEBUG LP_VARS: x[33] = 1.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.833333 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.974119 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.974119 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.848691 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
DEBUG BB: compute_good_lower_bound returned status=1
DEBUG BB: Node 79 is INFEASIBLE
 %      79    34    infeasible               28421873.2455    x0 U    49     9
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde83a9300
% @LO 0.07  28.42078524957726060052 99.9000000000
% @LN 0.07  28.42187324554837957180 99.9000000000
% Resuming node 80 at  28.42187324554837957180
DEBUG CONSTRNT: LP rows=47, pool->nlprows=47, pool->npend=0
DEBUG CONSTRNT: Checking 47 LP rows (pool tracks 47, total LP rows 47)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 142
DEBUG CONSTRNT: Pool row 142 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 135
DEBUG CONSTRNT: Pool row 135 has lprow=46, expected 46
 % @PAP adding 45 rows, 237 nz to LP
DEBUG BB: Processing node 80, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=73, theta=1.000000, up=1.000000
ITER 2: row=20, varin=45, theta=287129.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 28421873.245548
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 45 rows, 60 cols, 297 nonzeros, 1 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 2 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=45, varin=77, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=46)
DEBUG SOLUTION: LP solution array indices: FST[47-86], not_covered[87-106]
DEBUG SOLUTION: lp->best_solution[0] = 28429466.574132
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 46 rows, 60 cols, 263 nonzeros, 0 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 15 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=47, varin=32, theta=3.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28432741.350911
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 50 rows, 60 cols, 278 nonzeros, 1 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 3 rows, 46 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=52, varin=75, theta=0.045758, up=1.000000
ITER 2: row=50, varin=52, theta=328201.000000, up=999999999999999983222784.000000
ITER 3: row=34, varin=22, theta=0.140351, up=999999999999999983222784.000000
ITER 4: row=36, varin=21, theta=0.141593, up=999999999999999983222784.000000
ITER 5: row=37, varin=85, theta=1.000000, up=1.000000
ITER 6: row=45, varin=32, theta=0.698113, up=999999999999999983222784.000000
ITER 7: row=47, varin=45, theta=0.127660, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=7)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 28471143.056339
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 52 rows, 60 cols, 318 nonzeros, 5 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % @PAP adding 2 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=49, varin=71, theta=1.000000, up=1.000000
ITER 2: row=25, varin=31, theta=2.083333, up=999999999999999983222784.000000
ITER 3: row=48, varin=49, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 28490496.430109
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 49 rows, 60 cols, 264 nonzeros, 2 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 3 rows, 52 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=50, varin=32, theta=1.180602, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28503241.314439
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 50 rows, 60 cols, 306 nonzeros, 3 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=48, varin=77, theta=0.114182, up=1.000000
ITER 2: row=16, varin=103, theta=0.096581, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 28506708.110129
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 48 rows, 60 cols, 289 nonzeros, 0 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 80 LP 1 Solution, length = 28506708.110129, 0.01 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.250000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.250000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 1.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.903419 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.250000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.250000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.250000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.750000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.750000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.750000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.096581 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.750000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.096581 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28506708.110129, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 80 at  28.50670811012868455236
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde83aa1f0
% @LO 0.08  28.42187324554837957180 99.9000000000
% @LN 0.08  28.42325506827320680259 99.9000000000
% Resuming node 32 at  28.42325506827320680259
DEBUG CONSTRNT: LP rows=48, pool->nlprows=48, pool->npend=0
DEBUG CONSTRNT: Checking 48 LP rows (pool tracks 48, total LP rows 48)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=47, expected 47
 % @PAP adding 38 rows, 199 nz to LP
DEBUG BB: Processing node 32, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=12, varin=37, theta=4.008146, up=999999999999999983222784.000000
ITER 2: row=34, varin=31, theta=2.000000, up=999999999999999983222784.000000
ITER 3: row=2, varin=23, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=35, varin=33, theta=2.000000, up=999999999999999983222784.000000
ITER 5: row=1, varin=24, theta=0.500000, up=999999999999999983222784.000000
ITER 6: row=36, varin=3, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=31, varin=28, theta=0.500000, up=999999999999999983222784.000000
ITER 8: row=20, varin=25, theta=0.463228, up=999999999999999983222784.000000
ITER 9: row=29, varin=63, theta=0.428956, up=1.000000
ITER 10: row=32, varin=21, theta=0.237282, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=11)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=38)
DEBUG SOLUTION: LP solution array indices: FST[39-78], not_covered[79-98]
DEBUG SOLUTION: lp->best_solution[0] = 28423255.068273
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 38 rows, 60 cols, 259 nonzeros, 5 slack, 33 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 8 rows, 33 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=43, varin=22, theta=0.126304, up=999999999999999983222784.000000
ITER 2: row=39, varin=103, theta=0.985324, up=1.000000
ITER 3: row=3, varin=69, theta=0.450155, up=1.000000
ITER 4: row=44, varin=76, theta=1.206385, up=1.000000
ITER 5: row=44, varin=68, theta=0.165318, up=1.000000
ITER 6: row=45, varin=57, theta=0.622242, up=1.000000
ITER 7: row=42, varin=49, theta=1.121431, up=1.000000
ITER 8: row=42, varin=81, theta=0.134845, up=1.000000
ITER 9: row=44, varin=44, theta=0.139116, up=999999999999999983222784.000000
ITER 10: row=21, varin=39, theta=0.065920, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=14)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=46)
DEBUG SOLUTION: LP solution array indices: FST[47-86], not_covered[87-106]
DEBUG SOLUTION: lp->best_solution[0] = 28789071.187206
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 46 rows, 60 cols, 292 nonzeros, 4 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % @PAP adding 6 rows, 21 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=45, varin=71, theta=0.632523, up=1.000000
ITER 2: row=40, varin=70, theta=0.615216, up=1.000000
ITER 3: row=27, varin=76, theta=0.789768, up=1.000000
ITER 4: row=43, varin=72, theta=2.254219, up=1.000000
ITER 5: row=43, varin=91, theta=0.045603, up=1.000000
ITER 6: row=44, varin=72, theta=0.778297, up=1.000000
ITER 7: row=21, varin=27, theta=0.740971, up=999999999999999983222784.000000
ITER 8: row=40, varin=63, theta=0.073734, up=1.000000
ITER 9: row=16, varin=39, theta=0.660885, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=9)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 28893910.239170
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 48 rows, 60 cols, 305 nonzeros, 2 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=47, varin=69, theta=0.803241, up=1.000000
ITER 2: row=27, varin=59, theta=1.103579, up=1.000000
ITER 3: row=27, varin=73, theta=0.081023, up=1.000000
ITER 4: row=20, varin=59, theta=0.887711, up=1.000000
ITER 5: row=25, varin=76, theta=0.846603, up=1.000000
ITER 6: row=17, varin=78, theta=1.253592, up=1.000000
ITER 7: row=17, varin=81, theta=0.483597, up=1.000000
ITER 8: row=44, varin=80, theta=0.859212, up=1.000000
ITER 9: row=17, varin=78, theta=1.000000, up=1.000000
ITER 10: row=44, varin=49, theta=0.132166, up=1.000000
LP PHASE: Switching to primal (iter=11)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 29086393.921515
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 47 rows, 60 cols, 295 nonzeros, 1 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 3 rows, 9 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=48, varin=61, theta=0.500000, up=1.000000
ITER 2: row=47, varin=82, theta=1.000000, up=1.000000
ITER 3: row=39, varin=83, theta=1.000000, up=1.000000
ITER 4: row=5, varin=81, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 29179807.961020
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 49 rows, 60 cols, 302 nonzeros, 1 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=49, varin=76, theta=0.266568, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 29205068.978512
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 49 rows, 60 cols, 302 nonzeros, 0 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=50, varin=7, theta=0.131609, up=999999999999999983222784.000000
ITER 2: row=44, varin=19, theta=0.255384, up=999999999999999983222784.000000
ITER 3: row=41, varin=52, theta=0.003386, up=1.000000
ITER 4: row=12, varin=4, theta=0.014746, up=999999999999999983222784.000000
ITER 5: row=3, varin=40, theta=0.047893, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 29230748.461978
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.988027
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.988027
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 51 rows, 60 cols, 308 nonzeros, 6 slack, 45 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 6 slack rows
  % @PAP adding 6 rows, 14 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=48, varin=75, theta=1.106825, up=1.000000
ITER 2: row=48, varin=35, theta=0.203901, up=999999999999999983222784.000000
ITER 3: row=46, varin=4, theta=0.070694, up=999999999999999983222784.000000
ITER 4: row=50, varin=65, theta=1.633149, up=1.000000
ITER 5: row=50, varin=68, theta=0.378325, up=1.000000
ITER 6: row=14, varin=65, theta=3.424653, up=1.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 999999999999999983222784.000000
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.988027
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.988027
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 51 rows, 60 cols, 308 nonzeros, 1 slack, 50 tight.
  % Node 32 LP 1 Solution, length = 999999999999999983222784.000000, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.011973 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.500000 (FST 2)
  % DEBUG LP_VARS: x[3] = 1.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 1.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 1.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.500000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.011973 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.023946 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.500000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.011973 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.011973 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.190134 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.761973 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.988027 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.988027 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.988027 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.500000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 0.500000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
DEBUG BB: compute_good_lower_bound returned status=1
DEBUG BB: Node 32 is INFEASIBLE
 %      32    33    infeasible               28429923.2935    x3 U    23     6
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde83a93e0
% @LO 0.08  28.42325506827320680259 99.9000000000
% @LN 0.08  28.42992329351826086281 99.9000000000
% Resuming node 75 at  28.42992329351826086281
DEBUG CONSTRNT: LP rows=51, pool->nlprows=51, pool->npend=0
DEBUG CONSTRNT: Checking 51 LP rows (pool tracks 51, total LP rows 51)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 133
DEBUG CONSTRNT: Pool row 133 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 134
DEBUG CONSTRNT: Pool row 134 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=50, expected 50
 % @PAP adding 42 rows, 173 nz to LP
DEBUG BB: Processing node 75, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=9, varin=66, theta=1.000000, up=1.000000
ITER 2: row=34, varin=54, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 28429923.293518
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 42 rows, 60 cols, 233 nonzeros, 0 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 6 rows, 34 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=43, varin=53, theta=0.500000, up=1.000000
ITER 2: row=44, varin=36, theta=0.066667, up=999999999999999983222784.000000
ITER 3: row=48, varin=44, theta=0.076923, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 28443788.168275
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 48 rows, 60 cols, 267 nonzeros, 5 slack, 43 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % @PAP adding 3 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=44, varin=56, theta=1.000000, up=1.000000
ITER 2: row=13, varin=43, theta=0.800000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=46)
DEBUG SOLUTION: LP solution array indices: FST[47-86], not_covered[87-106]
DEBUG SOLUTION: lp->best_solution[0] = 28446190.622864
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 46 rows, 60 cols, 249 nonzeros, 1 slack, 45 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 75 LP 1 Solution, length = 28446190.622864, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.200000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.200000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.200000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.200000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 1.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.200000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.200000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.800000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.800000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.800000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.800000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.800000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.800000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.800000 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28446190.622864, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 75 at  28.44619062286372468407
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde83bccf0
% @LO 0.08  28.42992329351826086281 99.9000000000
% @LN 0.08  28.43124763127927323580 99.9000000000
% Resuming node 68 at  28.43124763127927323580
DEBUG CONSTRNT: LP rows=45, pool->nlprows=45, pool->npend=0
DEBUG CONSTRNT: Checking 45 LP rows (pool tracks 45, total LP rows 45)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 49
DEBUG CONSTRNT: Pool row 49 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 68
DEBUG CONSTRNT: Pool row 68 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 82
DEBUG CONSTRNT: Pool row 82 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 121
DEBUG CONSTRNT: Pool row 121 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=44, expected 44
 % @PAP adding 37 rows, 158 nz to LP
DEBUG BB: Processing node 68, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 68 LP 2 Solution, length = 28431247.631279, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.500000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.500000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.500000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.500000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 1.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.500000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.500000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.500000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.500000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.500000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=28431247.631279, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28431247.631279, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 68 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 68
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.500000
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.500000
DEBUG CAREFUL: Adding var 8 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.500000
DEBUG CAREFUL: Adding var 12 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.500000
DEBUG CAREFUL: Adding var 14 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=1.000000
DEBUG CAREFUL: Skipping var 20: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 4 fractional variables

  %  Carefully choosing branching variable, nfrac = 4
DEBUG CAREFUL: Testing fvar[0] = var 12
DEBUG CAREFUL: Calling compare_branch_vars for var 12
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 12
DEBUG CAREFUL: New best var: 12
DEBUG CAREFUL: Testing fvar[1] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[2] = var 8
DEBUG CAREFUL: Calling compare_branch_vars for var 8
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 8
DEBUG CAREFUL: Testing fvar[3] = var 14
DEBUG CAREFUL: Calling compare_branch_vars for var 14
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 14
  % Initial guess is x12, Z0 = 28431247.6312793        , Z1 = 28431247.6312793        

DEBUG EVAL: Testing var 12 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=13, varin=30, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=33, varin=32, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 12 = 0 gives z=28438796.300058
  % 	x12 = 0,	Z0 = 28438796.3000585        
DEBUG EVAL: First branch cutoff check: z=28438796.300058, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 12 = 1
ITER 1: row=13, varin=31, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=35, varin=27, theta=1.000000, up=999999999999999983222784.000000
  % 	x12 = 1,	Z1 = 28565793.4396482        
DEBUG EVAL: Second branch cutoff check: z=28565793.439648, best_z=INF, threshold=INF
  %   New best:  x12, Z = 28438796.3000585        
DEBUG EVAL: Testing var 2 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=64, theta=0.500000, up=1.000000
DEBUG EVAL: Branch var 2 = 0 gives z=28445212.609355
  % 	x2 = 0,	Z0 = 28445212.6093546        
DEBUG EVAL: First branch cutoff check: z=28445212.609355, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 1
ITER 1: row=1, varin=30, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=33, varin=36, theta=0.500000, up=999999999999999983222784.000000
ITER 3: row=2, varin=32, theta=0.500000, up=999999999999999983222784.000000
  % 	x2 = 1,	Z1 = 28438796.3000585        
DEBUG EVAL: Second branch cutoff check: z=28438796.300058, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 8 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=11, varin=30, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=33, varin=13, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 8 = 0 gives z=28522212.201222
  % 	x8 = 0,	Z0 = 28522212.2012224        
DEBUG EVAL: First branch cutoff check: z=28522212.201222, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 8 = 1
ITER 1: row=11, varin=27, theta=1.000000, up=999999999999999983222784.000000
  % 	x8 = 1,	Z1 = 28565793.4396482        
DEBUG EVAL: Second branch cutoff check: z=28565793.439648, best_z=INF, threshold=INF
  %   New best:  x8, Z = 28522212.2012224        
DEBUG EVAL: Testing var 14 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=25, varin=13, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 14 = 0 gives z=28522212.201222
  % 	x14 = 0,	Z0 = 28522212.2012224        
DEBUG EVAL: First branch cutoff check: z=28522212.201222, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 14 = 1
ITER 1: row=25, varin=30, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=33, varin=31, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=35, varin=32, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=1, varin=64, theta=1.000000, up=1.000000
  % 	x14 = 1,	Z1 = 28596177.8929669        
DEBUG EVAL: Second branch cutoff check: z=28596177.892967, best_z=INF, threshold=INF
  %   New best:  x14, Z = 28522212.2012224        
  % Best branch is x14, Z0 = 28522212.2012224        , Z1 = 28596177.8929669        

DEBUG CAREFUL: Final result - returning best.var = 14
DEBUG BB: Branching variable chosen: j=14
 % @NC   85   68	x14 = 0	28522212.201222
 % @NC   86   68	x14 = 1	28596177.892967
 %      68    34 28431247.6313               28433267.6433    x9 D    55     8
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde83ad260
% @LO 0.08  28.43124763127927323580 99.9000000000
% @LN 0.08  28.43326764331283129650 99.9000000000
% Resuming node 69 at  28.43326764331283129650
DEBUG CONSTRNT: LP rows=37, pool->nlprows=37, pool->npend=0
DEBUG CONSTRNT: Checking 37 LP rows (pool tracks 37, total LP rows 37)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 141
DEBUG CONSTRNT: Pool row 141 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 145
DEBUG CONSTRNT: Pool row 145 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 159
DEBUG CONSTRNT: Pool row 159 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 79
DEBUG CONSTRNT: Pool row 79 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 45
DEBUG CONSTRNT: Pool row 45 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 62
DEBUG CONSTRNT: Pool row 62 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=36, expected 36
 % @PAP adding 40 rows, 173 nz to LP
DEBUG BB: Processing node 69, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 69 LP 2 Solution, length = 28433267.643313, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.500000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.500000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.500000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.500000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 2 fractional variables
DEBUG CG: LP optimal, z=28433267.643313, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28433267.643313, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 69 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 69
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=1.000000
DEBUG CAREFUL: Skipping var 7: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.500000
DEBUG CAREFUL: Adding var 12 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.500000
DEBUG CAREFUL: Adding var 15 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 2 fractional variables

  %  Carefully choosing branching variable, nfrac = 2
DEBUG CAREFUL: Testing fvar[0] = var 12
DEBUG CAREFUL: Calling compare_branch_vars for var 12
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 12
DEBUG CAREFUL: New best var: 12
DEBUG CAREFUL: Testing fvar[1] = var 15
DEBUG CAREFUL: Calling compare_branch_vars for var 15
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 15
  % Initial guess is x12, Z0 = 28433267.6433128        , Z1 = 28433267.6433128        

DEBUG EVAL: Testing var 12 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=16, varin=21, theta=0.303030, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 12 = 0 gives z=28433728.446021
  % 	x12 = 0,	Z0 = 28433728.4460214        
DEBUG EVAL: First branch cutoff check: z=28433728.446021, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 12 = 1
ITER 1: row=16, varin=39, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=2, varin=25, theta=0.363636, up=999999999999999983222784.000000
ITER 3: row=25, varin=20, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=23, varin=11, theta=0.376471, up=999999999999999983222784.000000
ITER 5: row=1, varin=3, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=39, varin=37, theta=4.000000, up=999999999999999983222784.000000
  % 	x12 = 1,	Z1 = 28506042.4206007        
DEBUG EVAL: Second branch cutoff check: z=28506042.420601, best_z=INF, threshold=INF
  %   New best:  x12, Z = 28433728.4460214        
DEBUG EVAL: Testing var 15 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=26, varin=39, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=2, varin=25, theta=0.363636, up=999999999999999983222784.000000
ITER 3: row=25, varin=20, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=23, varin=11, theta=0.376471, up=999999999999999983222784.000000
ITER 5: row=1, varin=3, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=39, varin=33, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 15 = 0 gives z=28501786.316581
  % 	x15 = 0,	Z0 = 28501786.3165814        
DEBUG EVAL: First branch cutoff check: z=28501786.316581, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 15 = 1
ITER 1: row=26, varin=21, theta=0.303030, up=999999999999999983222784.000000
  % 	x15 = 1,	Z1 = 28433728.4460214        
DEBUG EVAL: Second branch cutoff check: z=28433728.446021, best_z=INF, threshold=INF
  % Best branch is x12, Z0 = 28433728.4460214        , Z1 = 28506042.4206007        

DEBUG CAREFUL: Final result - returning best.var = 12
DEBUG BB: Branching variable chosen: j=12
 % @NC   87   69	x12 = 0	28433728.446021
 % @NC   88   69	x12 = 1	28506042.420601
 %      69    35 28433267.6433               28433728.4460   x14 D    60     7
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde83bccf0
% @LO 0.08  28.43326764331283129650 99.9000000000
% @LN 0.08  28.43372844602139792869 99.9000000000
% Resuming node 87 at  28.43372844602139792869
DEBUG CONSTRNT: LP rows=40, pool->nlprows=40, pool->npend=0
DEBUG CONSTRNT: Checking 40 LP rows (pool tracks 40, total LP rows 40)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 91
DEBUG CONSTRNT: Pool row 91 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=39, expected 39
 % @PAP adding 40 rows, 173 nz to LP
DEBUG BB: Processing node 87, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=16, varin=21, theta=0.303030, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=40)
DEBUG SOLUTION: LP solution array indices: FST[41-80], not_covered[81-100]
DEBUG SOLUTION: lp->best_solution[0] = 28433728.446021
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.939394
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.939394
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 3.000000
  % @PL 40 rows, 60 cols, 233 nonzeros, 6 slack, 34 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=41, varin=14, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=23, varin=25, theta=0.512821, up=999999999999999983222784.000000
ITER 3: row=42, varin=41, theta=0.125000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28451920.984989
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.875000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.875000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 44 rows, 60 cols, 241 nonzeros, 10 slack, 34 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 10 slack rows
  % @PAP adding 3 rows, 14 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=35, varin=29, theta=1.400000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=37)
DEBUG SOLUTION: LP solution array indices: FST[38-77], not_covered[78-97]
DEBUG SOLUTION: lp->best_solution[0] = 28458748.007755
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 37 rows, 60 cols, 222 nonzeros, 4 slack, 33 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % @PAP adding 3 rows, 12 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=34, varin=40, theta=0.400000, up=1.000000
ITER 2: row=36, varin=16, theta=0.076923, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=36)
DEBUG SOLUTION: LP solution array indices: FST[37-76], not_covered[77-96]
DEBUG SOLUTION: lp->best_solution[0] = 28466740.929375
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 36 rows, 60 cols, 214 nonzeros, 1 slack, 35 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 3 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=36, varin=65, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=38)
DEBUG SOLUTION: LP solution array indices: FST[39-78], not_covered[79-98]
DEBUG SOLUTION: lp->best_solution[0] = 28468114.123451
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 38 rows, 60 cols, 210 nonzeros, 0 slack, 38 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 17 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=39, varin=49, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 28471698.701274
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 42 rows, 60 cols, 227 nonzeros, 0 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 28 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=43, varin=35, theta=0.666667, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=46)
DEBUG SOLUTION: LP solution array indices: FST[47-86], not_covered[87-106]
DEBUG SOLUTION: lp->best_solution[0] = 28472381.849385
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 46 rows, 60 cols, 255 nonzeros, 2 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % Node 87 LP 1 Solution, length = 28472381.849385, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.166667 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.166667 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.166667 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 1.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.166667 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.166667 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.166667 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.833333 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.833333 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.833333 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.833333 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.833333 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.833333 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.833333 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28472381.849385, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 87 at  28.47238184938464300444
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde83bff70
% @LO 0.08  28.43372844602139792869 99.9000000000
% @LN 0.08  28.43745282157383158506 99.9000000000
% Resuming node 82 at  28.43745282157383158506
DEBUG CONSTRNT: LP rows=44, pool->nlprows=44, pool->npend=0
DEBUG CONSTRNT: Checking 44 LP rows (pool tracks 44, total LP rows 44)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=43, expected 43
 % @PAP adding 49 rows, 186 nz to LP
DEBUG BB: Processing node 82, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=35, theta=6.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 28437452.821574
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 49 rows, 60 cols, 246 nonzeros, 1 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 3 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=52, varin=80, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 28446934.502087
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 52 rows, 60 cols, 254 nonzeros, 0 slack, 52 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=53, varin=85, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=54)
DEBUG SOLUTION: LP solution array indices: FST[55-94], not_covered[95-114]
DEBUG SOLUTION: lp->best_solution[0] = 28454527.830671
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 54 rows, 60 cols, 260 nonzeros, 0 slack, 54 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 15 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=55, varin=81, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=58)
DEBUG SOLUTION: LP solution array indices: FST[59-98], not_covered[99-118]
DEBUG SOLUTION: lp->best_solution[0] = 28466862.090341
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 58 rows, 60 cols, 275 nonzeros, 0 slack, 58 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 19 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=59, varin=95, theta=1.000000, up=1.000000
ITER 2: row=54, varin=84, theta=1.000000, up=1.000000
ITER 3: row=26, varin=21, theta=0.500000, up=999999999999999983222784.000000
ITER 4: row=42, varin=23, theta=0.200000, up=999999999999999983222784.000000
ITER 5: row=40, varin=38, theta=0.250000, up=999999999999999983222784.000000
ITER 6: row=43, varin=42, theta=0.500000, up=999999999999999983222784.000000
ITER 7: row=56, varin=30, theta=0.333333, up=999999999999999983222784.000000
ITER 8: row=43, varin=91, theta=1.000000, up=1.000000
ITER 9: row=16, varin=54, theta=0.250000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=9)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=62)
DEBUG SOLUTION: LP solution array indices: FST[63-102], not_covered[103-122]
DEBUG SOLUTION: lp->best_solution[0] = 28553258.240345
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 62 rows, 60 cols, 294 nonzeros, 7 slack, 55 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 7 slack rows
  % Node 82 LP 1 Solution, length = 28553258.240345, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.250000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.250000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.250000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.250000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.250000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.250000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.250000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.750000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.750000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.750000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.750000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.750000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.750000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.750000 (terminal 19)
 % 7 fractional variables
DEBUG CG: LP optimal, z=28553258.240345, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 82 at  28.55325824034515846961
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde83b0540
% @LO 0.08  28.43745282157383158506 99.9000000000
% @LN 0.08  28.44217204049230218743 99.9000000000
% Resuming node 71 at  28.44217204049230218743
DEBUG CONSTRNT: LP rows=55, pool->nlprows=55, pool->npend=0
DEBUG CONSTRNT: Checking 55 LP rows (pool tracks 55, total LP rows 55)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 85
DEBUG CONSTRNT: Pool row 85 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=54, expected 54
 % @PAP adding 45 rows, 181 nz to LP
DEBUG BB: Processing node 71, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 71 LP 2 Solution, length = 28442172.040492, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.500000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.500000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.500000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.500000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.500000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.500000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.500000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.500000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.500000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.500000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.500000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.500000 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=28442172.040492, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28442172.040492, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 71 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 71
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=1.000000
DEBUG CAREFUL: Skipping var 5: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.500000
DEBUG CAREFUL: Adding var 9 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.500000
DEBUG CAREFUL: Adding var 12 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.500000
DEBUG CAREFUL: Adding var 14 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.500000
DEBUG CAREFUL: Adding var 20 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 4 fractional variables

  %  Carefully choosing branching variable, nfrac = 4
DEBUG CAREFUL: Testing fvar[0] = var 9
DEBUG CAREFUL: Calling compare_branch_vars for var 9
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 9
DEBUG CAREFUL: New best var: 9
DEBUG CAREFUL: Testing fvar[1] = var 14
DEBUG CAREFUL: Calling compare_branch_vars for var 14
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 14
DEBUG CAREFUL: Testing fvar[2] = var 12
DEBUG CAREFUL: Calling compare_branch_vars for var 12
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 12
DEBUG CAREFUL: New best var: 12
DEBUG CAREFUL: Testing fvar[3] = var 20
DEBUG CAREFUL: Calling compare_branch_vars for var 20
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 20
  % Initial guess is x12, Z0 = 28452584.3975338        , Z1 = 28475087.8834343        

DEBUG EVAL: Testing var 9 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=22, varin=43, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 9 = 0 gives z=28498911.417806
  % 	x9 = 0,	Z0 = 28498911.4178058        
DEBUG EVAL: First branch cutoff check: z=28498911.417806, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 9 = 1
ITER 1: row=22, varin=39, theta=1.000000, up=999999999999999983222784.000000
  % 	x9 = 1,	Z1 = 28506108.3825734        
DEBUG EVAL: Second branch cutoff check: z=28506108.382573, best_z=INF, threshold=INF
  %   New best:  x9, Z = 28498911.4178058        
DEBUG EVAL: Testing var 14 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=38, varin=39, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 14 = 0 gives z=28506108.382573
  % 	x14 = 0,	Z0 = 28506108.3825734        
DEBUG EVAL: First branch cutoff check: z=28506108.382573, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 14 = 1
ITER 1: row=38, varin=43, theta=1.000000, up=999999999999999983222784.000000
  % 	x14 = 1,	Z1 = 28498911.4178058        
DEBUG EVAL: Second branch cutoff check: z=28498911.417806, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 12 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=32, varin=23, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 12 = 0 gives z=28449720.709272
  % 	x12 = 0,	Z0 = 28452584.3975338        
DEBUG EVAL: First branch cutoff check: z=28452584.397534, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 20 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=6, varin=43, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 20 = 0 gives z=28498911.417806
  % 	x20 = 0,	Z0 = 28498911.4178058        
DEBUG EVAL: First branch cutoff check: z=28498911.417806, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 20 = 1
ITER 1: row=6, varin=44, theta=0.500000, up=999999999999999983222784.000000
  % 	x20 = 1,	Z1 = 28452584.3975338        
DEBUG EVAL: Second branch cutoff check: z=28452584.397534, best_z=INF, threshold=INF
  % Best branch is x9, Z0 = 28498911.4178058        , Z1 = 28506108.3825734        

DEBUG CAREFUL: Final result - returning best.var = 9
DEBUG BB: Branching variable chosen: j=9
 % @NC   89   71	x9 = 0	28498911.417806
 % @NC   90   71	x9 = 1	28506108.382573
 %      71    36 28442172.0405               28443203.6530   x15 D    22     5
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde8386600
% @LO 0.08  28.44217204049230218743 99.9000000000
% @LN 0.08  28.44320365302507624961 99.9000000000
% Resuming node 61 at  28.44320365302507624961
DEBUG CONSTRNT: LP rows=45, pool->nlprows=45, pool->npend=0
DEBUG CONSTRNT: Checking 45 LP rows (pool tracks 45, total LP rows 45)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 63
DEBUG CONSTRNT: Pool row 63 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 91
DEBUG CONSTRNT: Pool row 91 has lprow=44, expected 44
 % @PAP adding 44 rows, 173 nz to LP
DEBUG BB: Processing node 61, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 61 LP 2 Solution, length = 28443203.653025, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.200000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.200000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.200000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.200000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.200000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.200000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.800000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.800000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.800000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.800000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.800000 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28443203.653025, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28443203.653025, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 61 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 61
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.200000
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.200000)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.200000
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.200000)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.200000
DEBUG CAREFUL: Adding var 4 to fractional list (xi=0.200000)
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=1.000000
DEBUG CAREFUL: Skipping var 5: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.200000
DEBUG CAREFUL: Adding var 11 to fractional list (xi=0.200000)
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.200000
DEBUG CAREFUL: Adding var 22 to fractional list (xi=0.200000)
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.200000
DEBUG CAREFUL: Adding var 27 to fractional list (xi=0.200000)
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 6 fractional variables

  %  Carefully choosing branching variable, nfrac = 6
DEBUG CAREFUL: Testing fvar[0] = var 4
DEBUG CAREFUL: Calling compare_branch_vars for var 4
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 4
DEBUG CAREFUL: New best var: 4
DEBUG CAREFUL: Testing fvar[1] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[2] = var 11
DEBUG CAREFUL: Calling compare_branch_vars for var 11
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 11
DEBUG CAREFUL: Testing fvar[3] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 3
DEBUG CAREFUL: Testing fvar[4] = var 27
DEBUG CAREFUL: Calling compare_branch_vars for var 27
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 27
DEBUG CAREFUL: Testing fvar[5] = var 22
DEBUG CAREFUL: Calling compare_branch_vars for var 22
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 22
DEBUG CAREFUL: New best var: 22
  % Initial guess is x22, Z0 = 28443203.6530251        , Z1 = 28453299.0892643        

DEBUG EVAL: Testing var 4 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=28, varin=43, theta=4.000000, up=999999999999999983222784.000000
ITER 2: row=33, varin=41, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 4 = 1 gives z=28508257.387697
  % 	x4 = 1,	Z1 = 28508257.3876966        
DEBUG EVAL: First branch cutoff check: z=28508257.387697, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 4 = 0
ITER 1: row=28, varin=77, theta=1.000000, up=1.000000
  % 	x4 = 0,	Z0 = 28460242.5830196        
DEBUG EVAL: Second branch cutoff check: z=28460242.583020, best_z=INF, threshold=INF
  %   New best:  x4, Z = 28460242.5830196        
DEBUG EVAL: Testing var 2 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=77, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 2 = 0 gives z=28460242.583020
  % 	x2 = 0,	Z0 = 28460242.5830196        
DEBUG EVAL: First branch cutoff check: z=28460242.583020, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 1
ITER 1: row=1, varin=43, theta=4.000000, up=999999999999999983222784.000000
ITER 2: row=33, varin=37, theta=3.000000, up=999999999999999983222784.000000
ITER 3: row=37, varin=42, theta=3.000000, up=999999999999999983222784.000000
ITER 4: row=42, varin=38, theta=0.666667, up=999999999999999983222784.000000
  % 	x2 = 1,	Z1 = 28545940.5823542        
DEBUG EVAL: Second branch cutoff check: z=28545940.582354, best_z=INF, threshold=INF
  %   New best:  x2, Z = 28460242.5830196        
DEBUG EVAL: Testing var 11 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=32, varin=77, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 11 = 0 gives z=28460242.583020
  % 	x11 = 0,	Z0 = 28460242.5830196        
DEBUG EVAL: First branch cutoff check: z=28460242.583020, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 11 = 1
ITER 1: row=32, varin=43, theta=4.000000, up=999999999999999983222784.000000
ITER 2: row=33, varin=37, theta=3.000000, up=999999999999999983222784.000000
ITER 3: row=37, varin=42, theta=3.000000, up=999999999999999983222784.000000
ITER 4: row=42, varin=29, theta=2.000000, up=999999999999999983222784.000000
ITER 5: row=39, varin=40, theta=2.000000, up=999999999999999983222784.000000
ITER 6: row=27, varin=34, theta=2.000000, up=999999999999999983222784.000000
ITER 7: row=34, varin=38, theta=2.000000, up=999999999999999983222784.000000
ITER 8: row=32, varin=52, theta=1.000000, up=1.000000
ITER 9: row=17, varin=33, theta=0.500000, up=999999999999999983222784.000000
  % 	x11 = 1,	Z1 = 28912345.9944553        
DEBUG EVAL: Second branch cutoff check: z=28912345.994455, best_z=INF, threshold=INF
  %   New best:  x11, Z = 28460242.5830196        
DEBUG EVAL: Testing var 3 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=11, varin=77, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 3 = 0 gives z=28460242.583020
  % 	x3 = 0,	Z0 = 28460242.5830196        
DEBUG EVAL: First branch cutoff check: z=28460242.583020, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 3 = 1
ITER 1: row=11, varin=43, theta=4.000000, up=999999999999999983222784.000000
ITER 2: row=33, varin=37, theta=3.000000, up=999999999999999983222784.000000
ITER 3: row=37, varin=42, theta=3.000000, up=999999999999999983222784.000000
ITER 4: row=42, varin=40, theta=2.000000, up=999999999999999983222784.000000
ITER 5: row=27, varin=34, theta=2.000000, up=999999999999999983222784.000000
ITER 6: row=34, varin=32, theta=0.666667, up=999999999999999983222784.000000
  % 	x3 = 1,	Z1 = 28756968.2867279        
DEBUG EVAL: Second branch cutoff check: z=28756968.286728, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 27 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=42, varin=43, theta=4.000000, up=999999999999999983222784.000000
ITER 2: row=33, varin=37, theta=3.000000, up=999999999999999983222784.000000
ITER 3: row=37, varin=38, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 27 = 1 gives z=28550680.578811
  % 	x27 = 1,	Z1 = 28550680.5788107        
DEBUG EVAL: First branch cutoff check: z=28550680.578811, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 27 = 0
ITER 1: row=42, varin=42, theta=0.250000, up=999999999999999983222784.000000
  % 	x27 = 0,	Z0 = 28450277.6858169        
DEBUG EVAL: Second branch cutoff check: z=28450277.685817, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 22 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=33, varin=37, theta=4.000000, up=999999999999999983222784.000000
ITER 2: row=37, varin=42, theta=4.000000, up=999999999999999983222784.000000
ITER 3: row=42, varin=40, theta=3.000000, up=999999999999999983222784.000000
ITER 4: row=27, varin=34, theta=3.000000, up=999999999999999983222784.000000
ITER 5: row=34, varin=28, theta=0.750000, up=999999999999999983222784.000000
ITER 6: row=44, varin=32, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 22 = 1 gives z=28887149.723624
  % 	x22 = 1,	Z1 = 28887149.7236244        
DEBUG EVAL: First branch cutoff check: z=28887149.723624, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 22 = 0
ITER 1: row=33, varin=43, theta=0.250000, up=999999999999999983222784.000000
  % 	x22 = 0,	Z0 = 28445295.7887536        
DEBUG EVAL: Second branch cutoff check: z=28445295.788754, best_z=INF, threshold=INF
  % Best branch is x11, Z0 = 28460242.5830196        , Z1 = 28912345.9944553        

DEBUG CAREFUL: Final result - returning best.var = 11
DEBUG BB: Branching variable chosen: j=11
 % @NC   91   61	x11 = 0	28460242.583020
 % @NC   92   61	x11 = 1	28912345.994455
 %      61    37 28443203.6530               28446190.6229    x1 D    57     7
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde83a93e0
% @LO 0.08  28.44320365302507624961 99.9000000000
% @LN 0.08  28.44619062286372468407 99.9000000000
% Resuming node 75 at  28.44619062286372468407
DEBUG CONSTRNT: LP rows=44, pool->nlprows=44, pool->npend=0
DEBUG CONSTRNT: Checking 44 LP rows (pool tracks 44, total LP rows 44)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=43, expected 43
 % @PAP adding 45 rows, 179 nz to LP
DEBUG BB: Processing node 75, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 75 LP 2 Solution, length = 28446190.622864, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.200000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.200000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.200000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.200000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 1.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.200000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.200000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.800000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.800000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.800000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.800000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.800000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.800000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.800000 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28446190.622864, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28446190.622864, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 75 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 75
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.200000
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.200000)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.200000
DEBUG CAREFUL: Adding var 4 to fractional list (xi=0.200000)
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.200000
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.200000)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.200000
DEBUG CAREFUL: Adding var 11 to fractional list (xi=0.200000)
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=1.000000
DEBUG CAREFUL: Skipping var 16: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.200000
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.200000)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.200000
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.200000)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 6 fractional variables

  %  Carefully choosing branching variable, nfrac = 6
DEBUG CAREFUL: Testing fvar[0] = var 4
DEBUG CAREFUL: Calling compare_branch_vars for var 4
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 4
DEBUG CAREFUL: New best var: 4
DEBUG CAREFUL: Testing fvar[1] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[2] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[3] = var 11
DEBUG CAREFUL: Calling compare_branch_vars for var 11
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 11
DEBUG CAREFUL: Testing fvar[4] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[5] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
  % Initial guess is x4, Z0 = 28446190.6228637        , Z1 = 28684290.7194014        

DEBUG EVAL: Testing var 4 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=9, varin=53, theta=4.000000, up=1.000000
ITER 2: row=9, varin=40, theta=1.500000, up=999999999999999983222784.000000
ITER 3: row=13, varin=53, theta=1.000000, up=1.000000
ITER 4: row=40, varin=34, theta=2.000000, up=999999999999999983222784.000000
ITER 5: row=34, varin=39, theta=2.000000, up=999999999999999983222784.000000
ITER 6: row=39, varin=17, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=44, varin=36, theta=2.000000, up=999999999999999983222784.000000
ITER 8: row=36, varin=35, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 4 = 1 gives z=28773141.651079
  % 	x4 = 1,	Z1 = 28773141.6510788        
DEBUG EVAL: First branch cutoff check: z=28773141.651079, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 4 = 0
ITER 1: row=9, varin=43, theta=0.333333, up=999999999999999983222784.000000
  % 	x4 = 0,	Z0 = 28448793.2820013        
DEBUG EVAL: Second branch cutoff check: z=28448793.282001, best_z=INF, threshold=INF
  %   New best:  x4, Z = 28448793.2820013        
DEBUG EVAL: Testing var 17 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=17, varin=53, theta=4.000000, up=1.000000
ITER 2: row=17, varin=43, theta=1.500000, up=999999999999999983222784.000000
ITER 3: row=13, varin=53, theta=1.000000, up=1.000000
ITER 4: row=9, varin=40, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 17 = 1 gives z=28486533.258967
  % 	x17 = 1,	Z1 = 28486533.2589673        
DEBUG EVAL: First branch cutoff check: z=28486533.258967, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 17 = 0
ITER 1: row=17, varin=18, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=41, varin=102, theta=1.000000, up=1.000000
  % 	x17 = 0,	Z0 = 28498780.5475028        
DEBUG EVAL: Second branch cutoff check: z=28498780.547503, best_z=INF, threshold=INF
  %   New best:  x17, Z = 28486533.2589673        
DEBUG EVAL: Testing var 10 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=12, varin=15, theta=0.250000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 0 gives z=28493521.863455
  % 	x10 = 0,	Z0 = 28493521.8634549        
DEBUG EVAL: First branch cutoff check: z=28493521.863455, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 1
ITER 1: row=12, varin=53, theta=4.000000, up=1.000000
ITER 2: row=12, varin=43, theta=1.500000, up=999999999999999983222784.000000
ITER 3: row=13, varin=53, theta=1.000000, up=1.000000
ITER 4: row=9, varin=40, theta=1.000000, up=999999999999999983222784.000000
  % 	x10 = 1,	Z1 = 28486533.2589673        
DEBUG EVAL: Second branch cutoff check: z=28486533.258967, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 11 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=40, varin=53, theta=4.000000, up=1.000000
ITER 2: row=40, varin=43, theta=1.500000, up=999999999999999983222784.000000
ITER 3: row=13, varin=53, theta=1.000000, up=1.000000
ITER 4: row=9, varin=34, theta=2.000000, up=999999999999999983222784.000000
ITER 5: row=34, varin=39, theta=2.000000, up=999999999999999983222784.000000
ITER 6: row=39, varin=18, theta=2.000000, up=999999999999999983222784.000000
ITER 7: row=41, varin=36, theta=2.000000, up=999999999999999983222784.000000
ITER 8: row=36, varin=35, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 11 = 1 gives z=28748414.969801
  % 	x11 = 1,	Z1 = 28748414.9698005        
DEBUG EVAL: First branch cutoff check: z=28748414.969801, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 11 = 0
ITER 1: row=40, varin=40, theta=0.333333, up=999999999999999983222784.000000
  % 	x11 = 0,	Z0 = 28457035.509094         
DEBUG EVAL: Second branch cutoff check: z=28457035.509094, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 2 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=35, theta=0.250000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 0 gives z=28486483.913573
  % 	x2 = 0,	Z0 = 28486483.9135731        
DEBUG EVAL: First branch cutoff check: z=28486483.913573, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 26 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=36, varin=36, theta=0.250000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 26 = 0 gives z=28479501.424535
  % 	x26 = 0,	Z0 = 28479501.4245354        
DEBUG EVAL: First branch cutoff check: z=28479501.424535, best_z=INF, threshold=INF
  % Best branch is x17, Z0 = 28498780.5475028        , Z1 = 28486533.2589673        

DEBUG CAREFUL: Final result - returning best.var = 17
DEBUG BB: Branching variable chosen: j=17
 % @NC   93   75	x17 = 1	28486533.258967
 % @NC   94   75	x17 = 0	28498780.547503
 %      75    38 28446190.6229               28449013.0047    x3 D    65     7
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde839c250
% @LO 0.08  28.44619062286372468407 99.9000000000
% @LN 0.08  28.44901300470283800337 99.9000000000
% Resuming node 64 at  28.44901300470283800337
DEBUG CONSTRNT: LP rows=45, pool->nlprows=45, pool->npend=0
DEBUG CONSTRNT: Checking 45 LP rows (pool tracks 45, total LP rows 45)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 49
DEBUG CONSTRNT: Pool row 49 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 68
DEBUG CONSTRNT: Pool row 68 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 82
DEBUG CONSTRNT: Pool row 82 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 121
DEBUG CONSTRNT: Pool row 121 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=44, expected 44
 % @PAP adding 50 rows, 188 nz to LP
DEBUG BB: Processing node 64, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 64 LP 2 Solution, length = 28449013.004703, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.500000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.500000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 1.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.500000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.500000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.500000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.500000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.500000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.500000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=28449013.004703, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28449013.004703, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 64 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 64
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.500000
DEBUG CAREFUL: Adding var 0 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.500000
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=1.000000
DEBUG CAREFUL: Skipping var 13: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.500000
DEBUG CAREFUL: Adding var 29 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.500000
DEBUG CAREFUL: Adding var 33 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 4 fractional variables

  %  Carefully choosing branching variable, nfrac = 4
DEBUG CAREFUL: Testing fvar[0] = var 0
DEBUG CAREFUL: Calling compare_branch_vars for var 0
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 0
DEBUG CAREFUL: New best var: 0
DEBUG CAREFUL: Testing fvar[1] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 1
DEBUG CAREFUL: Testing fvar[2] = var 33
DEBUG CAREFUL: Calling compare_branch_vars for var 33
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 33
DEBUG CAREFUL: New best var: 33
DEBUG CAREFUL: Testing fvar[3] = var 29
DEBUG CAREFUL: Calling compare_branch_vars for var 29
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 29
  % Initial guess is x33, Z0 = 28449013.0047028        , Z1 = 28473575.0382726        

DEBUG EVAL: Testing var 0 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=78, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 0 = 0 gives z=28511089.073231
  % 	x0 = 0,	Z0 = 28511089.0732306        
DEBUG EVAL: First branch cutoff check: z=28511089.073231, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 0 = 1
ITER 1: row=1, varin=49, theta=1.000000, up=999999999999999983222784.000000
  % 	x0 = 1,	Z1 = 28450213.0468272        
DEBUG EVAL: Second branch cutoff check: z=28450213.046827, best_z=INF, threshold=INF
  %   New best:  x0, Z = 28450213.0468272        
DEBUG EVAL: Testing var 1 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=2, varin=6, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=3, varin=78, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 1 = 0 gives z=28511089.073231
  % 	x1 = 0,	Z0 = 28511089.0732306        
DEBUG EVAL: First branch cutoff check: z=28511089.073231, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 1 = 1
ITER 1: row=2, varin=49, theta=1.000000, up=999999999999999983222784.000000
  % 	x1 = 1,	Z1 = 28450213.0468272        
DEBUG EVAL: Second branch cutoff check: z=28450213.046827, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 33 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=45, varin=45, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 33 = 1 gives z=28499693.775052
  % 	x33 = 1,	Z1 = 28499693.7750515        
DEBUG EVAL: First branch cutoff check: z=28499693.775052, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 33 = 0
ITER 1: row=45, varin=49, theta=1.000000, up=999999999999999983222784.000000
  % 	x33 = 0,	Z0 = 28450213.0468272        
DEBUG EVAL: Second branch cutoff check: z=28450213.046827, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 29 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=32, varin=45, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 29 = 0 gives z=28499693.775052
  % 	x29 = 0,	Z0 = 28499693.7750515        
DEBUG EVAL: First branch cutoff check: z=28499693.775052, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 29 = 1
ITER 1: row=32, varin=49, theta=1.000000, up=999999999999999983222784.000000
  % 	x29 = 1,	Z1 = 28450213.0468272        
DEBUG EVAL: Second branch cutoff check: z=28450213.046827, best_z=INF, threshold=INF
  % Best branch is x0, Z0 = 28511089.0732306        , Z1 = 28450213.0468272        

DEBUG CAREFUL: Final result - returning best.var = 0
DEBUG BB: Branching variable chosen: j=0
 % @NC   95   64	x0 = 1	28450213.046827
 % @NC   96   64	x0 = 0	28511089.073231
 %      64    39 28449013.0047               28450213.0468   x17 D    43     7
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde83a93e0
% @LO 0.08  28.44901300470283800337 99.9000000000
% @LN 0.08  28.45021304682720852952 99.9000000000
% Resuming node 95 at  28.45021304682720852952
DEBUG CONSTRNT: LP rows=50, pool->nlprows=50, pool->npend=0
DEBUG CONSTRNT: Checking 50 LP rows (pool tracks 50, total LP rows 50)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 65
DEBUG CONSTRNT: Pool row 65 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 121
DEBUG CONSTRNT: Pool row 121 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=49, expected 49
 % @PAP adding 50 rows, 188 nz to LP
DEBUG BB: Processing node 95, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=49, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28450213.046827
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
  % @PL 50 rows, 60 cols, 248 nonzeros, 2 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 5 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=51, varin=6, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=3, varin=4, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=46, varin=45, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=1, varin=80, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 28994538.659311
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
  % @PL 52 rows, 60 cols, 253 nonzeros, 4 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % @PAP adding 3 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=49, varin=36, theta=3.000000, up=999999999999999983222784.000000
ITER 2: row=51, varin=85, theta=1.000000, up=1.000000
ITER 3: row=29, varin=74, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 29088610.463579
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 51 rows, 60 cols, 253 nonzeros, 3 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 4 rows, 19 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=49, varin=85, theta=1.000000, up=1.000000
ITER 2: row=47, varin=19, theta=0.500000, up=999999999999999983222784.000000
ITER 3: row=40, varin=21, theta=0.200000, up=999999999999999983222784.000000
ITER 4: row=38, varin=36, theta=0.250000, up=999999999999999983222784.000000
ITER 5: row=41, varin=78, theta=1.000000, up=1.000000
ITER 6: row=25, varin=74, theta=0.600000, up=1.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 29158477.310745
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 0.800000
DEBUG SOLUTION: lp->best_solution[8] = 0.800000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 52 rows, 60 cols, 262 nonzeros, 4 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % @PAP adding 3 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=49, varin=36, theta=0.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 29159236.934383
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 0.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 51 rows, 60 cols, 260 nonzeros, 3 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % Node 95 LP 1 Solution, length = 29159236.934383, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 1.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.500000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 1.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 1.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 1.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.500000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.500000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 1.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.500000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.500000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 0.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 3 fractional variables
DEBUG CG: LP optimal, z=29159236.934383, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 95 at  29.15923693438303843095
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde83b0540
% @LO 0.08  28.45021304682720852952 99.9000000000
% @LN 0.08  28.46024258301962461815 99.9000000000
% Resuming node 91 at  28.46024258301962461815
DEBUG CONSTRNT: LP rows=48, pool->nlprows=48, pool->npend=0
DEBUG CONSTRNT: Checking 48 LP rows (pool tracks 48, total LP rows 48)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 65
DEBUG CONSTRNT: Pool row 65 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 121
DEBUG CONSTRNT: Pool row 121 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 142
DEBUG CONSTRNT: Pool row 142 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 135
DEBUG CONSTRNT: Pool row 135 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=47, expected 47
 % @PAP adding 44 rows, 173 nz to LP
DEBUG BB: Processing node 91, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=32, varin=77, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28460242.583020
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 44 rows, 60 cols, 233 nonzeros, 0 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 13 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=45, varin=25, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=20, varin=70, theta=0.500000, up=1.000000
ITER 3: row=23, varin=5, theta=0.100000, up=999999999999999983222784.000000
ITER 4: row=25, varin=58, theta=1.000000, up=1.000000
ITER 5: row=46, varin=45, theta=0.250000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 28492695.098722
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 0.750000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 0.750000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 48 rows, 60 cols, 246 nonzeros, 3 slack, 45 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 2 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=46, varin=39, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 28508257.387697
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 47 rows, 60 cols, 244 nonzeros, 1 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 4 rows, 21 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=47, varin=35, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=43, varin=79, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28517625.503681
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 50 rows, 60 cols, 263 nonzeros, 0 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 5 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=51, varin=36, theta=0.333333, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 28524604.169611
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 51 rows, 60 cols, 268 nonzeros, 5 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=47, varin=39, theta=0.250000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 28534175.463959
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 47 rows, 60 cols, 248 nonzeros, 1 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 91 LP 1 Solution, length = 28534175.463959, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.250000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.250000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.250000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.250000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.250000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.250000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.250000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.250000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.750000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.750000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.750000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.750000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.750000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 0.750000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 8 fractional variables
DEBUG CG: LP optimal, z=28534175.463959, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 91 at  28.53417546395914428103
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde8397010
% @LO 0.08  28.46024258301962461815 99.9000000000
% @LN 0.08  28.46843514187361279255 99.9000000000
% Resuming node 47 at  28.46843514187361279255
DEBUG CONSTRNT: LP rows=46, pool->nlprows=46, pool->npend=0
DEBUG CONSTRNT: Checking 46 LP rows (pool tracks 46, total LP rows 46)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=45, expected 45
 % @PAP adding 51 rows, 243 nz to LP
DEBUG BB: Processing node 47, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 47 LP 2 Solution, length = 28468435.141874, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.151557 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.151557 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.500000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 1.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.500000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.151557 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.151557 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.045329 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.151557 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.848443 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.848443 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.848443 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.848443 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.500000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.500000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 8 fractional variables
DEBUG CG: LP optimal, z=28468435.141874, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28468435.141874, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 47 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 47
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.151557
DEBUG CAREFUL: Adding var 0 to fractional list (xi=0.151557)
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.151557
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.151557)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=1.000000
DEBUG CAREFUL: Skipping var 2: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.500000
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=1.000000
DEBUG CAREFUL: Skipping var 17: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.500000
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.151557
DEBUG CAREFUL: Adding var 29 to fractional list (xi=0.151557)
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.151557
DEBUG CAREFUL: Adding var 30 to fractional list (xi=0.151557)
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.045329
DEBUG CAREFUL: Adding var 32 to fractional list (xi=0.045329)
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.151557
DEBUG CAREFUL: Adding var 33 to fractional list (xi=0.151557)
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 8 fractional variables

  %  Carefully choosing branching variable, nfrac = 8
DEBUG CAREFUL: Testing fvar[0] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 10
DEBUG CAREFUL: New best var: 10
DEBUG CAREFUL: Testing fvar[1] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
DEBUG CAREFUL: Testing fvar[2] = var 32
DEBUG CAREFUL: Calling compare_branch_vars for var 32
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 32
DEBUG CAREFUL: New best var: 32
DEBUG CAREFUL: Testing fvar[3] = var 30
DEBUG CAREFUL: Calling compare_branch_vars for var 30
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 30
DEBUG CAREFUL: Testing fvar[4] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 1
DEBUG CAREFUL: Testing fvar[5] = var 0
DEBUG CAREFUL: Calling compare_branch_vars for var 0
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 0
DEBUG CAREFUL: Testing fvar[6] = var 33
DEBUG CAREFUL: Calling compare_branch_vars for var 33
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 33
DEBUG CAREFUL: Testing fvar[7] = var 29
DEBUG CAREFUL: Calling compare_branch_vars for var 29
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 29
  % Initial guess is x32, Z0 = 28468435.1418736        , Z1 = 28635408.345208         

DEBUG EVAL: Testing var 10 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=4, varin=36, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=46, varin=25, theta=0.080973, up=999999999999999983222784.000000
ITER 3: row=25, varin=49, theta=0.124141, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 0 gives z=28631983.276083
  % 	x10 = 0,	Z0 = 28631983.2760835        
DEBUG EVAL: First branch cutoff check: z=28631983.276083, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 1
ITER 1: row=4, varin=30, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=46, varin=80, theta=0.495910, up=1.000000
ITER 3: row=16, varin=83, theta=0.667134, up=1.000000
ITER 4: row=3, varin=4, theta=0.748803, up=999999999999999983222784.000000
ITER 5: row=51, varin=35, theta=0.792648, up=999999999999999983222784.000000
ITER 6: row=33, varin=28, theta=0.888456, up=999999999999999983222784.000000
  % 	x10 = 1,	Z1 = 28983000.0761079        
DEBUG EVAL: Second branch cutoff check: z=28983000.076108, best_z=INF, threshold=INF
  %   New best:  x10, Z = 28631983.2760835        
DEBUG EVAL: Testing var 26 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=27, varin=36, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=46, varin=25, theta=0.080973, up=999999999999999983222784.000000
ITER 3: row=25, varin=49, theta=0.124141, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 26 = 0 gives z=28631983.276083
  % 	x26 = 0,	Z0 = 28631983.2760835        
DEBUG EVAL: First branch cutoff check: z=28631983.276083, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 26 = 1
ITER 1: row=27, varin=18, theta=1.000000, up=999999999999999983222784.000000
  % 	x26 = 1,	Z1 = 28822901.6857401        
DEBUG EVAL: Second branch cutoff check: z=28822901.685740, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 32 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=46, varin=25, theta=0.584194, up=999999999999999983222784.000000
ITER 2: row=25, varin=49, theta=0.895634, up=999999999999999983222784.000000
ITER 3: row=40, varin=48, theta=0.570820, up=999999999999999983222784.000000
ITER 4: row=48, varin=47, theta=0.628719, up=999999999999999983222784.000000
ITER 5: row=47, varin=46, theta=254583.250000, up=999999999999999983222784.000000
ITER 6: row=1, varin=44, theta=0.500000, up=999999999999999983222784.000000
ITER 7: row=44, varin=40, theta=0.500000, up=999999999999999983222784.000000
ITER 8: row=30, varin=43, theta=0.500000, up=999999999999999983222784.000000
ITER 9: row=43, varin=35, theta=0.535714, up=999999999999999983222784.000000
ITER 10: row=33, varin=38, theta=0.250000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 32 = 1 gives z=28687181.808455
  % 	x32 = 1,	Z1 = 28687181.8084549        
DEBUG EVAL: First branch cutoff check: z=28687181.808455, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 32 = 0
ITER 1: row=46, varin=80, theta=0.032353, up=1.000000
ITER 2: row=16, varin=83, theta=0.043524, up=1.000000
  % 	x32 = 0,	Z0 = 28473173.0234335        
DEBUG EVAL: Second branch cutoff check: z=28473173.023434, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 30 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=40, varin=80, theta=6.346150, up=1.000000
ITER 2: row=40, varin=4, theta=2.419027, up=999999999999999983222784.000000
ITER 3: row=51, varin=44, theta=3.821153, up=999999999999999983222784.000000
ITER 4: row=44, varin=36, theta=2.336143, up=999999999999999983222784.000000
ITER 5: row=16, varin=80, theta=1.000000, up=1.000000
ITER 6: row=4, varin=35, theta=1.577606, up=999999999999999983222784.000000
ITER 7: row=33, varin=38, theta=0.945948, up=999999999999999983222784.000000
ITER 8: row=38, varin=3, theta=0.967537, up=999999999999999983222784.000000
ITER 9: row=50, varin=37, theta=2.104343, up=999999999999999983222784.000000
ITER 10: row=37, varin=28, theta=3.397365, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 30 = 1 gives z=29311786.438550
  % 	x30 = 1,	Z1 = 29311786.4385496        
DEBUG EVAL: First branch cutoff check: z=29311786.438550, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 30 = 0
ITER 1: row=40, varin=49, theta=0.148299, up=999999999999999983222784.000000
  % 	x30 = 0,	Z0 = 28474855.1396038        
DEBUG EVAL: Second branch cutoff check: z=28474855.139604, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 1 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=2, varin=4, theta=0.215118, up=999999999999999983222784.000000
ITER 2: row=51, varin=33, theta=1.624107, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 1 = 0 gives z=28491874.915447
  % 	x1 = 0,	Z0 = 28491874.915447         
DEBUG EVAL: First branch cutoff check: z=28491874.915447, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 0 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=33, theta=1.624107, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 0 = 0 gives z=28491874.915447
  % 	x0 = 0,	Z0 = 28491874.915447         
DEBUG EVAL: First branch cutoff check: z=28491874.915447, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 33 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=44, varin=80, theta=6.346150, up=1.000000
ITER 2: row=44, varin=4, theta=2.419027, up=999999999999999983222784.000000
ITER 3: row=51, varin=36, theta=3.164225, up=999999999999999983222784.000000
ITER 4: row=46, varin=35, theta=3.451859, up=999999999999999983222784.000000
ITER 5: row=33, varin=49, theta=1.647728, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 33 = 1 gives z=29022596.969608
  % 	x33 = 1,	Z1 = 29022596.9696084        
DEBUG EVAL: First branch cutoff check: z=29022596.969608, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 33 = 0
ITER 1: row=44, varin=44, theta=0.166283, up=999999999999999983222784.000000
  % 	x33 = 0,	Z0 = 28482776.0445438        
DEBUG EVAL: Second branch cutoff check: z=28482776.044544, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 29 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=30, varin=80, theta=6.346150, up=1.000000
DEBUG EVAL: Branch var 29 = 1 gives z=28492051.734595
  % 	x29 = 1,	Z1 = 28492051.7345946        
DEBUG EVAL: First branch cutoff check: z=28492051.734595, best_z=INF, threshold=INF
  % Best branch is x10, Z0 = 28631983.2760835        , Z1 = 28983000.0761079        

DEBUG CAREFUL: Final result - returning best.var = 10
DEBUG BB: Branching variable chosen: j=10
 % @NC   97   47	x10 = 0	28631983.276083
 % @NC   98   47	x10 = 1	28983000.076108
 %      47    40 28468435.1419               28470600.5383   x17 U    33     8
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde83afb10
% @LO 0.08  28.46843514187361279255 99.9000000000
% @LN 0.08  28.47060053833816084534 99.9000000000
% Resuming node 83 at  28.47060053833816084534
DEBUG CONSTRNT: LP rows=51, pool->nlprows=51, pool->npend=0
DEBUG CONSTRNT: Checking 51 LP rows (pool tracks 51, total LP rows 51)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 85
DEBUG CONSTRNT: Pool row 85 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 158
DEBUG CONSTRNT: Pool row 158 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 145
DEBUG CONSTRNT: Pool row 145 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 159
DEBUG CONSTRNT: Pool row 159 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 133
DEBUG CONSTRNT: Pool row 133 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=50, expected 50
 % @PAP adding 46 rows, 186 nz to LP
DEBUG BB: Processing node 83, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=28, varin=45, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=30, varin=59, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=46)
DEBUG SOLUTION: LP solution array indices: FST[47-86], not_covered[87-106]
DEBUG SOLUTION: lp->best_solution[0] = 28470600.538338
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 46 rows, 60 cols, 246 nonzeros, 2 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 3 rows, 12 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=47, varin=74, theta=0.800000, up=1.000000
ITER 2: row=3, varin=52, theta=0.564706, up=1.000000
ITER 3: row=22, varin=5, theta=0.666667, up=999999999999999983222784.000000
ITER 4: row=7, varin=35, theta=9.600000, up=999999999999999983222784.000000
ITER 5: row=32, varin=68, theta=0.333333, up=1.000000
ITER 6: row=7, varin=38, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=49, varin=33, theta=0.208333, up=999999999999999983222784.000000
ITER 8: row=37, varin=12, theta=2.000000, up=999999999999999983222784.000000
ITER 9: row=8, varin=35, theta=0.111111, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=9)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 28533477.049316
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.944444
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 49 rows, 60 cols, 258 nonzeros, 7 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 7 slack rows
  % @PAP adding 7 rows, 26 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=49, varin=102, theta=0.051095, up=1.000000
ITER 2: row=44, varin=10, theta=2.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 28537523.483930
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 2.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 49 rows, 60 cols, 257 nonzeros, 11 slack, 38 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 11 slack rows
  % @PAP adding 3 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=39, varin=12, theta=2.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=41)
DEBUG SOLUTION: LP solution array indices: FST[42-81], not_covered[82-101]
DEBUG SOLUTION: lp->best_solution[0] = 28546035.735594
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 41 rows, 60 cols, 233 nonzeros, 4 slack, 37 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % @PAP adding 2 rows, 12 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=39, varin=18, theta=0.719298, up=999999999999999983222784.000000
ITER 2: row=38, varin=35, theta=3.200000, up=999999999999999983222784.000000
ITER 3: row=29, varin=43, theta=0.400000, up=1.000000
ITER 4: row=39, varin=39, theta=0.076923, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=39)
DEBUG SOLUTION: LP solution array indices: FST[40-79], not_covered[80-99]
DEBUG SOLUTION: lp->best_solution[0] = 28572592.497669
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 39 rows, 60 cols, 234 nonzeros, 3 slack, 36 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 3 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=37, varin=66, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=39)
DEBUG SOLUTION: LP solution array indices: FST[40-79], not_covered[80-99]
DEBUG SOLUTION: lp->best_solution[0] = 28573965.691744
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 39 rows, 60 cols, 214 nonzeros, 0 slack, 39 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 17 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=40, varin=18, theta=0.666667, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 28578233.417679
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 43 rows, 60 cols, 231 nonzeros, 2 slack, 41 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % Node 83 LP 1 Solution, length = 28578233.417679, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.166667 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.166667 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.166667 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 1.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.166667 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.166667 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.166667 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.833333 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.833333 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.833333 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.833333 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.833333 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.833333 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.833333 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28578233.417679, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 83 at  28.57823341767856817341
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde83bccf0
% @LO 0.08  28.47060053833816084534 99.9000000000
% @LN 0.08  28.47238184938464300444 99.9000000000
% Resuming node 87 at  28.47238184938464300444
DEBUG CONSTRNT: LP rows=41, pool->nlprows=41, pool->npend=0
DEBUG CONSTRNT: Checking 41 LP rows (pool tracks 41, total LP rows 41)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 79
DEBUG CONSTRNT: Pool row 79 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=40, expected 40
 % @PAP adding 44 rows, 177 nz to LP
DEBUG BB: Processing node 87, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 87 LP 2 Solution, length = 28472381.849385, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.166667 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.166667 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.166667 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 1.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.166667 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.166667 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.166667 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.833333 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.833333 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.833333 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.833333 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.833333 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.833333 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.833333 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28472381.849385, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28472381.849385, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 87 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 87
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.166667
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.166667
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=1.000000
DEBUG CAREFUL: Skipping var 7: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.166667
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=1.000000
DEBUG CAREFUL: Skipping var 15: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.166667
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.166667
DEBUG CAREFUL: Adding var 18 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.166667
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 6 fractional variables

  %  Carefully choosing branching variable, nfrac = 6
DEBUG CAREFUL: Testing fvar[0] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 17
DEBUG CAREFUL: New best var: 17
DEBUG CAREFUL: Testing fvar[1] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 3
DEBUG CAREFUL: New best var: 3
DEBUG CAREFUL: Testing fvar[2] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[3] = var 18
DEBUG CAREFUL: Calling compare_branch_vars for var 18
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 18
DEBUG CAREFUL: New best var: 18
DEBUG CAREFUL: Testing fvar[4] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[5] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
  % Initial guess is x18, Z0 = 28472381.8493846        , Z1 = 28600213.0885106        

DEBUG EVAL: Testing var 17 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=14, varin=15, theta=0.333333, up=999999999999999983222784.000000
ITER 2: row=34, varin=81, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 17 = 0 gives z=28510358.480083
  % 	x17 = 0,	Z0 = 28510358.4800826        
DEBUG EVAL: First branch cutoff check: z=28510358.480083, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 17 = 1
ITER 1: row=14, varin=41, theta=2.500000, up=999999999999999983222784.000000
ITER 2: row=41, varin=38, theta=5.000000, up=999999999999999983222784.000000
ITER 3: row=35, varin=35, theta=2.000000, up=999999999999999983222784.000000
ITER 4: row=9, varin=33, theta=1.000000, up=999999999999999983222784.000000
  % 	x17 = 1,	Z1 = 28534078.7088154        
DEBUG EVAL: Second branch cutoff check: z=28534078.708815, best_z=INF, threshold=INF
  %   New best:  x17, Z = 28510358.4800826        
DEBUG EVAL: Testing var 3 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=9, varin=41, theta=2.500000, up=999999999999999983222784.000000
ITER 2: row=41, varin=38, theta=5.000000, up=999999999999999983222784.000000
ITER 3: row=35, varin=33, theta=2.000000, up=999999999999999983222784.000000
ITER 4: row=39, varin=32, theta=2.000000, up=999999999999999983222784.000000
ITER 5: row=1, varin=28, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=2, varin=11, theta=0.200000, up=999999999999999983222784.000000
ITER 7: row=12, varin=30, theta=0.333333, up=999999999999999983222784.000000
ITER 8: row=30, varin=97, theta=2.000000, up=1.000000
ITER 9: row=30, varin=14, theta=0.500000, up=999999999999999983222784.000000
ITER 10: row=2, varin=97, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 3 = 1 gives z=28658765.452745
  % 	x3 = 1,	Z1 = 28658765.4527448        
DEBUG EVAL: First branch cutoff check: z=28658765.452745, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 3 = 0
ITER 1: row=9, varin=35, theta=0.250000, up=999999999999999983222784.000000
  % 	x3 = 0,	Z0 = 28477231.8297634        
DEBUG EVAL: Second branch cutoff check: z=28477231.829763, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 10 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=11, varin=12, theta=0.200000, up=999999999999999983222784.000000
ITER 2: row=31, varin=33, theta=0.333333, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 0 gives z=28486480.828690
  % 	x10 = 0,	Z0 = 28486480.8286899        
DEBUG EVAL: First branch cutoff check: z=28486480.828690, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 18 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=30, varin=41, theta=2.500000, up=999999999999999983222784.000000
ITER 2: row=41, varin=38, theta=5.000000, up=999999999999999983222784.000000
ITER 3: row=35, varin=35, theta=2.000000, up=999999999999999983222784.000000
ITER 4: row=9, varin=32, theta=2.000000, up=999999999999999983222784.000000
ITER 5: row=1, varin=28, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=2, varin=15, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=34, varin=3, theta=1.000000, up=999999999999999983222784.000000
ITER 8: row=28, varin=30, theta=1.000000, up=999999999999999983222784.000000
ITER 9: row=11, varin=16, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 18 = 1 gives z=28649270.647198
  % 	x18 = 1,	Z1 = 28649270.6471982        
DEBUG EVAL: First branch cutoff check: z=28649270.647198, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 18 = 0
ITER 1: row=30, varin=33, theta=0.333333, up=999999999999999983222784.000000
  % 	x18 = 0,	Z0 = 28486480.8286899        
DEBUG EVAL: Second branch cutoff check: z=28486480.828690, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 2 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=32, theta=0.200000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 0 gives z=28478821.385802
  % 	x2 = 0,	Z0 = 28478821.3858016        
DEBUG EVAL: First branch cutoff check: z=28478821.385802, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 26 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=35, varin=38, theta=0.200000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 26 = 0 gives z=28473235.394571
  % 	x26 = 0,	Z0 = 28473235.3945715        
DEBUG EVAL: First branch cutoff check: z=28473235.394571, best_z=INF, threshold=INF
  % Best branch is x17, Z0 = 28510358.4800826        , Z1 = 28534078.7088154        

DEBUG CAREFUL: Final result - returning best.var = 17
DEBUG BB: Branching variable chosen: j=17
 % @NC   99   87	x17 = 0	28510358.480083
 % @NC  100   87	x17 = 1	28534078.708815
 %      87    41 28472381.8494               28478488.1584   x12 D    69     8
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde83bf120
% @LO 0.08  28.47238184938464300444 99.9000000000
% @LN 0.08  28.47848815844799119645 99.9000000000
% Resuming node 72 at  28.47848815844799119645
DEBUG CONSTRNT: LP rows=44, pool->nlprows=44, pool->npend=0
DEBUG CONSTRNT: Checking 44 LP rows (pool tracks 44, total LP rows 44)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=43, expected 43
 % @PAP adding 46 rows, 217 nz to LP
DEBUG BB: Processing node 72, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=38, varin=7, theta=4.995057, up=999999999999999983222784.000000
ITER 2: row=2, varin=38, theta=3543723.750000, up=999999999999999983222784.000000
ITER 3: row=39, varin=45, theta=1.839101, up=999999999999999983222784.000000
ITER 4: row=2, varin=48, theta=1.000000, up=1.000000
ITER 5: row=35, varin=25, theta=3.060627, up=999999999999999983222784.000000
ITER 6: row=8, varin=3, theta=0.457033, up=999999999999999983222784.000000
ITER 7: row=13, varin=38, theta=659292.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=7)
ITER 8: row=6, varin=49, theta=0.000000, up=1.000000
ITER 9: row=1, varin=13, theta=0.000000, up=999999999999999983222784.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=46)
DEBUG SOLUTION: LP solution array indices: FST[47-86], not_covered[87-106]
DEBUG SOLUTION: lp->best_solution[0] = 28466708.730186
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 46 rows, 60 cols, 277 nonzeros, 6 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 12 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=47, varin=52, theta=0.500000, up=1.000000
ITER 2: row=48, varin=69, theta=0.071429, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 28490793.037315
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 48 rows, 60 cols, 289 nonzeros, 6 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 6 slack rows
  % @PAP adding 5 rows, 21 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=43, varin=74, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 28494638.686337
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 47 rows, 60 cols, 258 nonzeros, 0 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 17 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=48, varin=42, theta=3.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 28500312.552125
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 51 rows, 60 cols, 275 nonzeros, 5 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % Node 72 LP 1 Solution, length = 28500312.552125, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.500000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.500000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 1.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.500000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.500000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.500000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.500000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.500000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.500000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.500000 (terminal 19)
 % 3 fractional variables
DEBUG CG: LP optimal, z=28500312.552125, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 72 at  28.50031255212459058157
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde83bf820
% @LO 0.09  28.47848815844799119645 99.9000000000
% @LN 0.09  28.48324337872859146614 99.9000000000
% Resuming node 84 at  28.48324337872859146614
DEBUG CONSTRNT: LP rows=46, pool->nlprows=46, pool->npend=0
DEBUG CONSTRNT: Checking 46 LP rows (pool tracks 46, total LP rows 46)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=45, expected 45
 % @PAP adding 46 rows, 186 nz to LP
DEBUG BB: Processing node 84, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=28, varin=46, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=44, varin=41, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=30, varin=59, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=46)
DEBUG SOLUTION: LP solution array indices: FST[47-86], not_covered[87-106]
DEBUG SOLUTION: lp->best_solution[0] = 28483243.378729
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 46 rows, 60 cols, 246 nonzeros, 2 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 16 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=47, varin=27, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28500000.000000
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 50 rows, 60 cols, 262 nonzeros, 1 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 1 rows, 40 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=50, varin=75, theta=0.307692, up=1.000000
ITER 2: row=3, varin=5, theta=0.222222, up=999999999999999983222784.000000
ITER 3: row=7, varin=53, theta=0.345324, up=1.000000
ITER 4: row=22, varin=12, theta=0.333333, up=999999999999999983222784.000000
ITER 5: row=8, varin=11, theta=0.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28512541.581080
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.750000
DEBUG SOLUTION: lp->best_solution[5] = 2.750000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.750000
DEBUG SOLUTION: lp->best_solution[10] = 0.750000
DEBUG SOLUTION: lp->best_solution[11] = 3.500000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.750000
  % @PL 50 rows, 60 cols, 294 nonzeros, 13 slack, 37 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 13 slack rows
  % @PAP adding 2 rows, 5 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=38, varin=23, theta=4.363636, up=999999999999999983222784.000000
ITER 2: row=20, varin=26, theta=0.500000, up=999999999999999983222784.000000
ITER 3: row=35, varin=3, theta=0.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=39)
DEBUG SOLUTION: LP solution array indices: FST[40-79], not_covered[80-99]
DEBUG SOLUTION: lp->best_solution[0] = 28525940.406237
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.500000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 3.000000
  % @PL 39 rows, 60 cols, 263 nonzeros, 1 slack, 38 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 84 LP 1 Solution, length = 28525940.406237, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.500000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.500000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.500000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.500000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.500000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 1.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.500000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 2 fractional variables
DEBUG CG: LP optimal, z=28525940.406237, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 84 at  28.52594040623653981470
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde8386600
% @LO 0.09  28.48324337872859146614 99.9000000000
% @LN 0.09  28.48653325896731658418 99.9000000000
% Resuming node 93 at  28.48653325896731658418
DEBUG CONSTRNT: LP rows=38, pool->nlprows=38, pool->npend=0
DEBUG CONSTRNT: Checking 38 LP rows (pool tracks 38, total LP rows 38)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 79
DEBUG CONSTRNT: Pool row 79 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 45
DEBUG CONSTRNT: Pool row 45 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 62
DEBUG CONSTRNT: Pool row 62 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 121
DEBUG CONSTRNT: Pool row 121 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 162
DEBUG CONSTRNT: Pool row 162 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=37, expected 37
 % @PAP adding 45 rows, 179 nz to LP
DEBUG BB: Processing node 93, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=17, varin=53, theta=4.000000, up=1.000000
ITER 2: row=17, varin=43, theta=1.500000, up=999999999999999983222784.000000
ITER 3: row=13, varin=53, theta=1.000000, up=1.000000
ITER 4: row=9, varin=40, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 28486533.258967
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 45 rows, 60 cols, 239 nonzeros, 6 slack, 39 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 42 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=47, varin=7, theta=1.128955, up=999999999999999983222784.000000
ITER 2: row=4, varin=33, theta=0.437651, up=999999999999999983222784.000000
ITER 3: row=46, varin=15, theta=0.500000, up=999999999999999983222784.000000
ITER 4: row=3, varin=77, theta=1.054690, up=1.000000
ITER 5: row=3, varin=2, theta=0.032529, up=999999999999999983222784.000000
ITER 6: row=1, varin=77, theta=0.293124, up=1.000000
ITER 7: row=6, varin=46, theta=0.642476, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=7)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 28710202.704618
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 47 rows, 60 cols, 281 nonzeros, 9 slack, 38 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 9 slack rows
  % @PAP adding 4 rows, 13 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=39, varin=65, theta=0.720199, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 28778243.465510
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 42 rows, 60 cols, 276 nonzeros, 0 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=43, varin=100, theta=0.873798, up=1.000000
ITER 2: row=33, varin=71, theta=0.342487, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 28786894.265826
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 43 rows, 60 cols, 280 nonzeros, 1 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 2 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=43, varin=68, theta=1.000000, up=1.000000
ITER 2: row=44, varin=66, theta=0.710123, up=1.000000
ITER 3: row=28, varin=25, theta=0.277705, up=999999999999999983222784.000000
ITER 4: row=11, varin=56, theta=0.975643, up=1.000000
ITER 5: row=12, varin=70, theta=0.611062, up=1.000000
ITER 6: row=30, varin=24, theta=0.125873, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28849564.557853
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 44 rows, 60 cols, 282 nonzeros, 2 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 6 rows, 21 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=43, varin=26, theta=0.265151, up=999999999999999983222784.000000
ITER 2: row=45, varin=79, theta=0.987878, up=1.000000
ITER 3: row=37, varin=28, theta=1.139213, up=999999999999999983222784.000000
ITER 4: row=46, varin=94, theta=0.074910, up=1.000000
ITER 5: row=2, varin=53, theta=0.112881, up=1.000000
ITER 6: row=47, varin=59, theta=0.133746, up=1.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 28931782.761318
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 48 rows, 60 cols, 299 nonzeros, 2 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % Node 93 LP 1 Solution, length = 28931782.761318, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.133746 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.433127 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 1.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 1.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.433127 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.433127 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.133746 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.866254 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.866254 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.566873 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.566873 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28931782.761318, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 93 at  28.93178276131753534628
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde83b0600
% @LO 0.09  28.48653325896731658418 99.9000000000
% @LN 0.09  28.49008211611859664458 99.9000000000
% Resuming node 74 at  28.49008211611859664458
DEBUG CONSTRNT: LP rows=46, pool->nlprows=46, pool->npend=0
DEBUG CONSTRNT: Checking 46 LP rows (pool tracks 46, total LP rows 46)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 49
DEBUG CONSTRNT: Pool row 49 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 68
DEBUG CONSTRNT: Pool row 68 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 82
DEBUG CONSTRNT: Pool row 82 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 133
DEBUG CONSTRNT: Pool row 133 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 145
DEBUG CONSTRNT: Pool row 145 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 159
DEBUG CONSTRNT: Pool row 159 has lprow=45, expected 45
 % @PAP adding 34 rows, 140 nz to LP
DEBUG BB: Processing node 74, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 74 LP 2 Solution, length = 28490082.116119, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.250000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.750000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.750000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 1.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.250000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.250000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.750000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.750000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.250000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.250000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.750000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.250000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.750000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.250000 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28490082.116119, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28490082.116119, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 74 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 74
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.250000
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.750000
DEBUG CAREFUL: Adding var 9 to fractional list (xi=0.750000)
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.750000
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.750000)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=1.000000
DEBUG CAREFUL: Skipping var 15: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.250000
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.250000
DEBUG CAREFUL: Adding var 18 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 17
DEBUG CAREFUL: New best var: 17
DEBUG CAREFUL: Testing fvar[1] = var 9
DEBUG CAREFUL: Calling compare_branch_vars for var 9
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 9
DEBUG CAREFUL: Testing fvar[2] = var 18
DEBUG CAREFUL: Calling compare_branch_vars for var 18
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 18
DEBUG CAREFUL: New best var: 18
DEBUG CAREFUL: Testing fvar[3] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[4] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
  % Initial guess is x18, Z0 = 28490082.1161186        , Z1 = 28631577.7814806        

DEBUG EVAL: Testing var 17 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=15, varin=38, theta=0.500000, up=1.000000
DEBUG EVAL: Branch var 17 = 0 gives z=28496172.175204
  % 	x17 = 0,	Z0 = 28496172.1752041        
DEBUG EVAL: First branch cutoff check: z=28496172.175204, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 17 = 1
ITER 1: row=15, varin=34, theta=3.000000, up=999999999999999983222784.000000
ITER 2: row=1, varin=32, theta=2.000000, up=999999999999999983222784.000000
ITER 3: row=2, varin=29, theta=0.666667, up=999999999999999983222784.000000
  % 	x17 = 1,	Z1 = 28558147.6978761        
DEBUG EVAL: Second branch cutoff check: z=28558147.697876, best_z=INF, threshold=INF
  %   New best:  x17, Z = 28496172.1752041        
DEBUG EVAL: Testing var 9 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=9, varin=38, theta=0.500000, up=1.000000
DEBUG EVAL: Branch var 9 = 1 gives z=28496172.175204
  % 	x9 = 1,	Z1 = 28496172.1752041        
DEBUG EVAL: First branch cutoff check: z=28496172.175204, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 9 = 0
ITER 1: row=9, varin=31, theta=0.750000, up=999999999999999983222784.000000
  % 	x9 = 0,	Z0 = 28508878.0585228        
DEBUG EVAL: Second branch cutoff check: z=28508878.058523, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 18 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=24, varin=34, theta=3.000000, up=999999999999999983222784.000000
ITER 2: row=1, varin=32, theta=2.000000, up=999999999999999983222784.000000
ITER 3: row=2, varin=16, theta=2.000000, up=999999999999999983222784.000000
ITER 4: row=30, varin=3, theta=2.000000, up=999999999999999983222784.000000
ITER 5: row=32, varin=49, theta=1.000000, up=1.000000
ITER 6: row=11, varin=26, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=26, varin=17, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 18 = 1 gives z=28716956.675234
  % 	x18 = 1,	Z1 = 28716956.6752344        
DEBUG EVAL: First branch cutoff check: z=28716956.675234, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 18 = 0
ITER 1: row=24, varin=38, theta=0.500000, up=1.000000
  % 	x18 = 0,	Z0 = 28496172.1752041        
DEBUG EVAL: Second branch cutoff check: z=28496172.175204, best_z=INF, threshold=INF
  %   New best:  x18, Z = 28496172.1752041        
DEBUG EVAL: Testing var 10 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=12, varin=38, theta=0.500000, up=1.000000
DEBUG EVAL: Branch var 10 = 1 gives z=28496172.175204
  % 	x10 = 1,	Z1 = 28496172.1752041        
DEBUG EVAL: First branch cutoff check: z=28496172.175204, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 0
ITER 1: row=12, varin=31, theta=0.750000, up=999999999999999983222784.000000
  % 	x10 = 0,	Z0 = 28508878.0585228        
DEBUG EVAL: Second branch cutoff check: z=28508878.058523, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 2 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=34, theta=0.333333, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 0 gives z=28495551.336866
  % 	x2 = 0,	Z0 = 28495551.3368658        
DEBUG EVAL: First branch cutoff check: z=28495551.336866, best_z=INF, threshold=INF
  % Best branch is x18, Z0 = 28496172.1752041        , Z1 = 28716956.6752344        

DEBUG CAREFUL: Final result - returning best.var = 18
DEBUG BB: Branching variable chosen: j=18
 % @NC  101   74	x18 = 0	28496172.175204
 % @NC  102   74	x18 = 1	28716956.675234
 %      74    42 28490082.1161               28494103.9399   x15 U    59     7
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde83970d0
% @LO 0.09  28.49008211611859664458 99.9000000000
% @LN 0.09  28.49410393992462786628 99.9000000000
% Resuming node 66 at  28.49410393992462786628
DEBUG CONSTRNT: LP rows=34, pool->nlprows=34, pool->npend=0
DEBUG CONSTRNT: Checking 34 LP rows (pool tracks 34, total LP rows 34)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=33, expected 33
 % @PAP adding 45 rows, 177 nz to LP
DEBUG BB: Processing node 66, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=32, varin=43, theta=5.000000, up=999999999999999983222784.000000
ITER 2: row=40, varin=40, theta=2.000000, up=999999999999999983222784.000000
ITER 3: row=9, varin=39, theta=2.000000, up=999999999999999983222784.000000
ITER 4: row=1, varin=37, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=2, varin=30, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=29, varin=18, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=34, varin=3, theta=1.000000, up=999999999999999983222784.000000
ITER 8: row=37, varin=28, theta=0.428571, up=999999999999999983222784.000000
ITER 9: row=28, varin=33, theta=1.000000, up=999999999999999983222784.000000
ITER 10: row=12, varin=19, theta=0.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=10)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 28494103.939925
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 45 rows, 60 cols, 237 nonzeros, 10 slack, 35 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 5 rows, 59 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=50, varin=7, theta=2.123903, up=999999999999999983222784.000000
ITER 2: row=4, varin=61, theta=0.771876, up=1.000000
ITER 3: row=33, varin=63, theta=1.181501, up=1.000000
ITER 4: row=33, varin=75, theta=0.325425, up=1.000000
ITER 5: row=30, varin=63, theta=1.000000, up=1.000000
ITER 6: row=3, varin=14, theta=1.454652, up=999999999999999983222784.000000
ITER 7: row=36, varin=26, theta=2.728095, up=999999999999999983222784.000000
ITER 8: row=11, varin=77, theta=2.162404, up=1.000000
ITER 9: row=11, varin=74, theta=1.084417, up=1.000000
ITER 10: row=11, varin=25, theta=0.175612, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=22)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 29380879.320363
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 50 rows, 60 cols, 296 nonzeros, 9 slack, 41 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 9 slack rows
  % @PAP adding 6 rows, 22 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=44, varin=77, theta=1.000000, up=1.000000
ITER 2: row=42, varin=75, theta=2.145401, up=1.000000
ITER 3: row=42, varin=104, theta=1.412349, up=1.000000
ITER 4: row=42, varin=73, theta=0.301097, up=1.000000
ITER 5: row=33, varin=104, theta=0.500000, up=1.000000
ITER 6: row=27, varin=69, theta=0.415394, up=1.000000
ITER 7: row=41, varin=37, theta=0.097070, up=999999999999999983222784.000000
ITER 8: row=43, varin=5, theta=0.187885, up=999999999999999983222784.000000
ITER 9: row=5, varin=71, theta=1.594951, up=1.000000
ITER 10: row=5, varin=34, theta=0.028305, up=999999999999999983222784.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 999999999999999983222784.000000
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 47 rows, 60 cols, 300 nonzeros, 3 slack, 44 tight.
  % Node 66 LP 1 Solution, length = 999999999999999983222784.000000, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.039797 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 1.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 1.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.960203 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 1.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.960203 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
DEBUG BB: compute_good_lower_bound returned status=1
DEBUG BB: Node 66 is INFEASIBLE
 %      66    41    infeasible               28494706.6972   x18 U    37     6
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde83b5ba0
% @LO 0.09  28.49410393992462786628 99.9000000000
% @LN 0.09  28.49470669722931859269 99.9000000000
% Resuming node 53 at  28.49470669722931859269
DEBUG CONSTRNT: LP rows=47, pool->nlprows=47, pool->npend=0
DEBUG CONSTRNT: Checking 47 LP rows (pool tracks 47, total LP rows 47)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 49
DEBUG CONSTRNT: Pool row 49 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 68
DEBUG CONSTRNT: Pool row 68 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 82
DEBUG CONSTRNT: Pool row 82 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 121
DEBUG CONSTRNT: Pool row 121 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 145
DEBUG CONSTRNT: Pool row 145 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 159
DEBUG CONSTRNT: Pool row 159 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=46, expected 46
 % @PAP adding 49 rows, 195 nz to LP
DEBUG BB: Processing node 53, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 53 LP 2 Solution, length = 28494706.697229, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.250000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.250000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.250000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.250000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.250000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.250000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.250000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.750000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.750000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.750000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.750000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.750000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.750000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.750000 (terminal 19)
 % 7 fractional variables
DEBUG CG: LP optimal, z=28494706.697229, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28494706.697229, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 53 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 53
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.250000
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.250000
DEBUG CAREFUL: Adding var 4 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=1.000000
DEBUG CAREFUL: Skipping var 7: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.250000
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.250000
DEBUG CAREFUL: Adding var 11 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.250000
DEBUG CAREFUL: Adding var 22 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.250000
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.250000
DEBUG CAREFUL: Adding var 27 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 7 fractional variables

  %  Carefully choosing branching variable, nfrac = 7
DEBUG CAREFUL: Testing fvar[0] = var 4
DEBUG CAREFUL: Calling compare_branch_vars for var 4
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 4
DEBUG CAREFUL: New best var: 4
DEBUG CAREFUL: Testing fvar[1] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[2] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
DEBUG CAREFUL: Testing fvar[3] = var 11
DEBUG CAREFUL: Calling compare_branch_vars for var 11
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 11
DEBUG CAREFUL: Testing fvar[4] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[5] = var 22
DEBUG CAREFUL: Calling compare_branch_vars for var 22
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 22
DEBUG CAREFUL: Testing fvar[6] = var 27
DEBUG CAREFUL: Calling compare_branch_vars for var 27
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 27
  % Initial guess is x4, Z0 = 28494706.6972293        , Z1 = 28519545.6106478        

DEBUG EVAL: Testing var 4 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=10, varin=15, theta=3.000000, up=999999999999999983222784.000000
ITER 2: row=15, varin=46, theta=0.750000, up=999999999999999983222784.000000
ITER 3: row=39, varin=44, theta=1.500000, up=999999999999999983222784.000000
ITER 4: row=42, varin=33, theta=3.000000, up=999999999999999983222784.000000
ITER 5: row=43, varin=25, theta=3.000000, up=999999999999999983222784.000000
ITER 6: row=25, varin=47, theta=3.000000, up=999999999999999983222784.000000
ITER 7: row=44, varin=42, theta=1.500000, up=999999999999999983222784.000000
ITER 8: row=32, varin=36, theta=0.750000, up=999999999999999983222784.000000
ITER 9: row=36, varin=43, theta=1.000000, up=999999999999999983222784.000000
ITER 10: row=34, varin=40, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 4 = 1 gives z=28725127.139189
  % 	x4 = 1,	Z1 = 28725127.1391889        
DEBUG EVAL: First branch cutoff check: z=28725127.139189, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 4 = 0
ITER 1: row=10, varin=47, theta=0.333333, up=999999999999999983222784.000000
  % 	x4 = 0,	Z0 = 28502149.1961225        
DEBUG EVAL: Second branch cutoff check: z=28502149.196122, best_z=INF, threshold=INF
  %   New best:  x4, Z = 28502149.1961225        
DEBUG EVAL: Testing var 10 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=18, varin=47, theta=0.333333, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 0 gives z=28502149.196122
  % 	x10 = 0,	Z0 = 28502149.1961225        
DEBUG EVAL: First branch cutoff check: z=28502149.196122, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 1
ITER 1: row=18, varin=15, theta=3.000000, up=999999999999999983222784.000000
ITER 2: row=15, varin=46, theta=0.750000, up=999999999999999983222784.000000
ITER 3: row=39, varin=35, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=49, varin=33, theta=0.750000, up=999999999999999983222784.000000
  % 	x10 = 1,	Z1 = 28575422.6402985        
DEBUG EVAL: Second branch cutoff check: z=28575422.640298, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 26 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=28, varin=47, theta=0.333333, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 26 = 0 gives z=28502149.196122
  % 	x26 = 0,	Z0 = 28502149.1961225        
DEBUG EVAL: First branch cutoff check: z=28502149.196122, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 26 = 1
ITER 1: row=28, varin=15, theta=3.000000, up=999999999999999983222784.000000
ITER 2: row=15, varin=46, theta=0.750000, up=999999999999999983222784.000000
ITER 3: row=39, varin=35, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=49, varin=33, theta=0.750000, up=999999999999999983222784.000000
  % 	x26 = 1,	Z1 = 28575422.6402985        
DEBUG EVAL: Second branch cutoff check: z=28575422.640298, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 11 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=32, varin=15, theta=3.000000, up=999999999999999983222784.000000
ITER 2: row=15, varin=46, theta=0.750000, up=999999999999999983222784.000000
ITER 3: row=39, varin=35, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=49, varin=44, theta=1.500000, up=999999999999999983222784.000000
ITER 5: row=42, varin=48, theta=1.500000, up=999999999999999983222784.000000
ITER 6: row=10, varin=25, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=25, varin=47, theta=1.000000, up=999999999999999983222784.000000
ITER 8: row=44, varin=36, theta=0.750000, up=999999999999999983222784.000000
ITER 9: row=36, varin=42, theta=1.000000, up=999999999999999983222784.000000
ITER 10: row=34, varin=40, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 11 = 1 gives z=28700400.457911
  % 	x11 = 1,	Z1 = 28700400.4579106        
DEBUG EVAL: First branch cutoff check: z=28700400.457911, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 11 = 0
ITER 1: row=32, varin=47, theta=0.333333, up=999999999999999983222784.000000
  % 	x11 = 0,	Z0 = 28502149.1961225        
DEBUG EVAL: Second branch cutoff check: z=28502149.196122, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 2 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=2, varin=47, theta=0.333333, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 0 gives z=28502149.196122
  % 	x2 = 0,	Z0 = 28502149.1961225        
DEBUG EVAL: First branch cutoff check: z=28502149.196122, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 1
ITER 1: row=2, varin=15, theta=3.000000, up=999999999999999983222784.000000
ITER 2: row=15, varin=46, theta=0.750000, up=999999999999999983222784.000000
ITER 3: row=39, varin=48, theta=1.000000, up=999999999999999983222784.000000
  % 	x2 = 1,	Z1 = 28524156.0159245        
DEBUG EVAL: Second branch cutoff check: z=28524156.015924, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 22 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=34, varin=47, theta=0.333333, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 22 = 0 gives z=28502149.196122
  % 	x22 = 0,	Z0 = 28502149.1961225        
DEBUG EVAL: First branch cutoff check: z=28502149.196122, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 22 = 1
ITER 1: row=34, varin=15, theta=3.000000, up=999999999999999983222784.000000
ITER 2: row=15, varin=46, theta=0.750000, up=999999999999999983222784.000000
ITER 3: row=39, varin=44, theta=1.500000, up=999999999999999983222784.000000
ITER 4: row=42, varin=33, theta=3.000000, up=999999999999999983222784.000000
ITER 5: row=43, varin=25, theta=3.000000, up=999999999999999983222784.000000
ITER 6: row=25, varin=47, theta=3.000000, up=999999999999999983222784.000000
ITER 7: row=44, varin=36, theta=2.250000, up=999999999999999983222784.000000
ITER 8: row=36, varin=40, theta=3.000000, up=999999999999999983222784.000000
ITER 9: row=40, varin=41, theta=2.000000, up=999999999999999983222784.000000
ITER 10: row=26, varin=5, theta=5.333333, up=999999999999999983222784.000000
  % 	x22 = 1,	Z1 = 29103728.825943         
DEBUG EVAL: Second branch cutoff check: z=29103728.825943, best_z=INF, threshold=INF
  %   New best:  x22, Z = 28502149.1961225        
DEBUG EVAL: Testing var 27 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=40, varin=47, theta=0.333333, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 27 = 0 gives z=28502149.196122
  % 	x27 = 0,	Z0 = 28502149.1961225        
DEBUG EVAL: First branch cutoff check: z=28502149.196122, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 27 = 1
ITER 1: row=40, varin=15, theta=3.000000, up=999999999999999983222784.000000
  % 	x27 = 1,	Z1 = 28505523.9665323        
DEBUG EVAL: Second branch cutoff check: z=28505523.966532, best_z=INF, threshold=INF
  % Best branch is x22, Z0 = 28502149.1961225        , Z1 = 29103728.825943         

DEBUG CAREFUL: Final result - returning best.var = 22
DEBUG BB: Branching variable chosen: j=22
 % @NC  103   53	x22 = 0	28502149.196122
 % @NC  104   53	x22 = 1	29103728.825943
 %      53    42 28494706.6972               28496172.1752    x1 D    51    10
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde83bccf0
% @LO 0.09  28.49470669722931859269 99.9000000000
% @LN 0.09  28.49617217520409440112 99.9000000000
% Resuming node 101 at  28.49617217520409440112
DEBUG CONSTRNT: LP rows=49, pool->nlprows=49, pool->npend=0
DEBUG CONSTRNT: Checking 49 LP rows (pool tracks 49, total LP rows 49)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=48, expected 48
 % @PAP adding 34 rows, 140 nz to LP
DEBUG BB: Processing node 101, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=24, varin=38, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=34)
DEBUG SOLUTION: LP solution array indices: FST[35-74], not_covered[75-94]
DEBUG SOLUTION: lp->best_solution[0] = 28496172.175204
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 34 rows, 60 cols, 200 nonzeros, 0 slack, 34 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 6 rows, 31 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=35, varin=67, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=40)
DEBUG SOLUTION: LP solution array indices: FST[41-80], not_covered[81-100]
DEBUG SOLUTION: lp->best_solution[0] = 28501604.410027
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 40 rows, 60 cols, 231 nonzeros, 0 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=41, varin=29, theta=0.333333, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=41)
DEBUG SOLUTION: LP solution array indices: FST[42-81], not_covered[82-101]
DEBUG SOLUTION: lp->best_solution[0] = 28519971.115267
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 41 rows, 60 cols, 233 nonzeros, 5 slack, 36 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % Node 101 LP 1 Solution, length = 28519971.115267, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.333333 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.333333 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 1.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 1.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 1.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.333333 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.666667 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.666667 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.666667 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.666667 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 3 fractional variables
DEBUG CG: LP optimal, z=28519971.115267, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 101 at  28.51997111526681649707
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde83bcb30
% @LO 0.09  28.49617217520409440112 99.9000000000
% @LN 0.09  28.49878054750281464180 99.9000000000
% Resuming node 94 at  28.49878054750281464180
DEBUG CONSTRNT: LP rows=36, pool->nlprows=36, pool->npend=0
DEBUG CONSTRNT: Checking 36 LP rows (pool tracks 36, total LP rows 36)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 158
DEBUG CONSTRNT: Pool row 158 has lprow=35, expected 35
 % @PAP adding 45 rows, 179 nz to LP
DEBUG BB: Processing node 94, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=17, varin=18, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=41, varin=102, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 28498780.547503
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 45 rows, 60 cols, 239 nonzeros, 0 slack, 45 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 3 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=46, varin=7, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=4, varin=26, theta=2.000000, up=999999999999999983222784.000000
ITER 3: row=11, varin=76, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=46)
DEBUG SOLUTION: LP solution array indices: FST[47-86], not_covered[87-106]
DEBUG SOLUTION: lp->best_solution[0] = 28514001.354014
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 46 rows, 60 cols, 242 nonzeros, 0 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 94 LP 1 Solution, length = 28514001.354014, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.500000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.500000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 1.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.500000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.500000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.500000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.500000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.500000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.500000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.500000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 0.500000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28514001.354014, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 94 at  28.51400135401447144545
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde83ad260
% @LO 0.09  28.49878054750281464180 99.9000000000
% @LN 0.09  28.49891141780577186182 99.9000000000
% Resuming node 89 at  28.49891141780577186182
DEBUG CONSTRNT: LP rows=46, pool->nlprows=46, pool->npend=0
DEBUG CONSTRNT: Checking 46 LP rows (pool tracks 46, total LP rows 46)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 49
DEBUG CONSTRNT: Pool row 49 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 68
DEBUG CONSTRNT: Pool row 68 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 82
DEBUG CONSTRNT: Pool row 82 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 121
DEBUG CONSTRNT: Pool row 121 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 142
DEBUG CONSTRNT: Pool row 142 has lprow=45, expected 45
 % @PAP adding 45 rows, 181 nz to LP
DEBUG BB: Processing node 89, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=22, varin=43, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 28498911.417806
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 45 rows, 60 cols, 241 nonzeros, 3 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 5 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=46, varin=23, theta=2.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=46)
DEBUG SOLUTION: LP solution array indices: FST[47-86], not_covered[87-106]
DEBUG SOLUTION: lp->best_solution[0] = 28514008.755364
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 46 rows, 60 cols, 246 nonzeros, 2 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 2 rows, 12 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=45, varin=71, theta=2.000000, up=1.000000
ITER 2: row=45, varin=50, theta=0.250000, up=1.000000
ITER 3: row=3, varin=71, theta=1.000000, up=1.000000
ITER 4: row=46, varin=42, theta=0.071429, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=46)
DEBUG SOLUTION: LP solution array indices: FST[47-86], not_covered[87-106]
DEBUG SOLUTION: lp->best_solution[0] = 28538093.062493
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 46 rows, 60 cols, 252 nonzeros, 2 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 5 rows, 21 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=45, varin=76, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 28541938.711515
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 49 rows, 60 cols, 265 nonzeros, 0 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 17 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=50, varin=44, theta=3.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=53)
DEBUG SOLUTION: LP solution array indices: FST[54-93], not_covered[94-113]
DEBUG SOLUTION: lp->best_solution[0] = 28547612.577303
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 53 rows, 60 cols, 282 nonzeros, 5 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % Node 89 LP 1 Solution, length = 28547612.577303, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.500000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.500000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 1.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.500000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.500000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.500000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.500000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.500000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.500000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.500000 (terminal 19)
 % 3 fractional variables
DEBUG CG: LP optimal, z=28547612.577303, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 89 at  28.54761257730266876820
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde83bf120
% @LO 0.09  28.49891141780577186182 99.9000000000
% @LN 0.09  28.50031255212459058157 99.9000000000
% Resuming node 72 at  28.50031255212459058157
DEBUG CONSTRNT: LP rows=48, pool->nlprows=48, pool->npend=0
DEBUG CONSTRNT: Checking 48 LP rows (pool tracks 48, total LP rows 48)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=47, expected 47
 % @PAP adding 46 rows, 178 nz to LP
DEBUG BB: Processing node 72, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 72 LP 2 Solution, length = 28500312.552125, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.500000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.500000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 1.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.500000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.500000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.500000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.500000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.500000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.500000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.500000 (terminal 19)
 % 3 fractional variables
DEBUG CG: LP optimal, z=28500312.552125, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28500312.552125, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 72 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 72
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.500000
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.500000
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=1.000000
DEBUG CAREFUL: Skipping var 5: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=1.000000
DEBUG CAREFUL: Skipping var 15: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.500000
DEBUG CAREFUL: Adding var 20 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 3 fractional variables

  %  Carefully choosing branching variable, nfrac = 3
DEBUG CAREFUL: Testing fvar[0] = var 20
DEBUG CAREFUL: Calling compare_branch_vars for var 20
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 20
DEBUG CAREFUL: New best var: 20
DEBUG CAREFUL: Testing fvar[1] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 3
DEBUG CAREFUL: New best var: 3
DEBUG CAREFUL: Testing fvar[2] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
  % Initial guess is x3, Z0 = 28500312.5521246        , Z1 = 28585366.1340977        

DEBUG EVAL: Testing var 20 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=6, varin=70, theta=1.000000, up=1.000000
ITER 2: row=36, varin=58, theta=0.500000, up=1.000000
DEBUG EVAL: Branch var 20 = 0 gives z=28611614.563678
  % 	x20 = 0,	Z0 = 28611614.5636781        
DEBUG EVAL: First branch cutoff check: z=28611614.563678, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 20 = 1
ITER 1: row=6, varin=45, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=45, varin=42, theta=0.500000, up=999999999999999983222784.000000
  % 	x20 = 1,	Z1 = 28511418.6527358        
DEBUG EVAL: Second branch cutoff check: z=28511418.652736, best_z=INF, threshold=INF
  %   New best:  x20, Z = 28511418.6527358        
DEBUG EVAL: Testing var 3 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=22, varin=45, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=45, varin=41, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 3 = 1 gives z=28533916.374063
  % 	x3 = 1,	Z1 = 28585366.1340977        
DEBUG EVAL: First branch cutoff check: z=28585366.134098, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 3 = 0
ITER 1: row=22, varin=70, theta=1.000000, up=1.000000
ITER 2: row=36, varin=58, theta=0.500000, up=1.000000
  % 	x3 = 0,	Z0 = 28611614.5636781        
DEBUG EVAL: Second branch cutoff check: z=28611614.563678, best_z=INF, threshold=INF
  %   New best:  x3, Z = 28585366.1340977        
DEBUG EVAL: Testing var 2 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=41, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 0 gives z=28533916.374063
  % 	x2 = 0,	Z0 = 28533916.374063         
DEBUG EVAL: First branch cutoff check: z=28533916.374063, best_z=INF, threshold=INF
  % Best branch is x3, Z0 = 28611614.5636781        , Z1 = 28585366.1340977        

DEBUG CAREFUL: Final result - returning best.var = 3
DEBUG BB: Branching variable chosen: j=3
 % @NC  105   72	x3 = 1	28585366.134098
 % @NC  106   72	x3 = 0	28611614.563678
 %      72    43 28500312.5521               28502149.1961   x15 U    22     5
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde83970d0
% @LO 0.09  28.50031255212459058157 99.9000000000
% @LN 0.09  28.50214919612245267899 99.9000000000
% Resuming node 103 at  28.50214919612245267899
DEBUG CONSTRNT: LP rows=46, pool->nlprows=46, pool->npend=0
DEBUG CONSTRNT: Checking 46 LP rows (pool tracks 46, total LP rows 46)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=45, expected 45
 % @PAP adding 49 rows, 195 nz to LP
DEBUG BB: Processing node 103, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=34, varin=47, theta=0.333333, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 28502149.196122
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 49 rows, 60 cols, 255 nonzeros, 2 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=50, varin=48, theta=0.250000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 28507650.901073
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 51 rows, 60 cols, 261 nonzeros, 4 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % Node 103 LP 1 Solution, length = 28507650.901073, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.250000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.250000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.250000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.250000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.250000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.250000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.250000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.250000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.750000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.750000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.750000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.750000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.750000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 0.750000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 8 fractional variables
DEBUG CG: LP optimal, z=28507650.901073, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 103 at  28.50765090107295662847
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde83b74d0
% @LO 0.09  28.50214919612245267899 99.9000000000
% @LN 0.09  28.50359874547120853094 99.9000000000
% Resuming node 76 at  28.50359874547120853094
DEBUG CONSTRNT: LP rows=47, pool->nlprows=47, pool->npend=0
DEBUG CONSTRNT: Checking 47 LP rows (pool tracks 47, total LP rows 47)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=46, expected 46
 % @PAP adding 42 rows, 173 nz to LP
DEBUG BB: Processing node 76, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=9, varin=42, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=39, varin=17, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=37, varin=39, theta=2.000000, up=999999999999999983222784.000000
ITER 4: row=36, varin=35, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 28503598.745471
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 42 rows, 60 cols, 233 nonzeros, 4 slack, 38 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 54 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=46, varin=7, theta=1.278693, up=999999999999999983222784.000000
ITER 2: row=4, varin=33, theta=0.697193, up=999999999999999983222784.000000
ITER 3: row=43, varin=18, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=38, varin=19, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=1, varin=73, theta=0.413742, up=1.000000
ITER 6: row=4, varin=4, theta=1.470890, up=999999999999999983222784.000000
ITER 7: row=46, varin=46, theta=383739.000000, up=999999999999999983222784.000000
ITER 8: row=39, varin=83, theta=1.000000, up=1.000000
ITER 9: row=42, varin=70, theta=1.000000, up=1.000000
ITER 10: row=34, varin=58, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=16)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=46)
DEBUG SOLUTION: LP solution array indices: FST[47-86], not_covered[87-106]
DEBUG SOLUTION: lp->best_solution[0] = 28965694.189987
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 46 rows, 60 cols, 287 nonzeros, 3 slack, 43 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 1 rows, 3 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=44, varin=43, theta=14186.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28966315.967528
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 44 rows, 60 cols, 284 nonzeros, 1 slack, 43 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 76 LP 1 Solution, length = 28966315.967528, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.500000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.500000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 1.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 1.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.500000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.500000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.500000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.500000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.500000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.500000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.500000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 0.500000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28966315.967528, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 76 at  28.96631596752791182325
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde83af990
% @LO 0.09  28.50359874547120853094 99.9000000000
% @LN 0.09  28.50604242060065374176 99.9000000000
% Resuming node 88 at  28.50604242060065374176
DEBUG CONSTRNT: LP rows=43, pool->nlprows=43, pool->npend=0
DEBUG CONSTRNT: Checking 43 LP rows (pool tracks 43, total LP rows 43)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 49
DEBUG CONSTRNT: Pool row 49 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 68
DEBUG CONSTRNT: Pool row 68 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 82
DEBUG CONSTRNT: Pool row 82 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 121
DEBUG CONSTRNT: Pool row 121 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 142
DEBUG CONSTRNT: Pool row 142 has lprow=42, expected 42
 % @PAP adding 40 rows, 173 nz to LP
DEBUG BB: Processing node 88, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=16, varin=39, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=2, varin=25, theta=0.363636, up=999999999999999983222784.000000
ITER 3: row=25, varin=20, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=23, varin=11, theta=0.376471, up=999999999999999983222784.000000
ITER 5: row=1, varin=3, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=39, varin=37, theta=4.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=40)
DEBUG SOLUTION: LP solution array indices: FST[41-80], not_covered[81-100]
DEBUG SOLUTION: lp->best_solution[0] = 28506042.420601
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 3.000000
  % @PL 40 rows, 60 cols, 233 nonzeros, 2 slack, 38 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 16 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=41, varin=26, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=43, varin=27, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=37, varin=69, theta=1.000000, up=1.000000
ITER 4: row=3, varin=47, theta=0.564706, up=1.000000
ITER 5: row=11, varin=23, theta=9.600000, up=999999999999999983222784.000000
ITER 6: row=20, varin=63, theta=0.363636, up=1.000000
ITER 7: row=11, varin=45, theta=1.000000, up=1.000000
ITER 8: row=39, varin=21, theta=0.227273, up=999999999999999983222784.000000
ITER 9: row=25, varin=23, theta=0.121212, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=9)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28691441.511953
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.939394
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.939394
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 3.000000
  % @PL 44 rows, 60 cols, 249 nonzeros, 10 slack, 34 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 10 slack rows
  % @PAP adding 4 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=35, varin=12, theta=2.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=38)
DEBUG SOLUTION: LP solution array indices: FST[39-78], not_covered[79-98]
DEBUG SOLUTION: lp->best_solution[0] = 28697897.233232
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 38 rows, 60 cols, 216 nonzeros, 3 slack, 35 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 2 rows, 12 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=37, varin=17, theta=0.512821, up=999999999999999983222784.000000
ITER 2: row=36, varin=37, theta=1.600000, up=999999999999999983222784.000000
ITER 3: row=33, varin=41, theta=0.500000, up=1.000000
ITER 4: row=36, varin=26, theta=0.200000, up=999999999999999983222784.000000
ITER 5: row=37, varin=37, theta=0.076923, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=37)
DEBUG SOLUTION: LP solution array indices: FST[38-77], not_covered[78-97]
DEBUG SOLUTION: lp->best_solution[0] = 28724453.995307
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 37 rows, 60 cols, 220 nonzeros, 2 slack, 35 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 3 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=36, varin=65, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=38)
DEBUG SOLUTION: LP solution array indices: FST[39-78], not_covered[79-98]
DEBUG SOLUTION: lp->best_solution[0] = 28725827.189382
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 38 rows, 60 cols, 210 nonzeros, 0 slack, 38 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 17 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=39, varin=49, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 28729411.767206
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 42 rows, 60 cols, 227 nonzeros, 0 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 21 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=43, varin=17, theta=0.666667, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=46)
DEBUG SOLUTION: LP solution array indices: FST[47-86], not_covered[87-106]
DEBUG SOLUTION: lp->best_solution[0] = 28730094.915316
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 46 rows, 60 cols, 248 nonzeros, 2 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % Node 88 LP 1 Solution, length = 28730094.915316, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.166667 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.166667 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.166667 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 1.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.166667 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.166667 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.166667 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.833333 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.833333 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.833333 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.833333 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.833333 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.833333 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.833333 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28730094.915316, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 88 at  28.73009491531635717365
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde83bf040
% @LO 0.09  28.50604242060065374176 99.9000000000
% @LN 0.09  28.50610838257336610013 99.9000000000
% Resuming node 90 at  28.50610838257336610013
DEBUG CONSTRNT: LP rows=44, pool->nlprows=44, pool->npend=0
DEBUG CONSTRNT: Checking 44 LP rows (pool tracks 44, total LP rows 44)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=43, expected 43
 % @PAP adding 45 rows, 181 nz to LP
DEBUG BB: Processing node 90, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=22, varin=39, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 28506108.382573
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 45 rows, 60 cols, 241 nonzeros, 4 slack, 41 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 3 rows, 49 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=48, varin=12, theta=0.760360, up=999999999999999983222784.000000
ITER 2: row=5, varin=27, theta=0.417772, up=999999999999999983222784.000000
ITER 3: row=46, varin=5, theta=2.727273, up=999999999999999983222784.000000
ITER 4: row=48, varin=23, theta=2.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 28584316.190131
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 48 rows, 60 cols, 290 nonzeros, 4 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=45, varin=70, theta=1.003621, up=1.000000
ITER 2: row=45, varin=72, theta=0.001701, up=1.000000
ITER 3: row=3, varin=70, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 28587928.619075
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 45 rows, 60 cols, 278 nonzeros, 0 slack, 45 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 5 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=46, varin=51, theta=0.259827, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 28591909.159361
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 47 rows, 60 cols, 283 nonzeros, 0 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 90 LP 1 Solution, length = 28591909.159361, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.480346 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.259827 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 1.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.480346 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.519654 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.519654 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.519654 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.519654 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.519654 (terminal 19)
 % 3 fractional variables
DEBUG CG: LP optimal, z=28591909.159361, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 90 at  28.59190915936137855624
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde83a9300
% @LO 0.09  28.50610838257336610013 99.9000000000
% @LN 0.09  28.50670811012868455236 99.9000000000
% Resuming node 80 at  28.50670811012868455236
DEBUG CONSTRNT: LP rows=47, pool->nlprows=47, pool->npend=0
DEBUG CONSTRNT: Checking 47 LP rows (pool tracks 47, total LP rows 47)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 63
DEBUG CONSTRNT: Pool row 63 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 121
DEBUG CONSTRNT: Pool row 121 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=46, expected 46
 % @PAP adding 48 rows, 229 nz to LP
DEBUG BB: Processing node 80, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 80 LP 2 Solution, length = 28506708.110129, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.250000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.250000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 1.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.903419 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.250000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.250000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.250000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.750000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.750000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.750000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.096581 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.750000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.096581 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28506708.110129, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28506708.110129, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 80 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 80
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.250000
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.250000
DEBUG CAREFUL: Adding var 4 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=1.000000
DEBUG CAREFUL: Skipping var 9: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.903419
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.903419)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.250000
DEBUG CAREFUL: Adding var 11 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.250000
DEBUG CAREFUL: Adding var 22 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.250000
DEBUG CAREFUL: Adding var 27 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 6 fractional variables

  %  Carefully choosing branching variable, nfrac = 6
DEBUG CAREFUL: Testing fvar[0] = var 4
DEBUG CAREFUL: Calling compare_branch_vars for var 4
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 4
DEBUG CAREFUL: New best var: 4
DEBUG CAREFUL: Testing fvar[1] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[2] = var 27
DEBUG CAREFUL: Calling compare_branch_vars for var 27
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 27
DEBUG CAREFUL: Testing fvar[3] = var 22
DEBUG CAREFUL: Calling compare_branch_vars for var 22
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 22
DEBUG CAREFUL: Testing fvar[4] = var 11
DEBUG CAREFUL: Calling compare_branch_vars for var 11
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 11
DEBUG CAREFUL: Testing fvar[5] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
  % Initial guess is x4, Z0 = 28506708.1101287        , Z1 = 28506708.1101287        

DEBUG EVAL: Testing var 4 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=11, varin=48, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 4 = 0 gives z=28525903.855723
  % 	x4 = 0,	Z0 = 28525903.855723         
DEBUG EVAL: First branch cutoff check: z=28525903.855723, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 4 = 1
ITER 1: row=11, varin=16, theta=3.000000, up=999999999999999983222784.000000
ITER 2: row=16, varin=46, theta=1.500000, up=999999999999999983222784.000000
ITER 3: row=30, varin=41, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=41, varin=44, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=26, varin=25, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=25, varin=40, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=40, varin=48, theta=1.000000, up=999999999999999983222784.000000
ITER 8: row=31, varin=39, theta=1.000000, up=999999999999999983222784.000000
ITER 9: row=20, varin=27, theta=0.620147, up=999999999999999983222784.000000
ITER 10: row=27, varin=62, theta=0.410334, up=1.000000
  % 	x4 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: Second branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=11, varin=48, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 28525903.855723
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
   % @PL 48 rows, 60 cols, 289 nonzeros, 1 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
   % @PAP adding 3 rows, 14 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=48, varin=32, theta=0.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28539540.454107
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
   % @PL 50 rows, 60 cols, 301 nonzeros, 3 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 3 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 80 at  28.53954045410709383646
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde83970d0
% @LO 0.09  28.50670811012868455236 99.9000000000
% @LN 0.09  28.50765090107295662847 99.9000000000
% Resuming node 103 at  28.50765090107295662847
DEBUG CONSTRNT: LP rows=47, pool->nlprows=47, pool->npend=0
DEBUG CONSTRNT: Checking 47 LP rows (pool tracks 47, total LP rows 47)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=46, expected 46
 % @PAP adding 47 rows, 186 nz to LP
DEBUG BB: Processing node 103, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 103 LP 2 Solution, length = 28507650.901073, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.250000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.250000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.250000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.250000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.250000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.250000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.250000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.250000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.750000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.750000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.750000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.750000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.750000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 0.750000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 8 fractional variables
DEBUG CG: LP optimal, z=28507650.901073, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28507650.901073, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 103 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 103
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.250000
DEBUG CAREFUL: Adding var 0 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.250000
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=1.000000
DEBUG CAREFUL: Skipping var 7: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.250000
DEBUG CAREFUL: Adding var 23 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.250000
DEBUG CAREFUL: Adding var 24 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.250000
DEBUG CAREFUL: Adding var 27 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.250000
DEBUG CAREFUL: Adding var 30 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.250000
DEBUG CAREFUL: Adding var 32 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.250000
DEBUG CAREFUL: Adding var 33 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 8 fractional variables

  %  Carefully choosing branching variable, nfrac = 8
DEBUG CAREFUL: Testing fvar[0] = var 0
DEBUG CAREFUL: Calling compare_branch_vars for var 0
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 0
DEBUG CAREFUL: New best var: 0
DEBUG CAREFUL: Testing fvar[1] = var 24
DEBUG CAREFUL: Calling compare_branch_vars for var 24
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 24
DEBUG CAREFUL: Testing fvar[2] = var 33
DEBUG CAREFUL: Calling compare_branch_vars for var 33
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 33
DEBUG CAREFUL: Testing fvar[3] = var 32
DEBUG CAREFUL: Calling compare_branch_vars for var 32
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 32
DEBUG CAREFUL: Testing fvar[4] = var 30
DEBUG CAREFUL: Calling compare_branch_vars for var 30
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 30
DEBUG CAREFUL: Testing fvar[5] = var 23
DEBUG CAREFUL: Calling compare_branch_vars for var 23
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 23
DEBUG CAREFUL: Testing fvar[6] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[7] = var 27
DEBUG CAREFUL: Calling compare_branch_vars for var 27
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 27
  % Initial guess is x0, Z0 = 28507650.901073         , Z1 = 28676753.2806788        

DEBUG EVAL: Testing var 0 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=15, theta=3.000000, up=999999999999999983222784.000000
ITER 2: row=15, varin=45, theta=1.500000, up=999999999999999983222784.000000
ITER 3: row=2, varin=33, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=32, varin=25, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=25, varin=46, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=43, varin=43, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 0 = 1 gives z=28676753.280679
  % 	x0 = 1,	Z1 = 28676753.2806788        
DEBUG EVAL: First branch cutoff check: z=28676753.280679, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 0 = 0
ITER 1: row=1, varin=41, theta=0.500000, up=999999999999999983222784.000000
  % 	x0 = 0,	Z0 = 28523180.112884         
DEBUG EVAL: Second branch cutoff check: z=28523180.112884, best_z=INF, threshold=INF
  %   New best:  x0, Z = 28523180.112884         
DEBUG EVAL: Testing var 24 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=3, varin=41, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 24 = 0 gives z=28523180.112884
  % 	x24 = 0,	Z0 = 28523180.112884         
DEBUG EVAL: First branch cutoff check: z=28523180.112884, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 24 = 1
ITER 1: row=3, varin=15, theta=3.000000, up=999999999999999983222784.000000
ITER 2: row=15, varin=45, theta=1.500000, up=999999999999999983222784.000000
ITER 3: row=2, varin=33, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=32, varin=2, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=38, varin=25, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=25, varin=46, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=43, varin=43, theta=1.000000, up=999999999999999983222784.000000
  % 	x24 = 1,	Z1 = 28676753.2806788        
DEBUG EVAL: Second branch cutoff check: z=28676753.280679, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 33 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=36, varin=41, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 33 = 0 gives z=28523180.112884
  % 	x33 = 0,	Z0 = 28523180.112884         
DEBUG EVAL: First branch cutoff check: z=28523180.112884, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 33 = 1
ITER 1: row=36, varin=15, theta=3.000000, up=999999999999999983222784.000000
ITER 2: row=15, varin=45, theta=1.500000, up=999999999999999983222784.000000
ITER 3: row=2, varin=33, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=32, varin=2, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=38, varin=25, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=25, varin=46, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=43, varin=43, theta=1.000000, up=999999999999999983222784.000000
  % 	x33 = 1,	Z1 = 28676753.2806788        
DEBUG EVAL: Second branch cutoff check: z=28676753.280679, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 32 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=43, varin=41, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 32 = 0 gives z=28523180.112884
  % 	x32 = 0,	Z0 = 28523180.112884         
DEBUG EVAL: First branch cutoff check: z=28523180.112884, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 32 = 1
ITER 1: row=43, varin=15, theta=3.000000, up=999999999999999983222784.000000
ITER 2: row=15, varin=33, theta=3.000000, up=999999999999999983222784.000000
ITER 3: row=32, varin=25, theta=3.000000, up=999999999999999983222784.000000
ITER 4: row=25, varin=43, theta=3.000000, up=999999999999999983222784.000000
ITER 5: row=39, varin=39, theta=2.000000, up=999999999999999983222784.000000
ITER 6: row=26, varin=40, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=10, varin=36, theta=0.500000, up=999999999999999983222784.000000
  % 	x32 = 1,	Z1 = 28913591.4131444        
DEBUG EVAL: Second branch cutoff check: z=28913591.413144, best_z=INF, threshold=INF
  %   New best:  x32, Z = 28523180.112884         
DEBUG EVAL: Testing var 30 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=39, varin=41, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 30 = 0 gives z=28523180.112884
  % 	x30 = 0,	Z0 = 28523180.112884         
DEBUG EVAL: First branch cutoff check: z=28523180.112884, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 30 = 1
ITER 1: row=39, varin=15, theta=3.000000, up=999999999999999983222784.000000
ITER 2: row=15, varin=45, theta=1.500000, up=999999999999999983222784.000000
ITER 3: row=2, varin=33, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=32, varin=25, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=25, varin=46, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=43, varin=39, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=26, varin=40, theta=1.000000, up=999999999999999983222784.000000
ITER 8: row=10, varin=36, theta=0.500000, up=999999999999999983222784.000000
  % 	x30 = 1,	Z1 = 28740076.6236131        
DEBUG EVAL: Second branch cutoff check: z=28740076.623613, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 23 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=10, varin=41, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 23 = 0 gives z=28523180.112884
  % 	x23 = 0,	Z0 = 28523180.112884         
DEBUG EVAL: First branch cutoff check: z=28523180.112884, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 23 = 1
ITER 1: row=10, varin=15, theta=3.000000, up=999999999999999983222784.000000
ITER 2: row=15, varin=45, theta=1.500000, up=999999999999999983222784.000000
ITER 3: row=2, varin=33, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=32, varin=2, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=38, varin=25, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=25, varin=46, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=43, varin=26, theta=0.500000, up=999999999999999983222784.000000
  % 	x23 = 1,	Z1 = 28647502.453687         
DEBUG EVAL: Second branch cutoff check: z=28647502.453687, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 2 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=2, varin=46, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 1 gives z=28524156.015924
  % 	x2 = 1,	Z1 = 28524156.0159245        
DEBUG EVAL: First branch cutoff check: z=28524156.015924, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 0
ITER 1: row=2, varin=41, theta=0.500000, up=999999999999999983222784.000000
  % 	x2 = 0,	Z0 = 28523180.112884         
DEBUG EVAL: Second branch cutoff check: z=28523180.112884, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 27 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=26, varin=41, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 27 = 0 gives z=28523180.112884
  % 	x27 = 0,	Z0 = 28523180.112884         
DEBUG EVAL: First branch cutoff check: z=28523180.112884, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 27 = 1
ITER 1: row=26, varin=46, theta=1.000000, up=999999999999999983222784.000000
  % 	x27 = 1,	Z1 = 28524156.0159245        
DEBUG EVAL: Second branch cutoff check: z=28524156.015924, best_z=INF, threshold=INF
  % Best branch is x32, Z0 = 28523180.112884         , Z1 = 28913591.4131444        

DEBUG CAREFUL: Final result - returning best.var = 32
DEBUG BB: Branching variable chosen: j=32
 % @NC  107  103	x32 = 0	28523180.112884
 % @NC  108  103	x32 = 1	28913591.413144
 %     103    44 28507650.9011               28510358.4801   x22 D    53    11
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde8397010
% @LO 0.09  28.50765090107295662847 99.9000000000
% @LN 0.09  28.51035848008260131792 99.9000000000
% Resuming node 99 at  28.51035848008260131792
DEBUG CONSTRNT: LP rows=47, pool->nlprows=47, pool->npend=0
DEBUG CONSTRNT: Checking 47 LP rows (pool tracks 47, total LP rows 47)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=46, expected 46
 % @PAP adding 44 rows, 177 nz to LP
DEBUG BB: Processing node 99, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=14, varin=15, theta=0.333333, up=999999999999999983222784.000000
ITER 2: row=34, varin=81, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28510358.480083
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 44 rows, 60 cols, 237 nonzeros, 0 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=45, varin=69, theta=1.000000, up=1.000000
ITER 2: row=29, varin=57, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 28585090.000792
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 45 rows, 60 cols, 241 nonzeros, 0 slack, 45 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 6 rows, 34 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=46, varin=16, theta=0.250000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 28594097.639607
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 51 rows, 60 cols, 275 nonzeros, 7 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 7 slack rows
  % Node 99 LP 1 Solution, length = 28594097.639607, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.250000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.250000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.250000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 1.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.250000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.250000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.750000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.750000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.750000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.750000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.750000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.750000 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28594097.639607, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 99 at  28.59409763960696082563
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde83c94d0
% @LO 0.09  28.51035848008260131792 99.9000000000
% @LN 0.09  28.51108907323057195526 99.9000000000
% Resuming node 96 at  28.51108907323057195526
DEBUG CONSTRNT: LP rows=44, pool->nlprows=44, pool->npend=0
DEBUG CONSTRNT: Checking 44 LP rows (pool tracks 44, total LP rows 44)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=43, expected 43
 % @PAP adding 50 rows, 188 nz to LP
DEBUG BB: Processing node 96, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=78, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28511089.073231
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
  % @PL 50 rows, 60 cols, 248 nonzeros, 0 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=51, varin=83, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 28518682.401814
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
  % @PL 52 rows, 60 cols, 254 nonzeros, 0 slack, 52 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 15 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=53, varin=38, theta=3.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=56)
DEBUG SOLUTION: LP solution array indices: FST[57-96], not_covered[97-116]
DEBUG SOLUTION: lp->best_solution[0] = 28521957.178593
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
  % @PL 56 rows, 60 cols, 269 nonzeros, 1 slack, 55 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 2 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=56, varin=80, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=57)
DEBUG SOLUTION: LP solution array indices: FST[58-97], not_covered[98-117]
DEBUG SOLUTION: lp->best_solution[0] = 28531016.661484
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
  % @PL 57 rows, 60 cols, 269 nonzeros, 0 slack, 57 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 19 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=58, varin=94, theta=1.000000, up=1.000000
ITER 2: row=51, varin=21, theta=0.500000, up=999999999999999983222784.000000
ITER 3: row=42, varin=23, theta=0.200000, up=999999999999999983222784.000000
ITER 4: row=40, varin=38, theta=0.250000, up=999999999999999983222784.000000
ITER 5: row=43, varin=87, theta=1.000000, up=1.000000
ITER 6: row=27, varin=83, theta=0.600000, up=1.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=61)
DEBUG SOLUTION: LP solution array indices: FST[62-101], not_covered[102-121]
DEBUG SOLUTION: lp->best_solution[0] = 28600883.508650
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.800000
DEBUG SOLUTION: lp->best_solution[10] = 0.800000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
  % @PL 61 rows, 60 cols, 288 nonzeros, 4 slack, 57 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % @PAP adding 3 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=58, varin=38, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=49, varin=26, theta=0.333333, up=999999999999999983222784.000000
ITER 3: row=34, varin=22, theta=0.400000, up=999999999999999983222784.000000
ITER 4: row=60, varin=89, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=60)
DEBUG SOLUTION: LP solution array indices: FST[61-100], not_covered[101-120]
DEBUG SOLUTION: lp->best_solution[0] = 28613807.055054
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 60 rows, 60 cols, 286 nonzeros, 0 slack, 60 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 5 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=61, varin=47, theta=0.250000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=61)
DEBUG SOLUTION: LP solution array indices: FST[62-101], not_covered[102-121]
DEBUG SOLUTION: lp->best_solution[0] = 28617412.811488
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 61 rows, 60 cols, 291 nonzeros, 7 slack, 54 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 7 slack rows
  % Node 96 LP 1 Solution, length = 28617412.811488, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.250000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.250000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.250000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.250000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 1.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.250000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.250000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.250000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.750000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.750000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.750000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.750000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.750000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.750000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.750000 (terminal 19)
 % 7 fractional variables
DEBUG CG: LP optimal, z=28617412.811488, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 96 at  28.61741281148839277648
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde83bcb30
% @LO 0.09  28.51108907323057195526 99.9000000000
% @LN 0.09  28.51400135401447144545 99.9000000000
% Resuming node 94 at  28.51400135401447144545
DEBUG CONSTRNT: LP rows=54, pool->nlprows=54, pool->npend=0
DEBUG CONSTRNT: Checking 54 LP rows (pool tracks 54, total LP rows 54)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 65
DEBUG CONSTRNT: Pool row 65 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 121
DEBUG CONSTRNT: Pool row 121 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=53, expected 53
 % @PAP adding 46 rows, 182 nz to LP
DEBUG BB: Processing node 94, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 94 LP 2 Solution, length = 28514001.354014, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.500000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.500000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 1.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.500000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.500000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.500000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.500000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.500000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.500000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.500000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 0.500000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28514001.354014, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28514001.354014, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 94 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 94
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.500000
DEBUG CAREFUL: Adding var 0 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.500000
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=1.000000
DEBUG CAREFUL: Skipping var 16: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.500000
DEBUG CAREFUL: Adding var 23 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.500000
DEBUG CAREFUL: Adding var 24 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.500000
DEBUG CAREFUL: Adding var 29 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 29
DEBUG CAREFUL: Calling compare_branch_vars for var 29
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 29
DEBUG CAREFUL: New best var: 29
DEBUG CAREFUL: Testing fvar[1] = var 23
DEBUG CAREFUL: Calling compare_branch_vars for var 23
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 23
DEBUG CAREFUL: Testing fvar[2] = var 0
DEBUG CAREFUL: Calling compare_branch_vars for var 0
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 0
DEBUG CAREFUL: Testing fvar[3] = var 24
DEBUG CAREFUL: Calling compare_branch_vars for var 24
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 24
DEBUG CAREFUL: Testing fvar[4] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 1
  % Initial guess is x29, Z0 = 28514001.3540145        , Z1 = 28532784.6417883        

DEBUG EVAL: Testing var 29 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=61, theta=2.500000, up=1.000000
ITER 2: row=1, varin=4, theta=0.600000, up=999999999999999983222784.000000
ITER 3: row=31, varin=61, theta=1.000000, up=1.000000
ITER 4: row=7, varin=46, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 29 = 1 gives z=28529222.160526
  % 	x29 = 1,	Z1 = 28532784.6417883        
DEBUG EVAL: First branch cutoff check: z=28532784.641788, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 29 = 0
ITER 1: row=1, varin=80, theta=0.500000, up=1.000000
  % 	x29 = 0,	Z0 = 28538741.7181266        
DEBUG EVAL: Second branch cutoff check: z=28538741.718127, best_z=INF, threshold=INF
  %   New best:  x29, Z = 28532784.6417883        
DEBUG EVAL: Testing var 23 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=34, varin=4, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=7, varin=46, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 23 = 0 gives z=28529222.160526
  % 	x23 = 0,	Z0 = 28529222.1605261        
DEBUG EVAL: First branch cutoff check: z=28529222.160526, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 0 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=4, varin=4, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=7, varin=46, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 0 = 0 gives z=28529222.160526
  % 	x0 = 0,	Z0 = 28529222.1605261        
DEBUG EVAL: First branch cutoff check: z=28529222.160526, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 24 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=3, varin=4, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=7, varin=46, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 24 = 0 gives z=28529222.160526
  % 	x24 = 0,	Z0 = 28529222.1605261        
DEBUG EVAL: First branch cutoff check: z=28529222.160526, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 1 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=5, varin=46, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 1 = 0 gives z=28529222.160526
  % 	x1 = 0,	Z0 = 28529222.1605261        
DEBUG EVAL: First branch cutoff check: z=28529222.160526, best_z=INF, threshold=INF
  % Best branch is x29, Z0 = 28538741.7181266        , Z1 = 28532784.6417883        

DEBUG CAREFUL: Final result - returning best.var = 29
DEBUG BB: Branching variable chosen: j=29
 % @NC  109   94	x29 = 1	28532784.641788
 % @NC  110   94	x29 = 0	28538741.718127
 %      94    45 28514001.3540               28519681.8746   x17 D    75     8
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde83bf1e0
% @LO 0.10  28.51400135401447144545 99.9000000000
% @LN 0.10  28.51968187456272829650 99.9000000000
% Resuming node 70 at  28.51968187456272829650
DEBUG CONSTRNT: LP rows=46, pool->nlprows=46, pool->npend=0
DEBUG CONSTRNT: Checking 46 LP rows (pool tracks 46, total LP rows 46)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 49
DEBUG CONSTRNT: Pool row 49 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 68
DEBUG CONSTRNT: Pool row 68 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 82
DEBUG CONSTRNT: Pool row 82 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 121
DEBUG CONSTRNT: Pool row 121 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 142
DEBUG CONSTRNT: Pool row 142 has lprow=45, expected 45
 % @PAP adding 42 rows, 165 nz to LP
DEBUG BB: Processing node 70, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 70 LP 2 Solution, length = 28519681.874563, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.166667 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.166667 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.166667 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 1.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.166667 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.166667 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.166667 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.833333 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.833333 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.833333 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.833333 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.833333 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.833333 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.833333 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28519681.874563, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28519681.874563, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 70 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 70
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.166667
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.166667
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=1.000000
DEBUG CAREFUL: Skipping var 7: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.166667
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=1.000000
DEBUG CAREFUL: Skipping var 14: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.166667
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.166667
DEBUG CAREFUL: Adding var 18 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.166667
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 6 fractional variables

  %  Carefully choosing branching variable, nfrac = 6
DEBUG CAREFUL: Testing fvar[0] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 17
DEBUG CAREFUL: New best var: 17
DEBUG CAREFUL: Testing fvar[1] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 10
DEBUG CAREFUL: New best var: 10
DEBUG CAREFUL: Testing fvar[2] = var 18
DEBUG CAREFUL: Calling compare_branch_vars for var 18
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 18
DEBUG CAREFUL: New best var: 18
DEBUG CAREFUL: Testing fvar[3] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 3
DEBUG CAREFUL: New best var: 3
DEBUG CAREFUL: Testing fvar[4] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[5] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
  % Initial guess is x3, Z0 = 28519681.8745627        , Z1 = 28623422.7663088        

DEBUG EVAL: Testing var 17 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=16, varin=17, theta=0.333333, up=999999999999999983222784.000000
ITER 2: row=31, varin=79, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 17 = 0 gives z=28557658.505261
  % 	x17 = 0,	Z0 = 28557658.5052607        
DEBUG EVAL: First branch cutoff check: z=28557658.505261, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 17 = 1
ITER 1: row=16, varin=40, theta=5.000000, up=999999999999999983222784.000000
ITER 2: row=37, varin=37, theta=2.000000, up=999999999999999983222784.000000
ITER 3: row=9, varin=29, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=32, varin=36, theta=2.000000, up=999999999999999983222784.000000
ITER 5: row=1, varin=34, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=2, varin=28, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=27, varin=30, theta=0.333333, up=999999999999999983222784.000000
  % 	x17 = 1,	Z1 = 28625519.9358768        
DEBUG EVAL: Second branch cutoff check: z=28625519.935877, best_z=INF, threshold=INF
  %   New best:  x17, Z = 28557658.5052607        
DEBUG EVAL: Testing var 10 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=12, varin=40, theta=5.000000, up=999999999999999983222784.000000
ITER 2: row=37, varin=37, theta=2.000000, up=999999999999999983222784.000000
ITER 3: row=9, varin=30, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 1 gives z=28587460.189967
  % 	x10 = 1,	Z1 = 28587460.189967         
DEBUG EVAL: First branch cutoff check: z=28587460.189967, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 0
ITER 1: row=12, varin=14, theta=0.200000, up=999999999999999983222784.000000
ITER 2: row=32, varin=79, theta=1.000000, up=1.000000
  % 	x10 = 0,	Z0 = 28557658.5052607        
DEBUG EVAL: Second branch cutoff check: z=28557658.505261, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 18 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=29, varin=40, theta=5.000000, up=999999999999999983222784.000000
ITER 2: row=37, varin=37, theta=2.000000, up=999999999999999983222784.000000
ITER 3: row=9, varin=36, theta=2.000000, up=999999999999999983222784.000000
ITER 4: row=1, varin=34, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=2, varin=28, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=27, varin=17, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=31, varin=3, theta=1.000000, up=999999999999999983222784.000000
ITER 8: row=34, varin=26, theta=0.428571, up=999999999999999983222784.000000
ITER 9: row=28, varin=30, theta=1.000000, up=999999999999999983222784.000000
ITER 10: row=12, varin=18, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 18 = 1 gives z=28696570.672376
  % 	x18 = 1,	Z1 = 28696570.6723763        
DEBUG EVAL: First branch cutoff check: z=28696570.672376, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 18 = 0
ITER 1: row=29, varin=29, theta=0.333333, up=999999999999999983222784.000000
ITER 2: row=32, varin=79, theta=1.000000, up=1.000000
  % 	x18 = 0,	Z0 = 28557658.5052607        
DEBUG EVAL: Second branch cutoff check: z=28557658.505261, best_z=INF, threshold=INF
  %   New best:  x18, Z = 28557658.5052607        
DEBUG EVAL: Testing var 3 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=9, varin=40, theta=5.000000, up=999999999999999983222784.000000
ITER 2: row=37, varin=29, theta=2.000000, up=999999999999999983222784.000000
ITER 3: row=32, varin=36, theta=4.000000, up=999999999999999983222784.000000
ITER 4: row=1, varin=16, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=38, varin=34, theta=3.000000, up=999999999999999983222784.000000
ITER 6: row=2, varin=28, theta=3.000000, up=999999999999999983222784.000000
ITER 7: row=27, varin=30, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 3 = 1 gives z=28706065.477923
  % 	x3 = 1,	Z1 = 28706065.4779229        
DEBUG EVAL: First branch cutoff check: z=28706065.477923, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 3 = 0
ITER 1: row=9, varin=37, theta=0.250000, up=999999999999999983222784.000000
  % 	x3 = 0,	Z0 = 28524531.8549415        
DEBUG EVAL: Second branch cutoff check: z=28524531.854941, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 2 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=36, theta=0.200000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 0 gives z=28526121.410980
  % 	x2 = 0,	Z0 = 28526121.4109797        
DEBUG EVAL: First branch cutoff check: z=28526121.410980, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 26 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=37, varin=37, theta=2.500000, up=999999999999999983222784.000000
ITER 2: row=9, varin=30, theta=0.750000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 26 = 1 gives z=28605247.798011
  % 	x26 = 1,	Z1 = 28605247.7980106        
DEBUG EVAL: First branch cutoff check: z=28605247.798011, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 26 = 0
ITER 1: row=37, varin=40, theta=0.200000, up=999999999999999983222784.000000
  % 	x26 = 0,	Z0 = 28520535.4197495        
DEBUG EVAL: Second branch cutoff check: z=28520535.419750, best_z=INF, threshold=INF
  % Best branch is x18, Z0 = 28557658.5052607        , Z1 = 28696570.6723763        

DEBUG CAREFUL: Final result - returning best.var = 18
DEBUG BB: Branching variable chosen: j=18
 % @NC  111   70	x18 = 0	28557658.505261
 % @NC  112   70	x18 = 1	28696570.672376
 %      70    46 28519681.8746               28519971.1153   x14 U    60     7
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde83bccf0
% @LO 0.10  28.51968187456272829650 99.9000000000
% @LN 0.10  28.51997111526681649707 99.9000000000
% Resuming node 101 at  28.51997111526681649707
DEBUG CONSTRNT: LP rows=42, pool->nlprows=42, pool->npend=0
DEBUG CONSTRNT: Checking 42 LP rows (pool tracks 42, total LP rows 42)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=41, expected 41
 % @PAP adding 36 rows, 144 nz to LP
DEBUG BB: Processing node 101, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 101 LP 2 Solution, length = 28519971.115267, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.333333 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.333333 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 1.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 1.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 1.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.333333 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.666667 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.666667 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.666667 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.666667 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 3 fractional variables
DEBUG CG: LP optimal, z=28519971.115267, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28519971.115267, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 101 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 101
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.333333
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.333333
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=1.000000
DEBUG CAREFUL: Skipping var 9: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=1.000000
DEBUG CAREFUL: Skipping var 10: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=1.000000
DEBUG CAREFUL: Skipping var 15: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.333333
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 3 fractional variables

  %  Carefully choosing branching variable, nfrac = 3
DEBUG CAREFUL: Testing fvar[0] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 17
DEBUG CAREFUL: New best var: 17
DEBUG CAREFUL: Testing fvar[1] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 3
DEBUG CAREFUL: New best var: 3
DEBUG CAREFUL: Testing fvar[2] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
  % Initial guess is x3, Z0 = 28519971.1152668        , Z1 = 28616775.1222971        

DEBUG EVAL: Testing var 17 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=15, varin=36, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=36, varin=33, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 17 = 1 gives z=28567568.995392
  % 	x17 = 1,	Z1 = 28567568.9953923        
DEBUG EVAL: First branch cutoff check: z=28567568.995392, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 17 = 0
ITER 1: row=15, varin=29, theta=1.000000, up=999999999999999983222784.000000
  % 	x17 = 0,	Z0 = 28526665.6665664        
DEBUG EVAL: Second branch cutoff check: z=28526665.666566, best_z=INF, threshold=INF
  %   New best:  x17, Z = 28526665.6665664        
DEBUG EVAL: Testing var 3 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=9, varin=36, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=36, varin=32, theta=2.000000, up=999999999999999983222784.000000
ITER 3: row=1, varin=30, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=2, varin=15, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=34, varin=3, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=30, varin=51, theta=0.500000, up=1.000000
ITER 7: row=11, varin=26, theta=0.500000, up=999999999999999983222784.000000
ITER 8: row=26, varin=16, theta=0.500000, up=999999999999999983222784.000000
ITER 9: row=35, varin=17, theta=0.333333, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 3 = 1 gives z=28717039.314495
  % 	x3 = 1,	Z1 = 28717039.3144946        
DEBUG EVAL: First branch cutoff check: z=28717039.314495, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 3 = 0
ITER 1: row=9, varin=29, theta=1.000000, up=999999999999999983222784.000000
  % 	x3 = 0,	Z0 = 28526665.6665664        
DEBUG EVAL: Second branch cutoff check: z=28526665.666566, best_z=INF, threshold=INF
  %   New best:  x3, Z = 28526665.6665664        
DEBUG EVAL: Testing var 2 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=29, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 0 gives z=28526665.666566
  % 	x2 = 0,	Z0 = 28526665.6665664        
DEBUG EVAL: First branch cutoff check: z=28526665.666566, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 1
ITER 1: row=1, varin=36, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=36, varin=33, theta=1.000000, up=999999999999999983222784.000000
  % 	x2 = 1,	Z1 = 28567568.9953923        
DEBUG EVAL: Second branch cutoff check: z=28567568.995392, best_z=INF, threshold=INF
  % Best branch is x3, Z0 = 28526665.6665664        , Z1 = 28717039.3144946        

DEBUG CAREFUL: Final result - returning best.var = 3
DEBUG BB: Branching variable chosen: j=3
 % @NC  113  101	x3 = 0	28526665.666566
 % @NC  114  101	x3 = 1	28717039.314495
 %     101    47 28519971.1153               28522212.2012   x18 D    74     8
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55fde83aa1f0
% @LO 0.10  28.51997111526681649707 99.9000000000
% @LN 0.10  28.52221220122238776185 99.9000000000
% Resuming node 85 at  28.52221220122238776185
DEBUG CONSTRNT: LP rows=36, pool->nlprows=36, pool->npend=0
DEBUG CONSTRNT: Checking 36 LP rows (pool tracks 36, total LP rows 36)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 158
DEBUG CONSTRNT: Pool row 158 has lprow=35, expected 35
 % @PAP adding 37 rows, 158 nz to LP
DEBUG BB: Processing node 85, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=25, varin=13, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=37)
DEBUG SOLUTION: LP solution array indices: FST[38-77], not_covered[78-97]
DEBUG SOLUTION: lp->best_solution[0] = 28522212.201222
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 37 rows, 60 cols, 218 nonzeros, 2 slack, 35 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 85 LP 1 Solution, length = 28522212.201222, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 1.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 1.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 0 fractional variables
DEBUG CG: LP optimal, z=28522212.201222, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG IFS: Budget mode - accepting integer solution with 2 edges covering 7 vertices
DEBUG CG: integer_feasible_solution returned: TRUE
DEBUG CG: Solution is integer feasible, returning LB_INTEGRAL
DEBUG BB: compute_good_lower_bound returned status=3
DEBUG BB: Node 85 is INTEGRAL (integer solution found)
 %  	=== 46 nodes cut off ===
 % @UO 0.10   9.02221220122238598549 -216.1332449857
 % @UN 0.10   9.02221220122238598549 -216.1332449857
DEBUG BB: Calling heuristic UB for integer solution, current best_z=9022212.201222
DEBUG BB: Heuristic did not improve integer solution
 % *    85     0  9022212.2012  9022212.2012                 x14 D    68     9
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=(nil)
DEBUG BB: No more nodes to process, exiting

 % Certificate of solution:
 % @C	.4767008182741058	.2081993675729823
 % @C	.9346545514704401	.5030260596239182
 % @C	.8743159763680044	.2782542139644725
 % @C	.9603074535474138	.1921833678795793
%%Page: 1 1
BeginPlot
	Plot_Terminals
 % fs2: 13 0 6
	13 T	.4767008182741058	.2081993675729823	S
	.4767008182741058	.2081993675729823	0 T	S
	.4767008182741058	.2081993675729823	6 T	S
 % fs20: 19 15 3 6 12
	19 T	.9346545514704401	.5030260596239182	S
	.9346545514704401	.5030260596239182	.8743159763680044	.2782542139644725	S
	.8743159763680044	.2782542139644725	.9603074535474138	.1921833678795793	S
	.9603074535474138	.1921833678795793	15 T	S
	.9603074535474138	.1921833678795793	3 T	S
	.8743159763680044	.2782542139644725	6 T	S
	.9346545514704401	.5030260596239182	12 T	S
  (Euclidean SMT:  20 points,  length = 9.022212201222386,  0.10 seconds)
EndPlot

% @0 Euclidean SMT
% N M Nodes LPs P1CPU P2CPU TotCPU
% @1 20 40 94 143 0.00 0.10 0.10
% Z RootZ %Gap RootLPs RootCPU RedMST
% @2 9.022212201222386 27824089.338381 -208.39542 2 0.00 -188.5468
% InitPRows InitPNZ InitLPRows InitLPNZ
% @3 163 594 135 555
% RootPRows RootPNZ RootLPRows RootLPNZ
% @4 164 606 45 244
% FinalPRows FinalPNZ FinalLPRows FinalLPNZ
% @5 164 606 37 218
% SMTFSTs SMTAvgFSTSz SMTMaxFSTSz #2FSTs #3FSTs ... #10FSTS #>10FSTs
% @6 2 4.000000 5 0 1 0 1 0 0 0 0 0 0
